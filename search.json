[{"title":"LeetCode743-网络延迟时间","url":"/blog/2022/08/28/LeetCode743-网络延迟时间/","content":"\n#### 题目描述\n\n有 n 个网络节点，标记为 1 到 n。\n\n给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。\n\n现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。\n\n本题用到了**最短路径算法**-Dijkstra。\n\n<!-- more-->\n\n<img src=\"LeetCode743-网络延迟时间\\743.png\" alt=\"image-20220828210120507\" style=\"zoom:80%;\" />\n\n#### 解决思路\n\n##### 思路\n\n本题实际上是图论中的最短路径问题（带权有向图），并且是单源的最短路径，在给定起始点后，需要找到到达其他节点的最短路径，如果其他每个节点都能到达，则计算所有路径长度中最长的那个；否则，返回-1，表示有节点无法到达。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        vector<vector<pair<int, int>>> G(n + 1);\n        vector<int> dis(n + 1, INT_MAX);\n        vector<bool> vis(n + 1, false);\n        for(auto& node : times){\n            G[node[0]].emplace_back(node[1], node[2]);\n        }\n        dijkStra(G, vis, dis, k);\n        int ret = *max_element(dis.begin() + 1, dis.end());\n        return ret == INT_MAX ? -1 : ret;\n    }\n    void dijkStra(vector<vector<pair<int, int>>>& graph, vector<bool>& vis, vector<int>& dis, int k) {\n        auto cmp = [&](pair<int, int>& p1, pair<int, int>& p2) {\n            return p1.second > p2.second;\n        };\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> q(cmp);\n        q.emplace(k, 0);\n        dis[k] = 0;\n        while (!q.empty()) {\n            int curNode = q.top().first;\n            int curDist = q.top().second;\n            q.pop();\n            vis[curNode] = true;\n            for (auto& next : graph[curNode]) {\n                int nextNode = next.first;\n                int nextWeight = next.second;\n                if (!vis[nextNode] && curDist + nextWeight < dis[nextNode]) {\n                    dis[nextNode] = curDist + nextWeight;\n                    q.emplace(nextNode, dis[nextNode]);\n                }\n            }\n        }\n    }\n};\n```\n\n#### Appendix\n\nDijkstra实现模板：使用优先队列。\n\n1. 定义一个优先队列，存放`pair<int, int>`类型，`first`表示源节点，`second`表示从源节点到当前节点的最短路径，小顶堆；\n2. 建立带权图、记录已访问节点的数组、源节点当当前节点的最短路径长度数组（如果要记录路径，需要结合DFS，后续补充。该数组初始化为`INT_MAX`）；\n3. 将初始节点入队，进行广度优先搜索。\n\n```cpp\nvoid dijkStra(vector<vector<pair<int, int>>>& graph, vector<bool>& vis, vector<int>& dis, int k) {\n    auto cmp = [&](pair<int, int>& p1, pair<int, int>& p2) {\n        return p1.second > p2.second;\n    };\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> q(cmp);\n    q.emplace(k, 0);\n    dis[k] = 0;\n    while (!q.empty()) {\n        int curNode = q.top().first;\n        int curDist = q.top().second;\n        q.pop();\n        vis[curNode] = true;\n        for (auto& next : graph[curNode]) {\n            int nextNode = next.first;\n            int nextWeight = next.second;\n            if (!vis[nextNode] && curDist + nextWeight < dis[nextNode]) {\n                dis[nextNode] = curDist + nextWeight;\n                q.emplace(nextNode, dis[nextNode]);\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n","tags":["图论","最短路径"],"categories":["LeetCode"]},{"title":"2022-开始工作！","url":"/blog/2022/07/17/2022-开始工作！/","content":"\n#### 新的征程\n\n离开校园两周有余，步入工作已经一周了，不过只是进行培训，还未经受真正的“考验”。后半年是关键的半年，需要做好充分的计划并加以实施。\n\nPS：博客已经半年多没更新了，这段时间也经历很多事，以后慢慢在写。\n\n<!-- more-->\n\n#### 大致轮廓\n\n**关于工作**\n\n这个是目前最重要的，需要尽快的熟悉工作流程，熟悉相关知识等，还需要通过相应的考试，目标心里有底，在这里就不多说了，主要方面有：\n\n1. 工作必备知识；\n2. 各种网课；\n3. C语言；\n4. **听从指挥**。\n\n注意每种课程的规定时间，**必须**提前完成（在规定时间一半时完成80%及以上，3/4时完成）！如果回去晚了是自己的原因，不过也要安排好每日的任务，在每天早上制定相应的计划，完不成就别计划。\n\n**关于学习**\n\n与工作也不冲突，半年多没怎么刷题，还是懈怠了，虽然还是有一些客观原因影响，还是得抓起来，计划如下：\n\n1. 年底力扣刷题数量1000+，每日一题尽量做（实在做不出来就算了）；\n2. 每两周至少参加一次周赛，锻炼限制时间做题的能力；\n3. 力扣积分冲到9000，换个东西去。\n\n后面想到什么再补充，今天写这些刚好熟悉一下上传的过程。。。\n\n","tags":["计划"],"categories":["生活随笔"]},{"title":"C++学习路线","url":"/blog/2021/11/24/C-学习路线/","content":"\n这一年学习C++的路线，供参考。\n\n<!-- more-->\n\n### C++学习路线\n\n#### 语言基础\n\n1. C++ Primer\n2. Effective C++\n3. STL 源码剖析（建议视频课程结合）\n\n#### 算法与数据结构\n\n##### 基础\n\n1. 基础部分：玩转数据结构，从入门到进阶（Java）\n2. 进阶：算法与数据结构（C++）\n3. 面试：玩转算法面试（C++）\n\n网址：https://www.imooc.com/t/108955\n\n参考书籍：算法 4。\n\n##### 刷题\n\n**LeetCode 专栏（先思考最多20分钟，再看答案，主要是实现思路）**\n\n1. 数组\n2. 链表\n3. 队列 & 栈（包括深度优先搜索 DFS 和广度优先搜索 BFS）\n4. 二分查找\n5. 递归（包括回溯算法）\n6. 二叉树\n7. 哈希表\n\n**LeetCode 剑指offer**\n\n**LeetCode Top100**\n\n#### 计算机网络\n\n1. 计算机网络，谢希仁（主要是 TCP/IP）\n\n2. 图解 HTTP\n3. TCP-IP 详解卷一：协议*\n\n#### 操作系统\n\n王道操作系统考研课：https://www.bilibili.com/video/BV1YE411D7nH?p=58\n\n#### 数据库\n\n1. 尚硅谷数据库：https://www.bilibili.com/video/BV12b411K7Zu?from=search&seid=11827868485839167645&spm_id_from=333.337.0.0\n2. 知识点：https://space.bilibili.com/526653251/video?tid=0&page=1&keyword=&order=pubdate\n3. MySQL技术内幕  InnoDB存储引擎  第2版\n4. MySQL必知必会（当一个查询手册使用）\n\n#### LINUX及网络编程\n\n1. Linux 高性能服务器编程（必看）\n2. 鸟哥的 LINUX 私房菜（挑需要的看）\n3. 常用的命令\n\n#### 项目\n\nWebServer：https://gitee.com/settlezxy/web-server\n\n1. 原始版本 ：[#Web服务器-原始版本 (qq.com)](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxNzU2MzcwMw==&action=getalbum&album_id=1339230165934882817&scene=173&from_msgid=2649274288&from_itemidx=4&count=3&nolastread=1#wechat_redirect)\n2. C++11 版本：见 gitee\n\n#### 多线程*\n\nC++ 并发编程实战\n\n#### 设计模式*\n\nhttps://blog.csdn.net/a834595603/article/details/92706657\n\n常用的几个：\n\n1. 单例模式（饱汉（线程安全/不安全），饿汉）\n2. 工厂模式\n\n#### 书籍\n\n链接：https://pan.baidu.com/s/1qjBpgHIxMQmbSKKN2jnvDQ \n提取码：3du5\n\n更多：https://github.com/iamshuaidi/CS-Book\n\n","categories":["C++"]},{"title":"Linux高性能服务器编程（16-17）","url":"/blog/2021/10/08/Linux高性能服务器编程（16-17）/","content":"\nLinux高性能服务器编程（16-17）\n\n<!-- more-->\n\n### 第16章 服务器调制、调试和测试\n\n<img src=\"Linux高性能服务器编程（16-17）/16章概述.png\"  />\n\n#### 16.1 最大文件描述符数\n\nLinux 对应用程序能打开的最大文件描述符数量有两个层次的限制：\n\n1. 用户级限制：目标用户运行的所有进程总共能打开的文件描述符数。\n2. 系统级限制：所有用户总共能打开的文件描述符数。\n\n最常用的查看用户级文件描述符限制的方法：\n\n```shell\nulimit -n\n```\n\n可以通过以下方式临时将用户级文件描述符限制设定为 `max-file-number`，仅在当前 session 有效：\n\n```shell\nulimit -SHn max-file-number // max-file-number是一个自己定的数\n```\n\n如果要永久修改用户级文件描述符数限制，可以在 `/etc/security/limits.conf` 文件中加入如下两项：\n\n```shell\n* hard nofile max-file-number // 系统的硬限制\n* soft nofile max-file-number // 软限制\n```\n\n<img src=\"Linux高性能服务器编程（16-17）/修改系统级文件描述符限制.png\"  />\n\n#### 16.2 调整内核参数\n\n<img src=\"Linux高性能服务器编程（16-17）/内核参数.png\"  />\n\n##### 16.2.1 /proc/sys/fs 目录下的部分文件\n\n该目录下的内核参数都与文件系统相关。对于服务器来说，其中最重要的是如下两个参数：\n\n<img src=\"Linux高性能服务器编程（16-17）/fs修改.png\"  />\n\n##### 16.2.2 /proc/sys/net 目录下的部分文件\n\n该目录下是内核中网络模块的相关参数，其中 TCP/IP 协议相关的参数主要位于如下三个子目录中：core、ipv4、ipv6。现在再总结以下和服务器性能相关的部分参数：\n<img src=\"Linux高性能服务器编程（16-17）/内核网络模块参数.png\"  />\n\n<img src=\"Linux高性能服务器编程（16-17）/内核网络模块参数1.png\" style=\"zoom:95%;\" />\n\n也可以用 `sysctl` 命令来修改它们。（SYN风暴）\n\n以上两种修改方式都是临时的。永久的修改方法是在 `/etc/sysctl.conf` 文件中加入相应网络参数及其数值，并执行 `sysctl -p` 使之生效，就像修改系统最大允许打开的文件描述符那样。\n\n#### 16.3 gdb 调试\n\n##### 16.3.1 用 gdb 调试多进程程序\n\n如果一个进程通过 `fork` 系统调用创建了子进程，gdb 会继续调试原来的进程，子进程则正常运行。调试子进程常用的方法有如下两种：\n\n1. 单点调试子进程\n\n如果要调试一个子进程，我们可以先运行服务器，然后找到目标子进程的 PID，再将其附加（attach）到 gdb 调试器上，具体操作见 P327。\n\n2. 使用调试器选项 follow-fork-mode\n\ngdb 调试器的选项 follow-fork-mode 允许为我们选择程序再执行 `fork` 系统调用后是继续调试父进程还是调试子进程。其使用方法如下：\n\n```shell\n(gdb) set follow-fork-mode mode\n```\n\n其中，mode 的可选值是 parent 和 child，分别表示调试父进程和子进程。\n\n##### 16.3.2 用 gdb 调试多线程程序\n\ngdb 有一组命令可辅助多线程程序的调试。下面是一些常用的命令：\n\n<img src=\"Linux高性能服务器编程（16-17）\\gdb多线程.png\"  />\n\n#### 16.4 压力测试\n\n单纯的 I/O 复用方式的施压程度是最高的，因为线程和进程的调度本身也是要占用一定 CPU 时间的。\n\n### 第17章 系统监测工具\n\n<img src=\"Linux高性能服务器编程（16-17）/系统监测工具.png\"  />\n\n#### 17.1 tcpdump\n\ntcpdump 给使用者提供了大量的选项，用以过滤数据包或者定制输出格式。现在我们把常见的选项总结如下：\n\n<img src=\"Linux高性能服务器编程（16-17）/tcpdump.png\"  />\n\n除了使用选项外，tcpdump  还支持用表达式来进一步过滤数据包。tcpdump 表达式的操作数分为 3 种：类型（type）、方向（dir）和协议（proto）。如下：\n\n<img src=\"Linux高性能服务器编程（16-17）/tcpdump操作数.png\"  />\n\n* 还可以使用逻辑操作符来组织上述操作数以创建更复杂的表达式，tcpdump 支持的逻辑操作符和编程语言中的逻辑操作符完全相同，如 `&&,||,!` 等。\n* 如果表达式比较复杂，可以使用括号将它们分组。在使用括号时，要么使用反斜杠 ”\\“ 对它转义，要么用单引号将其括住，以避免它被 shell 所解释。\n* 此外，tcpdump 还允许直接使用数据包中的部分协议字段的内容来过滤数据包。比如，仅抓取 TCP 同步报文段，可使用 `tcpdump 'tcp[13] & 2 != 0'`，这是因为 TCP 头部的第 14 个字节的第 2 个位正式同步标志。\n\n#### 17.2 lsof\n\nlsof（list open file）是一个列出当前系统打开的文件描述符的工具。通过它我们可以了解感兴趣的进程打开了哪些文件描述符，或者我们感兴趣的文件描述符被哪些进程打开了。\n\nlsof 命令常用的选项包括：\n\n<img src=\"Linux高性能服务器编程（16-17）/lsof.png\"  />\n\n#### 17.3 nc\n\nnc（netcat）主要用来快速构建网络连接。我们可以让它以服务器方式运行，监听某个端口并接收客户连接，因此它可用来调试客户端程序。\n\n我们也可以使之以客户端方式运行，向服务器发起连接并收发数据，因此它可以用来调试服务器程序，此时它有点像 telnet 程序。\n\nnc 命令常用的选项包括：\n\n<img src=\"Linux高性能服务器编程（16-17）/nc.png\"  />\n\n#### 17.4 strace\n\nstrace 是测试服务器性能的重要工具。它跟踪程序运行过程中执行的系统调用和接收到的信号，并将系统调用名、参数、返回值及信号名输出到标准输出或者指定的文件。\n\nstrace 命令常用的选项包括：\n\n<img src=\"Linux高性能服务器编程（16-17）/strace.png\"  />\n\n#### 17.5 netstat\n\nnetstat 是一个功能很强大的网络信息统计工具。它可以打印本地网卡接口上的全部连接、路由表信息、网卡接口信息等。本书主要是利用上述功能的第一个。因为要获得路由表信息和网卡接口信息，我们可以使用输出内容更丰富的 route 和 ifconfig 命令。\n\nnetstat 命令常用的选项包括：\n\n<img src=\"Linux高性能服务器编程（16-17）/netstat1.png\"  />\n\n<img src=\"Linux高性能服务器编程（16-17）/netstat2.png\"  />\n\n#### 17.6 vmstat\n\nvmstat（virtual memory statistics），它能实时输出系统的各种资源的使用情况，比如进程信息、内存使用、CPU 使用率以及 I/O 使用情况。\n\nvmstat 命令常用的选项和参数包括：\n\n<img src=\"Linux高性能服务器编程（16-17）/vmstat.png\"  />\n\n默认情况下，vmstat 输出的内容相当丰富，示例如下：\n<img src=\"Linux高性能服务器编程（16-17）/vmstat示例.png\"  />\n\n#### 17.7 ifstat\n\n<img src=\"Linux高性能服务器编程（16-17）/ifstat.png\"  />\n\n举例来说，我们在测试机器 ernest-laptop 上执行如下命令：\n\n<img src=\"Linux高性能服务器编程（16-17）/ifstat示例.png\"  />\n\n#### 17.8 mpstat\n\nmpstat（multi-processer statistics），它能实时检测多处理器系统上每个 CPU 的使用情况。mpstat 命令和 iostat 命令通常都继承在包 sysstat 中，安装 sysstat 即可获得这两个命令。mpstat 命令的典型用法是：\n\n<img src=\"Linux高性能服务器编程（16-17）/mpstat.png\"  />\n\n","tags":["高性能服务器"],"categories":["Linux"]},{"title":"Linux高性能服务器编程（13-15）","url":"/blog/2021/10/08/Linux高性能服务器编程（13-15）/","content":"\nLinux高性能服务器编程（13-15）\n\n<!-- more-->\n\n### 第13章 多进程编程\n\n本章包括以下内容：\n\n* 复制进程映像的 fork 系统调用和替换进程映像的 exec 系列系统调用。\n* 僵尸进程以及如何避免僵尸进程。\n* 进程间通信（Inter-Process Communication，IPC）最简单的方式：管道。\n* 3 种 System V 进程间通信方式：信号量、消息队列和共享内存。\n* 在进程间传递文件描述符的通用方法：通过 UNIX 本地域 socket 传递特殊的辅助数据。\n\n#### 13.1 fork 系统调用\n\nLinux 下创建新进程的系统调用是 fork。其定义如下：\n\n```cpp\n#include <sys/types.h>\n#include <unistd.h>\npid_t fork( void );\n```\n\n该函数的每次调用都返回两次：\n\n* 在父进程中返回的是子进程的 PID\n* 在子进程中则返回 0\n\n该返回值是后续代码判断当前进程是父进程还是子进程的依据。fork 调用失败时返回 -1，并设置 errno。\n\n#### 13.2 exec 系列系统调用\n\n 有时需要在子进程中执行其他程序，即替换当前进程映像，这就需要使用如下 exec 系列函数之一：\n\n<img src=\"Linux高性能服务器编程（13-15）/exec.png\"  />\n\n#### 13.4 处理僵尸进程\n\n多进程程序中，父进程一般需要跟踪子进程的退出状态。**因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项**，以满足父进程后续对该子进程退出信息的查询（如果父进程还在运行）。**在子进程结束运行之后，父进程读取其退出状态之前，我们称该子进程处于僵尸态**。\n\n另一种使子进程进入僵尸态的情况是：**父进程结束或异常终止，而子进程继续运行。**此时子进程的 `PPID` 将被操作系统设置为 1，**即 `init` 进程**。`init` 进程接管了该子继承，并等待它结束。**在父进程退出之后，子进程退出之前，该子进程处于僵尸态（孤儿进程）。**\n\n下面这对函数在父进程中调用，以等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程的产生，或者使子进程的僵尸态立即结束：\n\n```cpp\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait( int* stat_loc );\npid_t waitpid( pid_t pid, int* stat_loc, int options );\n```\n\n`wait` 函数将阻塞进程，直到该进程的某个子进程结束运行为止，它返回结束运行的子进程的 PID，并将该子进程的退出状态信息存储于 stat_loc 参数指向的内存中，以下是几个宏定义帮助解释子进程退出状态信息：\n\n<img src=\"Linux高性能服务器编程（13-15）/子进程状态信息.png\" style=\"zoom:80%;\" />\n\n**waitpid**\n\n`wait` 函数的阻塞特性不是服务器程序所期望的，而 `waitpid` 解决了这个问题。\n\n`waitpid` 只等待由 pid 参数指定的子进程，如果 pid 取值为 -1，那么它就和 `wait` 函数相同，即等待任意一个子进程结束。stat_loc 参数的含义和 `wait` 函数的 stat_loc 参数相同。 options 参数可以控制 `waitpid` 的行为。**当 options 取值为 WNOHANG 时，`waitpid` 调用将是非阻塞的：**\n\n* 如果 pid 指定的目标子进程还没有结束或意外终止，则 `waitpid` 立即返回 0；\n* 如果目标子进程确实正常退出，则 `waitpid` 但会该子进程的 PID；\n* `waitpid` 调用失败时返回 -1，并设置 errno。\n\n**当一个进程结束时，它将给其父进程发送一个 SIGCHLD 信号。**因此，我们可以在父进程中捕获 SIGCHLD 信号，并在信号处理函数中调用 `waitpid` 函数以”彻底结束“一个子进程。如下代码清单：\n\n<img src=\"Linux高性能服务器编程（13-15）/SIGCHLD信号的典型处理函数.png\"  />\n\n#### 13.4 管道\n\n管道能在父、子进程间传递数据，利用的是 fork 调用之后两个管道文件描述符都保持打开。一对描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须有一个关闭 `fd[0]`，一个关闭 `fd[1]`。比如：父进程通过管道向子进程写数据，如下图：\n\n<img src=\"Linux高性能服务器编程（13-15）/父进程通过管道向子进程写数据.png\"  />\n\n不过，**管道只能用于有关联的两个进程间的通信。**而 3 种类 System V IPC 能用于无关联的多个进程之间的通信。\n\n还有一种特殊的管道称为 FIFO，也成为**命名管道**，可用于无关联进程之间的通信。网络编程中用的不多。\n\n#### 13.5 信号量\n\n##### 13.5.1 信号量原语\n\n临界区/关键代码区：任一时刻只有一个进程可以进入。\n\n假设有信号量 SV，则对它的 P（wait）、V（signal） 操作含义如下：\n\n* P(SV)：如果 SV 的值大于 0，就将其减 1；如果 SV 的值为 0，则挂起进程的执行。\n* V(SV)：如果有其他进程因为等待 SV 而挂起，则唤醒之；如果没有，则将 SV 加1。\n\n##### 13.5.2 semget 系统调用\n\n`semget` 系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。其定义如下：\n\n```cpp\n#include <sys/sem.h>\nint semget( key_t key, int num_sems, int sem_flags );\n```\n\n* key：键值，**用来标识一个全局唯一的信号量集**，就像文件名全局唯一地标识一个文件一样。要通过信号量通信的进程需要使用相同地键值来创建/获取该信号量。\n* num_sems：指定要创建/获取的信号量集中**信号量的数目**。如果是创建信号量，则该值必须被指定；如果是获取已经存在的信号量，则可以把它设置成 0。\n* sem_flag：指定一组标志。它低端的 9 个比特是该信号量的权限，其格式和含义都与系统调用 open 和 mode 参数相同。\n\n`semget` 成功时返回一个正整数值，它时信号量集的标识符；`semget` 失败时返回 -1，并设置 errno。\n\n##### 13.5.3 semop 系统调用\n\n`semop` 系统调用改变信号量的值，即执行P、V操作。\n\n```cpp\n#include <sys/sem.h>\nint semop( int sem_id, struct sembuf* sem_ops, size_t num_sem_ops );\n```\n\n* sem_id：由 `semget` 调用返回的信号量集标识符，用以指定被操作的目标信号量集。\n\n* sem_ops：指向一个 `sembuf` 结构体类型的数组，其定义如下：\n\n  ```cpp\n  struct sembuf{\n  \tunsigned short int sem_num; // 信号量集合中信号量的编号，0是第一个\n  \tshort int sem_op; // 指定操作类型，其可选值为正整数、0和负整数。每种类型的操作的行为又收到sem_flag 成员的影响。\n  \tshort int sem_flg; // IPC_NOWAIT/SEM_UNDO\n      // IPC_NOWAIT：无论信号量操作是否成功，semop调用都将立即返回，类似于非阻塞I/O操作\n      // SEM_UNDO：当进程退出时取消正在进行的semop操作\n  }\n  ```\n\n* num_sem_ops：指定要执行的操作个数，即 sem_ops 数组中元素的个数。\n\n`semop` 成功时返回 0，失败在返回 -1 并设置 errno。失败时 sem_ops 数组中指定的所有操作都不被执行。\n\n##### 13.5.4 semctl 系统调用\n\n`semctl` 系统调用允许调用者对信号量进行直接控制。其定义如下：\n\n```cpp\n#include <sys/sem.h>\nint semctl( int sem_id, int sem_num, int command, ... );\n```\n\n* sem_id：由 `semget` 调用返回的信号量集标识符，用以指定被操作的目标信号量集。\n* sem_num：指定被操作的信号量在信号量几种的编号。\n* command：指定要执行的命令。\n* 第四个参数的类型由用户自己定义，但 `sys/sem.h` 头文件给出了它的推荐格式。\n\n##### 13.5.5 特殊键值 IPC_PRIVATE\n\n`semget`调用者可给其 key 参数传递 IPC_PRIVATE（其值为 0），无论该信号量是否已经存在，`semget` 都将创建一个新的信号量。此名称具有误导性，非进程私有。其他进程，尤其是子进程也有方法来访问这个信号量。\n\n#### 13.6 共享内存\n\n**共享内存是最高效的 IPC 机制，**因为其不涉及进程之间的任何数据传输。不过其通常和其他进程间通信方式一起使用，否则会缠身竞态条件。\n\nLinux 共享内存的 API 都定义在 `sys/shm.h` 头文件中，包括 4 个系统调用：`shmget`、`shmat`、`shmdt` 和 `shmctl`。\n\n##### 13.6.1 shmget 系统调用\n\n`shmget` 系统调用创建一段新的共享内存，或者获取一段已经存在的共享内存。其定义如下：\n\n```cpp\n#include <sys/shm.h>\nint shmget ( key_t key, size_t size, int shmflg );\n```\n\n* key：键值，用来标识一段全局唯一的共享内存。\n\n* size：指定共享内存的大小，单位是字节。如果是创建新的共享内存，则 size 值必须指定。如果是获取已经存在的共享内存，则可以把 size 设置为 0。\n\n* shmflg：与 `semget` 系统调用的 `sem_flg` 参数相同，成功是返回一个正整数，它是共享内存的标识符，`shmget` 失败时返回 -1，并设置 errno。不过 `shmget` 支持两个额外的标志，如下所示：\n\n  <img src=\"Linux高性能服务器编程（13-15）/shmget额外标志.png\"  />\n\n如果 `shmget` 用于创建共享内存，则这段共享内存的所有字节都被初始化为 0，与之关联的内核数据结构 `shmid_ds` 将被创建并初始化，其结构体定义如下：\n\n<img src=\"Linux高性能服务器编程（13-15）/shmid_ds0.png\"  />\n\n<img src=\"Linux高性能服务器编程（13-15）/shmid_ds1.png\"  />\n\n`shmget` 对 `shmid_ds` 结构体的初始化包括：\n\n<img src=\"Linux高性能服务器编程（13-15）/shmid_ds初始化.png\" style=\"zoom:80%;\" />\n\n##### 13.6.2 shmat 和 shmdt 系统调用\n\n共享内存被创建/获取之后，我们不能立即访问它，而是①需要先将它关联到进程的地址空间中。②使用完共享内存之后，需要将它从进程地址空间中分离。使用如下两个系统调用实现：\n\n```cpp\n#include <sys/shm.h>\nvoid* shmat( int shm_id, const void* shm_addr, int shmflg );\nint shmdt( const void* shm_addr );\n```\n\n* shm_id：`shmget` 调用返回的共享内存标识符。\n\n* shm_addr：指定将共享内存关联到进程的哪块地址空间，最终的效果还受到 `shmflg` 参数的可选标志 SHM_RND 的影响：\n\n  <img src=\"Linux高性能服务器编程（13-15）/SHM_RND.png\"  />\n\n除了 SHM_END 标志外，`shmget` 参数还支持如下标志：\n\n<img src=\"Linux高性能服务器编程（13-15）/shmflg1.png\"  />\n\n<img src=\"Linux高性能服务器编程（13-15）/shmflg2.png\"  />\n\n**shmat**\n\n成功返回共享内存被关联到的地址，失败时返回 `(void*)-1` 并设置 errno，`shmat` 成功时，将修改内核数据结构 `shmid_ds` 的部分字段，如下：\n\n<img src=\"Linux高性能服务器编程（13-15）/shmat.png\"  />\n\n**shmdt**\n\n将关联到 shm_addr 处的共享内存从进程中分离。它成功时返回 0，失败时返回 -1 并设置 errno。`shmdt` 在成功调用时将修改内核数据结构 `shmid_ds` 的部分字段，如下：\n\n<img src=\"Linux高性能服务器编程（13-15）/shmdt.png\"  />\n\n##### 13.6.3 shmctl 系统调用\n\n`shmctl` 系统调用控制共享内存的某些属性。其定义如下：\n\n```cpp\n#include <sys/shm.h>\nint shmctl( int shm_id, int command, struct shmid_ds* buf );\n```\n\n* shm_id：`shmget` 调用返回的共享内存标识符。\n* command：指定要执行的命令。如下表：\n\n<img src=\"Linux高性能服务器编程（13-15）/shmctl命令.png\"  />\n\n`shmctl` 成功时的返回值取决于 command 参数，如上表所示。失败时返回 -1，并设置 errno。\n\n##### 13.6.4 共享内存的 POSIX 方法\n\n通过打开同一个文件，`mmap` 可以实现无关进程之间的内存共享。Linux 提供了另外一种利用 `mmap` 在无关进程之间共享内存的方式，这种方式无须任何文件的支持，但它需要先使用如下函数来创建或打开一个 POSIX 共享内存对象：\n\n```cpp\n#include <sys/mman.h>\n#inculde <sys/stat.h>\n#inculde <fcntl.h>\nint shm_open( const char* name, int oflag, mode_t mode );\n```\n\n`shm_open` 的使用方法与 `open` 系统调用完全相同。\n\n<img src=\"Linux高性能服务器编程（13-15）/shm_open.png\"  />\n\n`shm_open` 调用成功时返回一个文件描述符。该文件描述符可用于后续的 `mmap` 调用，从而将共享内存关联到调用进程。`shm_open` 失败时返回 -1，并设置 errno。\n\n**`shm_open` 创建的共享内存对象使用完之后也需要被删除**。这个过程是通过如下函数实现的：\n\n```cpp\n#include <sys/mman.h>\n#inculde <sys/stat.h>\n#inculde <fcntl.h>\nint shm_unlink( const char *name );\n```\n\n该函数将 name 参数指定的共享内存对象标记为等待删除。当所有使用该共享内存对象的进程都使用 ummap 将它从进程种分离之后，系统将销毁这个共享内存对象所占据的资源。\n\n**如果代码中使用了上述 POSIX 共享内存函数，则编译时候需要指定链接选项 -lrt 。**\n\n##### 13.6.5 共享内存示例\n\n#### 13.7 消息队列\n\n消息队列是在两个进程之间传递二进制数据的一种简单有效的方式。**每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据**，而不一定像管道和命名管道那样必须以先进先出地方式接收数据。\n\nLinux 消息队列的 API 都定义在 `sys/msg.h` 头文件中，包括 4 个系统调用：`msgget`、`msgsnd`、`msgrcv` 和 `msgctl` 。\n\n##### 13.7.1 msgget 系统调用\n\n`msgget` 系统调用创建一个消息队列，或者获取一个已有的消息队列。其定义如下：\n\n```cpp\n#include <sys/msg.h>\nint msgget( key_t key, int msgflg );\n```\n\n* key：键值，用来标识一个全局唯一的消息队列。\n* msgflag：与 `semget` 系统调用的 sem_flag 参数相同。\n\n`msgget` 成功时返回一个正整数值，它是消息队列的标识符。`msgget` 失败时返回 -1，并设置 errno。\n\n如果 `msgget` 用于创建消息队列，则与之关联的内核数据结构 `msqid_ds` 将被创建并初始化。`msqid_ds` 结构体的定义如下：\n\n<img src=\"Linux高性能服务器编程（13-15）/msqid_ds.png\"  />\n\n##### 13.7.2 msgsnd 系统调用\n\n`msgsnd` 系统调用把一条消息添加到消息队列中。其定义如下：\n\n```cpp\n#include <sys/msg.h>\nint msgsnd( int msqid, const void* msg_ptr, size_t msg_sz, int msgflg );\n```\n\n* msqid：由 `msgget` 调用返回的消息队列标识符。\n* msg_ptr：指向一个准备发送的消息，消息必须被定义为如下类型：\n  <img src=\"Linux高性能服务器编程（13-15）/msgbuf.png\" style=\"zoom:120%;\" />\n  * mtype：指定消息的类型，正整数。\n  * mtext：消息数据。\n* msg_sz：消息的数据部分（mtext）的长度。为 0 表示无数据。\n* msgflag：控制 `msgsnd` 行为，通常只支持 IPC_NOWAIT 标志，即以非阻塞的方式发送消息。\n\n默认情况下，发送消息时如果消息队列满了，则 `msgsnd` 将阻塞。若 IPC_NOWAIT 标志被指定，则 `msgsnd` 将立即返回并设置 errno 为 EAGAIN。\n\n处于阻塞状态的 `msgsnd` 调用可能被如下两种异常情况所中断：\n\n<img src=\"Linux高性能服务器编程（13-15）/msgsnd阻塞.png\"  />\n\n##### 13.7.3 msgrcv 系统调用\n\n`msgrcv` 系统调用从消息队列中获取消息。其定义如下：\n\n```cpp\n#include <sys/msg.h>\nint msgrcv( int msqid, void* msg_ptr, size_t msg_sz, long int msgtype, int msgflg );\n```\n\n* msqid：由 `msgget` 调用返回的消息队列标识符。\n* msg_ptr：用于存储接收的消息。\n* msg_sz：消息数据部分的长度。\n* msgtype：指定接收何种类型的消息。\n\n##### 13.7.4 msgctl 系统调用\n\n`msgctl` 系统调用控制消息队列的某些属性，其定义如下：\n\n```cpp\n#include <sys/msg.h>\nint msgctl( int msqid, int command, struct msqid_ds* buf );\n```\n\n* msqid：由 `msgget` 调用返回的消息队列标识符。\n* command：指定要执行的命令，支持命令在 P266 表 13-4。\n\n`msgctl` 成功时返回值取决于 command参数，如 P266 表 13-4 所示。失败时返回 -1，并设置 errno。\n\n#### 13.8 IPC命令\n\nLinux 提供 **ipcs** 命令，以观察当前系统上拥有哪些共享资源实例。此外，可以使用 **ipcrm** 命令来删除遗留在系统中的共享资源。\n\n<img src=\"Linux高性能服务器编程（13-15）/IPC命令.png\"  />\n\n#### 13.9 在进程间传递文件描述符\n\n需要注意的是，传递一个文件描述符并不是传递一个文件描述符的值，而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。\n\n### 第 14 章 多线程编程\n\n本章线程（NPTL）相关的内容都属于 POSIX 线程（简称 `pthread` ）标准，具体包括：\n\n1. 创建线程和结束线程。\n2. 读取和设置线程属性。\n3. POSIX 线程同步方式：**POSIX 信号量、互斥锁和条件变量。**\n\n#### 14.1 Linux 线程概述\n\n##### 14.1.1 线程模型\n\n线程可分为内核线程和用户线程：\n\n* 内核线程：也被称为 LWP（Light Weight Process，轻量级线程），运行在内核空间，由内核来调度。\n* 用户线程：运行在用户空间，由线程库调度。\n\n当进程的一个内核线程获得 CPU 的使用权时，它就加载并运行一个用户线程。可见，**内核线程相当于用户线程运行的“容器”。**\n\n一个进程可以拥有 M 个内核线程和 N 个用户线程，其中 $M \\leq N$。且在一个系统的所有进程中，M 和 N 的比值是**固定的**。\n\n线程的实现方式分为三种模式：\n\n* 完全在用户空间实现，多对一。\n* 完全由内核调度，一对一。\n* 双层调度，多对多。\n\n##### 14.1.2 Linux 线程库\n\n现代 Linux 上默认使用的线程库是 NPTL，可以用如下命令查看当前系统上所使用的线程库：\n\n<img src=\"Linux高性能服务器编程（13-15）/NPTL.png\"  />\n\n相比于 LinuxThreads，NPTL 的主要优势在于：\n\n<img src=\"Linux高性能服务器编程（13-15）/NPTL优势.png\"  />\n\n#### 14.2 创建进程和结束进程\n\n创建和结束线程的基础 API，Linux 上它们都定义在 `pthread.h` 头文件中。\n\n1. `pthread_create`，创建一个线程：\n\n   <img src=\"Linux高性能服务器编程（13-15）/pthread_create.png\"  />\n\n* thread 参数是新线程的标识符，后续 `pthread_*` 函数通过它来引用新线程。其类型 `pthread_t` 的定义如下：\n\n  <img src=\"Linux高性能服务器编程（13-15）/pthread_t.png\"  />\n\n* attr 参数用于设置新线程的属性。给它传递 NULL 标识使用默认线程属性。\n\n* start_routine 和 arg 指定新线程运行的函数及其参数。\n\n<img src=\"Linux高性能服务器编程（13-15）/pthread_create_flag.png\"  />\n\n2. `pthread_exit`，线程结束时最好调用此函数，以确保安全、干净的退出：\n\n   <img src=\"Linux高性能服务器编程（13-15）/pthread_exit.png\"  />\n\n`pthread_exit` 函数通过 retval 参数向线程的回收者传递其退出信息。它执行完之后不回返回到调用者，而且永远不会失败。\n\n3. `pthread_join`，一个进程中的所有线程都可以调用 `pthread_join` 函数来回收**其他线程**（前提是目标线程是可回收的，见后文），即等待**其他线程**结束，类似于回收进程的 `wait` 和 `waitpid` 系统调用。定义如下：\n\n   <img src=\"Linux高性能服务器编程（13-15）/pthread_join.png\"  />\n\n`thread` 参数是目标线程的标识符，retval 参数是目标线程返回的退出信息。该函数会一直阻塞，直到被回收的线程结束为止。该函数成功时返回 0，失败则返回错误码。可能的错误码如下：\n\n<img src=\"Linux高性能服务器编程（13-15）/pthread_join函数可能引发的错误码.png\"  />\n\n4. `pthread_cancel`，有时候希望异常终止一个线程，即取消线程，通过以下函数实现：\n\n   <img src=\"Linux高性能服务器编程（13-15）/pthread_cancel.png\"  />\n\n* thread 参数是目标线程的标识符。\n\n该函数成功时返回 0，失败则返回错误码。接收到取消请求的目标线程可以决定是否允许被取消以及如何取消，通过以下函数：\n\n<img src=\"Linux高性能服务器编程（13-15）/pthread_cancel_.png\"  />\n\n具体参数详见 P273。\n\n#### 14.3 线程属性※\n\n`pthread_attr_t` 结构体定义了一套完整的线程属性，如下所示：\n\n<img src=\"Linux高性能服务器编程（13-15）/pthread_attr_t结构体.png\"  />\n\n可见，各种线程属性全部包含在一个字符数组中。线程库定义了一系列函数来操作 `pthread_attr_t` 类型的变量，以方便我们获取和设置线程属性。这些函数在 P273。\n\n**脱离线程**：脱离了与其他线程同步的线程称为”脱离线程“。脱离线程在退出时将自行释放其占用的系统资源。可以设置 `detachstate` 设置为 `PTHREAD_CREATE_DETACH`，也可以使用 `pthread_detach` 函数直接将线程设置为脱离线程。\n\n#### 14.4 POSIX 信号量\n\nLinux 上信号量 API 有两组。一组是第 13 章讨论过的 System V IPC 信号量，另外一组是现在要讨论的 POSIX 信号量。这两组接口很相似，但不保证能互换。\n\nPOSIX 信号量函数的名字都以 `sem_` 开头，并不像大多数线程函数那样以 `pthread_` 开头。常用的 POSIX 信号量是下面 5 个：\n\n<img src=\"Linux高性能服务器编程（13-15）/POSIX信号量.png\"  />\n\n* sem：指向被操作的信号量。\n* sem_init：用于初始化一个未命名的信号量；pshared 参数指定信号量的类型，如果为 0，表示这个信号量是当前进程的局部信号量；value 参数指定信号量的初始值。**此外，初始化一个已经被初始化的信号量将导致不可预期的结果。**\n* sem_destroy：用于销毁信号量，以释放其占用的内核资源。**如果销毁一个正被其他线程等待的信号量，则将导致不可于其的结果。**\n* sem_wait：以原子操作的方式将信号量的值减 1，如果信号量的值为 0，则 sem_wait 将被阻塞，直到这个信号量具有非 0 值。\n* sem_trywait：与 sem_wait 类似，不过它始终立即返回，而不论操作的信号量是否具有非 0 值，相当于 sem_wait 的非阻塞版本。\n* sem_post：以原子操作的方式将信号量的值加 1。当信号量的值大于 0 时，其他正在调用 sem_wait 等待信号量的线程将被唤醒。\n\n以上函数成功时返回 0，失败则返回 -1 并设置 errno。\n\n#### 14.5 互斥锁\n\n互斥锁可以用于保护关键代码段，以确保其独占式的访问。当进入关键代码段时，我们需要获得互斥锁并将其加锁，类似于二进制信号量的 P 操作；当离开关键代码段时，我们需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程，等价于二进制信号量的 V 操作。\n\n##### 14.5.1 互斥锁基础 API\n\nPOSIX 互斥锁的相关函数主要有如下 5 个：\n\n<img src=\"Linux高性能服务器编程（13-15）/POSIX互斥锁.png\"  />\n\n* mutex：指向要操作的目标互斥锁，互斥锁的类型是 `pthread_mutex_t` 结构体。\n\n**pthread_mutex_init**\n\n用于初始化互斥锁。mutexattr 参数指定互斥锁的属性。如果将它设置为 NULL，则表示使用默认属性。也可以使用如下方式初始化一个互斥锁：\n\n```CPP\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n```\n\n**pthread_mutex_destroy**\n\n用于销毁互斥锁，以释放其占用的内核资源。**销毁一个已经加锁的互斥锁将导致不可预期的后果。**\n\n**pthread_mutex_lock**\n\n<img src=\"Linux高性能服务器编程（13-15）/pthread_mutex_lock.png\"  />\n\n**pthread_mutex_trylock**\n\n<img src=\"Linux高性能服务器编程（13-15）/pthread_mutex_trylock.png\"  />\n\n**pthread_mutex_unlock**\n\n<img src=\"Linux高性能服务器编程（13-15）/pthread_mutex_unlock.png\"  />\n\n上面这些函数成功时返回 0，失败则返回错误码。\n\n##### 14.5.2 互斥锁属性\n\n`pthread_mutexattr_t` 结构体定义了一套完整的互斥锁属性。线程库提供了一系列函数类操作 `pthread_mutexattr_t` 类型的变量以方便我们获取和设置互斥锁属性。如下：\n\n<img src=\"Linux高性能服务器编程（13-15）/互斥锁属性.png\"  />\n\n最主要两种是：`pshared` 和 `type`。\n\n互斥锁 `pshared` 指定是否允许跨进程共享互斥锁，其可选值有两个：\n\n<img src=\"Linux高性能服务器编程（13-15）/pshared.png\"  />\n\n互斥锁属性 `type` 指定互斥锁的类型。Linux 支持如下 4 种类型的互斥锁：\n\n<img src=\"Linux高性能服务器编程（13-15）/type.png\"  />\n\n##### 14.5.3 死锁举例\n\nP278。\n\n#### 14.6 条件变量\n\n互斥锁：同步线程对共享数据的访问。\n\n条件变量：线程之间同步共享数据的值。\n\n**条件变量**提供了一种线程间的通知机制：**当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。**条件变量的相关函数主要有如下 5 个：\n\n<img src=\"Linux高性能服务器编程（13-15）/条件变量.png\"  />\n\n* cond：指向要操作的目标条件变量，类型为 `pthread_cond_t` 结构体。\n\n**pthread_cond_init**\n\n用于初始化条件变量。cond_attr 参数执行条件变量的属性，设置为 NULL，表示使用默认属性。除了使用 `init` 函数，还可以用如下方式初始化：\n\n<img src=\"Linux高性能服务器编程（13-15）/pthread_cond_init.png\"  />\n\n宏实际上是把条件变量的各个字段都初始化为 0。\n\n**pthread_cond_destroy**\n\n用于销毁条件变量，以释放其占用的内核资源。销毁一个正在被等待的条件变量将失败并返回 EBUSY。\n\n**pthread_cond_broadcast**\n\n以广播的方式唤醒所有等待目标条件变量的线程。\n\n**pthread_cond_signal**\n\n用于唤醒一个等待目标条件变量的线程。至于哪个线程将被唤醒，则取决于线程的优先级和调度策略。\n\n**pthread_cond_wait**\n\n用于等待目标条件变量。mutex 参数是用于保护条件变量的互斥锁，以确保 `pthread_cond_wait` 的原子性。详细信息 P280。\n\n#### 14.7 线程同步机制包装类\n\n三种线程同步方式封装。P280-P282。\n\n#### 14.8 多线程环境\n\n##### 14.8.1 可重入函数\n\n如果一个函数能被多个线程**同时调用**且**不发生竞态条件**，则我们称它是**线程安全**的，或者**可重入函数**。Linux 库函数只有一小部分是不可重入的，比如 `inet_ntoa` 函数。不过 Linux 对很多不可重入的库函数提供了对应的可重入版本，这些可重入版本的函数名是在原函数名尾部加上 _r。如 `localtime` 对应的可重入函数是 `localtime_r`。\n\n##### 14.8.2 线程和进程\n\n如果一个多线程程序的某个线程调用了 `fork` 函数，那么新创建的子进程只拥有一个执行线程，它是调用 `fork` 的哪个线程的完整复制，并且子进程将自动继承父进程种互斥锁。关于可能造成死锁的详情见 P283。\n\n ##### 14.8.3 线程和信号\n\n每个线程都可以独立地设置信号掩码，多线程环境下应使用 `pthread` 版本的 `sigprocmask` 函数来设置线程信号掩码：\n\n<img src=\"Linux高性能服务器编程（13-15）/sigprocmask.png\"  />\n\n该函数的参数的含义与 `sigprocmask` 完全相同，成功返回 0，失败返回错误码。\n\n我们应该定义一个专门的线程来处理所有的信号，通过以下两个步骤来实现：\n\n<img src=\"Linux高性能服务器编程（13-15）/处理信号的线程.png\"  />\n\n* set：执行需要等待的信号的集合。\n* sig：指向的整数用于存储该函数返回的信号值\n\n`sigwait` 成功时返回 0，失败时返回错误码。\n\n最后，`pthread` 还提供以下方法，明确将一个信号发送给指定的线程：\n\n<img src=\"Linux高性能服务器编程（13-15）/pthread_kill.png\"  />\n\n* thread：指定目标线程。\n* sig：指定待发送的信号。\n\n`pthread_kill` 成功时返回 0，失败时返回错误码。\n\n### 第 15 章\n\n#### 15.1 进程池和线程池概述\n\n* 进程池是由服务器预先创建的一组子进程，典型情况数目为 3~10 个之间。而线程池中的线程数量应该和 CPU 数量差不多。\n* 进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、PGID等。\n* 当有新任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。\n\n相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。\n\n主进程选择哪个子进程来为新任务服务，则有**两种方式**：\n\n* <img src=\"Linux高性能服务器编程（13-15）/主进程选择子进程1.png\"  />\n* <img src=\"Linux高性能服务器编程（13-15）/主进程选择子进程2.png\"  />\n\n<img src=\"Linux高性能服务器编程（13-15）/进程池模型.png\"  />\n\n通知机制：\n\n* 父子进程：最简单的方法是通过管道。\n* 父子线程：全局变量。\n\n#### 15.2 处理多客户\n\n<img src=\"Linux高性能服务器编程（13-15）/处理多客户.png\"  />\n\n#### 15.3 半同步/半异步进程池实现\n\nP289-P297\n\n#### 15.4 用进程池实现的简单 CGI 服务器\n\nP298-P301\n\n#### 15.5 半同步/半反应堆线程池的实现\n\n相比于 15.3 半同步/半异步进程池实现，该线程池使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。\n\n如果要将该线程池应用到实际服务器程序中，那么我们必须保证客户请求都是无状态的，因为同一个连接上的不同请求可能会由不同的线程处理。\n\nP301-P304\n\n#### 15.6 用线程池实现的简单 Web 服务器\n\n##### 15.6.1 http_conn 类\n\nP304-P318s\n\n##### 15.6.2 main 函数\n\nP318-P321","tags":["高性能服务器"],"categories":["Linux"]},{"title":"Linux高性能服务器编程（7-12）","url":"/blog/2021/10/08/Linux高性能服务器编程（7-12）/","content":"\nLinux高性能服务器编程（7-12）\n\n<!-- more-->\n\n### 第 7 章 Linux 服务器程序规范\n\n服务器程序规范如下：\n\n* Linux 服务器程序一般以后台形式运行。后台程序又称为**守护进程**。它没有控制终端，因而也不会意外接收到用户输入。守护进程的父进程通常是 **init** 进程（PID 为 1 的进程）。\n* Linux 服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的 UDP 服务器。大部分后台进程都在 /var/log 目录下拥有自己的日志目录。\n* Linux 服务器程序一般以某个专门的非 root 身份运行。比如 mysqld、httpd、syslogd 等后台进程，分别拥有自己的运行账户 mysql、apache 和 syslog。\n* Linux 服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件，并存放在 /etc 目录下。\n* Linux 服务器进程通常会在启动的时候生成一个 PID 文件并存入 /var/run 目录中，以记录该后台进程的 PID。比如 syslogd 的 PID 文件是 /var/run/syslogd.pid。\n* Linux 服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。\n\n#### 7.1 日志\n\n##### 7.1.1 Linux 系统日志\n\nLinux 提供一个守护进程来处理系统日志——syslogd，不过现在的 Linux 系统上使用的都是它的升级版——rsyslogd。\n\nrsyslogd 守护进程既能接收用户进程输出的日志，又能接收内核日志。\n\n* 用户进程是通过调用 syslog 函数生成系统日志的。该函数将日志输出到一个 UNIX 本地域 socket 类型（AF_UNIX）的文件 /dev/log 中，rsyslogd 则监听该文件以获取用户进程的输出。\n* 内核日志由 printk 等函数打印至内核的环状缓存（ring buffer）中。环状缓存的内容直接映射到 /proc/kmsg 文件中。rsyslogd 则通过读取该文件获得内核日志。\n\n##### 7.1.2 syslog 函数\n\n应用程序通过使用 syslog 函数与 rsyslogd 守护进程通信。syslog 函数的定义如下：\n\n<img src=\"linux高性能服务器编程（7-12）/syslog.png\"  />\n\npriority 参数是所谓的设施值与日志级别的按位或。设施值的默认值是 LOG_USER，下面讨论的也只限于这一种设施值。日志级别有如下几个：\n\n<img src=\"linux高性能服务器编程（7-12）/日志级别.png\"  />\n\n下面这个函数可以改变 syslog 的默认输出方式，进一步结构化日志内容：\n\n<img src=\"linux高性能服务器编程（7-12）/openlog.png\"  />\n\n* ident：指定的字符串将被添加到日志消息的日期和时间之后，通常被设置为程序的名字。\n* logopt：对后续的 syslog 调用的行为进行配置，它可取下列值的按位或：\n\n<img src=\"linux高性能服务器编程（7-12）/openlog-logopt.png\"  />\n\n* facility：用来修改 syslog 函数中的默认设施值。\n\n**日志过滤**\n\nP116\n\n#### 7.2 用户信息\n\n##### 7.2.1 UID、EUID、GID 和 EGID※\n\n用户信息对于服务器程序的安全性来说很重要，大部分服务器就必须以 root 身份启动，但不能以 root 身份运行。下面这一组函数可以获取和设置当前进程的真实用户 ID（UID）、有效用户 ID（EUID）、真实组 ID（GID）和有效组 ID（EGID）:\n\n<img src=\"linux高性能服务器编程（7-12）/UID等.png\"  />\n\n需要指出的是，**一个进程有两个用户 ID**：UID 和 EUID。EUID 存在的目的是方便资源访问：**它使得运行程序的用户拥有该程序的有效用户的权限。**\n\n##### 7.2.2 切换用户\n\n#### 7.3 进程间关系\n\n##### 7.3.1 进程组\n\nLinux 下每个进程都隶属于一个进程组，因此它们除了 PID 信息外，还有进程组 ID（PGID）。可以用如下函数来获得指定进程的 PGID：\n\n<img src=\"linux高性能服务器编程（7-12）/getpgid.png\"  />\n\n每个进程组都有一个首领进程，其 PGID 和 PID 相同。进程组将一直存在，直到其中所有进程都退出，或者加入其他进程组。\n\n下面的函数用于设置 PGID：\n\n<img src=\"linux高性能服务器编程（7-12）/setpgid.png\"  />\n\n##### 7.3.2 会话\n\n一些有关联的进程组将形成一个会话（session）。下面的函数用于创建一个会话：\n\n<img src=\"linux高性能服务器编程（7-12）/setsid.png\"  />\n\n该函数不能由首领进程调用，否则将产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：\n<img src=\"linux高性能服务器编程（7-12）/新会话.png\"  />\n\nLinux 进程**并未提供所谓会话 ID（SID）**的概念，**但 Linux 系统认为它等于会话首领所在的进程组的 PGID**，并提供了如下函数来读取 SID：\n\n<img src=\"linux高性能服务器编程（7-12）/getsid.png\"  />\n\n##### 7.3.3 用 ps 命令查看进程关系※\n\n<img src=\"linux高性能服务器编程（7-12）/ps.png\"  />\n\n#### 7.4 系统资源限制\n\nLinux 系统资源限制可以通过如下一对函数来读取和设置：\n\n```c\n#include <sys/resource,h>\nint getrlimit( int resource, struct rlimit *rlim );\nint setrlimit( int resource, const struct rlimit *rlim );\n```\n\nrlim 参数是 rlimit 结构体类型的指针，rlimit 结构体的定义如下：\n\n```c\nstruct rlimit{\n\trlim_t rlim_cur;\n\trlim_t rlim_max;\n}\n```\n\nrlim_t 是一个整数类型，它描述资源级别。\n\n* rlim_cur 成员指定资源的软限制（建议性、最好不要超越的限制）\n* rlim_max 成员指定资源的硬限制（软限制的上限）\n\n**resource** 参数指定资源限制类型，如下表：\n\n<img src=\"linux高性能服务器编程（7-12）/资源限制类型.png\"  />\n\n#### 7.5 改变工作目录和根目录\n\n1. 获取进程当前工作目录和改变进程工作目录的函数分别是：\n   <img src=\"linux高性能服务器编程（7-12）/getcwd-chdir.png\"  />\n\n<img src=\"linux高性能服务器编程（7-12）/改变工作目录和跟目录.png\"  />\n\n2. 改变进程根目录的函数是 chroot，其定义如下：\n   <img src=\"linux高性能服务器编程（7-12）/chroot.png\"  />\n\n<img src=\"linux高性能服务器编程（7-12）/改变工作目录和跟目录1.png\"  />\n\n#### 7.6 服务器程序后台化\n\n在代码中让一个进程以守护进程的方式运行。\n\n<img src=\"linux高性能服务器编程（7-12）/后台化.png\"  />\n\n### 第8章 高性能服务器程序框架\n\n#### 8.1 服务器模型\n\n##### 8.1.1 C/S模型\n\n##### 8.1.2 P2P模型\n\n#### 8.2 服务器编程框架\n\n<img src=\"linux高性能服务器编程（7-12）/服务器基本框架.png\"  />\n\n#### 8.3 I/O模型\n\n<img src=\"linux高性能服务器编程（7-12）/IO模型.png\"  />\n\n* 同步 IO：同步 IO 模型包括阻塞 IO，非阻塞 IO 和 IO 多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。 \n  * **阻塞**：调用 IO 操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到 IO 可用并完成数据拷贝。\n  * **非阻塞**：调用 IO 操作的时候，内核会马上返回结果，如果 IO 不可用，会返回错误，这种方式下进程需要不断轮询直到 IO 可用为止，但是当进程从内核拷贝数据时是阻塞的。\n  * **IO 多路复用**：同时监听多个描述符，一旦某个描述符 IO 就绪（读就绪或者写就绪），就能够通知进程进行相应的 IO 操作，否则就将进程阻塞在 select 或者 epoll 语句上。\n  * **信号驱动 I/O**：进程在 IO 访问时，先通过 sigaction 系统调用，提交一个信号处理函数，立即返回，进程不阻塞。当内核准备好数据后，产生一个 SIGIO 信号并投递给信号处理函数，可以在此函数中调用读写函数操作数据，这段过程阻塞。\n* 异步 IO：在检测 IO 是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当 IO 完成后内核会给进程发送一个信号。\n\n**IO复用**：应用程序通过 I/O 复用函数向**内核**注册一组事件，内核通过 I/O 复用函数把其中就绪的事件通知给应用程序。Linux 上常用的 I/O 复用函数是 select、poll、epoll。I/O 复用函数本身是**阻塞**的，他们能提高程序效率的原因是它们具有同时监听多个 I/O 事件的能力。\n\n**共有 5 种 I/O模型。**\n\n下图来自于 UNIX 网络编程卷1。前四种为**同步 I/O。**\n\n<img src=\"linux高性能服务器编程（7-12）/5种IO模型.png\" style=\"zoom:80%;\" />\n\n#### 8.4 两种高效的事件处理模式※\n\n##### 8.4.1 Reactor模式\n\n主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。**读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。**\n\n使用同步 I/O 模型（epoll_wait为例）实现的 Reactor 模式工作流程：\n\n<img src=\"linux高性能服务器编程（7-12）/Reactor.png\"  />\n\n##### 8.4.2 Proactor模式\n\n与 Reactor 模式不同，Proactor 模式将所有 I/O 操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。\n\n使用异步 I/O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：\n\n<img src=\"linux高性能服务器编程（7-12）/Procator.png\"  />\n\n主线程中的 epoll_wait 调用**仅能**用来检测监听 socket 上的**连接请求**事件，而**不能**用来检测连接 socket 上的**读写事件**。\n\n##### 8.4.3 模拟 Proactor 模式\n\n原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写结果进行逻辑处理。\n\n使用同步 I/O 模型（仍然以 epoll_wait 为例）模拟出的 Proactor 模式的工作流程如下：\n\n<img src=\"linux高性能服务器编程（7-12）/模拟Proactor.png\"  />\n\n#### 8.5 两种高效的并发模式\n\n并发模式是指 I/O 处理单元和多个逻辑单元之间协调完成任务的方法。\n\n##### 8.5.1 半同步/半异步模式\n\n并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。如下图：\n\n<img src=\"linux高性能服务器编程（7-12）/异步.png\"  />\n\n半同步/半异步模式中，同步线程用于处理客户逻辑，相当于逻辑单元；异步线程用于处理 I/O 事件，相当于处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该对象请求：\n\n<img src=\"linux高性能服务器编程（7-12）/半同步-半异步.png\"  />\n\n一种变体—半同步/半反应堆模型：\n\n<img src=\"linux高性能服务器编程（7-12）/半同步-半反应堆模型.png\"  />\n\n其存在以下缺点：\n\n<img src=\"linux高性能服务器编程（7-12）/半同步-半反应堆.png\"  />\n\n一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接：\n\n<img src=\"linux高性能服务器编程（7-12）/高效的半同步-半异步模式.png\"  />\n\n##### 8.5.2 领导者/追随者模式\n\n<img src=\"linux高性能服务器编程（7-12）/领导者-追随者.png\"  />\n\n#### 8.6 有限状态机\n\n解析 HTTP。\n\n#### 8.7 提高服务器性能的其他建议\n\n##### 8.7.1 池\n\n池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。\n\n**内存池**常用于 socket 的接收缓存和发送缓存。对于某些长度有限的客户请求，比如 HTTP 请求，预先分配一个大小足够（比如5000字节）的接收缓存区是合理的。超过时可选择丢弃请求和动态扩大接收缓冲区。\n\n**进程池**和**线程池**作为工作进程或工作线程来处理新到来的客户请求时，我们可以直接从池中取得一个执行实体，而无须动态的调用 `fork` 或 `pthread_create` 等函数来创建进程或线程。\n\n**连接池**时服务器预先和数据库程序建立的一组连接的集合，当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用之，待完成数据库的访问之后，逻辑单元将该连接返回给连接池。\n\n##### 8.7.2 数据复制\n\n高性能服务器应该避免不必要的数据复制，尤其是当数据复制发生在用户代码和内核之间的时候。\n\n1. 如果内核可以直接处理（应用程序不关心这些数据的内容）从 socket 或者文件读入的数据，则应用程序就没西药将这些数据从内核缓冲区复制到应用程序缓冲区中。\n2. 避免用户代码内部（不访问内核）的数据复制也是应该避免的，例如两个工作进程之间需要传递大量数据时，应考虑使用共享内存来在它们之间传送数据，而不是用管道或消息队列来传递。\n\n##### 8.7.3 上下文切换和锁\n\n并发程序必须考虑上下文切换的问题，即**进程切换或线程切换导致的系统开销**。多线程服务器的一个优点是不同的线程可以同时运行在不同的 CPU 上，当线程的数量不大于 CPU 的数目时，上下文的切换就不是问题了。\n\n并发程序需要考虑的另外一个问题就是共享资源的**加锁保护**，如果服务器有更好的解决方案，就应该避免使用锁。如果服务器必须使用锁，则可以考虑减小锁的粒度，比如使用读写锁。半同步/半异步模式就比半同步/半反应堆模式要好。\n\n### 第9章 I/O 复用\n\n#### 9.1 select 系统调用\n\n##### 9.1.1 select api\n\n##### 9.1.2 文件描述符就绪条件\n\n##### 9.1.3 处理带外数据\n\n#### 9.2 poll 系统调用\n\n#### 9.3 epoll系列系统调用\n\n##### 9.3.1 内核事件表\n\n##### 9.3. 2 epoll_wait 函数\n\n##### 9.3.3 lt 和 et 模式\n\nepoll 对文件描述符的操作有两种模式：LT（Level Trigger，电平出发）模式和 ET（Edge Trigger，边沿触发）模式。\n\n* LT 模式是默认的工作模式，这种模式下 epoll 相当于一个效率较高的 poll。对于采用 LT 工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。当应用程序下一次调用 epoll_wait 时，epoll_wait 还会再次向应用程序通告此事件，直到该事件被处理。\n* ET 模式时 epoll 高效的工作模式，对于采用 ET 工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的 epoll_wait 调用将不再向应用程序通知这一事件。\n\n由此可见，ET 模式降低了同一个 epoll 事件被重复触发的次数，因此效率比 LT 模式高。\n\n**注意：**每个使用 ET 模式的文件都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一致处于阻塞状态（饥渴状态）。\n\n##### 9.3.4 epolloneshot 事件\n\n#### 9.4 三组 I/O 复用函数的比较\n\n<img src=\"linux高性能服务器编程（7-12）/三种复用的区别.png\"  />\n\n#### 9.5 I/O 复用的高级应用一：非阻塞 connect\n\n#### 9.6 I/O 复用的高级应用二：聊天室程序\n\n##### 9.6.1 客户端\n\n##### 9.6.2 服务器\n\n#### 9.7 I/O 复用的高级应用三：同时处理 TCP 和 UDP 服务\n\n### 第10章 信号\n\n信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。Linux 信号可由如下条件产生：\n\n<img src=\"linux高性能服务器编程（7-12）/信号.png\"  />\n\n#### 10.1 Linux 信号概述\n\n##### 10.1.1 发送信号\n\nLinux 下，一个进程给其他进程发送信号的 API 是 kill 函数，定义如下：\n\n```cpp\n#include <sys/types.h>\n#include <signal.h>\nint kill( pid_t pid, int sig );\n```\n\n该函数把信号 sig 发送给目标进程：目标进程由 pid 参数指定，其可能的取值及含义如下：\n\n<img src=\"linux高性能服务器编程（7-12）/kill.png\"  />\n\n##### 10.1.2 信号处理方式\n\n目标进程收到信号后，需要定义一个接收函数来处理，信号处理函数的原型如下：\n\n```cpp\n#include <signal.h>\ntypedef void (*_sighandler_t) ( int );\n```\n\n##### 10.1.3 Linux 信号\n\nLinux 可用信号都定义在 `bits/signum.h` 头文件中，其中包括标准信号和 POSIX 实时信号。表在 P180。\n\n##### 10.1.4 中断系统调用\n\n#### 10.2 信号函数\n\n##### 10.2.1 signal 系统调用\n\n要为一个信号设置处理函数，可以使用下面的 signal 系统调用：\n\n```cpp\n#include <signal.h>\n_sighandler_t signal ( int sig, _sighandler_ _handler )\n```\n\n* `sig`：要捕获的信号类型\n* `_handler`：_sighandler_t 类型的函数指针，用于指定信号 sig 的处理函数\n\nsignal 函数成功返回前一次调用 signal 函数时传入的函数指针，或者是信号 sig 对应的默认处理函数指针 SIG_DEF（如果是第一次调用 signal 的话）。\n\nsignal 系统调用出错时返回 SIG_ERR，并设置 errno。\n\n##### 10.2.2 sigaction 系统调用\n\n设置信号处理函数的更健壮的接口是如下的系统调用：\n\n```cpp\n#include <signal.h>\nint sigaction( int sig, const struct sigaction* act, struct sigaction* oact);\n```\n\n* `sig`：要捕获的信号类型\n* `act`：指定新的信号处理方式\n* `oact`：输出信号先前的处理方式（如果不为 NULL 的话）\n\nsigaction 结构体描述了信号处理的细节，其定义如下：\n\n```cpp\nstruct sigaction{\n#ifdef __USE_POSIX199309\n\tunion\n\t{\n\t\t_sighandler_t sa_handler;\n\t\tvoid (*sa_sigaction) ( int, siginfo_t*, void* );\n\t} \n\t_sigaction_handler;\n#define sa_handler\t\t__sigaction_handler.sa_handler\n#define sa_sigcation\t__sigaction_handler.sa_sigaction\n#else\n\t_sighandler_t sa_handler;\n#endif\n\t\n\t_sigset_t sa_mask;\n\tint sa_flags;\n\tvoid (*sa_restorer) (void);\n};\n```\n\n参数的详细介绍在 P182。\n\n#### 10.3 信号集\n\n##### 10.3.1 信号集函数\n\nLinux 使用数据结构 sigset_t 来表示一组信号。定义如下：\n\n```cpp\n#include <bits/sigset.h>\n# define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))\ntypedef struct\n{\n\tunsigned long int __val[_SIGSET_NWORDS];\n} __sigset_t;\n```\n\nsigset_t 实际上是一个长整型数组，数组中的每个元素的每个位表示一个信号。Linux 提供了如下一组函数来设置、修改、删除和查询信号集：\n\n<img src=\"linux高性能服务器编程（7-12）/信号集.png\"  />\n\n##### 10.3.2 进程信号掩码\n\n##### 10.3.3 被挂起的信号\n\n#### 10.4 统一事件源\n\n信号是一种异步事件：信号处理函数和程序的主循环是两条不同的执行路线。显然，信号处理函数需要尽可能快的执行完毕，以确保该信号不被屏蔽太久。一种典型的解决方案是 P184。\n\n#### 10.5 网络编程相关信号\n\n##### 10.5.1 SIGHUP\n\n当挂起进程的控制终端时，SIGHUP 信号将被出发。对于没有控制终端的网络后台程序而言，它们通常利用 SIGHUP 信号来强制服务器重读配置文件。一个典型的例子时 xinetd 超级服务程序。\n\n##### 10.5.2 SIGPIPE\n\n默认情况下，往一个读端关闭的通道或 socket 连接中写数据将引发 SIGPIPE 信号。我们需要在代码中捕获并处理该信号，或者至少忽略它。因为程序接收到 SIGPIPE 信号的默认行为是结束进程，我们不希望因为错误的写操作而导致程序退出。引起 SIGPIPE 信号的写操作将设置 errno 为 EPIPE。\n\n##### 10.5.3 SIGURG\n\nLinux 下内核通知应用程序带外数据到达主要有两种办法：\n\n1. I/O 复用计数\n2. 使用 SIGURG 信号\n\n**TCP带外数据相关知识**\n\n* 3.8 节 TCP 带外数据的基本知识\n* 5.8.1 小节 如何在应用程序中使用带 MSG_OOB 标志的 send/recv 系统调用来发送/接收带外数据\n* 9.1.3 10.5.3 小节 检测带外数据是否到达的两种方法\n\n### 第11章 定时器\n\nLinux 提供了三种定时方法，它们是：\n\n* socket 选项 SO_RCVTIMEO 和 SO_SNDTIMEO。\n* SIGALRM 信号。\n* I/O 复用系统调用的超时参数。\n\n#### 11.1 socket 选项 SO_RCVTIMEO 和 SO_SNDTIMEO\n\nSO_RCVTIMEO：设置 socket 接收数据超时时间。\n\n SO_SNDTIMEO：设置 socket 接收数据超时时间。\n\n仅对数据接收和发送相关的 socket 的 API 有效，包括 `send`、`sendmsg`、`recv`、`resvmsg`、`accept`和 `connect`。\n\n<img src=\"linux高性能服务器编程（7-12）/SO_REVTIMEO和SO_SNDTIMEO调用.png\"  />\n\n#### 11.2 SIGALRM 信号\n\n由 `alarm` 和 `setitimer` 函数设置的实时闹钟一旦超时，将出发 SIGALRM 信号。\n\n##### 11.2.1 基于升序链表的定时器\n\n定时器通常至少包含两个成员：一个超时时间（相对时间或者绝对时间）和一个任务回调函数。\n\n##### 11.2.2 处理非活动连接\n\n可以考虑在应用层实现类似于 KEEPALIVE 的机制，以管理所有长时间处于非活动状态的连接。\n\n#### 11.3 I/O 复用系统调用的超时参数\n\nLinux 下的 3 组 I/O 复用系统调用都带有超时参数，因此它们不仅能统一处理信和 I/O 时间，也能统一处理定时事件。但是由于 I/O 复用系统调用可能在超时事件到期之前就返回（有 I/O 事件发生），所以如果我们要利用它们来定时，就需要不断更新定时参数以反应剩余的时间。\n\n#### 11.4 高性能定时器\n\n##### 11.4.1 时间轮\n\n<img src=\"linux高性能服务器编程（7-12）/时间轮.png\"  />\n\n##### 11.4.2 时间堆\n\n将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数 tick 被调用，超时时间最小的定时器必然到期，我们就可以在 tick 函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。**最小堆**适合处理此种方案。\n\n### 第12章 高性能I/O框架库libevent\n\n#### 12.1 I/O 框架库概述\n\n基于 Reactor 模式的 I/O 框架库包含如下几个组件：句柄（handle）、事件多路分发器（EventDemultiplexer）、事件处理器（EventHander）和具体的事件处理器（ConcreteEventHandler）、Reactor。这些组件关系如图所示：\n\n<img src=\"linux高性能服务器编程（7-12）/IO框架库组件.png\"  />\n\n**句柄**\n\n<img src=\"linux高性能服务器编程（7-12）/句柄.png\"  />\n\n**事件多路分发器**\n\n<img src=\"linux高性能服务器编程（7-12）/事件多路分发器.png\"  />\n\n<img src=\"linux高性能服务器编程（7-12）/事件多路分发器1.png\"  />\n\n<img src=\"linux高性能服务器编程（7-12）/事件多路分发器2.png\" style=\"zoom:80%;\" />\n\n**事件处理器和具体事件处理器**\n\n<img src=\"linux高性能服务器编程（7-12）/事件处理器和具体事件处理器.png\"  />\n\n**Reactor**\n\nReactor 是 I/O 框架库的核心，它提供的几个主要方法是：\n\n* `handle_events`：该方法执行事件循环。它重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器。\n* `register_handler`：该方法调用事件多路分发器的 `register_event` 方法来往事件多路分发器中注册一个事件。\n* `remove_handler`：该方法掉调用事件多路分发器的 `remove_event` 方法来删除事件多路分发器中的一个事件。\n\n下图是 I/O 框架库的工作时序：\n\n<img src=\"linux高性能服务器编程（7-12）/IO框架库的工作时序.png\"  />\n\n#### 12.2 Libevent 源码分析\n\n\n\n","tags":["高性能服务器"],"categories":["Linux"]},{"title":"设计模式","url":"/blog/2021/10/08/设计模式/","content":"\n**目前已经整理的设计模式**\n\n1. 单例模式\n2. 简单工厂模式\n\n<!-- more-->\n\n### 设计模式的分类\n\n#### 创建型\n\n创建对象时，不由我们直接实例化对象，而是根据特殊场景，**由程序来确定创建对象的方式**，从而保证更大的性能、更好的架构优势。\n\n创建型模式主要有：\n\n* **简单工厂模式**\n* **工厂方法**\n* **抽象工厂模式**\n* **单例模式**\n* 生成器模式\n* 原型模式\n\n#### 结构型\n\n**用于帮助将多个对象组织成更大的结构。**\n\n结构型模式主要有：\n\n* 适配器模式\n* **桥接模式**\n* 组合器模式\n* 装饰器模式\n* **门面模式**\n* 享元模式\n* **代理模式**\n\n#### 行为型\n\n**用于帮助系统间各对象的通信，以及如何控制复杂系统中流程。**\n\n行为型模式主要有：\n\n* **命令模式**\n* 解释器模式\n* 迭代器模式\n* 中介者模式\n* 备忘录模式\n* **观察者模式**\n* 状态模式\n* **策略模式**\n* 模板模式\n* 访问者模式\n\n### 常见的设计模式介绍\n\n#### 创建型\n\n##### 单例模式（singleton）\n\n单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n主要解决：一个全局使用的类频繁地创建与销毁。\n\n何时使用：想控制实例数目，节省系统资源的时候。\n\n如何解决：判断系统是否已存在单例，如果有则返回，没有则创建。\n\n关键代码：私有构造函数。\n\n实现方法：懒汉与饿汉。\n\n###### **懒汉**\n\n不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化。\n\n```cpp\n// 懒汉式，线程不安全\n#ifndef SINGLETON_SINGLETON_H\n#define SINGLETON_SINGLETON_H\n#include <iostream>\nusing namespace std;\nclass Singleton {\npublic:\n    static Singleton* getInstance(){\n        if(instance == nullptr){\n            cout << \"创建新的实例\" << endl;\n            instance = new Singleton();\n        }\n        return instance;\n    }\n    Singleton(Singleton &obj) = delete; // 明确拒绝\n    Singleton& operator=(const Singleton&) = delete; // 明确拒绝\nprivate:\n    Singleton() = default;\n    static Singleton* instance;\n};\nSingleton* Singleton::instance = nullptr;\n#endif //SINGLETON_SINGLETON_H\n\n\n#include \"Singleton.h\"\nint main(){\n    Singleton *s1 = Singleton::getInstance();\n    Singleton *s2 = Singleton::getInstance();\n    return 0;\n}\n```\n\n```cpp\n// 懒汉式，线程安全\n#ifndef SINGLETON_SINGLETON_MT_H\n#define SINGLETON_SINGLETON_MT_H\n#include <iostream>\n#include <mutex>\nusing namespace std;\nclass Singleton_mt {\npublic:\n    static Singleton_mt* getInstance(){\n        if(instance == nullptr){\n            mt.lock();\n            cout << \"创建新的实例\" << endl;\n            instance = new Singleton_mt();\n            mt.unlock();\n        }\n        return instance;\n    }\n    Singleton_mt(Singleton_mt &obj) = delete; // 明确拒绝\n    Singleton_mt& operator=(const Singleton_mt&) = delete; // 明确拒绝\nprivate:\n    Singleton_mt() = default;\n    static Singleton_mt* instance;\n    static std::mutex mt;\n};\nSingleton_mt* Singleton_mt::instance = nullptr;\nstd::mutex Singleton_mt::mt;\n\n\n#include \"Singleton_mt.h\"\n#include <thread>\n#include <windows.h>\nconst int THREAD_NUM = 5;\nusing namespace std;\nvoid callSingleton(int n){\n    Singleton_mt *s = Singleton_mt::getInstance();\n    cout << \"线程编号为：\" << n << endl;\n    Sleep(50);\n}\nint main(){\n    thread th[THREAD_NUM];\n    // 线程编号\n    int threadNum = 0;\n    while(threadNum < THREAD_NUM){\n        th[threadNum] = thread(callSingleton, threadNum);\n        threadNum++;\n    }\n    for(auto &t : th){\n        t.join();\n    }\n    return 0;\n}\n```\n\n###### **饿汉**\n\n在单例类定义的时候就进行实例化。\n\n```cpp\n// 饿汉模式，线程安全\n#ifndef SINGLETON_SINGLETON_EHAN_H\n#define SINGLETON_SINGLETON_EHAN_H\n#include <iostream>\nusing namespace std;\nclass Singleton_ehan {\npublic:\n    static Singleton_ehan* getInstance(){\n        return instance;\n    }\n    Singleton_ehan(const Singleton_ehan&) = delete;\n    Singleton_ehan& operator=(const Singleton_ehan&) = delete;\nprivate:\n    static Singleton_ehan* instance;\n    Singleton_ehan(){\n        cout << \"创建新的实例\" << endl;\n    }\n};\nSingleton_ehan* Singleton_ehan::instance = new Singleton_ehan();\n\n#include \"Singleton_ehan.h\"\nint main(){\n    Singleton_ehan *s1 = Singleton_ehan::getInstance();\n    Singleton_ehan *s2 = Singleton_ehan::getInstance();\n    return 0;\n}\n```\n\n**如何选择**\n\n由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能，以空间换时间；在访问量较小时，采用懒汉实现。这是以时间换空间。\n\n##### 简单工厂模式（Factory）\n\n**实现流程**：\n\n* 设计一个抽象类，它包含一些公共方法的实现\n* 从抽象产品类中派生出多个具体产品类\n* 设计一个工厂类，工厂类中提供一个生产各种产品的工厂方法，该方法根据传入参数（产品名称）创建不同的具体产品类对象\n* 客户只需要调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象\n\n**简单工厂定义：**\n\n定义一个简单工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n\n**简单工厂模式结构**\n\n大体上分为 3 个角色。\n\n* 工厂（Factory）：根据客户提供的具体产品类的参数，创建具体产品实例。\n* 抽象产品（AbstractProduct）：具体产品类的基类，包含创建产品的公共方法。\n* 具体产品（ConcreteProduct）：抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。\n\n简单工厂模式 UML 类图如下：\n\n<img src=\"设计模式/简单工厂模式.png\"  />\n\n**实现**：\n\nhttps://gitee.com/settlezxy/design-pattern.git\n\n**优点：**\n\n* 工厂类提供创建具体产品的方法，并包含一定的逻辑，客户不必参与产品的创建过程。\n* 客户只需要知道对应产品的参数即可，参数一般简单好记。\n\n**缺点：**\n\n* 增加新的具体产品违反**开闭原则**（对扩展开放，对修改关闭），即在扩展功能时修改了既有的代码。\n* 简单工厂模式所有的判断逻辑都在工厂类中实现，一旦工厂类设计故障，则整个系统受之影响。\n\n#### 行为型\n\n##### 观察者模式\n\n一个对象行为的改变，其相关联的对象都会得到通知，并自动产生相应的行为。这在软件设计模式中，即是**观察者模式。**\n\n","tags":["简单工厂模式","单例模式"],"categories":["设计模式"]},{"title":"图解HTTP（7-11）","url":"/blog/2021/10/08/图解HTTP（7-11）/","content":"\n图解HTTP（7-11）\n\n<!-- more-->\n\n### 第 7 章 确保 Web 安全的 HTTPS\n\n#### 7.1 HTTP 的缺点\n\n* 通信使用明文，内容可能会被窃听\n* 不验证通信方的身份，因此有可能遭遇伪装\n* 无法证明报文的完整性，所以有可能已遭篡改\n\n##### 7.1.1 通信使用明文可能会被窃听\n\n* TCP/IP 是可能被窃听的网络\n\n* 加密处理防止被窃听\n\n  * SSL（Secure Socket Layer，安全套接层）\n  * TLC（Transport Layer Security，安全层传输协议）\n\n  与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。\n\n* 内容的加密，内容有被窜改的风险\n\n##### 7.1.2 不验证通信方的身份就可能遭遇伪装\n\n* 任何人都可发起请求，DOS 攻击\n* 查明对手的证书\n  * 虽然使用 HTTP 协议无法确定通信方，但使用 SSL 可以。SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。\n\n##### 7.1.3 无法证明报文完整性，可能已遭篡改\n\n* 接收到的内容可能有误。请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）\n* 如何防止篡改。使用 HTTPS。\n\n#### 7.2 HTTP+加密+认证+完整性保护=HTTPS\n\n##### 7.2.1 HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS\n\n我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。\n\n<img src=\"图解HTTP（7-11）/使用HTTPS通信.png\"  />\n\n##### 7.2.2 HTTPS 是身披 SSL 外壳的 HTTP\n\nHTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。\n\n<img src=\"图解HTTP（7-11）/HTTP-HTTPS.png\"  />\n\n在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。\n\n* SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是当今世界上应用最为广泛的网络安全技术。\n\n##### 7.2.3 相互交换密钥的公开密钥加密技术\n\nSSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。\n\n近代加密方法中**加密算法**是**公开**的，而**密钥**却是保密的，通过这种方式得以保持加密方法的安全性。\n\n加密和解密都会用到密钥，任何持有密钥的人都可以解密，如果被攻击者获得，则加密失去意义。\n\n* **共享密钥加密**的困境\n\n  * 加密和解密同用一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密。发送密钥就有被窃听的风险，但不发送，对方就不能解密。再说，密钥若能够安全发送，那数据也应该能安全到达。\n\n* 使用**两把**密钥的**公开密钥加密**，很好的解决了共享密钥加密的困难\n\n  * 公开密钥加密使用一对非对称的密钥，一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。私钥不能让其他人知道，而公钥任何人都可以获得。\n  * 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。\n\n* HTTPS 采用**混合加密机制**\n\n  * 在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。\n\n  <img src=\"图解HTTP（7-11）/混合加密机制.png\"  />\n\n##### 7.2.4 证明公开密钥正确性的证书\n\n公开密钥加密方式还是存在一些问题的。那就是无法证明**公开密钥本身就是货真价实的公开密钥。**\n\n为了解决上述问题，可以使用由**数字证书认证机构**（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。\n\n**流程**\n\n首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后将已签名的公开密钥分配，并将该公开密钥放入公钥证书后绑定在一起。\n\n多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。\n\n<img src=\"图解HTTP（7-11）/SSL流程.png\"  />\n\n* 可证明组织真实性的 EV SSL 证书\n  1. 证明作为通信一方的服务器是否规范\n  2. 确认服务器背后运营的企业是否真实存在\n* 用来确认客户端的客户端证书\n* 认证机构信誉第一，SSL 机制中介入认证机构之所以可行，是因为建立在其信用绝对可靠这一大前提下的。\n* 由自认证机构办法的证书称为自签名证书，浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。\n\n##### 7.2.5 HTTPS 的安全通信机制\n\n* SSL 和 TLS，HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security）这两个协议。\n  * SSL 技术起初由网景开发，直到 SSL3.0，后转移至 IETF 手中；\n  * IETF 以 SSL3.0 为基准，制定了 TLS1.0、TLS1.1 和 TLS1.2。有时候统称该协议为 SSL；\n  * 当前主流版本为 SSL3.0 和 TLS1.0。\n\n* SSL 速度慢吗？\n  * HTTPS 比 HTTP 慢 2 到 100倍\n\n### 第 8 章 确认访问用户身份的认证\n\n某些 Web 页面只想让特定的人浏览，或者干脆仅本人可见。为达到这个目标，必不可少的就是认证功能。\n\n#### 8.1 何为认证\n\n核对的信息通常是以下这些：\n\n* 密码：只有本人才会知道的字符串信息。 \n* 动态令牌：仅限本人持有的设备内显示的一次性密码。 \n* 数字证书：仅限本人（终端）持有的信息。 \n* 生物认证：指纹和虹膜等本人的生理信息。\n* IC 卡等：仅限本人持有的信息。\n\n**HTTP 使用的认证方式**\n\nHTTP/1.1 使用的认证方式如下所示：\n\n* BASIC 认证（基本认证） \n* DIGEST 认证（摘要认证）\n* SSL 客户端认证 \n* FormBase 认证（基于表单认证）\n\n#### 8.2 BASIC 认证\n\nBASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。\n\nBASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。 \n\n另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。\n\n#### 8.3 DIGEST 认证\n\n为了克服 BASIC 弱点，从 HTTP/1.1 起就有了 DIGEST 认证。\n\nDIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。\n\n#### 8.4 SSL 客户端认证\n\n##### 8.4.1 SSL客户端认证的认证步骤\n\n步骤 1： 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。\n\n步骤 2： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。\n\n步骤 3： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。\n\n##### 8.4.2 SSL 客户端认证采用双因素认证\n\n第一个认证因素的 SSL客户端证书用来认证客户端计算机， 另一个认证因素的密码则用来确定这是用户本人的行为。\n\n##### 8.4.3 SSL 客户端认证必要的费用\n\n#### 8.5 基于表单认证\n\n基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。\n\n##### 8.5.1 认证多半为基于表单认证\n\n##### 8.5.2 Session 管理及 Cookie 应用\n\n基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session（会话）。\n\n<img src=\"图解HTTP（7-11）/Session管理及Cookie状态管理.png\"  />\n\n你可以把 Session ID 想象成一种用以区分不同用户的等位号。\n\n### 第 9 章 基于 HTTP 的功能追加协议\n\n#### 9.1 基于 HTTP 的协议\n\nHTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃 HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了新的功能。\n\n#### 9.2 消除 HTTP 瓶颈的 SPDY\n\nGoogle 在 2010 年发布了 SPDY（取自 SPeeDY，发音同 speedy），其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。\n\n##### 9.2.1 HTTP 的瓶颈\n\n若想在现有 Web 实现所需的功能，以下这些 HTTP 标准就会成为瓶颈：\n\n* 一条连接上只可发送一个请求。 \n* 请求只能从客户端开始。客户端不可以接收除响应以外的指令。 \n* 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。\n* 发送冗长的首部。每次互相发送相同的首部造成的浪费较 多。\n* 可任意选择数据压缩格式。非强制压缩发送。\n\n<img src=\"图解HTTP（7-11）/从前的HTTP.png\" style=\"zoom:80%;\" />\n\n**Ajax 的解决方法**\n\nAjax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。\n\n**Comet 的解决方法**\n\n一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。\n\n##### 9.2.2 SPDY 的设计与功能\n\nSPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过**新加会话层**的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。\n\nSPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方法、 Cookie 以及 HTTP 报文等。\n\n<img src=\"图解HTTP（7-11）/SPDY.png\"  />\n\n使用 SPDY 后，HTTP 协议额外获得以下功能。\n\n* 多路复用流，单一 TCP 连接可以无限制处理多个 HTTP 请求，提高 TCP 处理效率。\n* 赋予请求优先级，在发送多个请求时，解决因带宽低而导致响应变慢的问题。\n* 压缩 HTTP 请求和响应的头部，通信产生的数据包数量和发送的字节数就更少了。\n* 推送功能，支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。\n* 服务器提示功能，服务器可以主动提示客户端请求所需的资源。\n\n##### 9.2.3 SPDY 消除 Web 瓶颈了吗\n\n因为 SPDY 基本上只是将单个域名（ IP 地址）的通信多路复用，所 以当一个 Web 网站上使用多个域名下的资源，改善效果就会受到限制。\n\nSPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致。\n\n#### 9.3 使用浏览器进行全双工通信的 WebSocket\n\n利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。\n\n##### 9.3.1 WebSocket 的设计与功能\n\nWebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。\n\n##### 9.3.2 WebSocket 协议\n\n特点：\n\n* 推送功能，服务器向客户端推送数据。\n\n* 减少通信量，只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。在 HTTP 连接建立之后，需要完成一 次“握手”（Handshaking）的步骤。\n\n  * 握手-请求，为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。\n\n  <img src=\"图解HTTP（7-11）/websocket1.png\"  />\n\n  * 握手-响应，对于之前的请求，返回状态码 101 Switching Protocols 的响应。\n\n  <img src=\"图解HTTP（7-11）/websocket2.png\"  />\n\n  成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。\n\n  * WebSocket API\n\n#### 9.4 期盼已久的 HTTP/2.0\n\n**HTTP/2.0 的 特点**\n\n<img src=\"图解HTTP（7-11）/HTTP2.0特点.png\"  />\n\n##### 9.5 Web 服务器管理文件的 WebDAV\n\nWebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。它作为扩展 HTTP/1.1 的协议定义在 RFC4918。\n\n使用 HTTP/1.1 的 PUT 方法和 DELETE 方法，就可以对 Web 服务器上的文件进行创建和删除操作。可是出于安全性及便捷性等考虑，一 般不使用。\n\n##### 9.5.1 扩展 HTTP/1.1 的 WebDAV\n\n针对服务器上的资源，WebDAV 新增加了一些概念，如下所示：\n\n* 集合：是一种统一管理多个资源的概念。\n* 资源：把文件或集合称为资源。\n* 属性：定义资源的属性。格式为“名称=值”。\n* 锁：把文件设置成无法编辑状态。\n\n##### 9.5.2 WebDAV 内新增的方法及状态码\n\nWebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。\n\n* PROPFIND ：获取属性\n* PROPPATCH ：修改属性 \n* MKCOL ：创建集合 \n* COPY ：复制资源及属性 \n* MOVE ：移动资源 \n* LOCK ：资源加锁 \n* UNLOCK ：资源解锁\n\n为配合扩展的方法，状态码也随之扩展。\n\n* 102 Processing ：可正常处理请求，但目前是处理中状态 \n* 207 Multi-Status ：存在多种状态 \n* 422 Unprocessible Entity ：格式正确，内容有误 \n* 423 Locked ：资源已被加锁 \n* 424 Failed Dependency ：处理与某请求关联的请求失败，因此不再维持依赖关系 \n* 507 Insufficient Storage ：保存空间不足\n\n### 第 10 章 构建 Web 内容的技术\n\n#### 10.1 HTML\n\n##### 10.1.1 Web 页面几乎全由 HTML 构建\n\nHTML（HyperText Markup Language，超文本标记语言）是为了发送 Web 上的超文本（Hypertext）而开发的标记语言。\n\n##### 10.1.2 HTML 的版本\n\n目前的最新版本是 HTML4.01 标准，1999 年 12 月 W3C（World Wide Web Consortium）组织推荐使用这一版本。下一个版本，预计会在 2014 年左右正式推荐使用 HTML5 标准。\n\nHTML5 标准不仅解决了浏览器之间的兼容性问题，并且可把文本作为数据对待，更容易复用，动画等效果也变得更生动。\n\n##### 10.1.3 设计应用 CSS\n\nCSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML 内的各种元素，属于样式表标准之一。即使是相同的 HTML 文档， 通过改变应用的 CSS，用浏览器看到的页面外观也会随之改变。CSS 的理念就是让文档的结构和设计分离，达到解耦的目的。\n\n#### 10.2 动态 HTML\n\n##### 10.2.1 让 Web 页面动起来的动态 HTML\n\n动态 HTML技术是通过调用客户端脚本语言 JavaScript，实现对 HTML 的 Web 页面的动态改造。利用 DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的 HTML 元素。\n\n##### 10.2.2 更易控制 HTML 的 DOM\n\nDOM 是用以操作 HTML 文档和 XML 文档的 API（Application Programming Interface，应用编程接口）。使用 DOM 可以将 HTML 内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。\n\n#### 10.3 Web 应用\n\n##### 10.3.1 通过 web 提供功能的 Web 应用\n\n原本应用 HTTP 协议的 Web 的机制就是对客户端发来的请求，返回事前准备好的内容。随着 Web 越来越普及，仅靠这样的做法已不足以应对所有的需求。\n\n引入由程序创建 HTML 内容的做法，称为动态内容，而事先准备好的内容称为静态内容。web应用则作用于动态内容之上。\n\n##### 10.3.2 与 Web 服务器及程序协作的 CGI※\n\nCGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建 HTML 等动态内容。\n\n<img src=\"图解HTTP（7-11）/CGI.png\"  />\n\n##### 10.3.3 因 JAVA 而普及的 Servlet\n\n之前提及的 CGI，由于每次接到请求，程序都要跟着启动一次。因此一旦访问量过大，Web 服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中，因此受到的负载较小 2。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。\n\n#### 10.4 数据发布的格式及语言\n\n##### 10.4.1 可扩展标记语言\n\nXML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数据共享变得更容易。 XML和 HTML都是从标准通用标记语言 SGML（Standard Generalized Markup Language）简化而成。与 HTML相比，它对数据的记录方式做了特殊处理。\n\n##### 10.4.2 发布更新信息的 RSS/Atom\n\nRSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。\n\n##### 10.4.3 JavaScript 衍生的轻量级易用 JSON\n\nJSON（JavaScript Object Notation）是一种以 JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符 串，这 7 种类型。\n\n<img src=\"图解HTTP（7-11）/JSON.png\"  />\n\nJSON 让数据更轻更纯粹，并且 JSON 的字符串形式可被 JavaScript 轻易地读入。\n\n### 第 11 章 Web 的攻击技术\n\n#### 11.1 针对 Web 的攻击技术\n\n##### 11.1.1 HTTP 不具备必要的安全功能\n\n##### 11.1.2 在客户端即可篡改请求\n\n##### 11.1.3 针对 Web 应用的攻击模式\n\n对 Web 应用的攻击模式有以下两种。\n\n* 主动攻击\n* 被动攻击\n\n**以服务器为目标的主动攻击**\n\n主动攻击模式里具有代表性的攻击是 SQL注入攻击和 OS 命令注入攻击。\n\n<img src=\"图解HTTP（7-11）/主动攻击.png\"  />\n\n**以服务器为目标的被动攻击**\n\n被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。\n\n<img src=\"图解HTTP（7-11）/被动攻击.png\" style=\"zoom:120%;\" />\n\n**利用用户的身份攻击企业内部网络（被动攻击）**\n\n<img src=\"图解HTTP（7-11）/被动攻击2.png\"  />\n\n#### 11.2 因输出值转义不完全引发的安全漏洞\n\n实施 Web 应用的安全对策大致分为以下两种：\n\n* 客户端的验证\n* Web 应用端（服务器端）的验证\n  * 输入值验证\n  * 输出值转义\n\n<img src=\"图解HTTP（7-11）/验证数据的几个位置.png\"  />\n\n从数据库或文件系统、HTML、邮件等输出 Web 应用处理的数据之际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。\n\n##### 11.2.1 跨站脚本攻击\n\n跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。动态创建的 HTML 部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。\n\n跨站脚本攻击有可能造成以下影响。：\n\n* 利用虚假输入表单骗取用户个人信息。 \n* 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下， 帮助攻击者发送恶意请求。 \n* 显示伪造的文章或图片。\n\n##### 11.2.2 SQL 注入攻击\n\n**会执行非法 SQL 的 SQL 注入攻击**\n\nSQL注入攻击有可能会造成以下等影响：\n\n* 非法查看或篡改数据库内的数据 \n* 规避认证 \n* 执行和数据库服务器业务关联的程序等\n\n**SQL 注入攻击案例**\n\nP211\n\n##### 11.2.3 OS 命令注入攻击\n\nOS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。\n\n##### 11.2.4 HTTP 首部注入攻击\n\nHTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。\n\nHTTP 首部注入攻击有可能会造成以下一些影响：\n\n* 设置任何 Cookie 信息 \n* 重定向至任意 URL \n* 显示任意的主体（HTTP 响应截断攻击）\n\n**HTTP 响应截断攻击**\n\nHTTP 响应截断攻击是用在 HTTP 首部注入的一种攻击。攻击顺 相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送。利用这两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的。这样的攻击叫做 HTTP 响应截断攻击。\n\n##### 11.2.5 邮件首部注入攻击\n\n邮件首部注入（Mail Header Injection）是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告邮件或病毒邮件。\n\n##### 11.2.6 目录遍历攻击\n\n目录遍历（Directory Traversal）攻击是指对本**无意公开**的文件目录， 通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。\n\n##### 11.2.7 远程文件包含漏洞\n\n远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文 件，让脚本读取之后，就可运行任意脚本的一种攻击。\n\n#### 11.3 因设置或设计上的缺陷引发的安全漏洞\n\n##### 11.3.1 强制浏览\n\n强制浏览（Forced Browsing）安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。\n\n强制浏览有可能会造成以下一些影响：\n\n* 泄露顾客的个人信息等重要情报\n* 泄露原本需要具有访问权限的用户才可查阅的信息内容 \n* 泄露未外连到外界的文件\n\n##### 11.3.2 不正确的错误消息处理\n\n不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web 应用的错误信息内包含对攻击者有用的信息。与 Web 应用有关的主要错误信息如下所示。\n\n* Web 应用抛出的错误消息 \n* 数据库等系统抛出的错误消息\n\n##### 11.3.3 开放重定向\n\n开放重定向（Open Redirect）是一种对指定的任意 URL作重定向跳转的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。\n\n#### 11.4 因会话管理疏忽引发的安全漏洞\n\n##### 11.4.1 会话劫持\n\n会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。\n\n下面列举了几种攻击者可获得会话 ID 的途径：\n\n* 通过非正规的生成方法推测会话 ID \n* 通过窃听或 XSS 攻击盗取会话 ID \n* 通过会话固定攻击（Session Fixation）强行获取会话 ID\n\n##### 11.4.2 会话固定攻击\n\n对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击。\n\n##### 11.4.3 跨站点请求伪造\n\n跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。\n\n跨站点请求伪造有可能会造成以下等影响：\n\n* 利用已通过认证的用户权限更新设定信息等 \n* 利用已通过认证的用户权限购买商品 \n* 利用已通过认证的用户权限在留言板上发表言论\n\n#### 11.5 其他安全漏洞\n\n##### 11.5.1 密码破解\n\n密码破解攻击（Password Cracking）即算出密码，突破认证。攻击不仅限于 Web 应用，还包括其他的系统（如 FTP 或 SSH 等），本节将会讲解对具备认证功能的 Web 应用进行的密码破解。\n\n密码破解有以下两种手段。 \n\n* 通过网络的密码试错 \n  * 穷举法\n  * 字典攻击\n* 对已加密密码的破解（指攻击者入侵系统，已获得加密或散列处理的密码数据的情况）\n\n##### 11.5.2 点击劫持\n\n点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖 在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。\n\n##### 11.5.3 Dos 攻击\n\nDoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。\n\n主要有以下两种 Dos 攻击方式：\n\n* 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈通知状态\n* 通过攻击安全漏洞使服务停止\n\n多台计算机发起的 DoS 攻击称为 DDoS 攻击（Distributed Denial of Service attack）。DDoS 攻击通常利用那些感染病毒的计算机作为攻 击者的攻击跳板。\n\n##### 11.5.4 后门程序\n\n后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。\n\n通常的后门程序分为以下 3 种类型。 \n\n* 开发阶段作为 Debug 调用的后门程序 \n* 开发者为了自身利益植入的后门程序 \n* 攻击者通过某种方法设置的后门程序\n\n","tags":["HTTP"],"categories":["计算机网络"]},{"title":"图解HTTP（1-6）","url":"/blog/2021/10/08/图解HTTP（1-6）/","content":"\n图解HTTP（1-6）\n\n<!-- more-->\n\n### 第 1 章 了解 web 及网络基础\n\n#### 1.6 各种协议与 HTTP 协议的关系\n\nIP协议、TCP协议和DNS服务在使用HTTP协议的通信过程中各自发挥了哪些作用。\n\n<img src=\"图解HTTP（1-6）/各种协议与HTTP协议的关系.png\"  />\n\n#### 1.7 URI 和 URL\n\nURI（Uniform Resource Identifier）：统一资源标识符。\n\nURL（Uniform Resource Locator）：统一资源定位符。\n\nURI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见**URL 是 URI 的子集**。URL 是通过定位方式实现的 URI。\n\n总的来说，**locators are also identifiers**, so every URL is also a URI, but there are URIs which are not URLs.\n\n参考：https://www.zhihu.com/question/21950864。\n\n### 第 2 章 简单的 HTTP 协议\n\n#### 2.1 HTTP 协议用于客户端和服务器端之间的通信\n\n#### 2.2 通过请求和响应的交换达成通信\n\n<img src=\"图解HTTP（1-6）/2.2-1.png\"  />\n\n**请求报文的构成**\n\n<img src=\"图解HTTP（1-6）/2.2-2.png\"  />\n\n**响应报文的构成**\n\n<img src=\"图解HTTP（1-6）/2.2-3.png\"  />\n\n#### 2.3 HTTP 是不保存状态的协议\n\nHTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。\n\n#### 2.4 请求 URI 定位资源\n\n以 `http://hackr.jp/index.htm` 为例： \n\n<img src=\"图解HTTP（1-6）/请求例子.png\"  />\n\n查询 HTTP 服务器端支持的 HTTP 方法种类：\n\n```html\nOPTIONS * HTTP/1.1\n```\n\n #### 2.5 告知服务器意图的 HTTP 方法※\n\n**GET**：获取资源。\n\n使用 GET 方法请求-响应的例子：\n\n<img src=\"图解HTTP（1-6）/2.5-1.png\"  />\n\n**POST**：传输实体主体。\n\n虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。使用 POST 方法的请求-响应的例子：\n\n<img src=\"图解HTTP（1-6）/2.5-2.png\"  />\n\n**PUT**：传输文件。\n\n就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。一般配合 Web 验证机制使用。使用 PUT 方法的请求-响应的例子：\n\n<img src=\"图解HTTP（1-6）/2.5-3.png\"  />\n\n**HEAD**：获得报文首部。\n\n**DELETE**：删除文件。\n\n**OPTIONS**：询问支持的方法。\n\n**TRACE**：追踪路径。\n\n**CONNECT**：要求用隧道协议连接代理。\n\n#### 2.6 使用方法下达命令\n\n向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。\n\n<img src=\"图解HTTP（1-6）/2.6.png\"  />\n\n#### 2.7 持久连接节省通信量\n\n##### 2.7.1 持久连接\n\n持久连接的特点是：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\n\n**在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。**\n\n##### 2.7.2 管线化\n\n持久连接使得多数请求以**管线化**（pipelining）方式发送成为可能。\n\n从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。\n\n##### 2.8 使用 Cookie 的状态管理\n\nCookie 技术通过在请求和响应报文中写入 Cookie 信息来控制**客户端**的状态。\n\n* Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。 \n\n* 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。\n\n发生 Cookie 交互，HTTP 请求报文和响应报文的内容如下：\n\n<img src=\"图解HTTP（1-6）/2.8.png\"  />\n\n### 第 3 章 HTTP 报文内的 HTTP 信息\n\n#### 3.1 HTTP 报文\n\n客户端：请求报文。\n\n服务器端：响应报文。\n\nHTTP 报文大致可分为**报文首部**和**报文主体**两块。两者由最初出现的**空行（CR+LF）**来划分。通常，并不一定要有报文主体。\n\n<img src=\"图解HTTP（1-6）/HTTP报文的结构.png\"  />\n\n####  3.2 请求报文及响应报文的结构\n\n<img src=\"图解HTTP（1-6）/请求报文和响应报文的结构.png\"  />\n\n请求行：包含用于请求的方法，请求 URI 和 HTTP 版本。\n\n状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本。\n\n首部字段：包含表示请求和响应的各种条件和属性的各类首部。\n\n#### 3.3 编码提升传输速率\n\n##### 3.3.1 报文主体和实体主体的差异\n\n* 报文（message） 是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。 \n* 实体（entity） 作为请求或响应的有效载荷数据（补充项）被传输，其内容由**实体首部**和**实体主体**组成。\n\nHTTP 报文的主体用于传输请求或响应的实体主体。\n\n通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。\n\n未编码的原始数据是实体主体，当不进行编码传输时，报文主体和实体主体等价，而原始数据经过编码再传输时，报文主体就不再是实体主体了，而是实体首部+实体主体的编码数据。\n\n##### 3.3.2 压缩传输的内容编码\n\n常用的内容编码有以下几种：\n\n* gzip(GNU zip)\n* compress(UNIX 系统的标准压缩)\n* deflate(zlib)\n* identity(不进行编码)\n\n##### 3.3.3 分割发送的分块传输编码\n\n<img src=\"图解HTTP（1-6）/分块传输编码.png\"  />\n\n#### 3.4 发送多种数据的多部分对象集合\n\nMIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）。在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。相应地，HTTP 协议中也采纳了**多部分对象集合**，发送的一份报文主体内可含有多类型实体。\n\n#### 3.5 获取部分内容的范围请求\n\n<img src=\"图解HTTP（1-6）/获取部分内容的范围请求.png\"  />\n\nbyte 范围的指定形式如下：\n\n<img src=\"图解HTTP（1-6）/byte范围.png\"  />\n\n针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。\n\n如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。\n\n#### 3.6 内容协商返回最合适的内容\n\n比如浏览器默认语言不同，访问相同 URI 的 Web 页面时，则会显示对应的语言版本的 web 页面。\n\n服务器驱动协商。\n\n客户端驱动协商。\n\n透明协商。\n\n### 第 4 章 返回结果的 HTTP 状态\n\n#### 4.1 状态码告知从服务器端返回的请求结果\n\n<img src=\"图解HTTP（1-6）/状态码.png\"  />\n\n#### 4.2 2XX 成功\n\n2XX 的响应结果表名请求被正常处理了。\n\n##### 4.2.1 200 OK\n\n表示从客户端发来的请求在服务器端被正常处理了。\n\n##### 4.2.2 204 No Content\n\n该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。\n\n##### 4.2.3 206 Partial Content\n\n该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n\n#### 4.3 3XX 重定向\n\n3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。\n\n##### 4.3.1 301 Moved Permanently\n\n永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。\n\n##### 4.3.3 302 Found\n\n临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问。\n\n##### 4.3.3 303 See Other\n\n该状态码表示由于请求对应的资源存在着另一个 URI，应使用 **GET** 方法定向获取请求的资源。\n\n##### 4.3.4 304 Not Modified\n\n该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。\n\n附带条件的请求是指采用 GET方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。\n\n##### 4.3.5 307 Temporary Redirect\n\n临时重定向。该状态码与 302 Found 有着相同的含义。但是 307 会遵照浏览器标准，不会从 POST 变成 GET。\n\n#### 4.4 4XX 客户端错误\n\n##### 4.4.1 400 Bad Request\n\n该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。\n\n##### 4.4.2 401 Unauthorized\n\n该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。\n\n##### 4.4.3 403 Forbidden\n\n该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由。\n\n##### 4.4.4 404 Not Found\n\n该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。\n\n#### 4.5 5XX 服务器错误\n\n5XX 的响应结果表明服务器本身发生错误。\n\n##### 4.5.1 500 Internal Server Error\n\n该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。\n\n##### 4.5.2 503 Service Unavailable\n\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n### 第 5 章 与 HTTP 协作的 Web 服务器\n\n#### 5.1 用单台虚拟主机实现多个域名\n\n#### 5.2 通信数据转发程序：代理、网关、隧道\n\n#### 5.3 保存资源的缓存\n\n### 第 6 章 HTTP 首部\n\n#### 6.1 HTTP 报文首部\n\n**HTTP 请求报文**\n\n<img src=\"图解HTTP（1-6）/请求报文.png\"  />\n\n**HTTP 响应报文**\n\n<img src=\"图解HTTP（1-6）/响应报文.png\"  />\n\n#### 6.2 HTTP 首部字段\n\n##### 6.2.1 HTTP 首部字段传递重要信息\n\n使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。\n\n##### 6.2.2 HTTP 首部字段结构\n\n```\n首部字段名: 字段值\n```\n\n##### 6.2.3 4 种 HTTP 首部字段类型\n\n**通用首部字段**\n\n请求报文和响应报文两方都会使用的首部。\n\n**请求首部字段**\n\n从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。\n\n**响应首部字段**\n\n从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。\n\n**实体首部字段**\n\n针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。\n\n##### 6.2.5 HTTP/1.1 首部字段一览\n\n**通用首部字段**\n\n<img src=\"图解HTTP（1-6）/通用首部字段.png\"  />\n\n**请求首部字段**\n\n<img src=\"图解HTTP（1-6）/请求首部字段.png\"  />\n\n**响应首部字段**\n\n<img src=\"图解HTTP（1-6）/响应首部字段.png\"  />\n\n**实体首部字段**\n\n<img src=\"图解HTTP（1-6）/实体首部字段.png\"  />\n\n##### 6.2.5 非 HTTP/1.1 首部字段\n\n如 Cookie、Set-Cookie 和 Content-Disposition 等。\n\n##### 6.2.6 End-to-end 首部和 Hop-by-hop 首部\n\n**端到端首部（End-to-end Header）**\n\n分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。\n\n**逐跳首部（Hop-by-hop Header）**\n\n分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。\n\n下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外， 其他所有字段都属于端到端首部。\n\n* Connerction\n* Keep-Alive\n* Proxy-Authenticate\n* Proxy-Authorization\n* Trailer\n* TE\n* Transfer-Encoding\n* Upgrade\n\n#### 6.3 HTTP/1.1 通用首部字段\n\n通用首部字段是指，请求报文和响应报文双方都会使用的首部。\n\n##### 6.3.1 Cache-Control\n\n通过指定首部字段 Cache-Control 指令，就能操作缓存的工作机制。\n\n指令的参数是可选的，多个指令之间通过 “,” 分隔。首部字段 Cache-Control 的指令可用于**请求**及**响应**时。\n\n```html\nCache-Control: private, max-age=0, no-cache\n```\n\n**缓存请求指令**\n\n<img src=\"图解HTTP（1-6）/缓存请求指令.png\"  />\n\n**缓存响应指令**\n\n<img src=\"图解HTTP（1-6）/缓存响应指令.png\"  />\n\n**表示是否能缓存的指令**\n\n* public：当指定使用 public 指令时，则明确表明其他用户也可利用缓存。\n* private：当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。\n* no-cache：防止从缓存中返回过期的资源，不是不缓存，是不缓存过期的资源。\n* no-store：暗示请求（和对应的响应）或响应中包含机密信息，真正的不缓存。\n\n**指定缓存期限和认证的指令**\n\n* s-maxage：`Cache-Control: s-maxage=604800`，（单位 ：秒）。与 max-age 指令相同，不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。\n* max-age：`Cache-Control: max-age=604800`，（单位：秒）。\n* min-fresh：令要求缓存服务器返回至少还未过指定时间的缓存资源。\n* max-stale：可指示缓存资源，即使过期也照常接收。\n* only-if-cached：该指令要求缓存服务器不重新 加载响应，也不会再次确认资源有效性。\n* must-revalidate：代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。\n* proxy-revalidate：要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。\n* no-transform：规定无论是在请求还是响应中，缓存都不能改 变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。\n\n**Cache-Control扩展**\n\ncache-extension token：通过 cache-extension 标记（token），可以扩展 Cache-Control 首部 段内的指令。仅对能理解它的缓存服务器来说是有意义的。\n\n##### 6.3.2 Connection※\n\nConnection 首部字段具备如下两个作用：\n\n* 控制不再转发给代理的首部字段\n\n<img src=\"图解HTTP（1-6）/控制不再转发给代理的首部字段.png\"  />\n\n* 管理持久连接\n\n<img src=\"图解HTTP（1-6）/管理持久连接.png\"  />\n\nHTTP/1.1 默认**持久连接**。客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。\n\nHTTP/1.1 之前的版本 HTTP 版本默认连接都是**非持久连接**，为此需要指定 Connection 首部字段的值为 Keep-Alive。\n\n<img src=\"图解HTTP（1-6）/持久连接.png\"  />\n\n如上图①所示，客户端发送请求给服务器时，服务器端会像上图 ② 那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回响应。\n\n##### 6.3.3 Date\n\n首部字段 Date 表明创建 HTTP 报文的日期和时间。\n\n**HTTP/1.1 RFC1123**\n\n```\nDate: Tue, 03 Jul 2012 04:40:59 GMT\n```\n\n**HTTP/1.1 之前的 RFC580**\n\n```\nDate: Tue, 03-Jul-12 04:40:59 GMT\n```\n\n**C 标准库 asctime()**\n\n```\nDate: Tue Jul 03 04:40:59 2012\n```\n\n##### 6.3.4 Pragma\n\nPragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。只用在客户端发送的请求中。要整体掌握全部中间服务器使用的 HTTP 协议版本是不现实的。因此，发送的请求会同时含有下面两个首部字段：\n\n```\nCache-Control: no-cache\nPragma: no-cache\n```\n\n##### 6.3.5 Trailer\n\n首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。\n\n##### 6.3.6 Transfer-Encoding\n\n<img src=\"图解HTTP（1-6）/Transfer-Encoding.png\"  />\n\n首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。\n\n##### 6.3.7 Upgrade\n\n首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。\n\n##### 6.3.8 Via\n\n使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。\n\n##### 6.3.9 Warning\n\nHTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。\n\n#### 6.4 请求首部字段\n\n##### 6.4.1 Accept\n\nAccept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。\n\n<img src=\"图解HTTP（1-6）/请求首部字段-文本-图片-视频-应用程序等.png\"  />\n\n若想要给显示的媒体类型增加优先级，则使用 q = 权重值，用分号进行分隔。\n\n权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q = 1.0。\n\n##### 6.4.2 Accept-Charset\n\nAccept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。\n\n<img src=\"图解HTTP（1-6）/Accept-Charset.png\"  />\n\n##### 6.4.3 Accept-Encoding\n\nAccept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。可一次性指定多种内容编码。\n\n<img src=\"图解HTTP（1-6）/Accept-Encoding.png\"  />\n\n下面是几个内容编码的例子：\n\n<img src=\"图解HTTP（1-6）/内容编码.png\"  />\n\n##### 6.4.4 Accept-Language\n\n首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。\n\n<img src=\"图解HTTP（1-6）/Accept-Language.png\"  />\n\n##### 6.4.5 Authorization\n\n首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。\n\n<img src=\"图解HTTP（1-6）/Authorization.png\"  />\n\n##### 6.4.6 Expect\n\n客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。\n\n<img src=\"图解HTTP（1-6）/Expect.png\"  />\n\n##### 6.4.7 From\n\n首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。\n\n##### 6.4.8 Host\n\n首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个**必须被包含在请求内的首部字段**。\n\n##### 6.4.9 If-Match\n\n形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。\n\n首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。\n\n服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。\n\n##### 6.4.10 If-Modified-Since\n\n首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。 \n\nIf-Modified-Since 用于**确认代理或客户端拥有的本地资源的有效性**。 获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。\n\n##### 6.4.11 If-None-Match\n\n首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。 可用于 PUT 指令。\n\n在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。\n\n##### 6.4.12 If-Range\n\n首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。\n\n##### 6.4.13 If-Unmodified-Since\n\n首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定 的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应 返回。\n\n##### 6.4.14 Max-Forwards\n\n通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。\n\n##### 6.4.15 Proxy-Authorization\n\n接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。\n\n##### 6.4.16 Range\n\n对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。\n\n##### 6.4.17 Referer\n\n首部字段 Referer 会告知服务器请求的原始资源的 URI。\n\n##### 6.4.18 TE\n\n首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于**传输编码**。\n\n##### 6.4.19 User-Agent\n\n首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。\n\n#### 6.5 响应头部字段\n\n##### 6.5.1 Accept-Ranges\n\n首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。\n\n##### 6.5.2 Age\n\n首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。\n\n##### 6.5.3 ETag\n\n首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做**唯一性**标识的方式。**服务器会为每份资源分配对应的 ETag 值**。另外，**当资源更新时，ETag 值也需要更新**。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。\n\n**强 ETag 和 弱 ETag**\n\n<img src=\"图解HTTP（1-6）/强ETag和弱ETag.png\"  />\n\n##### 6.5.4 Location\n\n使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。\n\n基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。\n\n##### 6.5.5 Proxy-Authenticate\n\n首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。\n\n它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与**代理**之间进行的。\n\n##### 6.5.6 Retry-After\n\n首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。\n\n##### 6.5.7 Server\n\n首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。\n\n##### 6.5.8 Vary\n\n首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。\n\n##### 6.5.9 WWW-Authenticate\n\n首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。\n\n#### 6.6 实体首部字段\n\n实体首部字段是包含在请求报文和响应报文中的**实体部分**所使用的首部，用于补充内容的更新时间等与实体相关的信息。\n\n##### 6.6.1 Allow\n\n首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。\n\n##### 6.6.2 Content-Encoding\n\n首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的**内容编码**方式。使用方式参考 6.4.3节。\n\n##### 6.6.3 Content-Language\n\n首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。\n\n##### 6.6.4 Content-Length\n\n首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。\n\n##### 6.6.5 Content-Location\n\n首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。\n\n##### 6.6.6 Content-MD5\n\n首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。\n\n##### 6.6.7 Content-Range\n\n针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。\n\n##### 6.6.8 Content-Type\n\n首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。\n\n##### 6.6.9 Expires\n\n首部字段 Expires 会将资源失效的日期告知客户端。\n\n##### 6.6.10 Last-Modified\n\n首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个 值就是 Request-URI 指定资源被修改的时间。\n\n#### 6.7 为 Cookie 服务的首部字段\n\n<img src=\"图解HTTP（1-6）/为Cookie服务的首部字段.png\"  />\n\n##### 6.7.1 Set-Cookie\n\n当服务器准备开始管理客户端的状态时，会事先告知各种信息。\n\nSet-Cookie 的字段值：\n\n<img src=\"图解HTTP（1-6）/Set-Cookie字段的属性.png\"  />\n\n**expires 属性**\n\nCookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。\n\n**path 属性**\n\nCookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。\n\n**domain 属性**\n\n通过 Cookie 的 domain 属性指定的域名可做到与**结尾匹配一致**。\n\n**secure 属性**\n\nCookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。\n\n**HttpOnly 属性**\n\nCookie 的 HttpOnly 属性是 Cookie 的扩展功能，**它使 JavaScript 脚本无法获得 Cookie。**其主要目的为**防止跨站脚本攻击**（Cross-site scripting，XSS）对 Cookie 的信息窃取。\n\n##### 6.7.2 Cookie\n\n首部字段 Cookie 会告知服务器，**当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。**接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。\n\n#### 6.8 其他首部字段\n\n##### 6.8.1 X-Frame-Options\n\n首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防 止点击劫持（clickjacking）攻击。\n\n##### 6.8.2 X-XSS-Protection\n\n首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。\n\n##### 6.8.3 DNT※\n\n首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。\n\n##### 6.8.4 P3P\n\n首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，**可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式**，以达到保护用户隐私的目的。\n\n","tags":["HTTP"],"categories":["计算机网络"]},{"title":"Linux文件系统","url":"/blog/2021/10/08/Linux文件系统/","content":"\n简单总结 Linux 文件系统\n\n<!-- more-->\n\n### Linux 文件系统\n\n#### 文件系统特性\n\n主要有三个部分：\n\n* 超级区块：记录此文件系统的总体信息，包括 inode 与数据区块的总量、使用量、剩余量，以及文件系统的格式与相关信息等；\n* inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的区块号码；\n* 数据区块：实际记录文件的内容，若文件太大，会占用多个区块。\n\n文件系统先格式化出 inode 和数据区块，根据 inode 记录可以找到文件数据的实际放置点，之后可以按顺序读出，这种方法称为**索引式文件系统**。类比于 FAT（文件分配表，U 盘中常用），基本不用进行碎片整理。\n\n#### Linux 的 ext2 文件系统（inode）\n\n<img src=\"Linux文件系统/ext2.png\"  />\n\n文件系统最前面有一个启动扇区（Boot Sector），这个启动扇区可以安装启动引导程序。\n\n##### 数据区块（data block）\n\n数据区块是用来放置文件数据的地方，在 ext2 文件系统中所支持的区块大小有 1K，2K 和 4K 三种。\n\n|     Block大小      | 1KB  |  2KB  | 4KB  |\n| :----------------: | :--: | :---: | :--: |\n|  最大单一文件限制  | 16GB | 256GB | 2TB  |\n| 最大文件系统总容量 | 2TB  |  8TB  | 16TB |\n\n注意：虽然 ext2 已经能够支持大于 2GB 以上的单一文件容量，不过某些应用程序只能够识别小于 2GB 的文件。\n\n除此之外，ext2 文件系统区块的限制还有：\n\n1. 原则上，区块的大小与数量在格式化完就不能够再修改\n2. 每个区块内最多只能够放置一个文件的数据\n3. 承上，如果文件小于区块的大小，则一个文件会占用多个区块数量\n4. 承上，若文件小于区块，则该区块的剩余容量就不能够再被使用了\n\n##### inode table（inode 表）\n\ninode 记录的数据至少有下面这些：\n\n* 该文件的读写属性（read、write、excute）；\n* 该文件的拥有者与用户组（owner、group）；\n* 该文件的大小；\n* 该文件建立或状态改变的时间（ctime）；\n* 最近一次的读取时间（atime）；\n* 最近修改的时间（mtime）；\n* 定义文件特性的标识（flag），如 SetUID；\n* 该文件真正内容的指向（pointer）。\n\ninode 的数量与大小在格式化时就已经固定了，除此之外 inode 还有什么特色？\n\n* 每个 inode 大小均固定为 128B（新的 ext4 和 xfs 可设置到 256B）；\n* 每个文件都仅会占用一个 inode 而已；\n* 承上，因此文件系统能够创建的文件数量与 inode 的数量有关；\n* 系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，如符合才能够读取区块的内容。\n\ninode 记录一个数据区块需要使用 4B，假设一个文件有 400MB 且每个区块为 4K 时，至少需要十万个数据块。为此系统将 inode 记录区块号码的区域定义为 12 个直接、一个间接、一个双间接与一个三间接记录区。假设区块大小为 1KB。\n\n* 12 个直接：12 × 1K = 12K；\n* 间接：256 × 1K = 256K，因为 1K 的大小能记录 256 条记录；\n* 双间接：256 × 256 × 1K = 256^2 K；\n* 三间接：256 × 256 × 256 × 1K = 256^3 K；\n\n总额：12 + 256 + 256 × 256 + 256 × 256 × 256（K）= 16GB。\n\n可以看到区块格式化为 1K 时，能够容纳的最大文件为 16GB，与文件系统限制表的结果一致，但此方法不能应用在 2K 和 4K 区块大小的计算中，因为大于 2K 的区块将会受到 ext2 文件系统本身的限制。\n\n##### Superblock（超级区块）\n\n超级区块是记录整个文件系统相关信息的地方，没有超级块，就没有这个文件系统，它记录的主要信息有：\n\n* 数据区块与 inode 的总量；\n* 未使用与已使用的 inode 与数据区块的数量；\n* 数据区块与 inode 的大小（block 为 1、2、4K，inode 为 128B 或 256B）；\n* 文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘的时间等文件系统相关信息；\n* 一个有效位数值，若此文件已被挂载，则有效位为 0，若未被挂载，则有效位为 1。\n\n##### Filesystem Description（文件系统描述说明）\n\n这个区段可以描述每个**区块群组**的开始与结束的区块，以及说明每个区段（超级区块、对照表、inode 对照表，数据区块）分别介于哪一个区块之间，这一部分也能够用 dumpe2fs 来观察。\n\n##### 区块对照表（block bitmap）\n\n从区块对照表中可以知道哪些区块是空的，因此我们的系统就能够很快速的找到可使用的空间来处理文件。\n\n在删除文件时，那些文件原本占用的区块号码就要释放出来，此时在区块对照表中对应到该区块号码的标志就要修改为【未使用中】，这就是对照表的功能。\n\n##### inode 对照表\n\ninode 对照表记录使用与未使用的 inode 号码。\n\n##### dumpe2fs\n\n查询 ext 系列超级区块信息的命令。\n\n1. `sudo blkid`：显示出目前系统被格式化的设备；\n2. `dumpe2fs 文件目录`：查看超级块。\n\n","categories":["Linux"]},{"title":"MySQL学习","url":"/blog/2021/10/08/MySQL学习/","content":"\nMysql架构介绍\n\n<!-- more-->\n\n### Mysql逻辑结构\n\n**数据文件**\n\n1. Myisam\n   1. frm 文件（framework）：存放表结构\n   2. myd 文件（data）：存放表数据\n   3. myi 文件（index）：存放表索引\n2. innodb\n   1. ibdata1：Innodb 引擎将所有表的的数据都存在这里面 /usr/share/mysql/ibdata1\n   2. frm 文件：存放表结构\n   3. 单独存放\n\n##### 总体结构\n\n<img src=\"mysql学习/mysql逻辑结构.png\"  />\n\n##### 每一层的功能\n\n<img src=\"mysql学习/mysql每层功能.png\" style=\"zoom: 100%;\" />\n\n#### Mysql存储引擎\n\n查看引擎命令：\n\n```\nshow engines;\n```\n\n##### InnoDB和MyISAM对比\n\n| ------------------------- |            -------------------------------             |               -------------------------------                |\n| :-----------------------: | :----------------------------------------------------: | :----------------------------------------------------------: |\n|          对比项           |                         MyISAM                         |                            InnoDB                            |\n|          主外键           |                         不支持                         |                             支持                             |\n|           事务            |                         不支持                         |                             支持                             |\n|          行表锁           | 表锁，即使操作一条记录也会锁住整个表，不适合高并发操作 | 行锁，操作时只锁某一行，不对其他行有影响，**适合高并发操作** |\n|           缓存            |               只缓存索引，不缓存真实数据               | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |\n|          表空间           |                           小                           |                              大                              |\n|          关注点           |                          性能                          |                             事务                             |\n|         默认安装          |                           Y                            |                              Y                               |\n\n### 索引优化\n\n#### 性能下降的原因\n\n1. SQL 写的不好\n2. 索引失效\n   1. 单值\n   2. 复合\n3. 关联查询太多 join\n4. 服务器调优及各个参数设置（缓冲、线程数等）\n\n#### 常见通用的join查询\n\n##### SQL执行顺序\n\n手写-机读（先从 FROM 开始）。\n\n<img src=\"mysql学习/sql解析.png\"  />\n\n##### join图\n\n<img src=\"mysql学习/join.png\" style=\"zoom: 80%;\" />\n\n##### 建表SQL\n\n##### 7种join\n\nmysql 不支持全外连接，可以使用 union 合并并去重。\n\n倒数第二种情况，A B 全有：\n\n```sql\nSELECT * FROM TABLE A t1\nLEFT JOIN TABLE B t2\nON t1.id = t2.id\nUNION\nSELECT * FROM TABLE A t1\nRIGHT JOIN TABLE B t2\nON t1.id = t2.id\n```\n\n最后一种情况，A B 独有：\n\n```sql\nSELECT * FROM TABLE A t1\nLEFT JOIN TABLE B t2\nON t1.id = t2.id\nWHERE t2.id IS NULL\nUNION\nSELECT * FROM TABLE A t1\nRIGHT JOIN TABLE B t2\nON t1.id = t2.id\nWHERE t1.id IS NULL;\n```\n\n#### 索引简介\n\n官方定义：索引是帮助 MySQL 高效获得数据的**数据结构**。\n\n总之，索引就是**排好序的快速查找数据结构**。排序 + 快速查找。\n\n**优势**\n\n1. 类似大学图书馆建书目索引，**提高数据检索的效率**，降低数据库的IO成本\n2. 通过索引列对数据进行排序，**降低数据排序的成本**，降低了CPU的消耗\n\n**劣势**\n\n1. 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的\n2. 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息\n3. 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句\n\n##### 索引分类\n\n###### 主键索引\n\n设定为主键后数据库会自动建立索引，innodb 为聚簇索引。\n\n###### 单值索引\n\n即一个索引只包含单个列，一个表可以有多个单列索引。\n\n###### 唯一索引\n\n索引列的值必须唯一，但允许有空值。\n\n###### 复合索引\n\n即一个索引包含多个列。\n\n##### 索引结构\n\nB+树。\n\n##### 哪些情况需要创建索引\n\n1. 主键自动建立唯一索引\n2. 频繁作为查询条件的字段应该创建索引(where 后面的语句)\n3. 查询中与其它表关联的字段，外键关系建立索引\n4. 单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)\n5. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度\n6. 查询中统计或者分组字段\n\n##### 哪些情况不需要创建索引\n\n1. 表记录太少\n2. 经常增删改的表\n3. where 条件里用不到的字段不创建索引\n4. 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。\n\n<img src=\"mysql学习/重复.png\" style=\"zoom:80%;\" />\n\n#### 性能分析\n\n##### MySQL常见瓶颈\n\n1. CPU：SQL中对大量数据进行比较、关联、排序、分组\n2. IO：\n   1. 实例内存满足不了缓存数据或排序等需要，导致产生大量 物理 IO\n   2. 查询执行效率低，扫描过多数据行\n3. 锁：\n   1. 不适宜的锁的设置，导致线程阻塞，性能下降\n   2. 死锁，线程之间交叉调用资源，导致死锁，程序卡住\n4. 服务器硬件的性能瓶颈：top，free，iostat 和 vmstat 来查看系统的性能状态\n\n##### Explain※\n\n使用 EXPLAIN关 键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈。\n\n```\nExplain + SQL语句\n```\n\n###### 作用\n\n1. 表的读取顺序\n2. 哪些索引可以使用\n3. 数据读取操作的操作类型\n4. 哪些索引被实际使用\n5. 表之间的引用\n6. 每张表有多少行被优化器查询\n\n###### 包含信息\n\n<img src=\"mysql学习/explain.png\" style=\"zoom:80%;\" />\n\n**id**\n\n1. select 查询的序列号,包含一组数字，表示查询中执行 select 子句或操作表的顺序\n2. 三种情况\n   1. id 相同，执行顺序由上至下\n   2. id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行\n   3. ~~id 相同 table 不同，同时存在，衍生表~~\n\n**select_type**\n\n<img src=\"mysql学习/select_type.png\" style=\"zoom: 80%;\" />\n\n查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。\n\n1. SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION\n2. PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为Primary\n3. SUBQUERY：在SELECT或WHERE列表中包含了子查询\n4. DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里。\n5. UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED\n6. UNION RESULT：从UNION表获取结果的SELECT\n\n**table**\n\n显示这一行的数据是关于哪张表的。\n\n**type**\n\n显示查询使用了何种类型。\n\n<img src=\"mysql学习/type.png\"  />\n\n**从最好到最差依次是：**\n\n```\nsystem > const > eq_ref > ref > range > index > ALL\n```\n\n一般来说查询至少达到 range 级别，最好能到 ref。\n\n1. system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。\n2. const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量\n3. eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。\n4. ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。\n5. range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、<、>、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。\n6. index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）。\n7. all：Full Table Scan，将遍历全表以找到匹配的行。\n\n**possible_keys**\n\n显示可能应用在这张表中的索引，一个或多个。\n查询涉及到的字段上若存在索引，则该索引将被列出，**但不一定被查询实际使用。**\n\n**key**\n\n1. 实际使用的索引。如果为NULL，则没有使用索引\n2. 查询中若使用了覆盖索引，则该索引仅出现在key列表中。**建立的索引和要查询的列个数和顺序刚好一致。**\n\n**key_len**\n\n1. 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。 \n2. key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出来的。\n\n**ref**\n\n显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。\n\n**rows**\n\nrows列显示MySQL认为它执行查询时必须检查的行数。**越少越好**。\n\n**Extra**\n\n包含不适合在其他列中显示但十分重要的额外信息。\n\n1. Using filesort ：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。\n\n2. Using temporary ：使了用**临时表**保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。\n\n3. USING index：\n\n   1. 表示相应的select操作中使用了**覆盖索引**(Covering Index)，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。\n\n   2. **覆盖索引**(Covering Index)：就是 select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回 select 列表中的字段，而不必根据索引再次读取数据文件，换句话说**查询列要被所建的索引覆盖**。\n\n      > 注意：\n      > 如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。\n\n4. Using where：表明使用了where过滤\n\n5. Using join buffer：使用了连接缓存\n\n6. impossible where：where子句的值总是false，不能用来获取任何元组\n\n7. select tables optimized away（了解）：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。\n\n##### 一个case\n\n<img src=\"D:/Desktop/待上传/mysql高级/case查询.png\" style=\"zoom: 135%;\" />\n\n<img src=\"mysql学习/case.png\"  />\n\n#### 索引优化\n\n##### 索引分析\n\n###### 单表\n\n###### 双表\n\n左连接：LEFT JOIN 条件用于确定如何从右表搜索行，左边一定都有，所以右边是我们的关键点，一定需要在右边建立索引。右连接类似，左边建立索引。\n\n###### 三表\n\n类似双表。索引最好设置在需要经常查询的字段中。\n\n###### 结论\n\njoin 语句的优化：\n\n1. 尽可能减少 join 语句中的循环总次数，**永远用小结果驱动大的数据集**\n2. 保证 join 语句中被驱动表上 join 条件字段已经被索引\n3. inner join 时，mysql 会自动把小结果集的表选为驱动表\n4. 当无法保证被驱动表的 join 条件字段被索引且内存资源充足的前提下，不要太吝惜 joinbuffer 的设置\n5. 子查询尽量不要放在被驱动表，有可能使用不到索引\n\n子查询优化：\n\n1. 有索引的情况下用 inner join 时最好的，其次是 in，exists 最糟糕\n\nORDER BY 关键字优化：\n\n1. ORDER BY 子句，尽量使用 index 方式排序，避免使用 filesort 方式排序\n2. 尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀\n\n分页查询优化 limit：\n\n1. order by 后的字段（XXX）有索引，sql 中有 limit 时\n\n   > 当 select id 或 XXX字段索引包含字段时 ，显示 using index\n   > 当 select 后的字段含有 bouder by 字段索引不包含的字段时，将显示 using filesort\n\nGROUP BY 关键字优化\n\n1. group by实质是先排序后进行分组，遵照索引建的最佳左前缀\n2. 当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置\n3. where高于having，能写在where限定的条件就不要去having限定了。\n\n去重优化：\n\n1. 尽量不要使用 distinct 关键字去重，可以使用 GROUP BY 去利用索引。\n\n##### 索引失效（应该避免）\n\n1. 全值匹配\n\n2. 最佳左前缀法则：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且**不跳过索引中的列**（**带头的必须在，中间兄弟不能断，**如果断了还会继续用到之前的索引，后面的不能用到）。\n\n3. 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描\n\n4. 存储引擎不能使用索引中范围条件右边的列\n\n   > index 为 idx_name_age_pos，如果查询中出现 age > 某个值，执行了索引 age 的范围查询，则 pos 索引失效。\n\n5. 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *\n\n6. mysql 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描\n\n7. is not null 也无法使用索引,但是is null是可以使用索引的\n\n8. like以通配符开头('%abc...')mysql索引失效会变成全表扫描的操作 \n\n   > like % 写右边\n   >\n   > 问题，解决like '%字符串%' 时索引不被使用的方法？使用覆盖索引\n\n9. 字符串不加单引号索引失效少用or，用它来连接时会索引失效\n\n口诀：带头大哥不能死，中间兄弟不能断，索引列上无计算，like%加右边，范围之后全失效，字符串里有引号。\n\n<img src=\"mysql学习/索引失效.png\"  />\n\n**面试题讲解**\n\n定值、范围还是排序，一般 order by 是给个范围。\n\ngroup by 基本上都需要进行排序，会有临时表产生。\n\n##### 一般建议\n\n1. 对于单键索引，尽量选择针对当前query过滤性更好的索引\n2. 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。(避免索引过滤性好的索引失效)\n3. 在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引\n4. 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的\n\n### 查询截取分析\n\n总结：\n\n1. 慢查询的开启并捕获\n2. explain + 慢 SQL 分析\n3. show profile 查询 SQL 在 Mysql 服务区里面的执行细节和声明周期情况\n4. SQL 数据库服务器的参数调优\n\n#### 查询优化\n\n##### 永远小表驱动大表\n\n<img src=\"mysql学习/exists_in.png\"  />\n\n* EXISTS：SELECT ... FROM table WHERE EXISTS(subquery)，可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE 或 FALSE）来决定查询的数据结果是否得以保留。\n  * EXISTS(subquery)只返回 TRUE 或者 FALSE，子查询中的 SELECT * 也可以是 SELECT 1 或其他，官方说法是实际执行会忽略 SELECT 清单，因此效果一样。\n\n##### ORDER BY 优化\n\n1. ORDER BY 子句，尽量使用 index 方式排序，避免使用 filesort 方式排序\n   1. Mysql 支持两种排序：filesort 和 index，后者效率高，后者指 Mysql 扫面索引本身完成排序。\n   2. ORDER BY 满足两情况，会使用 index 方式排序\n      1. ORDER BY 语句使用索引最左前列\n      2. 使用 where 子句与 ORDER BY 子句条件列组合满足索引最左前列\n2. 尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀\n3. 如果不在索引列上，filesort有两种算法：mysql就要启动双路排序（2次 IO）和单路排序（一般为 1 次）\n   1. 增大sort_buffer_size参数的设置\n   2. 增大max_length_for_sort_data参数的设置\n   3. 尽量不使用 SELECT *\n\n**总结**\n\n<img src=\"mysql学习/为排序使用索引.png\" alt=\"image-20210720171055191\"  />\n\n##### GROUP BY 关键字优化\n\n1. group by 实质是先排序后进行分组，遵照索引建的最佳左前缀\n2. 当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置\n3. where高于having，能写在where限定的条件就不要去having限定了\n\n#### 慢查询日志\n\n* MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。\n* 具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。\n* 由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。\n\n默认情况下，MySQL数据库**没有开启**慢查询日志，需要我们手动来设置这个参数。\n\n当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件\n\n#### 批量数据脚本\n\n#### Show Profile\n\n#### 全局查询日志\n\n### Mysql锁机制\n\n#### 锁的分类\n\n锁是计算机协调多个进程或线程并发访问某一资源的机制。\n\n从对数据操作的类型分：\n\n1. 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。\n2. 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。\n\n从对数据操作的粒度分：\n\n1. 表锁\n2. 行锁\n\n查看哪些表被加锁了：\n\n```sql\nshow open tables;\n```\n\n#### MySQL表级锁有两种模式\n\n##### 表锁（偏读）\n\n偏向 MyISAM 存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。\n\nsession1 可以读取自己锁的表，不能修改锁的表，不能读取其他表；\n\nsession2 可以读取被锁的表，可以修改被锁的表，但是会阻塞等待直到 session 1 解锁。\n\nsession1 可以读取自己锁的表，可以修改锁的表，不能读取其他表；\n\nsession2 可以读取，但是会阻塞等待直到 session 1 解锁。\n\n**简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都堵塞。**\n\n##### 行锁（偏写）\n\n偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。\n\nInnoDB与MyISAM的最大不同有两点：一是**支持事务**（TRANSACTION）；二是采用了行级锁\n\n###### 并发事务带来的问题\n\n1. 脏读：事务A读取到了事务B已修改但尚未提交的的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。\n2. 不可重复读：一个事务范围内两个相同的查询却返回了不同数据（另外一个事务修改并提交了）。不符合隔离性。\n3. 幻读：事务A读取到了事务B提交的新增数据，不符合隔离性。 \n\n<img src=\"mysql学习/事务的隔离级别.png\" alt=\"image-20210720195513006\"  />\n\n###### **无索引行锁升级为表锁**\n\n比如 varchar 忘记加单引号了。\n\n###### 间隙锁的危害\n\n当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；**对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁**，这种锁机制就是所谓的间隙锁（GAP Lock）。\n\n比如 a 有 1 3 4 5，此时 session1 更新 a > 1 and a < 5 的数据，但是 session2 想要插入 2 的数据，此时 session2 会阻塞，因为 session1 会把 2 3 4 都锁住，即使键值不存在。\n\n###### 锁定某一行（悲观锁）\n\nselect xxx for update 锁定某一行后，其他的操作会被阻塞，直到锁定行的会话提交 commit。\n\n###### 查看行锁状态\n\n```sql\nshow status like 'innodb_row_lock%';\n```\n\n* Innodb_row_lock_time_avg（等待平均时长）\n* Innodb_row_lock_waits（等待总次数）\n* Innodb_row_lock_time（等待总时长）\n\n### 主从复制\n\n#### 复制原理\n\nslave会从master读取binlog来进行数据同步\n\n<img src=\"mysql学习/主从复制.png\"  />\n\n MySQL复制过程分成三步：\n\n1. master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events\n2. slave将master的binary log events拷贝到它的中继日志（relay log）\n3. slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的\n\n#### 复制规则\n\n1. 每个slave只有一个master\n2. 每个slave只能有一个唯一的服务器ID\n3. 每个master可以有多个salve\n\n#### 一主一从常见配置\n\n1. mysql版本一致且后台以服务运行\n2. 主从都配置在[mysqld]结点下，都是小写\n3. 主机修改my.ini配置文件\n4. 从机修改my.cnf配置文件\n5. 因修改过配置文件，请主机+从机都重启后台mysql服务\n6. 主机从机都关闭防火墙\n7. 在Windows主机上建立帐户并授权slave\n8. 在Linux从机上配置需要复制的主机\n9. 主机新建库、新建表、insert记录，从机复制\n10. 如何停止从服务复制功能（stop slave）\n\n","categories":["MySQL"]},{"title":"自定义优先队列","url":"/blog/2021/10/08/自定义优先队列/","content":"\n三种方法自定义 C++ 中的优先队列\n\n<!-- more-->\n\n### 自定义优先队列\n\n#### 方法一：运算符重载\n\n**友元函数**\n\n使用非友元函数也行，但要放在结构体之外。\n\n```cpp\nstruct Pair{\n    int first;\n    int second;\n    Pair(int fi, int sec): first(fi), second(sec){};\n    // 友元函数\n    friend bool operator < (const Pair &p1, const Pair &p2) {\n        if(p1.first == p2.first){\n            return p1.second < p2.second;\n        }\n        else\n            return p1.first < p2.first;\n    }\n};\npriority_queue<Pair> pq;\n```\n\n**成员函数**\n\n```cpp\nstruct Pair{\n    int first;\n    int second;\n    Pair(int fi, int sec): first(fi), second(sec){};\n    // 成员函数\n    bool operator < (const Pair &p2) const {\n        if(this->first == p2.first){\n            return this->second < p2.second;\n        }\n        else\n            return this->first < p2.first;\n    }\n};\npriority_queue<Pair> pq;\n```\n\n#### 方法二：函数对象（仿函数）\n\n**概念**\n\n- 重载了函数调用操作符 () 的类，其对象称为函数对象。\n- 函数对象使用重载的 () 时，行为类似函数调用，也叫仿函数。\n\n**本质**\n\n* 函数对象（仿函数）是一个类，不是函数。\n\n```cpp\nstruct cmp{\n    bool operator() (const Pair &p1, const Pair &p2){\n        if(p1.first == p2.first){\n            return p1.second < p2.second;\n        }\n        else\n            return p1.first < p2.first;\n    }\n};\npriority_queue<Pair, vector<Pair>, cmp> pq1;\n```\n\n#### 方法三：lambda/function\n\n`lambda` 表达式也是一种函数对象，不过需要结合 `decltype` 运算符一同使用。\n\n```cpp\nauto f = [](const Pair &p1, const Pair &p2) -> bool{\n    if(p1.first == p2.first){\n        return p1.second < p2.second;\n    }\n    else\n        return p1.first < p2.first;\n};\n// function<bool(const Pair&, const Pair&) 可用 decltype(f) 替换\npriority_queue<Pair, vector<Pair>, function<bool(const Pair&, const Pair&)>> pq2(f);\n```\n\n除此之外，C++ 11 还可以使用 `function`  模板来指明一个**可调用对象**，包括函数指针、`lambda` 或者函数对象在内。\n\n```cpp\nfunction<bool(const Pair&, const Pair&)> f = [](const Pair &p1, const Pair &p2) -> bool{\n    if(p1.first == p2.first){\n        return p1.second < p2.second;\n    }\n    else\n        return p1.first < p2.first;\n};\npriority_queue<Pair, vector<Pair>, decltype(f)> pq(f);\n```\n","categories":["C++"]},{"title":"C++中的左值和右值","url":"/blog/2021/08/06/C-中的左值和右值/","content":"\n#### 要点\n\n1. C++ 中左值和右值是什么？\n2. 移动构造函数是什么， 如何实现完美转发？\n\n<!-- more-->\n\n#### 左值和右值的基本概念\n\n在 C++11 中可以取地址的、有名字的就是左值；反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。\n\n> 左值：int a = b + c；其有变量名 a，通过 &a 可以获取该变量的地址。\n>\n> 右值：表达式 b + c，函数 int func() 的返回值，在其被赋值给某一变量前，不能通过变量名找到它，&(b + c) 操作无法通过编译。\n\n**C++11 中的右值**\n\n1. 纯右值：临时变量值、不跟对象关联的字面值\n2. 将亡值：C++11 中新增的与右值引用相关的表达式，这样的表达式通常是将要被移动的对象，如右值引用 T&&、std::move 返回值、或者转换为 T&& 的类型转换函数的返回值。后面涉及一个叫**完美转发**的概念。\n\n**左值引用、右值引用**\n\n左值引用就是对一个左值进行引用的类型，右值引用就是对一个右值进行引用的类型。无论声明一个左值引用还是右值引用，都必须立即进行初始化。左值引用是具有名字的变量值的别名，右值引用时匿名变量的别名。\n\n最重要的一点是，**常量左值引用**是个**万能**的引用类型，它可以接受非常量左值、常量左值、右值对其进行初始化。\n\n<img src=\"C-中的左值和右值\\引用类型及其可以引用的值类型.png\"  />\n\n#### 移动构造函数\n\n移动构造函数是参数类型为**右值引用**的拷贝构造函数。一般应用于即将销毁的对象资源的转移。\n\n假如有一个 `Integer` 类，如下：\n\n```cpp\n#include <string>\n#include <iostream>\nusing namespace std;\n\nclass Integer{\nprivate:\n    int *ptr_;\npublic:\n    // 参数为常量左值引用的深拷贝构造函数，不能改变source.ptr_的值\n    Integer(const Integer& source): ptr_(new int(*source.ptr_)){\n        cout << \"Call Integer(const Integer& source)\" << endl;\n    }\n    // 参数为左值引用的深拷贝构造函数，转移堆内存资源所有权，改变source.ptr_的值\n    Integer(Integer& source): ptr_(source.ptr_){\n        // 需要保证销毁是无害的，移动完成，源对象必须不再指向被移动的资源\n        source.ptr_ = nullptr;\n        cout << \"Call Integer(Integer& source)\" << endl;\n    }\n    Integer(int value): ptr_(new int(value)){\n        cout << \"调用构造函数 Integer(int value)\" << endl;\n    }\n//    Integer(Integer&& source) = delete;\n    Integer(Integer&& source): ptr_(source.ptr_){\n        source.ptr_ = nullptr;\n        cout << \"Call Integer(Integer&& source)\" << endl;\n    };\n    ~Integer(){\n        cout << \"调用析构函数 ~Integer()\" << endl;\n        delete ptr_;\n    }\n    int GetValue(void){\n        return *ptr_;\n    }\n};\n```\n\n主函数如下：\n\n```cpp\nint main() {\n    Integer a(Integer(100));\n    int a_value = a.GetValue();\n    cout << a_value << endl;\n    cout << \"--------------------\" << endl;\n    Integer temp(10000);\n    Integer b(temp);\n    int b_value = b.GetValue();\n    cout << b_value << endl;\n    cout << \"--------------------\" << endl;\n    return 0;\n}\n```\n\n执行后结果为：\n\n```\n调用构造函数 Integer(int value)\n100\n--------------------\n调用构造函数 Integer(int value)\nCall Integer(Integer& source)\n10000\n--------------------\n调用析构函数 ~Integer()\n调用析构函数 ~Integer()\n调用析构函数 ~Integer()\n```\n\n在主函数中，`Integer(100)` 产生了一个匿名对象，使用了**常量左值引用的深拷贝构造函数**构造对象 `a`（但是在 GCC 8.1.0 下并没有显式的打印里面的内容，不知道原因），对象 `b` 调用了拷贝构造函数。**前者把对象的内容都复制了一份，而后者相当于将对象的资源进行了转移。**\n\n由运行结果可以看出，当同时存在参数类型为常量左值引用和左值引用的深拷贝构造函数时，匿名对象 `Integer(100)` 只能选择前者，非匿名对象 `temp` 可以选择后者，这是因为**常量左值引用可以接受左值、右值、常量左值、常量右值，而左值引用只能接受左值**。\n\n如果将**常量左值引用的深拷贝构造函数**注释掉，那么会直接报错，原因是**无法将右值绑定在非常量左值的上**：\n\n<img src=\"C-中的左值和右值\\左值右值.png\"  />\n\n**使用移动构造函数实现完美转发**\n\n如果要使用移动构造函数，可以使用标准库 `std::move` 将左值转换为右值：\n\n```cpp\nint main() {\n    Integer a(Integer(100));\n    int a_value = a.GetValue();\n    cout << a_value << endl;\n    cout << \"--------------------\" << endl;\n    Integer temp(10000);\n    Integer b(std::move(temp));\n    int b_value = b.GetValue();\n    cout << b_value << endl;\n    cout << \"--------------------\" << endl;\n    return 0;\n}\n```\n\n执行后结果为：\n\n```\n调用构造函数 Integer(int value)\n100\n--------------------\n调用构造函数 Integer(int value)\nCall Integer(Integer&& source)\n10000\n--------------------\n调用析构函数 ~Integer()\n调用析构函数 ~Integer()\n调用析构函数 ~Integer()\n```\n\n此时就显示的调用了移动构造函数，实现**完美转发**（temp -> b）。\n","tags":["左值","右值","移动构造函数"],"categories":["C++"]},{"title":"剑指offer_61_68","url":"/blog/2021/07/31/剑指offer-61-68/","content":"\n剑指 Offer 61~68\n\n<!-- more-->\n\n#### [剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)\n\n##### 题目描述※\n\n从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。\n\n**示例1：**\n\n```cpp\n输入: [1,2,3,4,5]\n输出: True\n```\n\n**示例2：**\n\n```\n输入: [0,0,1,2,5]\n输出: True\n```\n\n##### 思路\n\n只要数组中的最大值和最小值相差不超过 5 即可且不存在重复的牌（0 除外）。先进行排序，有重复的可以提前跳出。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool isStraight(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int numOfzero = 0;\n        for(int i = 0; i < nums.size() - 1; ++i){\n            if(nums[i] == 0) numOfzero++;\n            else if(nums[i] == nums[i + 1]) return false;\n        }\n        return nums[nums.size() - 1] - nums[numOfzero] < 5;\n    }\n};\n```\n\n#### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)\n\n##### 题目描述※\n\n0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n\n**示例1：**\n\n```\n输入: n = 5, m = 3\n输出: 3\n```\n\n**示例2：**\n\n```\n输入: n = 10, m = 17\n输出: 2\n```\n\n##### 思路\n\n数学推导。\n\n<img src=\"剑指offer-61-68\\约瑟夫环.png\"  />\n\n把 n = 1 的情况加上，可以得到递推公式：\n$$\nf(x)=\n\\begin{cases}\n0& \\text{n = 1}\\\\\n[f(n-1,m)+m]\\%n& \\text{n > 1}\n\\end{cases}\n$$\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int lastRemaining(int n, int m) {\n        int pos = 0;\n        for(int i = 2; i <= n; ++i){\n            pos = (pos + m) % i;\n        }\n        return pos;\n    }\n};\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/\n\n#### [剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)\n\n##### 题目描述\n\n假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n\n**示例1：**\n\n```\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n```\n\n**示例2：**\n\n```\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n##### 思路\n\n动态规划。\n\n当前天如果持有股票，那么前一天也持有股票或者当天购买了新的股票，针对后一种情况，利润就是负的，值的大小为当天股票的购买价格。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        if(n == 0) return 0;\n        // 第二维，第一个代表未持有，第二个代表持有时的最大利润\n        vector<vector<int>> dp(n, vector<int>(2, 0));\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(-prices[i], dp[i - 1][1]);\n        }\n        return dp[n - 1][0];\n    }\n};\n```\n\n#### [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)\n\n##### 题目描述\n\n求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n\n##### 思路\n\n替代 `if(n == 1)` 条件。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int res = 0;\n    int sumNums(int n) {\n        bool x = n > 1 && sumNums(n - 1) > 0;\n        res += n;\n        return res; \n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n    int sumNums(int n) {\n        bool a[n][n + 1];\n        return sizeof(a) >> 1;\n    }\n};\n```\n\n#### [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)\n\n##### 题目描述\n\n写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。\n\n##### 思路\n\n与运算+左移为进位，或运算得到**不进位**的求和结果。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int add(int a, int b) {\n    \t// 无符号，负数右移\n        return b == 0 ? a : add(a ^ b, (unsigned int)(a & b) << 1);\n    }\n};\n```\n\n#### [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)\n\n##### 题目描述\n\n给定一个数组 `A[0,1,…,n-1]`，请构建一个数组 `B[0,1,…,n-1]`，其中 `B[i]` 的值是数组 `A` 中除了下标 `i` 以外的元素的积，即 `B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]`。不能使用除法。\n\n**示例：**\n\n```\n输入: [1,2,3,4,5]\n输出: [120,60,40,30,24]\n```\n\n##### 思路\n\n1. 将当前元素左边的所有元素进行累乘并存储；\n2. 当前元素右边的所有元素进行累乘并与上一步存储的结果进行相乘。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> constructArr(vector<int>& a) {\n        vector<int> ans(a.size(), 1);\n        int left = 1;\n        for(int i = 0; i < a.size(); ++i){\n            ans[i] *= left;\n            left *= a[i];\n        }\n        int right = 1;\n        for(int i = a.size() - 1; i >= 0; --i){\n            ans[i] *= right;\n            right *= a[i];\n        }\n        return ans;\n    }\n};\n```\n\n#### [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)\n\n##### 题目描述\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n\n<img src=\"剑指offer-61-68\\二叉搜索树.png\"  />\n\n**示例1：**\n\n```\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n```\n\n**示例2：**\n\n```\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n```\n\n##### 思路\n\n* 如果两个节点的值都小于根节点值，那么它们都在根节点的左子树上\n* 如果两个节点的值都大于根节点值，那么它们都在根节点的右子树上\n* 除了以上两种情况，它们的最近公共祖先就是跟节点，以为满足的二叉搜索树的条件。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(p->val < root->val && q->val < root->val){\n            return lowestCommonAncestor(root->left, p, q);\n        }\n        if(p->val > root->val && q->val > root->val){\n            return lowestCommonAncestor(root->right, p, q);\n        }\n        return root;\n    }\n};\n```\n\n#### [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)\n\n##### 题目描述※\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]\n\n<img src=\"剑指offer-61-68\\offer-68.png\"  />\n\n* 节点 5 和节点 1 的最近公共祖先是节点 3。\n* 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n\n##### 思路\n\n递归。\n\n如果 p，q 不在一棵子树上（ `left` 或 `right` 都不为 `nullptr` ），则根节点就是公共祖先。如果 `left` 或者 `right` 其中一个为空，表示非空的那个指针指向 p 或者 q 或者最近公共节点，直接返回即可。如果两个都为空，则 `root` 左右子树都不包含 p，q ，返回 `nullptr`。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == nullptr || root == p || root == q) return root;\n        TreeNode *left = lowestCommonAncestor(root->left, p , q);\n        TreeNode *right = lowestCommonAncestor(root->right, p, q);\n        if(left == nullptr) return right;\n        if(right == nullptr) return left;\n        return root;\n    }\n};\n```\n\n#### [剑指 Offer 67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)\n\n##### 题目描述\n\n写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。\n\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n\n说明：\n\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。\n\n<img src=\"剑指offer-61-68\\offer-67.png\"  />\n\n##### 思路\n\n1. 找到第一个非空字符，如果非数字或 + - 则直接返回；\n2. 记录符号位，如果是 - ，则需要特判 - + 这种情况；\n3. 从符号位后寻找连续的数字字符，并求得相应的数字保存在 long long 中；\n4. int 的大小为 -2^31 ~ 2^31- 1，注意数字是否越界，越界了则进行相应处理；\n5. 根据符号位返回结果。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int strToInt(string str) {\n        int pos = str.find_first_not_of(' ');\n        // 全空\n        if(pos == str.npos) return 0;\n        // 判断+-或数字\n        int negFlag = 0;\n        if(str[pos] == '+')\n            pos++;\n        else if(str[pos] == '-'){\n            pos++;\n            negFlag = 1;\n        }\n        long long ans = 0;\n        while(str[pos] >= '0' && str[pos] <= '9'){\n            ans = ans * 10 + str[pos] - '0';\n            if(ans > INT_MAX){\n                if(negFlag){\n                    ans = (long long)INT_MAX + 1;\n                }\n                else ans = INT_MAX;\n                break;\n            }\n            pos++;\n        }\n        if(negFlag) return -ans;\n        else return ans;\n    }\n};\n```\n\n","categories":["LeetCode"]},{"title":"剑指offer_41_60","url":"/blog/2021/07/25/剑指offer-41-60/","content":"\n剑指 Offer 41~60\n\n<!-- more-->\n\n#### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)\n\n##### 题目描述※\n\n如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n\n例如，\n\n[2,3,4] 的中位数是 3\n\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n\n设计一个支持以下两种操作的数据结构：\n\n* void addNum(int num) - 从数据流中添加一个整数到数据结构中。\n* double findMedian() - 返回目前所有元素的中位数。\n\n**示例1：**\n\n```\n输入：\n[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\n[[],[1],[2],[],[3],[]]\n输出：[null,null,null,1.50000,null,2.00000]\n```\n\n**示例2：**\n\n```\n输入：\n[\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\n[[],[2],[],[3],[]]\n输出：[null,null,2.00000,null,2.50000]\n```\n\n##### 思路\n\n**使用一个小顶堆存储较大的一半数，大顶堆存储较小的一半数**，需要考虑当前元素总数是奇数还是偶数。奇数情况下大顶堆比小顶堆多一个数，这个数就是中位数；偶数情况下两个堆中的元素个数一致，两个堆顶元素和的一半就是中位数。我们记大顶堆为 A，小顶堆为 B，下面是需要添加一个元素时的两种情况。\n\n**添加元素**\n\n**奇数**\n\n如果 A 长度和 B 不同，说明此时元素总数为奇数，需要向 B 中继续添加元素。这时应先将此元素添加至 A 中，再将 A 的堆顶元素弹出，放入 B 中，保证两个堆的约束。如果直接将数加入 B 中，无法保证此时的 B 所有元素都小于等于 A 中的所有元素。\n\n**偶数**\n\n如果 A 长度和 B 一致，说明此时元素总数为偶数，需要向 A 中继续添加元素。这时应先将此元素添加至 B 中，再将 B 的堆顶元素弹出，放入 A 中，保证两个堆的约束。如果直接将数加入 A 中，无法保证此时的 A 所有元素都大于等于 B 中的所有元素。\n\n**返回中位数**\n\n**奇数**：返回大堆顶的堆顶。\n\n**偶数**：返回两个堆，堆顶元素的均值。\n\n##### 代码\n\n```cpp\nclass MedianFinder {\npublic:\n    /** initialize your data structure here. */\n    priority_queue<int, vector<int>, greater<int>> pqs; // 小顶堆，放大的一半\n    priority_queue<int, vector<int>, less<int>> pql; // 大顶堆， 放小的一半\n    MedianFinder() {\n\n    }\n    void addNum(int num) {\n        // 长度相等，要使大顶堆多一个\n        // 先放小顶堆里\n        if(pqs.size() == pql.size()){\n            pqs.push(num);\n            pql.push(pqs.top());\n            pqs.pop();\n        }\n        // 总数为奇数\n        // 大顶堆比小顶堆多一个\n        // 先放大顶堆里\n        else{\n            pql.push(num);\n            pqs.push(pql.top());\n            pql.pop();\n        }\n    }\n    double findMedian() {\n        if(pqs.size() == pql.size()){\n            return (double)(pqs.top() + pql.top()) / 2;\n        }\n        else\n            return (double)pql.top();\n    }\n};\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder* obj = new MedianFinder();\n * obj->addNum(num);\n * double param_2 = obj->findMedian();\n */\n```\n\n#### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)\n\n##### 题目描述\n\n输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\n\n要求时间复杂度为O(n)。\n\n**示例：**\n\n```\n输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n\n##### 思路\n\n动态规划，`dp[i]` 表示以 `nums[i]` 结尾的子数组的最大和。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        int ans = nums[0];\n        // 以i结尾的连续数组的最大和\n        for(int i = 1; i < nums.size(); ++i){\n            dp[i] = max(nums[i], dp[i - 1] + nums[i]);\n            ans = max(ans, dp[i]);\n        }\n        return ans;\n    }\n};\n```\n\n#### [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)\n\n##### 题目描述※\n\n输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。\n\n例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。\n\n**示例1：**\n\n```\n输入：n = 12\n输出：5\n```\n\n**示例2：**\n\n```\n输入：n = 13\n输出：6\n```\n\n##### 思路\n\n以 345 [d] XX 为例：\n\n1. 考虑 d 之前的数小于 345，d 只能取 1。\n\n```\n  000  1   00\n  001  1   01\n  ...  1   ...\n  344  1   99\n(344 + 1) * 100\n```\n\n2. 考虑 d 之前的数等于 345。\n\n（2.1）d > 1，XX 可以取 0 到 99。\n\n```\n345 => 1 * 100\n```\n\n（2.2）d == 1，XX 可以取 0 到 XX\n\n```\n345 => (XX + 1) * 1\n```\n\n（2.3）d == 0，XX 都不可以取到\n\n```\n345 => 0\n```\n\n**只考虑会经过 d 为 1 的组合。假如 d = 3，只考虑经过 1 后面对应的 0~99 共100 个数，不考虑经过 2 和 3 后面产生 1的可能，因为之前已经计算过了。**  \n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int countDigitOne(int n) {\n        if(n < 0) return 0;\n        int count = 0;\n        string str = to_string(n);\n        reverse(str.begin(), str.end());\n        for(int i = 1; i <= str.size(); ++i){\n            int v = n / (long)pow(10, i);\n            count += v * (long)pow(10, i - 1);\n            if(str[i - 1] - '0' > 1){\n                count += (long)pow(10, i - 1);\n            }\n            else if(str[i - 1] - '0' == 1){\n                count += n % (long)pow(10, i - 1) + 1;\n            }\n            else{\n                count += 0;\n            }\n        }\n        return count;\n    }\n};\n```\n\n##### 参考\n\nhttps://www.bilibili.com/video/BV1uJ411573j/\n\n#### [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)\n\n##### 题目描述※\n\n数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。\n\n请写一个函数，求任意第n位对应的数字。\n\n##### 思路\n\n当 $n<10$ 时，数字长度都为 1，一共有 10 个数，输出的结果就是 n；\n\n当 $10\\leq n\\leq 99$ 时，数字长度都为 2，一共有 90 个数，分别是 10 ~ 99，长度为 180；\n\n当 $100\\leq n\\leq 999$ 时，数字长度都为 3，一共有 900 个数，分别是 100 ~ 999，长度为 1800；\n\n$...$\n\n观察以上规律，当 n 小于 10 时，直接输出 n 即可。当 n 大于等于 10 时，需要知道 n 具体位于哪个区间（如 $[10,99]$ 还是 $[100,999]$ 等）。\n\n算法如下：\n\n1. n 小于 10 时，直接输出；\n2. n 大于等于 10 时，先减去 10；此时起始值 `start` 为 10，在此区间的每个数长度 `len` 为 2，区间总长 `cnt` 为 $9\\times start\\times len$ 为 180；\n3. 在 n 大于 cnt 时执行循环：\n   1. n 减去 cnt，表示进入下一个区间，且位于下一个区间的第 n 个位置；\n   2. 同时 `len` ，`start` 和 `cnt` 更新为新区间的值。\n4. 跳出循环后，此时可以得到 n 所处的值为 $start+n/len$，n 在值中的位置为 $n \\%len$。换成字符串输出即可。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int findNthDigit(int n) {\n        if(n < 10) return n;\n        n -= 10;\n        int len = 2; // n所在数字的位数，从2开始\n        long start = 10; // 起始的数，从10开始\n        long cnt = 9 * start * len; // 位的总长，比如10-99，总长为9*10*2=180\n        while(n > cnt){\n            n -= cnt;\n            len++;\n            start *= 10;\n            cnt = 9 * start * len;\n        }\n\n        long num = start + n / len;\n        int pos = n % len;\n        string str = to_string(num);\n        return str[pos] - '0';\n    }\n};\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/comments/\n\n#### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)\n\n##### 题目描述\n\n输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n\n**示例1：**\n\n```\n输入: [10,2]\n输出: \"102\"\n```\n\n**示例2：**\n\n```\n输入: [3,30,34,5,9]\n输出: \"3033459\"\n```\n\n##### 思路\n\n设数组 $nums$ 中任意两数字的字符串为 $x$ 和 $y$ ，则规定**排序判断规则**为：\n\n* 若拼接字符串 $x+y>y+x$ ，则 $x$ “大于” $y$；\n* 反之，若 $x+y<y+x$ ，则 $x$ “小于” $y$ ；\n\n**另一种思路**\n\n快排思想。\n\n##### 代码一\n\n```cpp\nclass Solution {\npublic:\n    string minNumber(vector<int>& nums) {\n        auto cmp = [&](int x, int y){\n            string s1 = to_string(x);\n            string s2 = to_string(y);\n            return s1 + s2 < s2 + s1;\n        };\n        sort(nums.begin(), nums.end(), cmp);\n        string ans;\n        for(auto &i : nums){\n            ans += to_string(i);\n        }\n        return ans;\n    }\n};\n```\n\n##### 代码二\n\n```cpp\nclass Solution {\npublic:\n    string minNumber(vector<int>& nums) {\n        vector<string> strs;\n        for(int i = 0; i < nums.size(); i++)\n            strs.push_back(to_string(nums[i]));\n        quickSort(strs, 0, strs.size() - 1);\n        string res;\n        for(string s : strs)\n            res.append(s);\n        return res;\n    }\nprivate:\n    void quickSort(vector<string>& strs, int l, int r) {\n        if(l >= r) return;\n        int i = l, j = r;\n        while(i < j) {\n            while(strs[j] + strs[l] >= strs[l] + strs[j] && i < j) j--;\n            while(strs[i] + strs[l] <= strs[l] + strs[i] && i < j) i++;\n            swap(strs[i], strs[j]);\n        }\n        swap(strs[i], strs[l]);\n        quickSort(strs, l, i - 1);\n        quickSort(strs, i + 1, r);\n    }\n};\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/\n\n#### [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)\n\n##### 题目描述\n\n给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n\n**示例1：**\n\n```\n输入: 12258\n输出: 5\n解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\"\n```\n\n##### 思路\n\n长度为 1 必然是一种选择，长度为 2 时看字符串转整数后是否在 10 到 25 之间，在此区间内也是一种选择，使用深搜找到所有的可能组合。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int cnt = 0;\n    int translateNum(int num) {\n        string s = to_string(num);\n        dfs(s, 0);\n        return cnt;\n    }\n    void dfs(string &s, int pos){\n        if(pos == s.size() || pos == s.size() - 1){\n            cnt++;\n            return;\n        }\n        dfs(s, pos + 1);\n        string str = s.substr(pos, 2);\n        int val = stoi(str);\n        if(val >= 10 && val <= 25){\n            dfs(s, pos + 2);\n        }\n    }\n};\n```\n\n#### [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)\n\n##### 题目描述\n\n在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n\n**示例1：**\n\n```\n输入: \n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 12\n解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物\n```\n\n##### 思路\n\n动态规划，类似于[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxValue(vector<vector<int>>& grid) {\n        if(grid.empty() || grid[0].empty()) return 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        dp[0][0] = grid[0][0];\n        for(int j = 1; j < n; ++j){\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n        for(int i = 1; i < m; ++i){\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n\n        for(int i = 1; i < m; ++i){\n            for(int j = 1; j < n; ++j){\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n```\n\n#### [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)\n\n##### 题目描述※\n\n请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n\n**示例1：**\n\n```\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3\n```\n\n**示例2：**\n\n```\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例2：**\n\n```\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n##### 思路\n\n1. 使用双指针，start 表示字符串起始位置，i 表示当前所处字符串位置；\n2. 用哈希表记录**当前遍历过的字符最后一次出现的位置**，当此字符再次出现时，将 start 更新为当前字符最后一次出现位置的下一个，作为新的起始位置；\n3. 每轮循环都更新最大长度 ans。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int len = s.size();\n        if(len == 0) return 0;\n        int ans = 1;\n        vector<int> lastPos(128, -1);\n\n        int start = 0;\n        for(int i = 0; i < len; ++i){\n            if(lastPos[s[i]] != -1 && lastPos[s[i]] >= start){\n                ans = max(ans, i - start);\n                start = lastPos[s[i]] + 1;\n                lastPos[s[i]] = i;\n            }\n            else{\n                lastPos[s[i]] = i;\n            }\n        } \n        // 更新最后一次\n        ans = max(ans, len - start);\n        return ans;\n    }\n};\n```\n\n#### [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)\n\n##### 题目描述※\n\n我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。\n\n**示例：**\n\n```\n输入: n = 10\n输出: 12\n解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。\n```\n\n##### 思路\n\n最小堆。\n\n每次取出最小的丑数，放进去它的2倍，3倍，5倍，同时用一个 set 去重。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        priority_queue<long, vector<long>, greater<long>> pq;\n        unordered_set<long> set;\n        pq.push(1);\n        long v;\n        while(n--){\n            v = pq.top();\n            pq.pop();\n            if(!set.count(v * 2)){\n                set.insert(v * 2);\n                pq.push(v * 2);\n            }\n            if(!set.count(v * 3)){\n                set.insert(v * 3);\n                pq.push(v * 3);\n            }\n            if(!set.count(v * 5)){\n                set.insert(v * 5);\n                pq.push(v * 5);\n            }\n        }\n        return v; \n    }\n};\n```\n\n**一种动态规划的解法**\n\n```cpp\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        int a = 0, b = 0, c = 0;\n        int dp[n];\n        dp[0] = 1;\n        for(int i = 1; i < n; i++) {\n            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;\n            dp[i] = min(min(n2, n3), n5);\n            if(dp[i] == n2) a++;\n            if(dp[i] == n3) b++;\n            if(dp[i] == n5) c++;\n        }\n        return dp[n - 1];\n    }\n};\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/评论\n\n#### [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)\n\n##### 题目描述※\n\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\n\n**示例1：**\n\n```\n输入: [7,5,6,4]\n输出: 5\n```\n\n##### 思路\n\n归并排序。\n\n在进行归并排序的同时，当遇到 $nums[i] > nums[j]$ 时更新逆序对的数量，参考下图：\n\n<img src=\"剑指offer-41-60\\分治.png\" style=\"zoom: 67%;\" />\n\n以 $[3,7|2,6]$ 为例，其中左右两部分已经排好序，当取 3 > 2 时，左半部分大于 3 的剩余部分都都大于 3，都可与后面构成逆序对，故可得到逆序对数计算公式（ mid = 1，i = 0​ ）：\n$$\nres = mid-i+1 = 2\n$$\n结果为 2，同时根据归并排序对原数组赋值。\n\n每当出现上述情况时，更新 res 即可。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int res = 0;\n    vector<int> buf;\n    int reversePairs(vector<int>& nums) {\n        buf = vector<int>(nums.size(), 0);\n        mergeSort(nums, 0, nums.size() - 1);\n        return res;\n    }\n    void mergeSort(vector<int> &nums, int left, int right){\n        if(left >= right) return;\n        int mid = (left + right) / 2;\n        mergeSort(nums, left, mid);\n        mergeSort(nums, mid + 1, right);\n        merge(nums, left, mid, right);\n    }\n    void merge(vector<int> &nums, int left, int mid, int right){\n        for(int i = left; i <= right; ++i){\n            buf[i] = nums[i];\n        }\n        int i = left, j = mid + 1;\n        for(int k = left; k <= right; ++k){\n            // 前半部分小于后半部分任意一个数\n        \t// 排序后的数组中元素的位置不变\n            if(i > mid){\n                nums[k] = buf[j];\n                j++;\n            }\n            // 前半部分数大于后半部分任意一个数\n        \t// 排序后的数组中前面的元素后移\n            else if(j > right){\n                nums[k] = buf[i];\n                i++;\n            }\n            else if(buf[i] <= buf[j]){\n                nums[k] = buf[i];\n                i++;\n            }\n            else{\n                nums[k] = buf[j];\n                j++;\n                res += mid - i + 1;\n            }\n        }\n    }\n};\n```\n\n**归并排序**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nvoid mergeSort(vector<int> &nums, int l, int r);\nvoid merge(vector<int> &nums, int l, int mid, int r);\nint main() {\n    vector<int> nums{1,3,2,3,1};\n    mergeSort(nums, 0, nums.size() - 1);\n    for(auto &num : nums) cout << num << \" \";\n    return 0;\n}\nvoid mergeSort(vector<int> &nums, int l, int r){\n    if(l >= r) return;\n    int mid = (l + r) / 2;\n    mergeSort(nums, l, mid);\n    mergeSort(nums, mid + 1, r);\n    merge(nums, l, mid, r);\n}\nvoid merge(vector<int> &nums, int l, int mid, int r){\n    vector<int> aux(r - l + 1, 0);\n    // 将原数组挪到以0为起点的数组上\n    // 如果不在乎空间消耗，直接给新数组开一个大小等于原数组的空间\n    // 就不用进行挪动了\n    for(int i = l; i <= r; ++i){\n        aux[i - l] = nums[i];\n    }\n    int i = l, j = mid + 1;\n    for(int k = l; k <= r; ++k){\n        // 前半部分小于后半部分任意一个数\n        // 排序后的数组中元素的位置不变\n        if(i > mid){\n            nums[k] = aux[j - l];\n            j++;\n        }\n        // 前半部分数大于后半部分任意一个数\n        // 排序后的数组中前面的元素后移\n        else if(j > r){\n            nums[k] = aux[i - l];\n            i++;\n        }\n        else if(aux[i - l] <= aux[j - l]){\n            nums[k] = aux[i - l];\n            i++;\n        }\n        else{\n            nums[k] = aux[j - l];\n            j++;\n        }\n    }\n}\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-pvn2h/\n\n#### [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)\n\n##### 题目描述\n\n输入两个链表，找出它们的第一个公共节点。\n\n##### 思路\n\n<img src=\"剑指offer-41-60\\offer-52.png\"  />\n\n链表 A 相交之前的部分为 a，链表 B 为 b，相交部分为 c。\n\n则有 $(a + c) + b = (b + c) + a$，最终在交点处相遇。对于无相交的情况，视 NULL 为两个链表的交点。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *l1 = headA; \n        ListNode *l2 = headB;\n        while(l1 != l2){\n            l1 = l1 != nullptr ? l1->next : headB;\n            l2 = l2 != nullptr ? l2->next : headA;\n        }\n        return l1;\n    }\n};\n```\n\n#### [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)\n\n##### 题目描述\n\n一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n\n**示例1：**\n\n```\n输入: [0,1,3]\n输出: 2\n```\n\n**示例2：**\n\n```\n输入: [0,1,2,3,4,5,6,7,9]\n输出: 8\n```\n\n##### 思路\n\n二分搜索。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int left = 0;\n        int right = nums.size() - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == mid){\n                left = mid + 1;\n            }\n            else{\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n};\n```\n\n#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)\n\n##### 题目描述\n\n给定一棵二叉搜索树，请找出其中第k大的节点。\n\n**示例1：**\n\n```\n输入: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\n输出: 4\n```\n\n**示例2：**\n\n```\n输入: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n输出: 4\n```\n\n##### 思路\n\n中序遍历，返回倒数第 K 个节点。\n\n##### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int kthLargest(TreeNode* root, int k) {\n        if(!root) return 0;\n        vector<int> vec;\n        TreeNode *node = root;\n        stack<TreeNode*> st;\n        while(!st.empty() || node){\n            if(node){\n                st.push(node);\n                node = node->left;\n            }\n            else{\n                node = st.top();\n                st.pop();\n                vec.push_back(node->val);\n                node = node->right;\n            }\n        }\n        return vec[vec.size() - k];\n    }\n};\n```\n\n#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)\n\n##### 题目描述\n\n输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n\n例如：\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n```\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回它的最大深度 3。\n\n##### 思路\n\n最大深度 = max（左子树最大深度，右子树最大深度）+ 1。\n\n##### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n```\n\n#### [剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)\n\n##### 题目描述\n\n输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n\n**示例1：**\n\n给定二叉树 `[3,9,20,null,null,15,7]`\n\n```\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回 true 。\n\n**示例 2:**\n\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n\n           1\n          / \\\n         2   2\n        / \\\n       3   3\n      / \\\n     4   4返回 false 。\n\n##### 思路\n\n如果左右子树的高度差大于 1，直接返回 false，否则，递归保证左右子树的左右子树的高度差要小于等于 1。当递归到空节点时，直接返回 true，因为左右子树高度都是 0。\n\n##### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        if(!root) return true;\n        return abs(maxDepth(root->left) - maxDepth(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);\n    }\n    int maxDepth(TreeNode *node){\n        if(!node)\n            return 0;\n        return max(maxDepth(node->left), maxDepth(node->right)) + 1;\n    }\n};\n```\n\n#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)\n\n##### 题目描述\n\n一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。\n\n**示例1：**\n\n```\n输入：nums = [4,1,4,6]\n输出：[1,6] 或 [6,1]\n```\n\n**示例2：**\n\n```\n输入：nums = [1,2,10,4,1,4,3,3]\n输出：[2,10] 或 [10,2]\n```\n\n##### 思路\n\n位运算，一个数异或自己得到的结果为 0，可以找到 $x\\oplus y$。\n$$\na\\oplus a \\oplus b \\oplus b \\oplus x \\oplus y = x \\oplus y\n$$\n如果 x 和 y 的某一位（二进制）不同，则那一位异或后为 1。根据这一位并使用**与运算**将数组分为两部分，其中一部分包括 x，一部分包括 y，再分别进行异或得到 x 和 y。\n$$\na\\oplus a \\oplus b \\oplus b \\oplus x = x\n$$\n\n$$\na\\oplus a \\oplus b \\oplus b \\oplus y = y\n$$\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> singleNumbers(vector<int>& nums) {\n        // x^x = 0;\n        int x = 0, y = 0;\n        int ret = 0;\n        // 找到x^y\n        for(auto &num : nums){\n            ret = ret ^ num;\n        }\n        // 找到xy二进制位不同的的首位\n        int m = 1;\n        while((m & ret) == 0){\n            m <<= 1;\n        }\n        // 将数组分成两部分分别计算出现一次的数\n        for(auto &num : nums){\n            if(num & m) x ^= num;\n            else y ^= num;\n        }\n        return {x, y};\n    }\n};\n```\n\n#### [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)\n\n##### 题目描述\n\n在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。\n\n**示例1：**\n\n```\n输入：nums = [3,4,3,3]\n输出：4\n```\n\n**示例2：**\n\n```\n输入：nums = [9,1,7,9,7,9,7]\n输出：1\n```\n\n##### 思路\n\n位运算。\n\n将 `nums` 数组中所有数的每一位求和，再对 3 取余，可以得到只出现一次的那个数的每一位，然后再将其恢复为十进制数。\n\n##### 代码一\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int cnt[32] = {0};\n        // 得到每一位二进制求和结果\n        for(int i = 0; i < nums.size(); ++i){\n            for(int j = 0; j < 32; ++j){\n                cnt[j] += (nums[i] & 1);\n                nums[i] >>= 1;\n            }\n        }\n        for(auto &c : cnt) cout << c << \" \";\n        // 取出取余后的每一位\n        int res = 0;\n        for(int i = 0; i < 32; ++i){\n            res <<= 1;\n            res |= (cnt[31 - i] % 3);\n        }\n        return res;\n    }\n};\n```\n\n##### 代码二\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        long long cnt[32] = {0};\n\n        for(int i = 0; i < 32; ++i){\n            int m = 1 << i;\n            for(auto &num : nums){\n                int v = num & m;\n                cnt[i] += v;\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < 31; ++i){\n            if(cnt[i] % 3){\n                ans += (1 << i);\n            }\n            else continue;\n        }\n        return ans;\n    }\n};\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/      \n\n####  [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)\n\n##### 题目描述\n\n输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\n\n**示例1：**\n\n```\n输入：nums = [2,7,11,15], target = 9\n输出：[2,7] 或者 [7,2]\n```\n\n**示例2：**\n\n```\n输入：nums = [10,26,30,31,47,60], target = 40\n输出：[10,30] 或者 [30,10]\n```\n\n##### 思路\n\n双指针。因为数组有序，收缩边界即可找到 target。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n        int sum = nums[left] + nums[right];\n        while(left < right){\n            if(sum == target){\n                return {nums[left], nums[right]};\n            }\n            else if(sum > target){\n                sum -= nums[right];\n                right--;\n                sum += nums[right];\n            }\n            else{\n                sum -= nums[left];\n                left++;\n                sum += nums[left];\n            }\n        }\n        return {};\n    }\n};\n```\n\n#### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)\n\n##### 题目描述\n\n输入一个正整数 `target` ，输出所有和为 `target` 的连续正整数序列（至少含有两个数）。\n\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n\n**示例1：**\n\n```\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n```\n\n**示例2：**\n\n```\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n```\n\n##### 思路\n\n双指针。右边界最大不超过 (target + 1) / 2。循环中的 j 不包含在结果中，所以最大值要比右边界多 1。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> findContinuousSequence(int target) {\n        vector<vector<int>> ans;\n        int end = (target + 1) / 2;\n        int i = 1;\n        int j = 1;\n        int sum = 0;\n        while(j <= end + 1){\n            if(sum == target){\n                vector<int> buf;\n                for(int m = i; m < j; ++m){\n                    buf.push_back(m);\n                }\n                if(buf.size() >= 2) ans.push_back(buf);\n                sum -= i;\n                i++;\n            }\n            else if(sum < target){\n                sum += j;\n                j++;\n            }\n            else{\n                sum -= i;\n                i++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n#### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)\n\n##### 题目描述\n\n输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串\"I am a student. \"，则输出\"student. a am I\"。\n\n**示例1：**\n\n```\n输入: \"the sky is blue\"\n输出: \"blue is sky the\"\n```\n\n**示例2：**\n\n```\n输入: \"  hello world!  \"\n输出: \"world! hello\"\n解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n```\n\n**示例3：**\n\n```\n输入: \"a good   example\"\n输出: \"example good a\"\n解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n```\n\n##### 思路\n\n见代码。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    string reverseWords(string s) {\n        stringstream str(s);\n        string buf;\n        string ans;\n        vector<string> vec;\n        while(str >> buf){\n            vec.push_back(buf);\n        }\n        reverse(vec.begin(), vec.end());\n        for(auto &v : vec){\n            ans += v;\n            ans += ' ';\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n```\n\n#### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)\n\n##### 题目描述\n\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。\n\n**示例1：**\n\n```\n输入: s = \"abcdefg\", k = 2\n输出: \"cdefgab\"\n```\n\n**示例2：**\n\n```\n输入: s = \"lrloseumgh\", k = 6\n输出: \"umghlrlose\"\n```\n\n##### 思路\n\n无。随你怎么写。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    string reverseLeftWords(string s, int n) {\n        if(s.empty()) return \"\";\n        string str = s.substr(0, n);\n        for(int i = 0; i < s.size() - n; ++i){\n            s[i] = s[i + n];\n        }\n        int j = 0;\n        for(int i = s.size() - n; i < s.size(); ++i){\n            s[i] = str[j++];\n        }\n        return s;\n    }\n};\n```\n\n#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)\n\n##### 题目描述\n\n给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。\n\n**示例：**\n\n```\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出: [3,3,5,5,6,7] \n解释: \n\n  滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n##### 思路\n\n首先使用优先队列存储 `nums` 的前 `k` 个值，队首就是第一个窗口最大的值。\n\n接着从第 `k` 个位置开始，将序列入队，每次最大的值都出现在队首。但是**当前的队首不一定是当前窗口中的元素**，此时队列的长度可能大于 `k`。如下：\n\n```\nnums = {3,1,1}, k = 2;\n1. {3,1} max = 3; // 队列中元素为3,1\n2. {1,1} max = 1; // 队列中元素为3,1,1，此时需要将3出队\n```\n\n如果不是当前窗口中的元素，只有可能是上一个窗口中的最大值，它一定是在当前窗口左端点的左侧，就需要将队首出队，直到队首元素在当前窗口内。\n\n所以优先队列需要同时存储当前序列的值和坐标。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        priority_queue<pair<int, int>> q;\n        for(int i = 0; i < k; ++i){\n            q.push({nums[i], i});\n        }\n        vector<int> ans{q.top().first};\n        for(int i = k; i < nums.size(); ++i){\n            q.push({nums[i], i});\n            // 队首元素不在当前窗口内\n            while(q.top().second <= i - k){\n                q.pop();\n            }\n            ans.push_back(q.top().first);\n        }\n        return ans;\n    }\n};\n```\n\n#### [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)\n\n##### 题目描述\n\n请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的**均摊**时间复杂度都是O(1)。\n\n若队列为空，pop_front 和 max_value 需要返回 -1。\n\n```\n输入: \n[\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"]\n[[],[1],[2],[],[],[]]\n输出: \n[null,null,null,2,1,2]\n```\n\n##### 思路\n\n主要是实现 max_value 的时间复杂度为 -1。\n\n使用一个队列存当前的所有元素；使用一个双端队列存非严格单调递减的元素，则最大值就是双端队列的首部。\n\n其中，当有新元素到来时，如果此元素的值大于双端队列的尾部，则将双端队列尾部持续出队，直到找到第一个大于等于新元素的元素，在这个元素之后将新元素入队。队列的入队和出队不受影响。\n\n**插入的值表示，到插入这个值之后队列里面的最大值。**\n\n##### 代码\n\n```cpp\nclass MaxQueue {\npublic:\n    queue<int> q;\n    deque<int> dq;\n    MaxQueue() {\n    }\n    \n    int max_value() {\n        return dq.empty() ? -1 : dq.front();\n    }\n    \n    void push_back(int value) {\n        q.push(value);\n        if(dq.empty()) dq.push_back(value);\n        // 当value大于双端队列的尾部元素时，持续将双端队列的尾部出队\n        else{\n            while(!dq.empty() && value > dq.back()){\n                dq.pop_back();\n            }\n            dq.push_back(value);\n        }\n    }\n    \n    int pop_front() {\n        if(q.empty()) return -1;\n        int v = q.front();\n        q.pop();\n        // 出队一个最大元素即可\n        if(!dq.empty() && v == dq.front()){\n            dq.pop_front();\n        }\n        return v;\n    }\n};\n\n/**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue* obj = new MaxQueue();\n * int param_1 = obj->max_value();\n * obj->push_back(value);\n * int param_3 = obj->pop_front();\n */\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/jian-zhi-offer-59-ii-dui-lie-de-zui-da-z-0pap/\n\n#### [剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)\n\n##### 题目描述\n\n把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n\n```cpp\n输入: 1\n输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]\n```\n\n##### 思路\n\n动态规划。\n\n**定义**\n\n`dp[i][j]` 表示 i 个骰子点数 j 出现的次数。\n\n**转移方程**\n\n第 i 个骰子点数 j 出现的次数根据第 i - 1 个骰子 j - 1，j - 2，j - 3，j - 4，j - 5，j - 6 出现的次数求和得到：\n$$\ndp[i][j] = \\sum \\limits_{i=1}^{6}dp[i-1][j-i]\n$$\n**初始化**\n\n第 1 个骰子出现的点数我们是已知的。\n\n```cpp\nfor(int i = 1; i <= 6; ++i)\n\tdp[1][i] = 1;\n```\n\n**注意**：i 个骰子最小的点数是 i，最大的点数是 6 * i，一共有 5 * i + 1 个可能出现的点数。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<double> dicesProbability(int n) {\n        // 表示有i个筛子时摇出j的次数\n        vector<vector<int>> dp(n + 1, vector<int>(6 * 11 + 1, 0));\n        for(int i = 1; i <= 6; ++i)\n            dp[1][i] = 1;\n        for(int i = 2; i <= n; ++i){\n            for(int j = i; j <= i * 6; ++j){\n                for(int m = 1; m <= 6; ++m){\n                    if(j - m > 0) dp[i][j] += dp[i - 1][j - m];\n                }\n            }\n        }\n        vector<double> ans(6 * n - n + 1, 0);\n        for(int i = 0; i <= 5 * n; i++){\n            // n个骰子，出现的点数是n~n+5*n\n            ans[i] = (double)dp[n][i + n] / pow(6, n);\n        }\n        return ans;\n    }\n};\n```\n\n##### **参考**\n\nhttps://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/nge-tou-zi-de-dian-shu-dong-tai-gui-hua-ji-qi-yo-3/#comment\n\n","categories":["LeetCode"]},{"title":"剑指offer_21_40","url":"/blog/2021/07/18/剑指offer-21-40/","content":"\n剑指 Offer 21~40\n\n<!-- more-->\n\n#### [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)\n\n##### 题目描述※\n\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。\n\n**示例：**\n\n```\n输入：nums = [1,2,3,4]\n输出：[1,3,2,4] \n注：[3,1,2,4] 也是正确的答案之一。\n```\n\n##### 思路\n\n遍历一遍数组，如果遇到奇数，就和 `nums[k]` 进行交换。其中，k 初始值为 0，经过交换后，`num[k]` 一定是奇数。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> exchange(vector<int>& nums) {\n        int k = 0;\n        for(int i = 0; i < nums.size(); ++i){\n            if(nums[i] % 2 == 1){\n                swap(nums[i], nums[k]);\n                k++;\n            }\n        }\n        return nums;\n    }\n};\n```\n\n#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)\n\n##### 题目描述\n\n输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。\n\n例如，一个链表有 `6` 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第 `3` 个节点是值为 `4` 的节点。\n\n**示例：**\n\n```\n给定一个链表: 1->2->3->4->5, 和 k = 2.\n返回链表 4->5.\n```\n\n##### 思路\n\n先用一个指针 `cur` 指向 `head`，然后后移 `k` 个单位。此时，让 `head` 和 `cur` 同时后移直到 `cur` 为空，`head` 的位置就是倒数第 `k` 个节点的位置。\n\n##### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* getKthFromEnd(ListNode* head, int k) {\n        if(!head) return nullptr;\n        ListNode *cur = head;\n        while(k--){\n            cur = cur->next;\n        }\n        while(cur){\n            head = head->next;\n            cur = cur->next;\n        }\n        return head;\n    }\n};\n```\n\n#### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)\n\n##### 题目描述\n\n定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n\n**示例：**\n\n```\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n```\n\n##### 思路\n\n存储当前节点的下一个节点和前一个节点（头节点的上一个节点为 `nullptr`）。令当前节点指向前一个节点，将前一个节点更新为当前节点（也就是下一个节点的前一个节点），再将当前节点更新为新的下一个节点。\n\n##### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *cur = head;\n        ListNode *pre = nullptr;\n        while(cur){\n            ListNode *tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp;\n        }\n        return pre;\n    }\n};\n// 反转双向链表\nclass DoubleListNode \n{\npublic:\n\tint value;\n\tDoubleListNode* next;\n\tDoubleListNode* last;\n\tDoubleListNode(int m_value, DoubleListNode* nextl = nullptr, DoubleListNode* last1 = nullptr) {\n\t\tvalue = m_value;\n\t\tnext = nextl;\n\t\tlast = last1;\n\t}\n};\nDoubleListNode *reverseList(DoubleListNode*  head) \n{\n\tDoubleListNode *pre = nullptr;\n\tDoubleListNode *cur = head;\n\twhile (cur) {\n        // 1.记录下一个位置\n\t\tDoubleListNode *tmp = cur->next; \n        // 2.交换当前节点和前一个的值\n\t\tcur->next = pre;   \n\t\tcur->last = tmp;\n\t\tpre = cur;\n        // 3.当前节点后移\n\t\tcur = tmp;       \n\t}\n\treturn pre;\n}\n```\n\n#### [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)\n\n##### 题目描述※\n\n输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。\n\n**示例：**\n\n```\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n```\n\n##### 思路\n\n每次挑两个链表中较小的的续到新链表的后面。\n\n##### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode *dummyNode = new ListNode(0);\n        ListNode *cur = dummyNode;\n        while(l1 && l2){\n            if(l1->val < l2->val){\n                cur->next = l1;\n                cur = cur->next;\n                l1 = l1->next;\n            }\n            else{\n                cur->next = l2;\n                cur = cur->next;\n                l2 = l2->next;  \n            }\n        }\n        if(l1) cur->next = l1;\n        if(l2) cur->next = l2;\n        return dummyNode->next;\n    }\n};\n```\n\n#### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)\n\n##### 题目描述\n\n输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\n\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n\n例如:\n给定的树 A:\n\n```cpp\n  3\n / \\\n4   5\n   / \\\n  1   2\n```\n\n给定的树 B：\n\n```\n  4 \n /\n1\n```\n\n\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n\n##### 思路\n\n从 A 中找到与 B 根节点值相同的结点进行递归对比，直到 B 至末尾时完全匹配，表示 B 是 A 的子结构。需要察看三个方面 B 是否可以构成 A 的子结构：\n\n1. A 的根节点与 B 的根节点直接递归；\n2. A 的左子树与 B 的根节点进行递归；\n3. A 的右子树与 B 的根节点进行递归；\n\n上述三个满足一个就表示 B 是 A 的子结构。同时根据题目要求：**空树不是任意一个树的子结构**，如果 A 或 B 结点一个为空，那么直接返回 false。如果在递归中，A 已为空而 B 非空，返回 false。\n\n**另外一种思路**\n\n对 A 进行任意一种遍历，对遍历到的每个节点与 B 进行对。见代码二。\n\n##### 代码一\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSubStructure(TreeNode* A, TreeNode* B) {\n        if(!B || !A) return false;\n        // 调用自身而不调用isSubTree是因为isSubTree的返回值是&&的关系\n        // 如果出现A的某子树包含B，另一子树不包含B，那么返回false，实际上应返回true\n        return isSubStructure(A->left, B) || isSubStructure(A->right, B) || isSubTree(A, B);\n    }\n    bool isSubTree(TreeNode *node1, TreeNode *node2){\n        if(!node2) return true;\n        if(!node1) return false;\n        \n        return node1->val == node2->val && isSubTree(node1->left, node2->left) && isSubTree(node1->right, node2->right);\n    }\n};\n```\n\n##### 代码二\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSubStructure(TreeNode* A, TreeNode* B) {\n        if(A == nullptr || B == nullptr) return false;\n        stack<TreeNode*> st;\n        st.push(A);\n        while(!st.empty()){\n            TreeNode *tmp = st.top();\n            st.pop();\n            if(tmp){\n                if(dfs(tmp, B)) return true;\n                st.push(tmp->right);\n                st.push(tmp->left);\n            }\n\n        }\n        return false;\n    }\n    bool dfs(TreeNode *node1, TreeNode *node2){\n        if(node2 == nullptr){\n            return true;\n        }\n        // node2不为空且node1为空\n        else if(node1 == nullptr){\n            return false;\n        }\n        // 都不为空\n        if(node1->val == node2->val){\n            return dfs(node1->left, node2->left) && dfs(node1->right, node2->right);\n        }\n        else return false;\n    }\n};\n```\n\n#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)\n\n##### 题目描述\n\n请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n\n例如输入：\n\n     \t  4\n        /   \\\n       2     7\n      / \\   / \\\n     1   3 6   9\n\n镜像输出：\n\n     \t  4\n        /   \\\n       7     2\n      / \\   / \\\n     9   6 3   1\n\n**示例1：**\n\n```\n输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n```\n\n##### 思路\n\n由上至下，交换同一根节点下的两个指针。\n\n##### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mirrorTree(TreeNode* root) {\n        if(!root) return nullptr;\n\n        TreeNode *left = root->left;\n        TreeNode *right = root->right;\n\n        root->left = mirrorTree(right);\n        root->right = mirrorTree(left);\n\n        return root;\n    }\n};\n```\n\n#### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)\n\n请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n\n    \t1\n       / \\\n      2   2\n     / \\ / \\\n    3  4 4  3\n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    \t1\n       / \\\n      2   2\n       \\   \\\n       3    3\n\n **示例1：**\n\n```\n输入：root = [1,2,2,3,4,4,3]\n输出：true\n```\n\n**示例2：**\n\n```\n输入：root = [1,2,2,null,3,null,3]\n输出：false\n```\n\n##### 思路\n\n由上至下，对比**左子树的左节点和右子树的右节点**，**左子树的右节点和右子树的左节点**是否相等。两者都相等时返回 true。\n\n##### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if(!root) return true;\n        return dfs(root->left, root->right);\n    }\n\n    bool dfs(TreeNode *left, TreeNode *right){\n        if(left && !right) return false;\n        if(!left && right) return false;\n        if(!left && !right) return true;\n        if(left->val == right->val)\n            return dfs(left->left, right->right) && dfs(left->right, right->left);\n        else return false;\n    }\n};\n```\n\n#### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)\n\n##### 题目描述\n\n输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\n\n**示例1：**\n\n```\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n```\n\n**示例2：**\n\n```\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n```\n\n##### 思路\n\n模拟一下遍历的顺序，然后逐步缩减边界，直到完全遍历。具体顺序如下：\n\n1. 向右，遍历到最右边时，上边界加 1，下一步向下；\n2. 向下，遍历到最下边时，右边界减 1，下一步向左；\n3. 向左，遍历到最左边时，下边界减 1，下一步向上；\n4. 向上，遍历到最上边时，左边界加 1，下一步继续向右，即返回 1。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> ans;\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        if(matrix.empty()) return {};\n        dfs(matrix, 0, matrix[0].size() - 1, 0, matrix.size() - 1, 0);\n        return ans;\n    }\n    // 0 right\n    // 1 down\n    // 2 left\n    // 3 up\n    void dfs(vector<vector<int>> &matrix, int left, int right, int up, int down, int flag){\n        // 注意返回条件\n        if(left > right || up > down)\n            return;\n        if(flag == 0){\n            for(int i = left; i <= right; ++i){\n                ans.push_back(matrix[up][i]);\n            }\n            dfs(matrix, left, right, up + 1, down, 1);\n        }\n        else if(flag == 1){\n            for(int i = up; i <= down; ++i){\n                ans.push_back(matrix[i][right]);\n            }\n            dfs(matrix, left, right - 1, up, down, 2);\n        }\n        else if(flag == 2){\n            for(int i = right; i >= left; --i){\n                ans.push_back(matrix[down][i]);\n            }\n            dfs(matrix, left, right, up, down - 1, 3);\n        }\n        else{\n            for(int i = down; i >= up; --i){\n                ans.push_back(matrix[i][left]);\n            }\n            dfs(matrix, left + 1, right, up, down, 0);\n        }\n    }\n};\n```\n\n#### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)\n\n##### 题目描述\n\n定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\n\n**示例1：**\n\n```\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.min();   --> 返回 -2.\n```\n\n##### 思路\n\n使用两个栈，第一个栈存储每个元素；第二个栈存储单调递增的元素，即栈顶就是到目前为止最小的元素（为空时直接存储当前元素）。\n\n出栈时，第一个栈正常出栈，第二个栈如果和第一个栈出栈的元素相同，才进行出栈。\n\n##### 代码\n\n```cpp\nclass MinStack {\npublic:\n    stack<int> st1;\n    stack<int> st2;\n    /** initialize your data structure here. */\n    MinStack() {\n\n    }\n    \n    void push(int x) {\n        st1.push(x);\n        if(st2.empty() || x <= st2.top()){\n            st2.push(x);\n        }\n    }\n    \n    void pop() {\n        int val = st1.top();\n        if(val == st2.top()){\n            st2.pop();\n        }\n        st1.pop();\n    }\n    \n    int top() {\n        return st1.top();\n    }\n    \n    int min() {\n        return st2.top();\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(x);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->min();\n */\n```\n\n#### [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)\n\n##### 题目描述※\n\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。\n\n**示例1：**\n\n```\n输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n输出：true\n解释：我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -> 4,\npush(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n```\n\n**示例2：**\n\n```\n输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n输出：false\n解释：1 不能在 2 之前弹出。\n```\n\n##### 思路\n\n由于所有数组中的数不是重复的，用一个栈来模拟 `pushed` 数组对应的入栈出栈过程。\n\n* 当栈顶元素等于 `poped` 数组的第一个元素时，说明要进行出栈，同时 `poped` 数组坐标增加；\n* 出栈后的新栈顶与数组第二个元素比较，如果相等则持续出栈；\n* 如果不相等则继续将 `poped` 的下一个元素入栈，再进行比较。直到完全遍历 `pushed`。\n\n如果最后栈为空，说明 `poped` 数组是 `pushed` 数组某种压栈序列的弹出序列。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\n        stack<int> st;\n        int popPos = 0;\n        for(int i = 0; i < pushed.size(); ++i){\n            st.push(pushed[i]);\n            while(!st.empty() && st.top() == popped[popPos]){\n                st.pop();\n                popPos++;\n            }\n        }    \n        return st.empty();                                                                                                    \n    }\n};\n```\n\n#### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)\n\n##### 题目描述※\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。\n\n参考以下这颗二叉树：\n\n```\n     5\n    / \\\n   2   6\n  / \\\n 1   3\n```\n\n**示例1：**\n\n```\n输入: [1,6,3,2,5]\n输出: false\n```\n\n**示例2：**\n\n```\n输入: [1,3,2,6,5]\n输出: true\n```\n\n##### 思路\n\n后序遍历二叉树得到的结果是：左子树、右子树、根节点。\n\n根据二叉搜索树的特性，左子树值全部小于根节点的值，右子树的值全部大于根节点的值，可以根据根节点将序列分为两个部分，当这两个部分都满足二叉搜索树性质时，当前的后序遍历序列就是二叉搜索树的后续遍历序列。通过递归，来实现左右子树和根节点的分离。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool verifyPostorder(vector<int>& postorder) {\n        return check(postorder, 0, postorder.size() - 1);\n    }\n    // left 子树起始位置\n    // right 根节点位置\n    bool check(vector<int>& vec, int left, int right){\n        // 当节点只剩下一个时，返回true\n        if(left >= right)\n            return true;\n        // 使用变量p遍历当前序列\n        int p = left;\n        while(vec[p] < vec[right]) p++;\n        // 左子树的结束位置\n        int m = p - 1;\n        while(vec[p] > vec[right]) p++;\n        // 当遍历完成后，p应处于根节点位置\n        return p == right && check(vec, left, m) && check(vec, m + 1, right - 1);\n    }\n};\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/cchao-100de-di-gui-jie-fa-by-ffreturn-42w4/\n\n#### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)\n\n##### 题目描述※\n\n输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。\n\n**示例：**\n\n给定如下二叉树，以及目标和 `target = 20`。\n\n```\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n```\n\n返回：\n\n```\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n```\n\n##### 思路\n\n**本题最主要的是把根节点先加入数组中。**\n\n使用 DFS + 回溯 可以很好的解决这个问题，算法如下：\n\n1. 是否存在根节点？不存在直接返回空，否则，进行2；\n2. 设置一个数组 buf 存储当前路径，首先将根节点的值放入数组中，同时使用一个变量 sum 记录当前的路径和，sum 初始值为根节点的值。接下来进行递归；\n3. 递归的结束条件为：当前节点为叶子节点，如果此时的 sum 等于 target，那么就将此条路径加入答案数组中，然后返回；否则，直接返回；\n4. 在递归中，如果当前节点存在左节点或者右节点：\n   1. 存在左节点，将左节点的值加到 buf 中，同时 sum 加上此值，再进行递归，递归完成后，进行回溯（也就是弹出 buf 的最后一个值，并用 sum 减去此值，恢复原值）；\n   2. 存在右节点，将右节点的值加到 buf 中，同时 sum 加上此值，再进行递归，递归完成后，进行回溯（也就是弹出 buf 的最后一个值，并用 sum 减去此值，恢复原值）；\n   3. 同时存在，上述两条都执行；\n\n##### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<int> buf;\n    vector<vector<int>> pathSum(TreeNode* root, int target) {\n        if(!root) return {};\n        buf.push_back(root->val);\n        dfs(root, root->val, target);\n        return ans;\n    }\n    void dfs(TreeNode *node, int sum, int target){\n        if(!node->left && !node->right){\n            if(sum == target){\n                ans.push_back(buf);\n            }\n            return;\n        }\n        if(node->left){\n            buf.push_back(node->left->val);\n            dfs(node->left, sum + node->left->val, target);\n            buf.pop_back();\n        }\n        if(node->right){\n            buf.push_back(node->right->val);\n            dfs(node->right, sum + node->right->val, target);\n            buf.pop_back();\n        }\n    }\n};\n```\n\n#### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)\n\n##### 题目描述※\n\n请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。\n\n<img src=\"剑指offer-21-40\\offer-35.png\"  />\n\n##### 思路\n\n1. 将原始链表复制一份，新节点续在原始节点之后；\n2. 构建新节点的 `random` 指针，`cur->next->random = cur->random->next`；\n3. 将链表拆分为原始链表和新链表，返回新链表的头指针。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if(!head) return nullptr;\n        // 复制各节点，跟随在原节点之后\n        Node *cur = head;\n        while(cur){\n            Node *tmp = new Node(cur->val);\n            tmp->next = cur->next;\n            cur->next = tmp;\n            cur = tmp->next;\n        }\n        // 构建复制节点的random指针\n        cur = head;\n        while(cur){\n            if(cur->random){\n                cur->next->random = cur->random->next;\n            }\n            cur = cur->next->next;\n        }\n        // 拆分原链表与新链表\n        cur = head->next;\n        Node *res = cur;\n        Node *pre = head;\n        while(cur->next){\n            pre->next = pre->next->next;\n            cur->next = cur->next->next;\n            pre = pre->next;\n            cur = cur->next;\n        }\n        // 处理原链表尾节点\n        pre->next = nullptr;\n        return res; // 返回新链表头节点\n    }\n};\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/\n\n#### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)\n\n#####  题目描述\n\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n\n<img src=\"剑指offer-21-40\\offer-36.png\"  />\n\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n\n<img src=\"剑指offer-21-40\\offer-36-1.png\"  />\n\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n\n##### 思路\n\n二叉搜索树**中序遍历**时可以得到**升序的序列**。根据这个性质，对二叉搜索树进行中序遍历，同时按照题目要求构建为循环链表。\n\n需要注意：\n\n1. 如果根节点为空则返回空\n2. 除了链表的首节点外，构建其他节点时，需要记录上一节点，从而构建双向的关系。\n3. 遍历完所有节点后，最后一个节点和首节点需要构建双向关系。\n\n##### 代码\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n        left = NULL;\n        right = NULL;\n    }\n\n    Node(int _val, Node* _left, Node* _right) {\n        val = _val;\n        left = _left;\n        right = _right;\n    }\n};\n*/\nclass Solution {\npublic:\n    Node* treeToDoublyList(Node* root) {\n        if(!root) return nullptr;\n        stack<Node*> st;\n        Node *last;\n        Node *head;\n        Node *node = root;\n        int headFlag = 0;\n        while(!st.empty() || node){\n            if(node){\n                st.push(node);\n                node = node->left;\n            }\n            else{\n                node = st.top();\n                st.pop();\n                if(!headFlag){\n                    headFlag = 1;\n                    last = node;\n                    head = last;\n                }\n                else{\n                    last->right = node;\n                    node->left = last;\n                    last = node; // 注意更新\n                }\n                node = node->right;\n            }\n        }\n        last->right = head;\n        head->left = last;\n        return head;\n    }\n};\n```\n\n##### 参考\n\n[二叉树的三种遍历方式（迭代法）](http://www.xingyuzhao.ltd/blog/2020/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89/)\n\n#### [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)\n\n##### 题目描述\n\n请实现两个函数，分别用来序列化和反序列化二叉树。\n\n你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n**提示：**输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n<img src=\"剑指offer-21-40\\offer-37.png\"  />\n\n##### 思路\n\n**序列化**\n\n使用层次遍历的思想，但是每个 `null` 节点也需要加入队列，同时使用 `string` 来记录已经得到的节点。\n\n**反序列化**\n\n先对输入进来的 data 按照 `,` 进行划分，将划分结果分别存入 `vector<string>` 中，得到的结果可能是数字，也可能是 `null`。\n\n继续使用层次遍历的思想，构建二叉树，具体的，`string` 数组只有不为 `null` 时才构造新的节点，先构造左子树，再构造右子树，两个子树的根节点位置分别为当前节点位置 +1 和 +2。\n\n##### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n    // Encodes a tree to a single string.\n   \t// 输入：[1,2,3,null,null,4,5]\n    // 输出：[1,2,3,null,null,4,5,null,null,null,null]\n    string serialize(TreeNode* root) {\n        string s = \"[\";\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            TreeNode *node;\n            int n = q.size();\n            for(int i = 0; i < n; ++i){\n                node = q.front();\n                q.pop();\n                if(node){\n                    s += to_string(node->val);\n                    s += \",\";\n                    q.push(node->left);\n                    q.push(node->right);\n                }\n                else{\n                    s += \"null\";\n                    s += \",\";\n                }\n            }\n        }\n        s.pop_back();\n        s += \"]\";\n        return s;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        if(data == \"[null]\") return nullptr;\n        data = data.substr(1);\n        data.pop_back();\n        vector<string> vec;\n        stringstream str(data);\n        string buf;\n        while(getline(str, buf, ','))\n            vec.push_back(buf);\n        queue<TreeNode*> q;\n        TreeNode *root = new TreeNode(stoi(vec[0]));\n        q.push(root);\n        int pos = 1;\n        while(!q.empty()){\n            TreeNode *node = q.front();\n            q.pop();\n            if(vec[pos] != \"null\"){\n                node->left = new TreeNode(stoi(vec[pos]));\n                q.push(node->left);\n            }\n            pos++;\n            if(vec[pos] != \"null\"){\n                node->right = new TreeNode(stoi(vec[pos]));\n                q.push(node->right);\n            }\n            pos++;\n        }\n\n        return root;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec;\n// codec.deserialize(codec.serialize(root));\n```\n\n#### [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)\n\n##### 题目描述\n\n输入一个字符串，打印出该字符串中字符的所有排列。\n\n你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。\n\n**示例：**\n\n```\n输入：s = \"abc\"\n输出：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\n```\n\n##### 思路\n\n回溯 + 哈希表。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    unordered_set<string> set;\n    vector<string> permutation(string s) {\n        vector<string> ans;\n        vector<bool> vis(s.size(), false);\n        for(int i = 0; i < s.size(); ++i){\n            string buf;\n            vis[i] = true;\n            dfs(s, buf + s[i], vis);\n            vis[i] = false;\n        }\n        ans = vector<string>(set.begin(), set.end());\n        return ans;\n    }\n\n    void dfs(string &s, string buf, vector<bool> &vis){\n        if(buf.size() == s.size()){\n            if(!set.count(buf)){\n                set.insert(buf);\n            }\n            return;\n        }\n        for(int i = 0; i < s.size(); ++i){\n            if(vis[i]) continue;\n\n            vis[i] = true;\n            dfs(s, buf + s[i], vis);\n            vis[i] = false;\n        }\n    }\n};\n```\n\n#### [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)\n\n##### 题目描述\n\n数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n**示例：**\n\n```\n输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]\n输出: 2\n```\n\n##### 思路\n\n哈希表计数。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int len = nums.size() / 2;\n        unordered_map<int, int> map;\n        for(int i = 0; i < nums.size(); ++i){\n            map[nums[i]]++;\n        }\n\n        for(auto &[fir, sec] : map){\n            if(sec > len)\n                return fir;\n        }\n        return -1;\n    }\n};\n```\n\n#### [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)\n\n##### 题目描述\n\n输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n\n**示例1：**\n\n```\n输入：arr = [3,2,1], k = 2\n输出：[1,2] 或者 [2,1]\n```\n\n**示例2：**\n\n```\n输入：arr = [0,1,2,1], k = 1\n输出：[0]\n```\n\n##### 思路\n\nTOP K 问题，使用优先队列。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> getLeastNumbers(vector<int>& arr, int k) {\n        if(k == 0) return {};\n        vector<int> ans;\n        // 大顶堆\n        priority_queue<int, vector<int>, less<int>> pq;\n        for(int i = 0; i < k; ++i)\n            pq.push(arr[i]);\n\n        for(int i = k; i < arr.size(); ++i){\n            if(arr[i] < pq.top()){\n                pq.pop();\n                pq.push(arr[i]);\n            }\n        }\n\n        while(!pq.empty()){\n            ans.push_back(pq.top());\n            pq.pop();\n        }\n\n        return ans;\n    }\n};\n```\n\n","categories":["LeetCode"]},{"title":"剑指offer_1_20","url":"/blog/2021/07/12/剑指offer-1-20/","content":"\n剑指 Offer 01~20\n\n<!-- more-->\n\n#### [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)\n\n##### 题目描述\n\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n**示例：**\n\n现有矩阵 matrix 如下：\n\n```\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n```\n\n给定 target = `5`，返回 `true`。\n\n给定 target = `20`，返回 `false`。\n\n##### 思路\n\n从右上角往左下角看，是一棵二叉搜索树。从右上角开始遍历，如果当前值小于 `target` ，那么需要将列递减；如果当前值大于 `target`，就需要将行递增，直到找到 `target`。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {\n        if(matrix.size() == 0) return false;\n        int row = 0;\n        int col = matrix[0].size() - 1;\n        while(row < matrix.size() && col >= 0){\n            if(matrix[row][col] == target)\n                return true;\n            else if(matrix[row][col] > target)\n                col--;\n            else\n                row++;\n        }\n        return false;\n    }\n};\n```\n\n#### [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n\n##### 题目描述\n\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n例如，给出\n\n```\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n```\n\n返回如下的二叉树：\n\n```\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n##### 思路\n\n前序遍历的第一个元素便是二叉树的根节点，由于元素不重复，那么在中序遍历中找到该节点，就可以将中序遍历分为 **「左子树|根节点|右子树」** 三部分，再根据中序遍历中左子树和右子树的元素的个数，将前序遍历分为**「根节点|左子树|右子树」**三部分。建立根节点，再用根节点指向左子树和右子树。\n\n算法如下：\n\n1. 根据前序遍历记录根节点在中序遍历中出现的位置；\n2. 在中序遍历中，根据根节点将左右子树分开，使根节点分别指向左子树和右子树；\n3. 根据中序遍历中左子树和右子树的元素长度，将前序遍历分为根节点、左子树、右子树三部分，然后再对左子树和右子树分别建树。\n\n详见注释。\n\n##### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    unordered_map<int, int> map;\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int n  = preorder.size();\n        for(int i = 0; i < inorder.size(); ++i){\n            map[inorder[i]] = i;\n        }\n        TreeNode *root = build(preorder, inorder, 0, n - 1, 0, n - 1);\n        return root;\n    }\n    // 前序数组，中序数组。左/右子树在前序遍历和中序遍历中起点，终点。\n    TreeNode *build(vector<int> &v1, vector<int> &v2, int left1, int right1, int left2, int right2){\n        if(left1 > right1 || left2 > right2){\n            return nullptr;\n        }\n        // 找到根节点\n        int root = v1[left1];\n        int pos = map[root];\n        TreeNode *node = new TreeNode(root);\n        // 前序遍历左子树起点，终点；中序遍历左子树起点，终点\n        node->left = build(v1, v2, left1 + 1, left1 + pos - left2, left2, pos - 1);\n        // 前序遍历右子树起点，终点；中序遍历右子树起点，终点\n        node->right = build(v1, v2, left1 + pos - left2 + 1, right1, pos + 1, right2);\n        return node;\n    }\n};\n```\n\n#### [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)\n\n##### 题目描述\n\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n\n**示例1：**\n\n```\n输入：\n[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n```\n\n**示例2：**\n\n```\n输入：\n[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n```\n\n##### 思路\n\n使用 s1 存储新元素。当需要实现出队时，如果 s2 非空，直接出队即可；如果 s2 为空，将 s1 中的所有元素出栈并放入 s2 中，再将 s2 栈顶弹出，保证出队顺序。\n\n##### 代码\n\n```cpp\nclass CQueue {\npublic:\n    stack<int> s1;\n    stack<int> s2;\n    CQueue() {\n\n    }\n    \n    void appendTail(int value) {\n        s1.push(value);\n    }\n    \n    int deleteHead() {\n        if(s2.empty()){\n            if(s1.empty()) return -1;\n            while(!s1.empty()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int v = s2.top();\n        s2.pop();\n        return v;\n    }\n};\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue* obj = new CQueue();\n * obj->appendTail(value);\n * int param_2 = obj->deleteHead();\n */\n```\n\n#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)\n\n##### 题目描述\n\n写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：\n\n```\nF(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.\n```\n\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n**示例1：**\n\n```\n输入：n = 2\n输出：1\n```\n\n**示例2：**\n\n```\n输入：n = 5\n输出：5\n```\n\n##### 思路\n\n注意边界。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int fib(int n) {\n        if(n <= 1) return n;\n        int f0 = 0, f1 = 1;\n        int fn = 0;\n        for(int i = 2; i <= n; ++i){\n            fn = f0 % (int)(1e9+7) + f1 % (int)(1e9+7);\n            f0 = f1;\n            f1 = fn;\n        }\n        return fn % (int)(1e9+7);\n    }\n};\n```\n\n#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)\n\n##### 题目描述\n\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n**示例：**\n\n```\n输入：n = 2\n输出：2\n```\n\n##### 思路\n\n与上题类似，注意边界。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int numWays(int n) {\n        if(n == 0) return 1;\n        if(n <= 2) return n;\n        int f1 = 1, f2 = 2;\n        int fn = 0;\n        for(int i = 3; i <= n; ++i){\n            fn = f1 % (int)(1e9+7) + f2 % (int)(1e9+7);\n            f1 = f2;\n            f2 = fn;\n        }\n        return fn % (int)(1e9+7);\n    }\n};\n```\n\n#### [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)\n\n##### 题目描述※\n\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为1。  \n\n**示例1：**\n\n```\n输入：[3,4,5,1,2]\n输出：1\n```\n\n**示例2：**\n\n```\n输入：[2,2,2,0,1]\n输出：0\n```\n\n##### 思路\n\n二分查找。详见注释。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minArray(vector<int>& numbers) {\n        int left = 0;\n        int right = numbers.size() - 1;\n        while(left < right){\n            int mid = left + (right - left) / 2;\n            // 此条件下说明最小元素坐标i范围是left <= i <= mid\n            if(numbers[mid] < numbers[right]){\n                right = mid;\n            }\n            // 此条件下说明最小元素坐标i范围是mid + 1 <= i <= right \n            else if(numbers[mid] > numbers[right]){\n                left = mid + 1;\n            }\n            // [1,3,3],[3,3,1,3]等情况，使right处于数组的较小部分\n            else\n                right--;\n        }\n        return numbers[left];\n    }\n};\n```\n\n#### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)\n\n##### 题目描述\n\n请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。\n\n[[\"a\",\"**b**\",\"c\",\"e\"],\n[\"s\",\"**f**\",\"**c**\",\"s\"],\n[\"a\",\"d\",\"**e**\",\"e\"]]\n\n但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。\n\n##### 思路\n\n* 找到可以匹配 `word` 第一个字符的位置，更新 `pos` 和 `vis`；\n* 从匹配的位置进行 DFS，寻找下一个匹配的位置，如果此路不通，需要将 **坐标和是否访问** “归还”（回溯思想）。\n* 如果 `pos == word.size()` 说明存在此条路线，记录此时状态。\n\n其中：\n\n* 使用 `pos` 标记当前 `word` 中应该对比的字符的位置；\n* 使用 `vis[i][j]` bool型数组记录当前坐标是否被访问。\n\n##### 剪枝\n\n1. 上述解题思路 2 中，**寻找匹配位置**是一种剪枝方法，避免走其他路线；\n2. 当已经存在一条路线时，就不需要继续找了，设置**全局变量**记录是否存在路线。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int dx[4] = {-1,1,0,0};\n    int dy[4] = {0,0,-1,1};\n    int flag = 0;\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size();\n        int n = board[0].size();\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(board[i][j] == word[0]){\n                    vis[i][j] = 1;\n                    dfs(board, word, 1, i, j, vis);\n                    vis[i][j] = 0;\n                }\n            }\n        }\n        return flag == 1;\n    }\n    void dfs(vector<vector<char>>& board, string &word, int pos, int i, int j, vector<vector<bool>> &vis){\n        if(pos == word.size()){\n            flag = 1;\n            return;\n        }\n\n        for(int m = 0; m < 4; ++m){\n            if(flag == 1) return;\n            int x = i + dx[m];\n            int y = j + dy[m];\n\n            if(x >= 0 && x < board.size() && y >= 0 && y < board[0].size()\n                && board[x][y] == word[pos] && !vis[x][y]){\n                vis[x][y] = 1;\n                dfs(board, word, pos + 1, x, y, vis);\n                vis[x][y] = 0;\n            }\n        }\n    }\n};\n```\n\n#### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)\n\n##### 题目描述\n\n地上有一个m行n列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]` 。一个机器人从坐标 `[0, 0]` 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n##### 思路\n\n深度优先搜索。从（0，0）开始，找到所有的可能性。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int dx[4] = {-1,1,0,0};\n    int dy[4] = {0,0,-1,1};\n    int cnt = 0;\n    int movingCount(int m, int n, int k) {\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\n        dfs(m, n, 0, 0, k, vis);\n        return cnt;\n        \n    }\n    void dfs(int m, int n, int i1, int j1, int k, vector<vector<bool>> &vis){\n        // 主要针对只有初始点是可以进去的\n        if(!vis[i1][j1]){\n            vis[i1][j1] = 1;\n            cnt++;\n        }\n        for(int i = 0; i < 4; ++i){\n            int x = i1 + dx[i];\n            int y = j1 + dy[i];\n            if(x >= 0 && x < m && y >= 0 && y < n && vis[x][y]) continue;\n            // 数位求和，这里可以简化，懒得弄了就直接转string处理了\n            string x_s = to_string(x);\n            string y_s = to_string(y);\n            int n1 = 0, n2 = 0;\n            for(auto &ch : x_s) n1 += ch - '0';\n            for(auto &ch : y_s) n2 += ch - '0';\n            if(x >= 0 && x < m && y >= 0 && y < n && !vis[x][y] && n1 + n2 <= k){\n                vis[x][y] = 1;\n                cnt++;\n                dfs(m, n, x, y, k, vis);\n            }\n        }\n    }\n};\n```\n\n一种并查集做法：\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\npublic:\n    unionFind(int m, int n){\n        this->count = 0;\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                parent.push_back(i * n + j);\n            }\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : p = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        parent[pRoot] = qRoot;\n    }\n};\nclass Solution {\npublic:\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n    int movingCount(int m, int n, int k) {\n        unionFind uf(m, n);\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(!isValid(i, j, k)) continue;\n                for(int idx = 0; idx < 4; ++idx){\n                    int x = i + dx[idx];\n                    int y = j + dy[idx];\n                    if(x >= 0 && x < m && y >= 0 && y < n && isValid(x, y, k)){\n                        uf.unionElem(i * n + j, x * n + y);\n                    }\n                }\n            }\n        }\n        unordered_map<int, int> map;\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                map[uf.find(i * n + j)]++;\n            }\n        }\n        int ans = 0;\n        for(auto &m : map){\n            ans = max(ans, m.second);\n        }\n        return ans;\n    }\n    bool isValid(int x, int y, int k){\n        int sum = 0;\n        while(x != 0){\n            sum += x % 10;\n            x /= 10;\n        }\n        while(y != 0){\n            sum += y % 10;\n            y /= 10;\n        }\n        return sum <= k;\n    }\n};\n```\n\n#### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)\n\n[剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)\n\n##### 题目描述\n\n给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m - 1]` 。请问 `k[0]*k[1]*...*k[m - 1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n**示例1：**\n\n```\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n```\n\n**示例2：**\n\n```\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n```\n\n##### 思路1：动态规划\n\n`dp[i]` 表示长度等于 i 时的绳子可获得成绩的最大值，可以拆解为两部分的乘积：\n$$\ndp[i] = dp[j] \\times dp[i - j]\\ \\ \\ \\ \\ \\ j = 1...i/2\n$$\n当 n 小于等于 3 时，返回 `n - 1`。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int cuttingRope(int n) {\n        if(n == 2) return 1;\n        if(n == 3) return 2;\n        vector<int> dp(n + 1, 0);\n        dp[0] = dp[1] = 1;\n        dp[2] = 2;\n        dp[3] = 3;\n        for(int i = 4; i <= n; ++i){\n            for(int j = 1; j <= i / 2; ++j){\n                dp[i] = max(dp[i], dp[j] * dp[i - j]);\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n##### 思路2：数学方法\n\n1. 任何大于 1 的数都可以由 2 和 3 相加而成；\n2. 使用 3 作为因数比使用 2 作为因数乘积更大；\n3. 当 n 大于 4 时，将绳子不断减去 3，并进行累乘。\n\n至于为什么不是 n 大于 3，因为 n 等于 4 时，将绳子切为两段 2 比切为 1 和 3 更优。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int cuttingRope(int n) {\n        if(n == 2) return 1;\n        if(n == 3) return 2;\n        long long sum = 1;\n        while(n > 4){\n            sum *= 3;\n            sum %= 1000000007;\n            n -= 3;\n        }\n        return sum * n % static_cast<int>(1e9 + 7);\n    }\n};\n```\n\n#### [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)\n\n实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数（即，$x^n$）。不得使用库函数，同时不需要考虑大数问题。\n\n**示例1：**\n\n```\n输入：x = 2.00000, n = 10\n输出：1024.00000\n```\n\n**示例2：**\n\n```\n输入：x = 2.00000, n = -2\n输出：0.25000\n解释：2-2 = 1/22 = 1/4 = 0.25\n```\n\n##### 思路\n\n快速幂运算，只需要在奇数时将结果与平方数相乘。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        bool flag = n < 0;\n        long nn = n;\n        nn = abs(nn);\n        // 快速幂\n        double sum = 1;\n        while(nn){\n            // 奇数\n            if(nn & 1 == 1){\n                sum *= x;\n            }\n            x *= x;\n            nn >>= 1;\n        }\n        return flag ? 1 / sum : sum;\n    }\n};\n```\n\n#### [剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)\n\n##### 题目描述※\n\n请实现一个函数用来匹配包含 `'. '` 和 `'*'` 的正则表达式。模式中的字符 `'.'` 表示任意一个字符，而 `'*'` 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 `\"aaa\"` 与模式 `\"a.a\"` 和 `\"ab*ac*a\"` 匹配，但与 `\"aa.a\"` 和 `\"ab*a\"` 均不匹配。\n\n<img src=\"剑指offer-1-20\\offer-19.png\"  />\n\n##### 思路\n\n假设主串为 A，长度为 n；匹配串为 B，长度为 m。关注 B 的**最后一个字符**是什么，有三种可能：正常字符， `*` 和 `.`。\n\n1. 正常字符：看 A[n - 1] 是否等于 B[m - 1]，如果相等则同时前移；\n2. `.`，可以匹配任意字符，直接看前一个是否匹配；\n3. `*`，表示 B[m - 2] 可以重复 0 次或多次：\n   1. 表示 0 次，B 最后两个字符无效，比较 B[0 : m - 3] 和 A[0 : n - 1] 是否匹配；\n   2. 表示多次，即 B[m - 2] = c 可以出现多次，如果此时 A[n - 1] = c，或者 c = `.`，则可以匹配，那么 A 向前移动一个，B 不动，再次查看 A[0 : n - 2] 和 B[0 : m - 1] 是否匹配（将 A 从后往前等于 c 的元素都匹配上）。\n\n###### 动态规划\n\n$dp[i][j]$ 表示 A 的前 $i$ 个 和 B 的前 $j$ 个能否匹配。\n\n* 对于前两种情况，可以合并为 $dp[i][j] = dp[i - 1][j - 1]$\n* 对于第三种情况，简单记为 c*，分为两种情况\n  1. 表示 0 次，直接砍掉 B 后面两个字符，$dp[i][j] = dp[i][j - 2]$\n  2. 表示多次，正则串不动，主串前移一个，$dp[i][j] = dp[i - 1][j]$\n\n###### 初始化\n\n正则串为空，如果主串为空，则匹配，否则不匹配：\n\n```cpp\ndp[i][0] = i == 0;\n```\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.size();\n        int m = p.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\n        // i和j表示当前字符串的长度\n        for(int i = 0; i <= n; ++i){\n            for(int j = 0; j <= m; ++j){\n                // 如果正则串空，那么只能匹配空串\n                if(j == 0){\n                    dp[i][j] = i == 0;\n                }\n                // 正则串非空，分为*和非*\n                else{\n                    // 如果不为*，则直接比较当前字符是否相等，或正则串字符为.\n                    if(p[j - 1] != '*'){\n                        if(i > 0 && (s[i - 1] == p[j - 1] || p[j - 1] == '.')){\n                            dp[i][j] = dp[i - 1][j - 1];\n                        }\n                    }\n                    // 碰到*了，分为*表示0次还是多次\n                    else{\n                        // 表示0次，直接砍掉正则串后两个\n                        if(j >= 2){\n                            dp[i][j] = dp[i][j - 2];\n                        }\n                        // 表示多次，主串当前和正则串上一位置相等，或正则串的前一位置为.\n                        if(i >= 1 && j >= 2 && (s[i - 1] == p[j - 2] || p[j - 2] == '.')){\n                            dp[i][j] = dp[i][j] | dp[i - 1][j];\n                        }\n\t\t\t\t\t\t// 注意：使用 | 表示上述两种情况只要有一种满足即可！！！\n                    }\n                }\n            }\n        }\n        return dp[n][m];\n    }\n};\n```\n\n##### 参考\n\nhttps://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/\n\n#### [剑指 Offer 20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)\n\n##### 题目描述※\n\n请实现一个函数用来判断字符串是否表示**数值**（包括整数和小数）。\n\n**数值**（按顺序）可以分成以下几个部分：\n\n1. 若干空格\n2. 一个 **小数** 或者 整数\n3. （可选）一个 `'e'` 或 `'E'` ，后面跟着一个 **整数**\n4. 若干空格\n\n**小数**（按顺序）可以分成以下几个部分：\n\n1. （可选）一个符号字符（`'+'` 或 `'-'`）\n2. 下述格式之一：\n   1. 至少一位数字，后面跟着一个点 `'.'`\n   2. 至少一位数字，后面跟着一个点 `'.'` ，后面再跟着至少一位数字\n   3. 一个点 `'.'` ，后面跟着至少一位数字\n\n**整数**（按顺序）可以分成以下几个部分：\n\n1. （可选）一个符号字符（`'+'` 或 `'-'`）\n2. 至少一位数字\n\n部分**数值**列举如下：\n\n* `[\"+100\", \"5e2\", \"-123\", \"3.1416\", \"-1E-16\", \"0123\"]`\n\n部分**非数值**列举如下：\n\n* `[\"12e\", \"1a3.14\", \"1.2.3\", \"+-5\", \"12e+5.4\"]`\n\n<img src=\"剑指offer-1-20\\offer-20.png\"  />\n\n##### 思路\n\n详见注释。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool isNumber(string s) {\n        int pos1 = s.find_first_not_of(' ');\n        if(pos1 == s.npos) return false;\n        int pos2 = s.find_last_not_of(' ');\n        bool numFlag = 0, dotFlag = 0, eFlag = 0;\n\n        for(int i = pos1; i <= pos2; ++i){\n            // 判定为数字，标记为numFlag\n            if(s[i] >= '0' && s[i] <= '9'){\n                numFlag = 1;\n            }\n            // 判定为.，需要没出现过.且没出现过e\n            else if(s[i] == '.' && !dotFlag && !eFlag){\n                dotFlag = 1;\n            }\n            // 判定为e，需要没出现过e且出现过数字\n            else if((s[i] == 'E' || s[i] == 'e') && numFlag && !eFlag){\n                eFlag = 1;\n                numFlag = 0; // 出现e之后重新判断整数\n            }\n            // 判断为+-，只能出现在第一位或者紧接在e后面\n            else if((s[i] == '+' || s[i] == '-') && (i == pos1 || s[i - 1] == 'e' || s[i - 1] == 'E')){\n                continue;\n            }\n            // 其他情况非法\n            else return false;\n        }\n        return numFlag;\n    }\n};\n```\n\n","categories":["LeetCode"]},{"title":"C++中static的用法总结","url":"/blog/2021/05/26/C-中static的用法总结/","content":"\n#### 摘要\n\nC++ 中 **static** 关键字的作用。\n\n<!-- more-->\n\n##### 静态局部变量\n\n用于函数体内部修饰变量，这种变量的生存期长于该函数。\n\n1. 该变量在**全局数据区**分配内存；\n2. 在首次执行到该对象声明处被首次初始化，以后的函数调用不再进行初始化，即：**静态变量只初始化一次**；\n3. **静态局部变量一般在声明处初始化**，如果没有显示初始化，会被程序自动初始化为 0；\n4. 它始终驻留在全局数据区，直到程序运行结束，但是其作用域为局部作用域，在函数体外无法使用。\n\n##### 静态全局变量\n\n定义在函数体外，用于修饰全局变量，表示该变量只在**本文件**可见。\n\n1. 静态全局变量**不能被其他文件使用**（全局变量可以）；\n2. 其他文件可以定义同名变量且不会发生冲突。\n\n##### 静态函数\n\n类似于静态全局变量。\n\n1. 静态函数**不能被其他文件使用**；\n2. 其他文件可以定义同名函数且不会发生冲突。\n\n##### 静态数据成员\n\n用于修饰类中的数据成员，称为**静态成员**。这种数据成员的生存期大于类的对象。静态数据成员是每个类有一份，普通数据成员每个对象有一份。\n\n1. 静态成员存储在全局数据区，在定义时需要分配空间，所以不能在类中定义。且只分配一次内存，被类的所有对象共同访问；\n2. **静态成员不占据类的空间，必须在类外进行初始化，且在初始化时与私有或公有无关**。\n\n```cpp\nclass A{\n\tstatic int a;\n};\nint A::a = 0;\n// sizeof(A) = 1，空类大小为1\n```\n\n##### 静态成员函数\n\n用于修饰类的成员函数，可以用 **类名::函数名** 进行访问。\n\n1. 静态成员函数**可访问**静态数据成员和静态成员函数；\n2. 非静态成员函数**可访问**静态数据成员和静态成员函数；\n3. 静态数据成员**不可访问**非静态数据成员和非静态成员函数；\n4. 调用静态成员函数，可以用成员访问操作符 (.) 和 (->) 为一个类的对象或指向类对象的指针调用静态成员函数，也可以用 类名::函数名 调用。\n\n静态成员函数不能声明为 `const`，因为其不能访问对象的非静态数据成员，无法使用 `thiscall`。\n\n#### 相关问题\n\n（1）静态成员函数和非静态成员函数的区别？\n\n静态成员函数不存在 `this` 指针，不能访问非静态成员变量。\n\n（2）为什么要使用静态成员变量和静态成员函数？\n\n为了实现共享。静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享。\n\n（3）在头文件把一个变量声明为 static 变量，引用该文件的源文件能访问到该变量吗？\n\n可以，因为 cpp 文件包含了头文件。\n","tags":["static"],"categories":["C++"]},{"title":"libevent服务端接收连接的代码示例","url":"/blog/2021/04/27/libevent服务端接收连接的代码示例/","content":"\n#### 说明\n\nlibevent服务端接收连接的代码示例。\n\n<!-- more-->\n\n#### 代码\n\n```cpp\n#include <event2/event.h>\n#include <event2/listener.h>\n#include <string.h>\n#ifndef _WIN32\n#include <signal.h>\n#endif\n#include <iostream>\nusing namespace std;\n#define SPORT 5001\nvoid listen_cb(struct evconnlistener *e, evutil_socket_t s, struct sockaddr *a, int socklen, void *arg) {\n\tcout << \"listen_cb\" << endl;\n}\nint main()\n{\n#ifdef _WIN32\n\t// 初始化socket库\n\tWSADATA wsa;\n\tWSAStartup(MAKEWORD(2,2), &wsa);\n#else\n\t// 忽略管道信号，发送数据给已关闭的socket\n\t// 防止程序down掉\n\tif (signal(SIGPIPE, SIG_IGN) == SIG_ERR)\n\t\treturn 1;\n#endif\n    std::cout << \"test server!\\n\";\n\t// 创建libevent的上下文\n\tevent_base *base = event_base_new();\n\tif (base) {\n\t\tcout << \"event_base_new success\" << endl;\n\t}\n\t// 监听端口\n\t// socket，bind，listen在一起做了，绑定事件\n\tsockaddr_in sin;\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_port = htons(SPORT);\n\n\tevconnlistener *ev = evconnlistener_new_bind(base, // libevent的上下文\n\t\tlisten_cb,                // 接受到连接的回调函数\n\t\tbase,\t\t\t\t\t  // 回调函数获取的参数arg\n\t\tLEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, // 地址重用，listen关闭同时关闭socket\n\t\t10,\t\t\t\t\t\t\t\t\t\t // 连接队列大小，对应listen函数\n\t\t(sockaddr*)&sin,\t\t\t\t\t\t\t\t\t // 绑定的地址和端口\n\t\tsizeof(sin)\n\t);\n\t// 事件分发处理\n\tif(base)\n\t\tevent_base_dispatch(base);\n\tif(ev)\n\t\tevconnlistener_free(ev);\n\tif(base)\n\t\tevent_base_free(base);\n#ifdef _WIN32\n\tWSACleanup();\n#endif\n\treturn 0;\n}\n```\n\n#### 执行\n\n在 cmd 中输入：`telnet 127.0.0.1 5001` 可以看到在控制台输出 `listen_cb`：\n\n<img src=\"libevent服务端接收连接的代码示例\\1.png\"  />\n\n","tags":["libevent"]},{"title":"条款43：学习处理模板化基类内的名称","url":"/blog/2021/04/08/条款43：学习处理模板化基类内的名称/","content":"\n#### 要点\n\n可在派生类模板内通过 `this->` 指出基类模板内的成员名称，或者由一个清晰的**基类资格修饰符**完成。\n\n<!-- more-->\n\n#### 一个传送信息的模板程序\n\n我们需要一个程序将加密的信息或者未经加工的文字传到不同的公司去。如果在编译期间我们可知哪一个信息传到哪一家公司，可以使用基于模板的解法：\n\n```cpp\nclass CompanyA{\npublic:\n\t...\n    void sendCleartext(const std::string& msg); // 未加工的文本\n    void sendEncrypted(const std::string& msg); // 加密的信息\n};\nclass CompanyB{\npublic:\n\t...\n    void sendCleartext(const std::string& msg); // 未加工的文本\n    void sendEncrypted(const std::string& msg); // 加密的信息\n};\n... // 针对其他公司设计的class\nclass MsgInfo { ... }; // 用来保存及产生信息\n```\n\n```cpp\ntemplate<typename Company>\nclass MsgSender{\npublic:\n\t...\n\tvoid sendClear(const MsgInfo& info){\n\t\tstd::string msg;\n\t\t根据info产生信息\n\t\tCompany c;\n\t\tc.sendCleartext(msg);\n\t}\n    // 类似sendClear，调用sendEncrypted\n\tvoid sendSecret(const MsgInfo& info){ ... } \n}\n```\n\n如果我们希望在每次发送信息时记录某些信息，可以使用派生类：\n\n```cpp\ntemplate<typename Company>\nclass LoggingMsgSender: public MsgSender<Company>{\npublic:\n\t...\n\tvoid sendClearMsg(const MsgInfo& info){\n\t\t将传送前信息写至log\n\t\tsendClear(info); // 调用基类函数，代码无法通过编译\n\t\t将传送后信息写至log\n\t}\n\t...\n};\n```\n\n上述代码编译器会提示 `sendClear` 不存在，原因是编译器不知道类模板 `LoggingMsgSender` 继承的是什么样的类（ `MsgSender<Company>` 中的 `company` 未知），所以更不知道是否有 `sendClear` 函数。\n\n#### 模板全特化\n\n假设有个类 `CompanyZ` 坚持使用加密通信：\n\n```cpp\nclass CompanyZ{ // 这个类不提供sendCleartext函数，你懂的\npublic:\n\t...\n\tvoid sendEncrypted(const std::string& msg);\n\t...\n}\n```\n\n一般性的 `MsgSender` 模板对 `CompanyZ` 并不合适，因为模板提供了 `sendClear` 函数，此函数又调用了 `sendCleartext` 函数，对 `CompanyZ` 对象来说合理吗？这不合理。针对这个问题，可以产生一个 `MsgSender` **全特化版**：\n\n```cpp\ntemplate<>\nclass MsgSender<CompanyZ>{\npublic:\n\t...\n\tvoid sendSecret(const MsgInfo& info) // 此函数针对加密文档的传送\n\t...\n}\n```\n\n##### 再看派生类LoggingMsgSender\n\n```cpp\ntemplate<typename Company>\nclass LoggingMsgSender: public MsgSender<Company>{\npublic:\n\t...\n\tvoid sendClearMsg(const MsgInfo& info){\n\t\t将传送前信息写至log\n\t\tsendClear(info); // 如果Company = CompanyZ，此函数将不存在\n\t\t将传送后信息写至log\n\t}\n\t...\n};\n```\n\n如注释所言，如果基类被指定为 `MsgSender<CompanyZ>` 必然是不合法的，**编译器知道基类模板有可能被特化**，特化版本可能不提供和一般性模板相同的接口。因此编译器**拒绝在模板化基类中寻找继承而来的名称**（本例中 `MsgSender<Company>`）。\n\n##### 令C++可以进入模板化基类\n\n1. 在基类函数调用动作之前加上 `this->`：\n\n```cpp\ntemplate<typename Company>\nclass LoggingMsgSender: public MsgSender<Company>{\npublic:\n\t...\n\tvoid sendClearMsg(const MsgInfo& info){\n\t\t将传送前信息写至log\n\t\tthis->sendClear(info); // 成立，sendClear将被继承\n\t\t将传送后信息写至log\n\t}\n\t...\n};\n```\n\n2. 使用 `using` 声明式：\n\n```cpp\ntemplate<typename Company>\nclass LoggingMsgSender: public MsgSender<Company>{\npublic:\n    using MsgSender<Company>::sendClear; // 告诉编译器，基类中存在sendClear\n\t...\n\tvoid sendClearMsg(const MsgInfo& info){\n\t\t将传送前信息写至log\n\t\tsendClear(info); // 成立，sendClear将被继承\n\t\t将传送后信息写至log\n\t}\n\t...\n};\n```\n\n3. 明白指出被调用的函数位于基类：\n\n```cpp\ntemplate<typename Company>\nclass LoggingMsgSender: public MsgSender<Company>{\npublic:\n\t...\n\tvoid sendClearMsg(const MsgInfo& info){\n\t\t将传送前信息写至log\n\t\tMsgSender<Company>::sendClear(info); // 成立，sendClear将被继承\n\t\t将传送后信息写至log\n\t}\n\t...\n};\n```\n\n**注意**：这种解法如果调用的是虚函数，上述做法会关闭虚函数的绑定行为。","tags":["模板"],"categories":["Effective C++"]},{"title":"条款42：了解typename的双重意义","url":"/blog/2021/04/06/条款42：了解typename的双重意义/","content":"\n#### 要点\n\n1. 声明 template 参数时，前缀关键字 class 和 typename 可互换\n2. 请使用关键字 typename 标识嵌套从属类型名称；但不得在基类列表或成员初始化列表内作为基类的修饰符\n\n<!-- more-->\n\n#### 从属名称和非从属名称\n\n以下程序想要实现打印 STL 容器里的第二个元素（STL 里对象为 int 类型）。先不管能否通过编译。\n\n```cpp\ntemplate<typename C>\nvoid print2nd(const C& container){\n    if(container.size() >= 2){\n        C::const_iterator iter(container.begin());\n        ++iter;\n        int value = *iter;\n        std::cout << value;\n    }\n}\n```\n\n* 变量 iter 的类型是 C::const_iterator，实际是什么类型取决去 template 参数 C。如果 template 内出现的名称依赖于某个 template 参数，称之为从属名称，如果从属名称在 class 中呈嵌套状，称其为嵌套从属名称，C::const_iterator 就是如此；\n* 变量 value 的类型是 int，int 不依赖任何 template 参数，所以这样的名称是非从属名称。\n\n如果解析器在 template 中遭遇一个嵌套从属名称，**它便假设这个名称非一种类型，除非你使用 typename 告诉它确实是一种类型**。以下才是合法的代码：\n\n```cpp\ntemplate<typename C>\nvoid print2nd(const C& container){\n\tif(container.size() >= 2){\n\t\ttypename C::const_iterator iter(container.begin());\n        ...\n\t}\n}\n```\n\n#### 一个例外\n\ntypename 必须作为嵌套从属类型名称的前缀词这一规则的例外是：\n\n* typename 不可以出现在**基类列表**中的嵌套从属类型名称之前，也不可在**成员初始化列表**中作为基类的修饰符。\n\n```cpp\ntemplate<typename T>\nclass Derived: public Base<T>::Nested{ // 基类列表中不允许typename\npublic:\n\texplicit Derived(int x): Base<T>::Nested(x){ // 成员初始化列表中也不允许typename\n\t\ttypename Base<T>::Nested temp; // 不在上述两种情况内且是嵌套从属类型名称，必须加上typename\n\t\t...\n\t}\n\t...\n};\n```\n\n#### typedef与typename结合\n\n假设我们正在撰写一个函数模板，它接受一个迭代器，我们要对迭代器所指向的对象做一份局部拷贝：\n\n```cpp\ntemplate<typename IterT>\nvoid workWithIterator<IterT iter){\n\ttypename std::iterator_traits<IterT>::value_type temp(*iter);\n\t...\n}\n```\n\n`std::iterator_traits<IterT>::value_type` 表示类型为 IterT 之对象所指之物的类型，并将 temp 初始化为 iter 所指物。即：IterT 是 `vector<int>::iterator`，temp 的类型就是 int，由于 value_type 是一个嵌套从属类型名称，所以我们必须在它之前放置 typename。\n\n同时可以使用 typedef 减少一遍又一遍的使用 `std::iterator_traits<IterT>::value_type`：\n\n```cpp\ntemplate<typename IterT>\nvoid workWithIterator<IterT iter){\n\ttypedef typename std::iterator_traits<IterT>::value_type temp(*iter) value_type;\n    value_type temp(*iter);\n\t...\n}\n```\n\n","tags":["typename"],"categories":["Effective C++"]},{"title":"条款38：通过复合塑模出has-a或“根据某物实现出”","url":"/blog/2021/04/01/条款38：通过复合塑模出has-a或“根据某物实现出”/","content":"\n#### 要点\n\n* 复合的意义和 public 继承完全不同。\n* 在应用域，复合意味 has-a（有一个）。在实现域，复合意味 is-implemented-in-terms-of（根据某物实现出）。\n\n<!-- more-->\n\n#### 复合指某种类型中含其他类型的对象\n\n```cpp\nclass Address { ... };\nclass PhoneNumber { ... };\nclass Person{\npublic:\n\t...\nprivate:\n\tstd::string name;\n\tAddress address; \n\tPhoneNumber voiceNumber;\n\tPhoneNumber faxNumber;\n}\n```\n\nPerson 对象由 string，Address，PhoneNumber，PhoneNumber 构成。\n\n#### has-a or is-implemented-in-terms-of\n\n##### 应用域与实现域\n\n应用域：程序中的对象相当于你所塑造的世界中的某些事物，例如人、汽车等。\n\n实现域：另外一些对象是实现细节上的人工制品，例如：缓冲区、互斥器、查找树等。\n\n在应用域中的对象间，复合表现为 has-a 的关系；当它发生于实现域则表现 is-implemented-in-terms-of 的关系。\n\n#### 区分 is-a 和 is-implemented-in-terms-of\n\n**实现Set**，基于标准库 list **template**。\n\n##### Set template 继承 std::list\n\n```cpp\n// is-a\ntemplate<typename T> // 将list应用与set错误用法\nclass Set::public std::list<T> { ... };\n```\n\n如果 Set 是一种 list，那么对 list 为真的每件事对 Set 也为真，但是 list 可以包含重复元素而 Set 不行。\n\n##### Set 对象根据 list 对象实现出来\n\n```cpp\ntemplate<class T>\nclass Set{\npublic:\n\tbool member(const T& item) const;\n\tvoid insert(const T& item);\n\tvoid remove(const T& item);\n\tstd::size_t size() const;\nprivate:\n    std::list<T> rep;\n}\n```\n\n```cpp\ntemplate<typename T>\nbool Set<T>::member(const T& item) const{\n\treturn std::find(rep.begin(), rep.end(), item) != rep.end());\n}\ntemplate<typename T>\nvoid Set<T>::insert(const T& item){\n    if(!member(item)) rep.push_back(item);\n}\ntemplate<typename T>\nvoid Set<T>::remove(const T& item){\n\ttypename std::list<T>::iterator it = \n        std::find(rep.begin(), rep.end(), item);\n    if(it != rep.end()) rep.erase(it);\n}\ntemplate<typename T>\nstd::size_t Set<T>::size() const{\n    return rep.size();\n}\n```\n\nSet 与 list 的关系为：**根据某物实现出（is-implemented-in-terms-of）**而不是**是一种（is-a）**。\n\n","tags":["has-a"],"categories":["Effective C++"]},{"title":"LeetCode132-分割回文串Ⅱ","url":"/blog/2021/03/08/LeetCode132-分割回文串Ⅱ/","content":"\n#### 题目描述\n\n给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文。\n\n返回符合要求的 **最少分割次数** 。\n\n<!-- more-->\n\n<img src=\"LeetCode132-分割回文串Ⅱ\\132.png\"  />\n\n#### 解决方案\n\n##### 思路\n\n与[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)类似，但是不能使用暴力回溯，会超时。\n\n使用两次动态规划来解决：\n\n1. 得到回文串的二维 `dp` 数组，`dp[i][j]` 表示 `s[i:j]` 是否构成回文子串；\n2. 设置新的一维数组 `f`，`f[i]` 表示以 `i` 结尾的字符串最少需要几次分割。\n\n**具体算法如下**：\n\n我们定义 f[i] 为以下标为 i 的字符作为结尾的最小分割次数，那么最终答案为 f[n - 1]。\n\n不失一般性的考虑第 j 字符的分割方案：\n\n1. 从起点字符到第 j 个字符能形成回文串，那么最小分割次数为 0。此时有 f[j] = 0；\n2. 从起点字符到第 j 个字符不能形成回文串：\n   1. 该字符独立消耗一次分割次数。此时有 f[j] = f[j - 1] + 1；\n   2. 该字符不独立消耗一次分割次数，而是与前面的某个位置 i 形成回文串，[i, j] 作为整体消耗一次分割次数。此时有 f[j] = f[i - 1] + 1；\n\n在 2.2 中满足回文要求的位置 i 可能有很多，我们在所有方案中取一个 min 即可。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minCut(string s) {\n        int n = s.size();\n        \n        vector<vector<bool>> dp(n, vector<bool>(n, false));\n        isPalindrome(s, n, dp);\n        // f[i]表示以i结尾的字符串最少需要几次分割\n        vector<int> f(n);\n        // 初始化，仅一个字符时不需要分割\n        f[0] = 0; \n        for (int j = 1; j < n; ++j) {\n            // 如果从起始位置到j可构成回文串，那么仍不需要分割\n            if (dp[0][j]) {\n                f[j] = 0;\n            }\n            // 否则，以j结尾的字符串可选则分割一次或不分割\n            else {\n                // 分割一次\n                f[j] = f[j - 1] + 1;\n                // 从之前某个字符开始时是回文子串\n                for (int i = 1; i < j; ++i) {\n                    if (dp[i][j]) {\n                        // 以i开始到j的字符串是回文串\n                        // 由i-1处的分割次数加1得到，持续更新最小值\n                        f[j] = min(f[j], f[i - 1] + 1);\n                    }\n                }\n            }\n        }\n\n        return f[n - 1];\n    }\n    vector<vector<bool>>& isPalindrome(string &s, int n, vector<vector<bool>> &dp){\n        for(int i = 0; i < n; ++i)\n            dp[i][i] = true;\n        for(int j = 1; j < n; ++j){\n            for(int i = 0; i < j; ++i){\n                if(s[i] != s[j]) dp[i][j] = false;\n                else{\n                    if(j - i < 3) dp[i][j] = true;\n                    else dp[i][j] = dp[i + 1][j - 1];\n                }\n            }\n        }\n        return dp;\n    }\n};\n```\n\n#### 参考\n\n作者：AC_OIer\n链接：https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/xiang-jie-liang-bian-dong-tai-gui-hua-ji-s5xr/","tags":["动态规划","字符串"],"categories":["LeetCode"]},{"title":"回文子串/子序列相关问题","url":"/blog/2021/03/07/回文相关问题/","content":"\n#### 题目列表\n\n1. [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)\n2. [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n3. [214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)\n4. [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)\n\n<!-- more-->\n\n#### 回文子串\n\n给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n\n<img src=\"回文相关问题\\647.png\" style=\"zoom:80%;\" />\n\n##### 解决方案一：动态规划\n\n```cpp\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int n = s.size();\n        int count = 0;\n        // dp[i][j]表示s[i:j]是否是回文子串\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\n        // 三种情况\n        // 1.自身\n        // 2.如果长度为2，判断两个是否相同\n        // 3.长度大于2，在两个字符相同的条件下，判断dp[i+1][j-1]也是就是左右各缩小一位的字串是否是回文\n        for(int j = 0; j < n; ++j){\n            for(int i = 0; i <= j; ++i){\n                if(i == j) {\n                    count++;\n                    dp[i][j] = true;\n                }\n                else if(j - i == 1 && s[j] == s[i]){\n                    count++;\n                    dp[i][j] = true;\n                }\n                else if(j - i > 1 && s[j] == s[i] && dp[i + 1][j - 1]){\n                    count++;\n                    dp[i][j] = true;\n                }\n            }\n        }\n        return count;\n    }\n};\n```\n\n##### 解决方案二：中心扩展法\n\n```cpp\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int ans = 0;\n        for(int i = 0; i < s.size(); ++i){\n            // 回文长度为奇数\n            int count1 = expandAroundCenter(s, i, i);\n            // 回文长度为偶数\n            int count2 = expandAroundCenter(s, i, i + 1);\n            ans += count1 + count2;\n        }\n        return ans;\n    }\n    // 中心扩展求当前字符起始的最长回文子串\n    int expandAroundCenter(string &s, int left, int right){\n        int count = 0;\n        while(left >= 0 && right < s.size() && s[left] == s[right]){\n            left--;\n            right++;\n            count++;\n        }\n        return count;\n    }\n};\n```\n\n##### 解决方案三：Manacher算法\n\n后续补充\n\n#### 最长回文子串\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n<img src=\"回文相关问题\\5.png\"  />\n\n##### 解决方案一：动态规划\n\n```cpp\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\n        for(int i = 0; i < n; ++i)\n            dp[i][i] = true;\n        int begin = 0;\n        int maxLen = 1;\n        // 以列填充dp数组，因为dp[i][j]由dp[i + 1][j - 1]转移而来\n        for(int j = 1; j < n; ++j){\n            for(int i = 0; i < j; ++i){\n                if(s[i] != s[j]) dp[i][j] = false;\n                else{\n                    // 此时s[i]=s[j]，剩下的字符串长度为0或者1时，都是回文字符串\n                    // 即(j - 1) - (i + 1)  + 1 < 2 => j - i < 3\n                    if(j - i < 3) dp[i][j] = true;\n                    else{\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n                if(dp[i][j] && j - i + 1 > maxLen){\n                        begin = i;\n                        maxLen = j - i + 1;\n                }\n            }\n        }\n        return s.substr(begin, maxLen);\n    }\n};\n```\n\n另一种动态规划的写法，跟**回文子串**类似，能稍微快些：\n\n```cpp\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        int maxLen = 1;\n        int begin = 0;\n        // dp[i][j]表示s[i:j]是否是回文子串\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\n        // 三种情况\n        // 1.自身\n        // 2.如果长度为2，判断两个是否相同\n        // 3.长度大于2，在两个字符相同的条件下，判断dp[i+1][j-1]也是就是左右各缩小一位的字串是否是回文\n        for(int j = 0; j < n; ++j){\n            for(int i = 0; i <= j; ++i){\n                if(i == j) {\n                    dp[i][j] = true;\n                }\n                else if(j - i == 1 && s[j] == s[i]){\n                    dp[i][j] = true;\n                }\n                else if(j - i > 1 && s[j] == s[i] && dp[i + 1][j - 1]){\n                    dp[i][j] = true;\n                }\n                if(dp[i][j] && j - i + 1 > maxLen){\n                    maxLen = j - i + 1;\n                    begin = i;\n                }\n            }\n        }\n        return s.substr(begin, maxLen);\n    }\n};\n```\n\n##### 解决方案二：中心扩展法\n\n```cpp\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int begin = 0;\n        int maxLen = 1;\n        for(int i = 0; i < s.size(); ++i){\n            // 回文串为奇数\n            int len1 = expandAroundCenter(s, i, i);\n            // 回文串为偶数\n            int len2 = expandAroundCenter(s, i, i + 1);\n            int curLen = max(len1, len2);\n            if(curLen > maxLen){\n                maxLen = curLen;\n                // 自己画图模拟一下\n                begin = i - (maxLen - 1) / 2;\n            }\n\n        }\n        return s.substr(begin, maxLen);\n    }\n    int expandAroundCenter(string &s, int left, int right){\n        while(left >= 0 && right < s.size() && s[left] == s[right]){\n            left--;\n            right++;\n        }\n        // 真正回文串长度需要减去两边\n        return right - left - 1;\n    }\n};\n```\n\n#### 最短回文串\n\n给定一个字符串 ***s***，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。\n\n<img src=\"回文相关问题\\214.png\"  />\n\n本题其实是找包括  `s` 起始位置的最长回文子串，但是只有在 $O(n)$ 的复杂度情况下才能过，所以不能用 $O(n^2)$ 的动态规划或者中心扩展法，只能用Manacher算法和KMP匹配算法。\n\n##### 解决方案：Manacher算法\n\n```cpp\nclass Solution {\npublic:\n    string shortestPalindrome(string s) {\n        if(s.empty()) return \"\";\n        int pos = longestPalindrome(s);\n        cout << pos;\n        string helper = s.substr(pos, s.size() - pos);\n        reverse(helper.begin(), helper.end());\n        s = helper + s;\n        return s;\n    }\n    int longestPalindrome(string &s) {\n        string buf;\n        buf = '#';\n        int mirror;\n        int center = 1;\n        int max_right = 1;\n        int max_pos;\n        int l, r;     \n        for(auto &ch : s){\n            buf += ch;\n            buf += '#';\n        }\n        int n = buf.size();\n        vector<int> p(n, 0);\n        for(int i = 1; i != n; ++i){\n            mirror = 2 * center - i;\n            p[i] = min(p[mirror], max_right - i);\n            l = i - p[i] - 1;\n            r = i + p[i] + 1;\n            while(l >= 0 && r < n){\n                if(buf[l] == buf[r]){\n                    --l;\n                    ++r;\n                    ++p[i];\n                }\n                else{\n                    break;\n                }\n            }\n            if(i - p[i] <= 1){\n                max_pos = i + p[i];\n            }            \n            if(i + p[i] >= max_right){\n                max_right = i + p[i];\n                center = i;\n            }\n            // cout << p[i] << \" \";\n        }\n        return max_pos / 2;\n    }\n};\n```\n\n#### 最长回文子序列\n\n给定一个字符串 `s` ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 `s` 的最大长度为 `1000` 。\n\n<img src=\"回文相关问题\\516.png\"  />\n\n##### 解决方案：动态规划\n\n<img src=\"回文相关问题\\516-helper.png\"  />\n\n```cpp\nclass Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        int n = s.length();\n        // dp[i][j]表示从i到j的最长回文子序列\n        vector<vector<int>> dp(n, vector<int>(n,0));\n        for(int i = 0; i < n; i++)\n            dp[i][i] = 1;\n        // 从右下角进行左斜上遍历\n        for(int i = n - 1; i >= 0; i--){\n            for(int j = i + 1; j < n; j++){\n                // 如果相等，缩小区间的最长回文子序列长度加上两个边界\n                if(s[i] == s[j])\n                    dp[i][j] = dp[i+1][j-1] + 2;\n                // 否则，缩小左区间或缩小右区间的最长回文子序列长度中的较大值得到\n                else\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n        return dp[0][n-1];\n    }\n};\n```\n\n","tags":["动态规划","字符串","中心扩展法","Manacher算法"],"categories":["LeetCode"]},{"title":"条款25：考虑写出一个不抛异常的swap函数","url":"/blog/2021/03/05/考虑写出一个不抛异常的swap函数/","content":"\n#### 前言\n\n缺省情况下 `swap` 动作由标准库提供的 `swap` 算法实现，如下：\n\n```cpp\nnamespace std{\n\ttemplate<typename T>\n\tvoid swap(T &a, T &b){\n\t\tT temp(a);\n\t\ta = b;\n\t\tb = temp;\n\t}\n}\n```\n\n只要 T 支持拷贝运算（拷贝构造函数和拷贝赋值运算符）就可使用，但是经历了三次复制，对于某些类型而言，这样的复制操作并无必要，那么应该如何做？\n\n<!-- more-->\n\n#### pimpl(pointer to implement)\n\n这种类型主要就是**以指针指向一个对象，内含真正数据**，如下：\n\n```cpp\nclass WidgetImpl{\npublic:\n\t...\nprivate:\n\tint a, b, c;\n\tstd::vector<double> v;\n\t...\n};\nclass Widget{ // 这个class使用pimpl手法\npublic:\n    Widget(const Widget& rhs);\n    Widget& operator=(const Widget& rhs){\n\t\t...\n        *pImpl = *(rhs.pImpl);\n        ...\n    }\n    ...\nprivete:\n    WidgetImpl *pImpl; // 所指对象内含Widget数据\n};\n```\n\n##### 为类特化std::swap\n\n我们希望告诉 `std::swap`：当 `Widget`被置换时真正该做的是置换其内部的 `pImpl` 指针。一个实现的思路是将 `std::swap` 针对 `Widget` 特例化，同时为了能够访问 `Widget` 的 `private`，令 `Widget` 声明一个 `swap` 的 `public` 成员函数做真正的置换操作，再将 `std::swap` 特例化：\n\n```cpp\nclass Widget{\npublic:\n\t...\n\tvoid swap(Widget &other){\n\t\tusing std::swap;\n\t\tswap(pImpl, other.pImpl);\n\t}\n\t...\n};\nnamespace std{ // 一般不能被改变std中任何东西，但是可以进行特例化\n\ttemplate <> // 全特化\n\tvoid swap<Widget>(Widget &a, Widget &b){\n\t\ta.swap(b); // 调用Widget的成员函数\n\t}\n}\n```\n\n##### 假设两个类都是类模板\n\n```cpp\ntemplate <typename T>\nclass WidgetImpl { ... };\ntemplate <typename T>\nclass Widget { ... };\n```\n\n此时再去特化 `std::swap`：\n\n```cpp\nnamespace std{\n\ttemplate<typename T>\n\tvoid swap<Widget<T>>(Widget<T> &a, Widget<T> &b){\n\t\ta.swap(b);\n\t}\n}\n```\n\n以上做法是**错误的**，因为我们企图**偏特化**一个函数模板，这是不允许的，**因为有函数重载的概念，C++ 根据参数的类型来判断重载哪一个函数，如果还进行偏特化，这就与重载相冲突**。但是我们可以对一个函数模板进行重载，同时需要注意不能在 std 中重载，因为 C++ 标准禁止添加新的 `template` 到 std 中（包括 `class` 或 `function` 等任何其他东西）：\n\n```cpp\nnamespace WidgetStuff{\n\t... // 模板化的WidgetImpl等\n\ttemplate <typename T> // 同前，含swap成员函数\n\tclass Widget { ... };\n\t...\n\ttemplate <typename T>\n\tvoid swap(Widget<T> &a, Widget<T> &b){ // 非成员函数且不属于std\n\t\ta.swap(b);\n\t}\n}\n```\n\n此时如果准备置换两个对象，C++ 名称查找法则会找到 `WidgetStuff` 内的 `Widget` 的专属版本。\n\n上述方法对**类**和**类模板**都适用，但是为了让你的**类专属版**的 `swap` 在更多的语境下调用，你需要同时在该 `class` 所在命名空间内写一个非成员函数版本和一个 `std::swap` 特化版本。\n\n##### 更多语境下使用类专属的swap\n\n```cpp\ntemplate <typename T>\nvoid doSomething(T &obj1, T &obj2){\n\tusing std::swap; // 令std::swap在此函数内可用\n\t...\n\tswap(obj1, obj2); // 为T型对象调用最佳的swap版本\n}\n```\n\n此时，C++ 的名称查找法则确保将找到 global 作用域及 T 所在命名空间内的任何 T 专属的 `swap`，具体顺序如下：\n\n1. 编译器使用**实参取决之查找规则**找出 `WidgetStuff` 内的 `swap`，如果没有，转下；\n2. 使用 `std` 中对于 T 的特例化  `swap`，如果没有，转下；\n3.  使用 `std` 中一般化的 `template` 版本。\n\n**不能使用** `std::swap(obj1, obj2)`，这会使**编译器只认 `std` 内的 `swap`**。\n\n##### 成员版swap绝不可抛出异常\n\n当写下一个自定版本的 `swap`，往往提供的不只是高效率的置换对象值的办法，而且不抛出异常。因为高效率的 `swap` 几乎总是基于对内置类型的操作，而内置类型上的操作绝不会抛出异常。\n\n##### 小结\n\n1. 如果 `swap` 的缺省版本对类或者类模板提供可接受的效率，那么不需要额外做任何事。\n2. 如果效率不足，意味着你的类或者模板使用了 pimpl 手法，试着做以下事情：\n   1. 提供一个成员函数 `swap`，让它高效置换你的类型的两个对象值且不抛出异常；\n   2. 在你的类或模板所在的命名空间提供一个非成员函数调用上述成员函数 `swap`；\n   3. 如果你正在编写一个类而**非**类模板，特化 `std::swap`，并令其调用成员函数 `swap`，并且调用前使用 `using` 声明式。\n\n#### 总结\n\n1. 当 `std::swap` 对你的类型效率不高时，提供一个 `swap` 成员函数，并确定这个函数不抛出异常。\n2. 如果你提供一个成员函数 `swap`，也应提供一个非成员函数调用前者，对于类，也要特化 `std::swap`。\n3. 调用 `swap` 时应针对 `std::swap` 使用 `using ` 声明式，然后调用 `swap` 并且不带任何**命名空间资格修饰**。\n4. 为“用户定义类型”进行 std **template** 全特化是好的，但不要尝试在 std 内加入对 std 而言全新的东西。\n\n#### 参考\n\n《Effective C++》条款 25：考虑写出一个不抛异常的 swap 函数\n\nhttps://blog.csdn.net/qq_35976351/article/details/82822285","tags":["swap"],"categories":["Effective C++"]},{"title":"一些小tips","url":"/blog/2021/03/03/一些小tips/","content":"\n有关做题时的一些小知识点，持续记录。\n\n<!-- more-->\n\n##### 位运算 $i\\&(i-1)$ \n\n作用：将 $i$ 的二进制表示中的最低位的 1 改为 0。\n\n使用场景：计算二进制数中 1 的个数。\n\n例题：[338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)\n\n##### $lowbit(x)$\n\n```cpp\nint lowbit(x){\n\treturn x & -x;\n}\n```\n\n作用：$x$ 的二进制表示中最低位的 1 所对应的值。\n\n例如，6 的二进制为 110，则 $lowbit(6)$ 为 $110\\&010=010$，即 2。\n\n使用场景：树状数组。\n\n例题：[315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)\n\n ##### 位掩码\n\n###### 子集\n\n对于一个长度位 $n$ 的数组求其所有的子集，则一共有 $2^n$ 种可能，也就是 $1<<n$。使用一个长度为 $n$ 的二进制数表示数组中每一个数**是否出现**，出现为 1，否则为 0。\n\n例如：数组 [1,2] 对应长度为 2 的二进制数，一共有四种可能：\n\n1. 00 表示两个都不取，为 []；\n2. 01 表示只取第一个，为 [1]；\n3. 10 表示只取第二个，为 [2]；\n4. 11 表示全部都取，为 [1,2]。\n\n以上，就得到的数组的所有子集。\n\n例题：[78. 子集](https://leetcode-cn.com/problems/subsets/)\n\n###### 状态压缩\n\n详见：[1178. 猜字谜](https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/)\n\n##### 辗转相除法\n\n作用：求取公因数。\n\n```cpp\nint gcd(int a, int b){\n\tif(a < b) swap(a, b);\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n```\n\n例题：[365. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)\n\n##### 快速幂运算\n\n作用：求 $x^n$。\n\n```cpp\nint pow(int x, int n){\n\tint ret = 1;\n\twhile(n){\n\t\tif((n & 1) == 1)\n\t\t\tret *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n    return n > 0 ? ret : 1 / ret;\n}\n```\n\n例题：[剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)","tags":["位运算","数学"],"categories":["LeetCode"]},{"title":"条款03：尽可能使用const","url":"/blog/2021/03/01/尽可能使用const/","content":"\n#### 前言\n\n`const` 可以在  `class` 外部修饰 `global` 或 `namespace` 作用域中的常量，或修饰文件、函数、或**区域作用块中被声明为 `static` 的对象**；也可以修饰 `class` 内部的静态或非静态成员变量。对于指针，可以指出指针自身、指针所指物，或两者都（或都不）是 `const`。\n\n<!-- more-->\n\n#### 指针与const\n\n```cpp\nchar s[] = \"hi\";\nchar *p = s; // non_const pointer, non_const data\nconst char *p = s; // non_const pointer, const data\nchar* const p = s; // const pointer, non_const data\nconst char* const p = s; // const_pointer, const_data\n```\n\n* **`const` 出现在 * 左侧，表示被指物为常量；如果出现在 * 右侧，表示指针自身为常量**。\n\n* 如果被指物为常量，则 `const char*` 或 `char const*` 都一样。\n\n#### 迭代器与const\n\n迭代器类似于 `T*` 指针：\n\n* 迭代器为 `const`：`T* const`。\n\n```cpp\nstd::vector<int> vec;\nconst std::vector<int>::iterator iter = vec.begin(); // T* const\n*iter = 10; // 正确，所指变量可变\niter++; // 错误，迭代器不可变\n```\n\n* 迭代器所指对象为 `const`：`const T*` ，且需要使用 `const_iterator`。\n\n```cpp\nstd::vector<int> vec;\n// auto cIter = vec.cbegin();\nstd::vector<int>::const_iterator cIter = vec.begin(); // T* const\n*cIter = 10; // 错误，所指变量为常量\ncIter++; // 正确，迭代器可变\n```\n\n#### 令函数返回一个常量值防止误操作而造成的意外\n\n```cpp\nclass Rational { ... };\nconst Rational operator* (const Rational &lhs, const Rational &rhs);\n/***************************/\nRational a, b, c;\n(a * b) = c; // 错误，防止无意义的赋值\n```\n\n#### const成员函数\n\n`const` 用于成员函数，表示该成员函数可作用于 `const` 对象，其理由有二：\n\n1. 使 `class` 接口容易理解，告诉哪个函数可以改变对象内容哪个不行；\n2. 使操作 `const` 对象成为可能。\n\n```cpp\nclass TextBlock{\npublic:\n    TextBlock(string &s): text(s) {}\n    const char& operator[](size_t position) const{\n        return text[position];\n    }\n    char& operator[](size_t position){\n        return text[position];\n    }\nprivate:\n    string text;\n};\n/***************************/\nint main() {\n    string s = \"hello\";\n    TextBlock tb(s);\n    cout << tb[0]; // OK，读一个non_const TextBlock\n    tb[0] = 'x'; // OK，写一个non_const TextBlock\n    const TextBlock ctb(s);\n    cout << ctb[0]; // OK，读一个const TextBlock\n    ctb[0] = 'x'; // Error，写一个const TextBlock\n    return 0;\n}\n```\n\n##### bitwise constness\n\n成员函数不能更改对象的任何成员变量（除了 `static`），编译器只需找到成员的赋值动作即可。\n\n然而一个更改了”指针所指物“的成员函数虽然不能算是 `const`，但如果只有指针（而非其所指物）属于对象，那么称此函数为 `bitwise constness` 不会引发编译器异议。 \n\n```cpp\nclass CTextBlock{\npublic:\n    CTextBlock(char *s): pText(s) {}\n    char& operator[](size_t position) const{ // bitwise const声明，但不恰当\n        return pText[position];\t// 并不更改pText，所以是bitwise const\n    }\nprivate:\n    char* pText;\n};\n/***************************/\nint main(){\n    char s[] = \"hello\";\n    const CTextBlock cctb(s); // 声明一个常量对象\n    char *pc = &cctb[0]; // 调用const operatorp[]取得一个指针，指向cctb数据\n    *pc = 'J'; // cctb现在有了\"Jello\"的内容，这样是不允许的\n    return 0;\n}\n```\n\n##### logical constness\n\n一个 `const` 成员函数可以修改它所处理的对象内的某些 `bits`，但只有在**客户端侦测不出的情况下**才得如此。\n\n```cpp\nclass CTextBlock{\npublic:\n    ...\n    size_t length() const;\nprivate:\n    char* pText;\n    size_t textLength; // 最近一次计算的文本区块长度\n    bool lengthIsValid; // 目前的长度是否有效\n};\nsize_t CTextBlock::length() const{\n    if(!lengthIsValid){\n        // 错误！在const成员函数内不能赋值\n        textLength = strlen(pText);\n        lengthIsValid = true;\n    }\n}\n```\n\n对于 `logical constness`，编译器不允许这种做法，此时需要使用一个与 `const` 相关的摆动场：**`mutable`（可变的）**。`mutable` 释放掉 `non_static` 成员变量的 `bitwise constness` 约束。\n\n```cpp\nclass CTextBlock{\npublic:\n    ...\n    size_t length() const;\nprivate:\n    char* pText;\n    // 这些成员变量可能总是会被更改，即使在const函数内\n    mutable size_t textLength; \n    mutable bool lengthIsValid; \n};\nsize_t CTextBlock::length() const{\n    if(!lengthIsValid){\n        // 赋值正确\n        textLength = strlen(pText);\n        lengthIsValid = true;\n    }\n}\n```\n\n#### 在const和non-const成员函数中避免重复\n\n如果 `const` 和 `non_const` 成员函数有着等价的实现时，令 `non-const` 版本调用 `const` 版本可避免代码重复。\n\n```cpp\n//\n// Created by Zxy on 2021/3/1.\n//\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass TextBlock{\npublic:\n    TextBlock(string &s): text(s) {}\n    const char& operator[](size_t position) const{\n        return text[position];\n    }\n    char& operator[](size_t position){\n        // 第一次为*this添加const，第二次从const operator[]的返回值移除const。\n        return const_cast<char&>(static_cast<const TextBlock&>(*this)[position]);\n    }\nprivate:\n    string text;\n};\nint main() {\n    string s = \"hello\";\n    TextBlock tb(s);\n    tb[0] = 'H';\n    cout << tb[0]; // 正确，对象为变量\n    const TextBlock ctb(s);\n    cout << ctb[1];\n    ctb[1] = 'E'; // 错误，对象为常量\n    return 0;\n}\n```\n\n#### 总结\n\n* 将某些东西声明为 `const` 可帮助编译器侦测出错误用法；\n* 编译器强制实施 `bitwise constness`，但编程时应注重**概念上的常量性**；\n* 如果 `const` 和 `non_const` 成员函数有着等价的实现时，令 `non-const` 版本调用 `const` 版本可避免代码重复。\n\n除此之外：\n\n* `const` 对象只能调用 `const` 成员函数；\n* 非 `const` 对象既可以调用 `const` 成员函数，又可以调用非 `const` 成员函数。\n\n#### 参考\n\n《Effective C++》条款 03：尽可能使用 const","tags":["const"],"categories":["Effective C++"]},{"title":"LeetCode1178-猜字谜","url":"/blog/2021/02/26/LeetCode1178-猜字谜/","content":"\n#### 题目描述\n\n外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。\n\n字谜的迷面 `puzzle` 按字符串形式给出，如果一个单词 `word` 符合下面两个条件，那么它就可以算作谜底：\n\n* 单词 `word` 中包含谜面 `puzzle` 的第一个字母。\n* 单词 `word` 中的每一个字母都可以在谜面 `puzzle` 中找到。\n  例如，如果字谜的谜面是 \"abcdefg\"，那么可以作为谜底的单词有 \"faced\", \"cabbage\", 和 \"baggage\"；而 \"beefed\"（不含字母 \"a\"）以及 \"based\"（其中的 \"s\" 没有出现在谜面中）。\n\n返回一个答案数组 `answer`，数组中的每个元素 `answer[i]` 是在给出的单词列表 `words` 中可以作为字谜迷面 `puzzles[i]` 所对应的谜底的单词数目。\n\n<!-- more-->\n\n<img src=\"LeetCode1178-猜字谜\\1178.png\"  />\n\n#### 解决方案\n\n##### 思路\n\n从题目我们可以得到两个信息（省略了在 `i` 处）：\n\n* `puzzle` 的第一个字母在 `word` 中；\n* `puzzle` 中包括 `word` 中的任一字母。\n\n如果对于每个 `puzzle` 都去遍历每个 `word`，那么复杂度会很高，因为每个 `word` 都含有多个字母。**除此之外，`puzzle` 的长度都为 7**。\n\n###### 状态压缩\n\n如果我们用一个**26位**长的二进制数来表示对应字母是否存在（存在为 1，否则为 0），再用**哈希表**存储每种二进制数出现的次数，可以大大降低查询 `words` 的时间复杂度，这种方法称为**状态压缩**（换句话说，去重后的 `word` 如果具有相同特征，将对应相同的二进制数）。\n\n###### 算法\n\n1. 统计 `words` 对应二进制数的出现次数（每个二进制数中 1 的个数必须小于等于 7，否则 `puzzle` 不可能将 `word` 完全覆盖）；\n2. 由于 `puzzle` 的长度为 7，且第一个字母必须出现在 `word` 中，所以只需要计算 $2^6$ 种二进制组合，再将 `puzzle[0]` 对应二进制数的位置为 1。如果哈希表中存在此二进制数，说明此二进制数是 `puzzle` 谜底。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\n        // 根据word建立哈希表，映射26个字母\n        // 统计每种状态压缩的出现次数\n        unordered_map<int, int> map;\n        for(auto &s : words){\n            int mask = 0;\n            for(auto &ch : s){\n                mask |= (1 << (ch - 'a'));\n            }\n            // 统计二进制位中1的出现次数\n            if(__builtin_popcount(mask) <= 7){\n                map[mask]++;\n            }\n        }\n        // puzzle的第一个字母在word中\n        // puzzle中包括word中的任一字母\n        vector<int> ans;\n        for(auto &puzzle : puzzles){\n            // 一共有2^6种可能\n            // puzzle的第一个字母对应的位必为1\n            int total = 0;\n            for(int choose = 0; choose < (1 << 6); ++choose){\n                int mask = 0;\n                // puzzle的每个字母\n                for(int i = 0; i < 6; ++i){\n                    // 每个位代表一个字母是否存在\n                    // choose代表二进制的一种组合，使用与操作找到此种组合下存在的每一位\n                    if(choose & (1 << i)){\n                        mask |= (1 << (puzzle[i + 1] - 'a'));\n                    }\n                    // puzzle的第一个字母必须存在于word中\n                    mask |= (1 << (puzzle[0] - 'a'));\n                }\n                if(map.count(mask)){\n                    total += map[mask];\n                }\n            }\n            ans.push_back(total);\n        }\n        return ans;\n    }\n};\n```\n\n#### 参考\n\n官方题解：https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/cai-zi-mi-by-leetcode-solution-345u/\n\n#### 附录\n\n`__builtin_popcount(var)`：统计二进制数中 1 的个数。","tags":["位运算","状态压缩","哈希表"],"categories":["LeetCode"]},{"title":"C++模板与泛型编程（三）","url":"/blog/2021/02/24/C-模板与泛型编程（三）/","content":"\n#### 本次学习要点\n\n1. 重载与模板\n2. 可变参数模板\n3. 模板特例化\n\n<!-- more-->\n\n#### 重载与模板\n\n##### 编写重载模板\n\n在调试中可能用到的一组函数，每个函数都返回一个给定对象的 `string` 表示：\n\n```cpp\n// 打印任何我们不能处理的类型\ntemplate <typename T> string debug_rep(const T &t){\n\tostringstream ret;\n\tret << t;\n\treturn ret.str(); // 返回ret绑定的string的一个副本\n}\n```\n\n再定义一个打印指针的版本：\n\n```cpp\n// 打印指针的值，后跟指针指向的对象\n// 此函数不能用于char*\ntemplate <typename T> string debug_rep(T *p){\n\tostringstream ret;\n\tret << \"pointer: \" << p; // 打印指针本身的值\n\tif(p)\n\t\tret << \" \" << debug_rep(*p); // 打印p指向的值\n\telse\n\t\tret << \" null pointer\"; // 或指出p为空\n\treturn ret.str();\n}\n```\n\n**此函数不能打印字符指针**。\n\n1. 只能匹配第一个版本：\n\n```cpp\nstring s(\"hi\");\ncout << debug_rep(s) << endl;\n```\n\n2. 两个版本都可匹配，而第二个精确匹配，选择第二个：\n\n```cpp\ncout << debug_rep(&s) << endl;\n```\n\n##### 多个可行模板\n\n当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。\n\n##### 非模板和模板重载\n\n对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。\n\n##### 重载模板与类型转换\n\nC 风格字符串指针和字符串常量，考虑调用 `cout << debug_rep(\"hi world!\") << endl`：\n\n```cpp\ndebug_rep(const T&); // T被绑定到char[10]\ndebug_rep(T*); // T被绑定到const char\ndebug_rep(const string&); // 要求从const char*到string的类型转换\n```\n\n##### 缺少声明可能导致程序行为异常\n\n在定义任何函数之前，**需要声明所有重载的函数版本**，否则编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。\n\n#### 可变参数模板\n\n可变参数模板：接受**可变数目**参数的模板函数或模板类。可变数目的参数被称为**参数包**。\n\n参数包有两种：\n\n1. 模板参数包，表示零个或多个模板参数；\n2. 函数参数包，表示零个或多个函数参数。\n\n在一个模板参数列表中，`class...` 或 `typename...` 指出接下来的参数表示零个或多个类型的列表：\n\n```cpp\n// Args是一个模板参数包；rest是一个函数参数包\n// Args表示零个或多个模板类型参数\n// rest表示零个或多个函数参数\ntemplate <typename T, typename... Args>\nvoid foo(const T&t, const Args& ... rest);\n```\n\n编译器从函数的实参推断模板参数类型，对于可变参数模板，编译器同时推断包中参数的数目：\n\n```cpp\nint i = 0; double d = 3.14; string s = \"how now brown cow\";\n// void foo(const int&, const string&, const int&, const double&);\nfoo(i, s, 42, d); // 包中有三个参数\n// void foo(const string&, const int&, const int&, const char[3]&);\nfoo(s, 42, \"hi\"); // 包中有两个参数\n// void foo(const double&, const string&);\nfoo(d, s); // 包中有一个参数\n// void foo(const char[3]&);\nfoo(\"hi\"); // 空包\n```\n\n**sizeof...运算符**\n\n```cpp\ntemplate <typename ... Args> void g(Args ... args){\n\tcout << sizeof...(Args) << endl; // 类型参数的数目\n\tcout << sizeof...(args) << endl; // 函数参数的数目\n}\n```\n\n##### 编写可变参数函数模板\n\n可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身：\n\n```cpp\n// 用来终止递归并打印最后一个元素的函数\n// 此函数必须在可变参数版本的print定义之前声明\ntemplate <typename T>\nostream &print(ostream &os, const T &t){\n\treturn os << t; // 包中最后一个元素之后不打印分隔符\n}\n// 包中除了最后一个元素之外的其他元素都会调用这个版本的print\ntemplate <typename T, typename... Args>\nostream &print(ostream &os, const T &t, const Args&... rest){\n\tos << t << \", \"; // 打印第一个实参\n\treturn print(os, rest...); // 递归调用，打印其他实参\n}\n```\n\n第一个版本的 `print` 负责终止递归并打印最后一个实参，第二个版本的 `print` 是可变参数版本，它打印绑定到 `t` 的实参，并调用自身来打印函数参数包中的剩余值。\n\n对于 `print(cout, i, s, 42)`，递归会执行如下：\n\n<img src=\"C-模板与泛型编程（三）\\调用.png\"  />\n\n对于最后一个调用，两个函数提供同样好的匹配。但是**非可变参数模板**比**可变参数模板**更特例化，因此编译器选择非可变参数模板。\n\n<img src=\"C-模板与泛型编程（三）\\调用warning.png\"  />\n\n##### 包扩展\n\n扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号 `...` 来触发扩展操作。（**此处不是很理解，包扩展不就是可变参数模板吗?**）\n\n###### 理解包扩展\n\n```cpp\n// 在print调用中对每个实参调用debug_req\ntemplate <typename... Args>\nostream &print(ostream &os, const Args&... rest){\n\t// print(os, debug_req(a1), debug_req(a2), ..., debug_req(an))\n\tprint(os, debug_req(rest)...); // print(os, debug_req(rest...))错误，此调用无匹配函数\n}\n```\n\n<img src=\"C-模板与泛型编程（三）\\包扩展.png\"  />\n\n##### 转发参数包\n\n新标准下，我们可以组合使用可变参数模板与 `forward` 机制来编写函数，实现将其实参不变的传递给其他函数。\n\n<img src=\"C-模板与泛型编程（三）\\建议_转发和可变参数模板.png\"  />\n\n\n\n#### 模板特例化\n\n##### 定义函数模板特例化\n\n定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。先前声明版本：\n\n```cpp\ntempalte <typename T> int compare(const T&, const T&)\n```\n\n特例化版本：\n\n```cpp\n// compare的特殊版本，处理字符数组的指针\ntemplate <> // <>表示我们正在实例化一个模板\nint compare(const char* const &p1, const char* const &p2){\n\treturn strcmp(p1, p2);\n}\n```\n\n##### 函数重载与模板实例化\n\n**一个特例化版本的本质上是一个实例，而非函数名的一个重载版本**。\n\n<img src=\"C-模板与泛型编程（三）\\函数重载与模板实例化.png\"  />\n\n<img src=\"C-模板与泛型编程（三）\\普通作用域规则应用于特例化.png\"  />\n\n##### 类模板特例化\n\nP626.\n\n##### 类模板部分特例化\n\n与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。\n\n一个类模板的部分特例化（partial specialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。\n\n<img src=\"C-模板与泛型编程（三）\\类模板部分特例化.png\"  />\n\n标准库 `remove_reference` 模板是通过一系列的特例化版本来完成其功能的：\n\n```\n// 最原始、最通用版本\ntemplate <class T> struct remove_reference{\n\ttypedef T type;\n};\n// 部分特例化版本， 将用于左值引用和右值引用\ntemplate <class T> struct remove_reference<T&>{\n\ttypedef T type;\n};\ntemplate <class T> struct remove_reference<T&&>{\n\ttypedef T type;\n};\n```\n\n使用如下：\n\n```cpp\nint i;\n// decltype(42)为int，使用原始模板\nremove_reference<decltype(42)>::type a;\n// decltype(i)为int&，使用特例化版本一\nremove_reference<decltype(i)>::type b;\n// decltype(std::move(i))为int&&，使用特例化版本二\nremove_reference<decltype(std::move(i))>::type c;\n```\n\n以上三个变量都是 `int` 类型。\n\n##### 特例化成员而不是类\n\n我们可以只特例化成员函数而不是特例化整个模板。\n\n```cpp\ntemplate <typename T> struct Foo{\n\tFoo(const T &t = T()): mem(t){ }\n\tvoid Bar(){ /* ... */}\n\tT mem;\n\t//\n};\ntemplate<> // 特例化\nvoid Foo<int>::Bar(){\n\t// 进行应用于int的特例化处理\n}\n```\n\n实例化 `Foo<int>` 类的一个成员，其他成员由 `Foo` 模板提供：\n\n```cpp\nFoo<string> fs; // Foo<string>::Foo()\nfs.Bar(); // Foo<string>::Bar()\nFoo<int> fi; // Foo<int>::Foo()\nfi.Bar(); // 使用我们特例化版本的Foo<int>::Bar()\n```","categories":["C++"]},{"title":"C++模板与泛型编程（二）——模板实参推断","url":"/blog/2021/02/23/C-模板与泛型编程（二）/","content":"\n#### 本次学习要点\n\n1. 类型转换与模板类型参数\n2. 函数模板显式实参\n3. 尾置返回类型与类型转换\n4. 函数指针和实参推断\n5. 模板实参推断和引用\n6. 理解 `std::move`\n7. 转发\n\n<!-- more-->\n\n从函数实参来确定模板实参的过程称为**模板实参推断**。\n\n#### 类型转换与模板类型参数\n\n编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。顶层 `const`无论在形参还是实参中都会被忽略。\n\n* `const` 转换：可以将一个非 `const` 对象的引用（或指针）传递给一个 `const` 的引用（或指针）形参。\n* 数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。\n\n<img src=\"C-模板与泛型编程（二）\\实参传递给模板类型的函数形参note.png\"  />\n\n##### 使用相同模板参数类型的函数形参\n\n一个模板类型参数可以作为多个函数形参的类型，但是传递给形参的实参类型必须相同：\n\n```cpp\nlong lng;\ncompare(lng, 1024); // 错误，不能实例化compare(long, int)，类型不匹配\n```\n\n如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数：\n\n```cpp\ntemplate <typename A, typename B>\nint flexibleCompare(const A& v1, const B& v2){\n\tif(v1 < v2) return -1;\n\tif(v2 < v1) return 1;\n\treturn 0;\n}\n```\n\n##### 正常类型转换应用于普通函数实参\n\n```cpp\ntemplate <typename T> ostream &print(ostream &os, const T &obj){\n\treturn os << obj;\n}\n```\n\n由于 `os` 类型固定，因此调用 `print` 时，传递给它的实参会正常进行类型转换。\n\n<img src=\"C-模板与泛型编程（二）\\正常类型转换应用于普通函数实参.png\"  />\n\n#### 函数模板显式实参\n\n##### 指定显式模板实参\n\n我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型：\n\n```cpp\n// 编译器无法推断T1，它未出现在函数参数列表中\ntemplate <typename T1, typename T2, typename T3>\nT1 sum(T2, T3);\n```\n\n每次调用前，调用者必须为 `T1` 提供一个**显式模板实参**：\n\n```cpp\nauto val3 = sum<long long>(i, lng); // long long sum(int, long)\n```\n\n**显式模板实参按照由左至右的顺序与对应的模板参数匹配**。\n\n##### 正常类型转换应用于显式指定的实参\n\n对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换：\n\n```cpp\nlong lng;\ncompare(lng, 1024); // 错误：模板类型不匹配\ncompare<long>(lng, 1024); // 正确：实例化compare(long, long)，接受两个const long&;\ncompare<int>(lng, 1024); // 正确：实例化compare(int, int)，lng被转换为int;\n```\n\n#### 尾置返回类型与类型转换\n\n```cpp\n// 尾置返回类型允许我们在参数列表之后声明返回类型\ntemplate <typename It>\nauto fcn(It beg, It end) -> decltype(*beg) // 迭代器解引用返回元素引用\n{\n\t//\n\treturn *beg; // 返回序列中的一个元素的引用\n}\n```\n\n##### 进行类型转换的标准库模板类\n\n如果希望编写一个类似 `fcn` 的函数，但返回一个元素的值而非引用。可以使用标准库的**类型转换**模板，定义在头文件 `type_traits` 中。模板如下表：\n\n<img src=\"C-模板与泛型编程（二）\\标准类型转换模板.png\"  />\n\n上述模板中每个都拥有一个名为 `type` 的 `public` 成员，表示一个类型。\n\n* 如果不可能（不必要）转换模板参数，则 `type` 成员就是模板参数本身。\n\n组合使用 `remove_reference` ，尾置返回类型及 `decltype`，我们可以在函数中返回元素值的拷贝：\n\n```cpp\n// 使用typename表示type是一个类型\ntemplate <typnemae It>\nauto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)::type\n{\n\t// \n\treturn *beg; // 返回序列中一个元素的拷贝\n}\n```\n\n#### 函数指针和实参推断\n\n当我们使用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参：\n\n```cpp\ntemplate <typename T> int compare(const T&, const T&);\n// pf1指向实例int compare(const int&, const int&)\nint (*pf1)(const int&, const int&) = compare;\n```\n\n如果不能从函数指针类型确定函数模板，则产生错误：\n\n```cpp\n// func的重载版本，每个版本接受一个不同的函数指针类型\nvoid func(int(*)(const string&, const string&));\nvoid func(int(*)(const int&, const int&));\nfunc(compare); // 错误，使用compare的哪个实例？\n```\n\n可以使用显式模板实参来消除 `func` 调用的歧义：\n\n```cpp\nfunc(compare<int>); // 传递compare(const int&, const int&)\n```\n\n#### 模板实参推断和引用\n\n##### 从左值引用函数参数推断类型\n\n当一个函数参数是模板类型参数的一个普通(左值)引用时（即，形如T&）。绑定规则告诉我们：\n\n* 只能传递给它一个左值（如，一个变量或一个返回引用类型的表达式）。\n\n实参可以是 `const` 类型，也可以不是。如果实参是 `const` 的，则 `T` 将被推断为 `const` 类型：\n\n```cpp\ntemplate <typename T> void f1(T&); // 实参必须是一个左值\nf1(i); // i是一个int，模板参数类型T是int\nf1(ci); // ci是一个const int，模板参数T是const int\nf1(5); // 错误：5是右值\n```\n\n如果一个函数参数的类型是 `const T&`，正常的绑定规则告诉我们：\n\n* 可以传递给它任何类型的实参一个对象（ `const` 或非 `const` ）、一个临时对象或是一个字面常量值。\n\n当函数参数本身是 `const` 时，其已经是**函数参数类型**的一部分，因此，**它不会也是模板参数类型的一部分**：\n\n```cpp\ntemplate <typename T> void f2(const T&); // 可以接受一个右值\n// f2中的参数是const &，实参中的const是无关的\n// 在每个调用中，f2的函数实参都被推断为const int&\nf2(i); // i是一个int，模板参数类型T是int\nf2(ci); // ci是一个const int，但模板参数T是int\nf2(5); // 一个const &参数可以绑定到一个右值，T是int\n```\n\n##### 从右值引用函数参数推断类型\n\n```cpp\ntemplate <typename T> void f3(T&&);\nf3(42); // 实参是一个int类型的右值，模板参数T是int\n```\n\n##### 引用折叠和右值引用参数\n\n* X& &、X& && 和 X&& & 都折叠成类型 X&\n* 类型 X&& && 折叠成 X&&\n\n<img src=\"C-模板与泛型编程（二）\\引用折叠.png\"  />\n\n这两个规则导致了两个重要结果：\n\n1. 函数参数指向模板类型参数的右值引用，则它可以被绑定到一个左值；\n2. 如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个普通左值引用参数。\n\n<img src=\"C-模板与泛型编程（二）\\右值引用参数.png\" style=\"zoom:80%;\" />\n\n##### 编写接受右值引用参数的函数模板\n\n```cpp\ntemplate <typename T> void f(T&&); // 绑定到非const右值\ntemplate <typename T> void f(const T&); // 左值和const右值\n```\n\n#### 理解std::move\n\n##### std::move是如何定义的\n\n标准库定义如下：\n\n```cpp\ntemplate <typename T>\ntypename remove_reference<T>::type&& move(T&& t){\n\treturn static_cast<typename remove_reference<T>::type&&>(t);\n}\n```\n\n通过引用折叠，我们既可以传递给 `move` 一个左值，也可以传递给它一个右值：\n\n```cpp\nstring s1(\"hi!\"), s2;\ns2 = std::move(string(\"bye!\")); // 正确，从一个右值移动数据\ns2 = std::move(s1); // 正确，但在赋值之后，s1的值是不确定的\n```\n\n##### std::move是如何工作的\n\n在 `std::move(string(\"bye!\"))` 中：\n\n* 推断出的 `T` 的类型为 `string`。\n* 因此，`remove reference` 用 `string` 进行实例化。\n* `remove_reference<string> `的 `type` 成员是 `string`。\n* `move` 的返回类型是 `string&&`。\n* `move` 的函数参数 `t` 的类型为 `string&&`。\n\n这个调用实例化 `move<string>`，即函数：`string&& move(string &&t)`。无需类型转换。\n\n第二个赋值，传递给 `move` 的实参是一个左值：\n\n* 推断出的 `T` 的类型为 `string&`（ `string` 的引用，而非普通 `string`)。\n* 因此，`remove_reference` 用 `string&` 进行实例化。\n* `remove_reference<string&>` 的 `type` 成员是 `string`。\n* `move`的返回类型仍是 `string&`。\n* `move` 的函数参数 `t` 实例化为 `string& &&`，会折叠为 `string&`。\n\n这个调用实例化 `move<string&>`，即函数：`string&& move(string &t)`。\n\n**将一个右值引用绑定到一个左值**。这个实例的函数体返回 `static_cast<string&&>(t)`，在此情况下，`cast` 将 `t` 的类型 `string&` 转换为 `string&&`。\n\n##### 从一个左值static_cast到一个右值引用时允许的\n\n 可以用 `static_cast` 显式的将一个左值转换为一个右值引用。\n\n#### 转发\n\n```cpp\ntemplate <typename F, typename T1, typename T2>\nvoid flip1(F f, T1 t1, T2 t2){\n\tf(t2, t1);\n}\nvoid f(int v1, int &v2){\n    cout << v1 << \" \" << ++v2 << endl;\n}\n```\n\n上述代码中，`f` 改变了绑定到 `v2` 的实参的值，但是通过 `flip1` 调用 `f`，`f` 所作的改变就不会影响实参：\n\n```cpp\nf(42, i); // f改变了实参i\nflip1(f, j, 42); // 通过flip1调用f不会改变j\n```\n\n##### 定义能保持类型信息的函数参数\n\n```cpp\ntemplate <typename F, typename T1, typename T2>\nvoid flip2(F f, T1 &&t1, T2 &&t2){\n\tf(t2, t1);\n}\n```\n\n<img src=\"C-模板与泛型编程（二）\\转发.png\"  />\n\n当 `flip2` 调用 `f` 时，`f` 中的引用参数 `v2` 被绑定到 `t1`，也就是绑定到 `j`，当 `f` 递增 `v2` 时，它同时改变了 `j` 的值。\n\n上述 `flip2` 不能用于接受右值引用参数的函数：\n\n```cpp\nvoid g(int &&i, int &j){\n\tcout << i << \" \" << j << endl;\n}\n```\n\n通过使用 `flip2` 调用 `g`，则参数 `t2` 将被传递给 `g` 的右值引用参数。即使我们传递一个右值给 `flip2`：\n\n```cpp\nflip2(g, i, 42); // 函数参数为左值表达式，不能从一个左值实例化int&&\n```\n\n##### 在调用中使用std::forward保持类型信息\n\n```cpp\n// 定义在头文件utility中，forward必须通过显式模板来调用\ntemplate <typename Type> intermediary(Type &&arg){\n\tfinalFcn(std::forward<Type>(arg));\n\t// ...\n}\n```\n\n<img src=\"C-模板与泛型编程（二）\\forward.png\"  />\n\n重写翻转函数：\n\n```cpp\ntemplate <typename F, typename T1, typename T2>\nvoid flip(F f, T1 &&t1, T2 &&t2){\n\tf(std::forward<T2>(t2), std::forward<T1>(t1));\n}\n```\n\n此时调用 `flip(g, i, 42)`，`i` 将以 `int&` 类型传递给 `g`，`42` 将以 `int&&` 类型传递给 `g`。","tags":["泛型"],"categories":["C++"]},{"title":"LeetCode1052-爱生气的书店老板","url":"/blog/2021/02/23/LeetCode1052-爱生气的书店老板/","content":"\n#### 题目描述\n\n今天，书店老板有一家店打算试营业 `customers.length` 分钟。每分钟都有一些顾客（`customers[i]`）会进入书店，所有这些顾客都会在那一分钟结束后离开。\n\n在某些时候，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。\n\n书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 `X` 分钟不生气，但却只能使用一次。\n\n请你返回这一天营业下来，最多有多少客户能够感到满意的数量。\n\n<!-- more-->\n\n<img src=\"LeetCode1052-爱生气的书店老板\\1052.png\"  />\n\n#### 解决方案\n\n##### 思路\n\n* 先求得原始条件下可获得的满意数量之和 `sum`；\n* 维护一个长度为 `X` 的窗口，从 `customers` 起始位置开始滑动。先得到当前窗口原始条件下的满意总和，使用 `sum` 减去此和，再加上当前窗口顾客全部满意数的和；\n* 更新最大满意数量 `ans = max(ans, sum)`。\n\n##### 实现\n\n```cpp\nclass Solution {\npublic:\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\n        int sum = 0;\n        \n        int ans = 0;\n        for(int i = 0; i < customers.size(); ++i){\n            if(grumpy[i] == 0){\n                sum += customers[i];\n            }\n        }\n        int sum_copy = sum;\n        // cout << sum << \" \";\n        int left = 0, right = left + X;\n        while(right < customers.size() + 1){\n            int subSum = 0;\n            for(int j = left; j < right; ++j){\n                if(grumpy[j] == 0)\n                    subSum += customers[j];\n            }\n            // cout << subSum << \" \";\n            sum -= subSum;\n            // cout << sum << \" \";\n            sum += accumulate(customers.begin() + left, customers.begin() + right, 0);\n            // cout << sum << \" \";\n            ans = max(sum, ans);\n            sum = sum_copy;\n            left++;\n            right++;\n        }\n        return ans;\n    }\n};\n```\n\n这个算法的时间复杂度很高，为 $O((2X)^n)$。\n\n#### 更进一步\n\n##### 思路\n\n在求得原始条件下可获得的满意数量之和 `sum`，同时将不生气时顾客的满意值置为 0 后，此时题目转换为：在修改后的 `customers` 数组中，长度为 `X` 的子数组的最大的和为多少？找的这个最大值再加上 `sum` 即可。时间复杂度为 $O(n)$。\n\n##### 实现\n\n```cpp\nclass Solution {\npublic:\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\n        if(X == customers.size()) return accumulate(customers.begin(), customers.end(), 0);\n        int sum = 0;\n        for(int i = 0; i < customers.size(); ++i){\n            if(grumpy[i] == 0){\n                sum += customers[i];\n                customers[i] = 0;\n            }\n        }\n        int subSum = 0;\n        for(int i = 0; i < X; ++i)\n            subSum += customers[i];\n        int maxVal = subSum;\n        for(int i = X; i < customers.size(); ++i){\n            subSum -= customers[i - X];\n            subSum += customers[i];\n            maxVal = max(maxVal, subSum);\n        }\n        return sum + maxVal;\n    }\n};\n```\n\n#### 参考\n\n评论区：https://leetcode-cn.com/problems/grumpy-bookstore-owner/comments/\n\n","tags":["滑动窗口"],"categories":["LeetCode"]},{"title":"C++模板与泛型编程（一）——定义模板","url":"/blog/2021/02/22/C-模板与泛型编程（一）/","content":"\n#### 本次学习要点\n\n1. 函数模板\n2. 类模板\n3. 模板参数\n4. 成员模板\n5. 控制实例化\n6. 效率与灵活性\n\n<!-- more-->\n\n#### 函数模板\n\n```cpp\ntemplate <typename T>\nint compare(const T &v1, const T &v2){\n\tif(v1 < v2) return -1;\n\tif(v2 < v1) return 1;\n\treturn 0;\n}\n```\n\n在模板定义中，模板参数列表不能为空。\n\n##### 实例化函数模板\n\n编译器用推断处的模板参数来进行**实例化**。\n\n```cpp\n// 实例化出int compare(const int&, const int&)\ncout << compare(1, 0) << endl; // T为int\n```\n\n##### 模板类型参数\n\n类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。\n\n类型参数前必须使用关键字 `class` 或 `typename`，两个关键字含义相同，可以互相使用：\n\n```cpp\ntemplate<typename T, class U> calc(const T&, const U&);\n```\n\n##### 非类型模板参数\n\n一个非类型参数表示一个值而非一个类型。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。\n\n```cpp\n// 第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度\ntemplate<unsigned N, unsigned M>\nint compare(const char (&p1)[N], const char (&p2)[M]){\n\treturn strcmp(p1, p2);\n}\n```\n\n当调用此函数 `compare(\"hi\", \"mom\")` 时，编译器使用字面常量的大小来代替 N 和 M，从而实例化模板：\n\n```cpp\n// 编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符\nint compare(const char (&p1)[3], const char (&p2)[4])\n```\n\n**非类型模板参数的模板实参必须是常量表达式**。\n\n##### inline和constexpr的函数模板\n\n注意位置。\n\n```cpp\ntemplate <typename T> inline T min(const T&, const T&);\n```\n\n##### 模板编译\n\n模板的头文件通常既包括声明也包括定义。\n\n* 函数模板和类模板成员函数的定义通常放在头文件中。\n\n<img src=\"C-模板与泛型编程（一）\\模板和头文件.png\"  />\n\n##### 大多数编译错误在实例化期间报告\n\n<img src=\"C-模板与泛型编程（一）\\调用者责任.png\"  />\n\n#### 类模板\n\n##### 定义类模板\n\n```cpp\n// Blob之前只针对string\ntemplate <typename T> class Blob{\n\t//\n};\n```\n\n##### 实例化类模板\n\n当使用一个类模板时，必须提供额外信息：\n\n```cpp\nBlob<int> ia; // 空Blob<int>\n```\n\n对我们指定的每一种元素类型，编译器都生成一个不同的类。\n\n<img src=\"C-模板与泛型编程（一）\\类模板的实例.png\"  />\n\n##### 在模板作用域中引用模板类型\n\n通常将模板自己的参数当作被使用模板的参数。\n\n##### 类模板的成员函数\n\n定义在类模板之外的成员函数必须以关键字 `template` 开始，后接类模板参数列表。\n\n##### 类模板成员函数的实例化\n\n成员函数只有在被用到时才进行实例化。\n\n<img src=\"C-模板与泛型编程（一）\\类模板成员函数实例.png\"  />\n\n##### 在类代码内简化模板类名的使用\n\n在类模板自己的作用域中，可以直接使用模板名而不提供实参。\n\n##### 类模板和友元\n\n当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。\n\n##### 令模板自己的类型参数成为友元\n\n```cpp\ntemplate <typename Type> class Bar{\nfriend Type; // 将访问权限授予用来实例化Bar的类型\n\t// ...\n};\n```\n\n例如，对于某个类型名 `Foo`，`Foo` 将成为 `Bar<Foo>` 的友元。\n\n##### 模板类型别名\n\n实例化的模板版本可以使用类型别名：\n\n```cpp\ntypedef Blob<string> StrBlob;\n```\n\n新标准下，可以对类模板定义一个类型别名：\n\n```cpp\ntemplate<typename T> using twin = pair<T, T>;\ntwin<string> authors; // authors是一个pair<string, string>\n```\n\n##### 类模板的static成员\n\n```cpp\ntemplate<typename T> class Foo{\npublic:\n\tstatic std::size_t count() { return ctr; }\n\t//\nprivate:\n\tstatic std::size_t ctr;\n\t//\n};\n```\n\n每个 `Foo` 实例都有自己的 `static` 成员实例，所有的 `Foo<X>` 类型的对象共享相同的 `ctr` 对象和 `count` 函数。\n\n```cpp\n// 所有三个对象共享相同的Foo<int>::ctr和Foo<int>::count成员\nFoo<int> fi, fi2, fi3;\n```\n\n**一个 static 成员函数只有在使用时才会实例化**。\n\n#### 模板参数\n\n##### 模板参数与作用域\n\n模板参数遵循普通的作用域规则。\n\n##### 模板声明\n\n声明必须包括模板参数。且声明中的模板参数名字不必与定义中相同。\n\n##### 使用类的类型成员\n\n假设 T 是一个模板参数类型，编译器遇到 `T::mem` 时不知道 `mem` 是一个类型成员还是一个 `static` 数据成员，直至实例化时才知道。例如：\n\n```cpp\n// 定义一个p变量 or 一个名为size_type的static数据成员与变量p相乘\n// 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型\nT::size_type * p;\n```\n\n如果希望使用一个模板类型参数的类型成员，必须显示的告诉编译器该名字是一个类型，使用关键字 `typename` 实现：\n\n```cpp\ntemplate <typename T>\ntypename T::value_type top(const T&c){\n\tif(!c.empty())\n\t\treturn c.back();\n\telse \n\t\treturn typename T::value_type();\n}\n```\n\n`top` 函数期待一个容器类型的实参，使用 `typename` 指明其返回类型并在 `c` 空时生成一个值初始化的元素返回给调用者。\n\n<img src=\"C-模板与泛型编程（一）\\名字表示类型.png\"  />\n\n##### 默认模板实参\n\n```cpp\n// compare有一个默认模板实参less<T>和一个默认函数实参F()\ntemplate<typename T, typename F = less<T>>\nint compare(const T &v1, const T &v2, F f = F()){\n\tif(f(v1, v2)) return - 1;\n\tif(f(v2,v1))) return 1;\n\treturn 0;\n}\n```\n\n`F` 为可调用对象的类型，新的函数参数 `f` 绑定到一个可调用对象上。\n\n##### 模板默认实参与类模板\n\n```cpp\ntemplate<class T = int> class Numbers{ // T默认为int\npublic:\n\tNumbers(T v = 0): val(v);\n\t//\nprivate:\n\tT val;\n};\nNumbers<long double> lots_of_precision;\nNumbers<> average_precision; // 空<>表示我们希望使用默认类型\n```\n\n#### 成员模板\n\n##### 普通类的成员模板\n\n成员模板以模板参数列表开始。\n\n##### 类模板的成员模板\n\n同时提供类模板和成员模板的参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。\n\n##### 实例化与成员模板\n\n实例化一个类模板的成员模板，必须同时提供类和函数模板的实参。\n\n#### 控制实例化\n\n相同的实例可能出现在多个对象文件中，造成额外的开销。新标准中通过**显示实例化**来避免这种开销：\n\n```cpp\nextern template declaration; // 实例化声明\ntemplate declaration; // 实例化定义\n```\n\n`declaration` 是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如：\n\n```cpp\nextern template class Blob<string>; // 声明\ntemplate int compare (const int&, const int&); // 定义\n```\n\n当编译器遇到 `extern` 模板声明时，它不会再本文件中生成实例化代码。将一个实例化声明为 `extern` 就表示承诺在程序的其他位置有该实例化的一个非 `extern` 声明。对于一个给定的实例化版本，可能有多个 `extern` 声明，但必须只有一个定义。\n\n##### 实例化定义会实例化所有成员\n\n<img src=\"C-模板与泛型编程（一）\\实例化定义会实例化所有成员.png\"  />\n\n#### 效率与灵活性\n\n通过**在编译时绑定删除器**， `unique_ptr` 避免了间接调用删除器的运行时开销。通过**在运行时绑定删除器**，`shared_ptr` 使用户重载删除器更为方便。\n","tags":["泛型"],"categories":["C++"]},{"title":"LeetCode1004-最大连续1的个数Ⅲ","url":"/blog/2021/02/19/LeetCode1004-最大连续1的个数Ⅲ/","content":"\n#### 题目描述\n\n给定一个由若干 `0` 和 `1` 组成的数组 `A`，我们最多可以将 `K` 个值从 0 变成 1 。\n\n返回仅包含 1 的最长（连续）子数组的长度。\n\n<!-- more-->\n\n<img src=\"LeetCode1004-最大连续1的个数Ⅲ\\1004.png\"  />\n\n#### 思路\n\n使用指针 `left` 表示当前的**连续 1 的子数组**的左端点，`right` 指针表示当前的**连续1的子数组**的右端点。\n\n* 如果 `A[right]` 为 0，并且此时 K 不为零，说明当前元素可以由 0 变为 1，并将次数减 1；\n* 如果 `A[right]` 为 0，并且此时 K 为零，说明当前元素不可以由 0 变为 1，并且需要将窗口左端点右移：\n  * 如果 `A[left]` 为 0，说明用使用过一次从 0 到 1。此时需要将这次值的改变“回收”，即 K++；\n  * 更新滑动窗口的最大长度，同时将左端点右移。\n* 如果 `A[right]` 为 0，右端点右移即可。\n\n最后一个连续 1 的子数组可能没被统计，所以需要再更新一次窗口最大长度。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int longestOnes(vector<int>& A, int K) {\n        int ans = 0;\n        int left = 0, right = 0;\n        while(right < A.size()){\n            if(A[right] == 1){\n                right++;\n            }\n            else if(A[right] == 0 && K != 0){\n                right++;\n                K--;\n            }\n            else if(A[right] == 0 && K == 0){\n                if(A[left] == 0) K++;\n                ans = max(ans, right - left);\n                // cout << ans << \" \";\n                left++;\n            }\n        }\n        ans = max(right - left, ans); // 最后一个值为1\n        return ans;\n    }\n};\n```\n\n","tags":["滑动窗口"],"categories":["LeetCode"]},{"title":"C++面向对象程序设计（二）","url":"/blog/2021/02/12/C-面向对象程序设计（二）/","content":"\n#### 本次学习要点\n\n1. 抽象基类\n2. 访问控制与继承\n3. 继承中的类作用域\n4. 构造函数与拷贝控制\n\n<!-- more-->\n\n#### 抽象基类\n\n含有（或者未经覆盖直接继承？）纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。\n\n在函数体的位置（即声明语句的分号之前）书写 = 0 就可以将一个虚函数说明为纯虚函数。\n\n#### 访问控制与继承\n\n##### 受保护的成员protected\n\n* 和私有成员类似，受保护的成员对类的用户是不可访问的。\n* 和公有成员类似，受保护的成员对于派生类的成员和友元来说可访问。\n\n除此之外：\n\n**派生类的成员和友元只能通过派生类对象来访问基类的受保护成员，而不能访问基类对象中的受保护成员。**\n\n##### 公有、私有和受保护继承\n\n<img src=\"C-面向对象程序设计（二）\\继承1.png\" style=\"zoom:67%;\" />\n\n<img src=\"C-面向对象程序设计（二）\\继承2.png\" style=\"zoom:67%;\" />\n\n<img src=\"C-面向对象程序设计（二）\\继承3.png\" style=\"zoom:67%;\" />\n\n某个类对其继承而来的成员的访问权限受两个因素影响：\n\n1. 基类中该成员的访问说明符；\n2. 派生类在派生列表中的访问说明符。\n\n**派生类访问说明符对派生类的成员及友元能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。**\n\n**派生类访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限**。\n\n<img src=\"C-面向对象程序设计（二）\\类的设计与受保护的成员.png\"  />\n\n##### 友元与继承\n\n友元关系不能**传递或继承**，每个类负责控制各自成员的访问权限。\n\n##### 改变个别成员的可访问性\n\n使用 `using` 声明：\n\n```cpp\nclass Base{\npublic:\n    std::size_t size() const { return n; }\nprotected:\n    std::size_t n;\n};\nclass Derived : private Base{\npublic:\n    // Derived的用户可以使用size成员\n    using Base::size;\nprotected:\n    // Derived的派生类可以使用n\n    using Base::n;\n}\n```\n\n在类的内部使用 `using `声明语句，将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。\n\n* 如果一条 `using` 声明语句出现在类的 `private` 部分,则该名字只能被类的成员和友元访问；\n\n* 如果 `using` 声明语句位于 `public` 部分，则类的所有用户都能访问它；\n\n* 如果 `using` 声明语句位于 `protected` 部分，则该名字对于成员、友元和派生类是可访问的。\n\n##### 默认的继承保护级别\n\n默认情况下，使用 `class` 关键字定义的派生类是私有继承的；而使用 `struct` 关键字定义的派生类是公有继承的。\n\n#### 继承中的类作用域\n\n##### 在编译时进行名字查找\n\n##### 名字冲突与继承\n\n派生类的成员将隐藏同名的基类成员。\n\n##### 通过作用域运算符来使用隐藏的成员\n\n我们可以通过作用域运算符来使用一个被隐藏的基类成员：\n\n```cpp\nstruct Derived : Base{\n\tint get_base_mem() { return Base::mem; }\n\t// ...\n};\n```\n\n<img src=\"C-面向对象程序设计（二）\\名字重用.png\"  />\n\n<img src=\"C-面向对象程序设计（二）\\名字查找与继承.png\" style=\"zoom:80%;\" />\n\n##### 名字查找先于类型检查\n\n##### 虚函数与作用域\n\n基类与派生类中的虚函数必须有相同的形参列表。\n\n#### 构造函数与拷贝控制\n\n##### 虚析构函数\n\n基类通常应该定义一个虚析构函数。如果基类的析构函数不是虚函数，则 `delete` 一个指向派生类对象的基类指针将产生未定义的行为。\n\n**虚析构函数将阻止合成移动操作**。\n\n##### 合成拷贝控制和继承\n\n合成的成员负责使用**直接基类**中对应的操作对一个对象的**直接基类部分**进行初始化、赋值或销毁的操作。\n\n##### 派生类的拷贝控制成员\n\n<img src=\"C-面向对象程序设计（二）\\派生类的拷贝控制成员.png\"  />\n\n###### 定义派生类的拷贝或移动构造函数\n\n```cpp\nclass Base{ /* ... */ };\nclass D: public Base{\npublic:\n\tD(const D& d): Base(d) // 拷贝基类成员\n\t\t\t\t/* D的成员的初始值 */ { /* ... */ }\n\tD(D&& d): Base(std::move(d)) // 移动基类成员\n\t\t\t\t/* D的成员的初始值 */ { /* ... */ }\n}\n```\n\n<img src=\"C-面向对象程序设计（二）\\派生类的拷贝或移动构造函数.png\"  />\n\n###### 派生类赋值运算符\n\n```cpp\n// Base::operator=(const Base&) 不会被自动调用\nD &D::operator=(const D &rhs){\n\tBase::operator=(rhs); // 为基类部分赋值\n\t// 为派生类的成员赋值\n\t// 处理自赋值及释放已有资源等\n\treturn *this;\n}\n```\n\n###### 派生类析构函数\n\n```cpp\nclass D : public Base{\npublic:\n\t// Base::Base 被自动调用执行\n\t~D() { /* 用户定义清楚派生类成员的操作 */ }\n};\n```\n\n派生类的析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。\n\n###### 在构造函数和析构函数中调用虚函数\n\n<img src=\"C-面向对象程序设计（二）\\在构造函数和析构函数中调用虚函数.png\"  />\n\n##### 继承的构造函数\n\n使用 `using` 声明语句：\n\n```cpp\nclass Bulk_quote : public Disc_quote{\npublic:\n\tusing Disc_quote::Disc_quote; // 继承Disc_quote的构造函数\n\tdouble net_price(std::size_t) const;\n};\n```\n\n对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数：\n\n```cpp\n// derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数\nderived(parms) : base(args) { }\n```\n\n###### 继承的构造函数特点\n\n与普通成员的 `using` 声明不同，一个构造函数的 `using` 声明不会改变该构造函数的访问级别。\n\n`using` 声明语句不能指定 `explicit` 或 `constexpr`。\n\n**当一个基类构造函数含有默认实参时，这些实参并不会被继承**。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。\n\n例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：\n\n1. 构造函数接受两个形参（没有默认实参），**此时并未省略掉一个形参？**；\n\n2. 构造函数只接受一个形参，它对应于基类中最左侧的**没有默认值**的那个形参。","tags":["面向对象"],"categories":["C++"]},{"title":"2021，新年快乐！","url":"/blog/2021/02/12/2021，新年快乐！/","content":"\n祝大家新年快乐，心想事成，牛年吉祥！\n\n2021，新的一年，机遇与挑战并存。\n\n**抓住机遇，迎接挑战！**\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n​\t\t\t\t\t\t\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  赵星宇\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t             2021.2.12  大年初一"},{"title":"C++面向对象程序设计（一）","url":"/blog/2021/02/08/C-面向对象程序设计（一）/","content":"\n#### 本次学习要点\n\n1. OOP：概述\n2. 定义基类和派生类\n3. 虚函数\n\n<!-- more-->\n\n#### OOP：概述\n\n面向对象程序设计的核心思想是**数据抽象、继承和动态绑定**。\n\n**OOP** 三大特征为：**封装、继承、多态**。\n\n数据抽象：将类的接口与实现分离。\n\n继承：可以定义相似的类型并对其相似关系建模。\n\n动态绑定：在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象。\n\n##### 继承\n\n通过**继承**联系在一起的类构成一种层次关系。层次关系的根部有一个**基类**，负责定义层次关系中所有类共同拥有的成员。通过从基类继承得到的类称为**派生类**，每个派生类定义各自特有的成员。\n\n如果某些函数基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数**。\n\n```cpp\nclass Quote{\npublic:\n\tstd::string isbn() const;\n\tvirtual double net_price(std::size_t n) const;\n};\n```\n\n派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来。\n\n```cpp\nclass Bulk_quote : public Quote{\npublic:\n\tdouble net_price(std::size_t) const override;\n}\n```\n\n**C++11 新标准允许派生类显式的注明它将使用哪个成员函数改写基类的虚函数，在该函数形参列表之后增加一个 `override` 关键字即可**。而不用在函数前加上 `virtual` 关键字。\n\n##### 动态绑定\n\n也称为**运行时绑定**，在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。\n\n#### 定义基类和派生类\n\n##### 定义基类\n\n基类通常都需要定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。\n\n###### 成员函数与继承\n\n基类必须将它得两种成员函数区分开来：\n\n1. 基类希望其派生类进行覆盖的函数，将其定义为虚函数。\n   * 当使用指针或引用调用虚函数时，该调用将被动态绑定。\n   * 如果基类把一个函数声明为虚函数，则该函数的派生类中隐式的也是虚函数。\n2. 基类希望直接继承而不需要改变的类。\n\n###### 访问控制与继承\n\n派生类可以访问基类的公有成员。如果基类希望派生类可以访问成员，并且该成员禁止其他用户访问，这种成员应定义为**受保护的（protected）**。\n\n##### 定义派生类\n\n通过**类派生列表**，形式为：首先是一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前可以有：`public`、`protected` 或 `private` 中的一个。\n\n###### 派生类中的虚函数\n\n###### 派生类对象及派生类向基类的类型转换\n\n可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；也可以把派生类对象的指针用在需要基类指针的地方。\n\n###### 派生类构造函数\n\n首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。\n\n```cpp\nBulk_quote(const std::string& book, double p, std::size_t qty, double disc): \n\t\t\tQuote(book, p), min_qty(qty), discount(disc) { }\n```\n\n###### 派生类使用基类的成员\n\n<img src=\"C-面向对象程序设计（一）\\遵循基类的接口.png\"  />\n\n###### 继承与静态成员\n\n如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。\n\n###### 派生类的声明\n\n声明中包含类名但不包含它的派生列表。\n\n###### 被用作基类的类\n\n如果要将某个类用作基类，则该类必须已经定义而非仅仅声明。\n\n###### 防止继承的发生\n\nC++11 新标准提供关键字 `final` 防止继承发生：\n\n```cpp\nclass NoDerived final { /* */ }; // NoDerived 不能作为基类\n```\n\n##### 类型转换与继承\n\n当使用基类的引用（或指针）时，实际上我们并不知道该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。\n\n###### 静态类型与动态类型\n\n静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。\n\n###### 不存在从基类向派生类的隐式类型转换\n\n###### 在对象之间不存在类型转换\n\n派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。\n\n<img src=\"C-面向对象程序设计（一）\\在对象之间不存在类型转换_note.png\"  />\n\n###### 转换规则\n\n<img src=\"C-面向对象程序设计（一）\\转换规则.png\"  />\n\n#### 虚函数\n\n无论是否被用到，每个虚函数都需要定义。\n\n##### 对虚函数的调用可能运行时才被解析\n\n当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。\n\n##### 多态性\n\n<img src=\"C-面向对象程序设计（一）\\多态性.png\"  />\n\n##### 派生类中的虚函数\n\n一个派生类的函数如果覆盖了某个继承而来的虚函数，则**它的形参类型必须与它覆盖的基类函数完全一致**。一般来说，返回类型也应该一致，除非类的虚函数返回类型是类本身的指针或引用。\n\n##### final 和 override 说明符\n\n如果使用 `override` 标记了某个函数，但是该函数并没有覆盖已存在的虚函数，此时编译器将报错。\n\n如果将某个函数指定为 `final`，则之后任何尝试覆盖该函数的操作都将引发错误。\n\n上述两个函数出现在形参列表（包括任何 `const` 或引用修饰符）以即尾置返回类型之后。\n\n##### 虚函数与默认实参\n\n如果某次函数调用使用了默认实参， 则该实参值由本次调用的静态类型决定。\n\n如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参。\n\n<img src=\"C-面向对象程序设计（一）\\虚函数与默认实参.png\"  />\n\n##### 回避虚函数的机制\n\n通常当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，需要回避虚函数机制。\n\n```cpp\n// 强行调用基类中定义的函数版本而不管 baseP 的动态类型到底是什么\ndouble undiscounted = baseP->Quote::net_price(42);\n```\n\n<img src=\"C-面向对象程序设计（一）\\回避虚函数机制.png\"  />\n","tags":["面向对象"],"categories":["C++"]},{"title":"LeetCode978-最长湍流子数组","url":"/blog/2021/02/08/LeetCode978-最长湍流子数组/","content":"\n#### 题目描述\n\n当 `A` 的子数组 `A[i], A[i+1], ..., A[j]` 满足下列条件时，我们称其为湍流子数组：\n\n若 `i <= k < j`，当 `k` 为奇数时， `A[k] > A[k+1]`，且当 `k` 为偶数时，`A[k] < A[k+1]`；\n或 若 `i <= k < j`，当 `k` 为偶数时，`A[k] > A[k+1]` ，且当 `k` 为奇数时， `A[k] < A[k+1]`。\n也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。\n\n返回 A 的最大湍流子数组的**长度**。\n\n<!-- more-->\n\n<img src=\"LeetCode978-最长湍流子数组\\978.png\"  />\n\n#### 思路\n\n如果当前值同时小于其前一个值和后一个值，或者当前值同时大于其前一个值和后一个值，说明这三个元素可以构成湍流数组。\n\n当无法构成湍流数组时，更新起始位置，并且更新最长长度。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxTurbulenceSize(vector<int>& arr) {\n        int len = arr.size();\n        if(len == 2){\n            if(arr[0] == arr[1]) return 1;\n            else return 2;\n        } \n        int start = 0;\n        int ans = 0;\n        int flag = 0;\n        for(int i = 1; i < len - 1; ++i){\n            if(arr[i] > arr[i - 1] && arr[i] > arr[i + 1]){\n                continue;\n            }\n            else if(arr[i] < arr[i - 1] && arr[i] < arr[i + 1]){\n                continue;\n            }\n            else{\n                if(arr[i] != arr[i - 1]) ans = max(ans, i + 1 - start);\n                else ans = max(ans, i - start);\n                start = i;\n                // 遍历最后一组元素处恰好能截取最后一个湍流数组\n                if(i == len - 2) flag = 1; \n            }\n        }\n        // 如果在末尾未截取湍流数组，表示还存在最后一个湍流数组\n        if(flag == 0) ans = max(ans, len - start);\n        return ans;\n    }\n};\n```\n\n#### Appendix\n\n一种动态规划的解法：\n\n```cpp\nclass Solution {\npublic:\n    int maxTurbulenceSize(vector<int>& arr) {\n        if(arr.size() == 1) return 1;\n        vector<int> up(arr.size(), 1);\n        vector<int> down(arr.size(), 1);\n        int ans = 0;\n        for(int i = 1; i < arr.size(); ++i){\n            if(arr[i] > arr[i - 1]){\n                up[i] = down[i - 1] + 1;\n            }\n            else if(arr[i] < arr[i - 1]){\n                down[i] = up[i - 1] + 1;\n            }\n            ans = max(ans, max(up[i], down[i]));\n        }\n        return ans;\n    }\n};\n```\n\n##### Reference\n\nhttps://leetcode-cn.com/problems/longest-turbulent-subarray/solution/yi-zhang-dong-tu-xiang-jie-dong-tai-gui-wrwvn/","tags":["动态规划","双指针"],"categories":["LeetCode"]},{"title":"LeetCode665-非递减序列","url":"/blog/2021/02/07/LeetCode665-非递减序列/","content":"\n#### 题目描述\n\n给你一个长度为 `n` 的整数数组，请你判断在 **最多** 改变 `1` 个元素的情况下，该数组能否变成一个非递减数列。\n\n我们是这样定义一个非递减数列的： 对于数组中所有的 `i` `(0 <= i <= n-2)`，总满足 `nums[i] <= nums[i + 1]`。\n\n<!-- more-->\n\n<img src=\"LeetCode665-非递减序列\\665.png\"  />\n\n#### 思路\n\n记当前遍历到的位置为 `i`， 如果 `nums[i] < nums[i - 1]`，此时需要修改数组：\n\n* 如果 `nums[i] >= nums[i - 2]` ，说明需要将 `nums[i - 1]` 改小，为了方便起见，令 `nums[i - 1] = nums[i]`；\n* 否则，说明需要将 `nums[i]` 改大，令 `nums[i] = nums[i - 1]`。\n\n对于 `i = 1` 时 `nums[i] < nums[i - 1]`，应将 `nums[i - 1]` 改小，令`nums[i - 1] = nums[i]`，这样做的目的是**使已遍历的序列尽可能的小，减小修改次数**。比如 `2,1,1`，如果修改为 `2,2,1`，那么就不能一次修改得到非递减序列；修改为 `1,1,1`即可。\n\n修改的同时进行计数，计数必须小于等于 1。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool checkPossibility(vector<int>& nums) {\n        int cnt = 0;\n        for(int i = 1; i < nums.size(); ++i){\n            if(nums[i - 1] > nums[i]){\n                cnt++;\n                if(i == 1 || nums[i] >= nums[i - 2]){\n                    nums[i - 1] = nums[i];\n                }\n                else{\n                    nums[i] = nums[i - 1];\n                }\n            }\n        }\n        return cnt <= 1;\n    }\n};\n```\n\n#### Reference\n\nhttps://leetcode-cn.com/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/","tags":["数组"],"categories":["LeetCode"]},{"title":"LeetCode周赛-227","url":"/blog/2021/02/07/LeetCode周赛-227/","content":"\n#### 题目\n\n1. 检查数组能否经排序和轮转得到\n2. 移除石子的最大得分\n3. 构造字典序最大的合并字符串\n4. 最接近目标值的子序列和\n\n<!-- more-->\n\n#### 检查数组能否经排序和轮转得到\n\n给你一个数组 `nums` 。`nums` 的源数组中，所有元素与 `nums` 相同，但按非递减顺序排列。\n\n如果 `nums` 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 `true` ；否则，返回 `false` 。\n\n源数组中可能存在 **重复项** 。\n\n注意：我们称数组 `A` 在轮转 `x` 个位置后得到长度相同的数组 `B` ，当它们满足 `A[i] == B[(i+x) % A.length]` ，其中 % 为取余运算。\n\n##### 解决方案一\n\n根据已有等式，从 0 开始递增 `x`，如果轮转 `x` 后可以从 `A` 得到 `B`，返回 `true`，否则返回 `false`。如果数组长度很大，则时间复杂度会很高。\n\n**代码**\n\n```cpp\nclass Solution {\npublic:\n    bool check(vector<int>& nums) {\n        auto buf = nums;\n        sort(buf.begin(), buf.end());\n        int len = nums.size();\n        int x = 0;\n        while(x < len){\n            int flag = 1;\n            for(int i = 0; i < len; ++i){\n                if(nums[i] != buf[(i + x) % len]){\n                    flag = 0;\n                    break;\n                }\n            }\n            if(flag) return true;\n            x++;\n        }\n        return false;\n    }\n};\n```\n\n##### 解决方案二\n\n如果出现 `nums[i] > nums[(i + 1) % n]` ，表示找到了一个轮转位置，如果最终找到的轮转位置数不大于 1，说明可以轮转。\n\n**代码**\n\n```cpp\nclass Solution {\npublic:\n    bool check(vector<int>& nums) {\n        int n = nums.size(), cnt = 0;\n        for(int i = 0; i < n; ++i){\n            if(nums[i] > nums[(i + 1) % n]){\n                cnt++;\n            }\n            if(cnt > 1) return false;\n        }\n        return true;\n    }\n};\n```\n\n#### 移除石子的最大得分\n\n你正在玩一个单人游戏，面前放置着大小分别为 `a`、`b` 和 `c` 的 **三堆** 石子。\n\n每回合你都要从两个 **不同的非空堆** 中取出一颗石子，并在得分上加 `1` 分。当存在 **两个或更多** 的空堆时，游戏停止。\n\n给你三个整数 `a` 、`b` 和 `c` ，返回可以得到的 **最大分数** 。\n\n##### 解决方案\n\n* 较小的两个值之和等于较大的值，此时最多得 **较大值** 的分数；\n* 较小的两个值之和大于较大的值，此时最多得分为： **较大值** 的分数加 **较小值之和的一半** 的分数之和；\n* 较小的两个值之和小于较大的值，此时最多得 **较小值之和** 的分数；\n\n情况①：较小的两个值之和等于较大的值\n\n两个较小值可以将较大值**一一抵消**。\n\n情况②：较小的两个值之和大于较大的值\n\n除了较大的值可以将两个较小的值抵消一部份外，剩下的两个较小值需要**尽可能平分抵消后剩下的石子**，目的是可以最大程度的拿掉更多的石子。这样做还可以获得的分数为**抵消后两者之和的一半**。\n\n情况③：较小的两个值之和小于较大的值\n\n那么较大的值最多可以将较小的两个值**全部抵消**。\n\n**代码**\n\n```cpp\nclass Solution {\npublic:\n    int maximumScore(int a, int b, int c) {\n        vector<int> vec{a, b, c};\n        sort(vec.begin(), vec.end());\n        if(vec[0] + vec[1] == vec[2]) return vec[2];\n        else if(vec[0] + vec[1] > vec[2]) return vec[2] + (vec[0] + vec[1] - vec[2]) / 2;\n        else\n            return vec[0] + vec[1];\n    }\n};\n```\n\n#### 构造字典序最大的合并字符串\n\n给你两个字符串 `word1` 和 `word2` 。你需要按下述方式构造一个新字符串 `merge` ：如果 `word1` 或 `word2` 非空，选择 **下面选项之一** 继续操作：\n\n如果 `word1` 非空，将 `word1` 中的第一个字符附加到 `merge` 的末尾，并将其从 `word1` 中移除。\n例如，`word1 = \"abc\"` 且 `merge = \"dv\"` ，在执行此选项操作之后，`word1 = \"bc\"` ，同时 `merge = \"dva\"` 。\n如果 `word2` 非空，将 `word2` 中的第一个字符附加到 `merge` 的末尾，并将其从 `word2` 中移除。\n例如，`word2 = \"abc\"` 且 `merge = \"\"` ，在执行此选项操作之后，`word2 = \"bc\"` ，同时 `merge = \"a\"` 。\n返回你可以构造的字典序 **最大** 的合并字符串 `merge` 。\n\n长度相同的两个字符串 `a` 和 `b` 比较字典序大小，如果在 `a` 和 `b` 出现不同的第一个位置，`a` 中字符在字母表中的出现顺序位于 `b` 中相应字符之后，就认为字符串 `a` 按字典序比字符串 `b` 更大。例如，`\"abcd\"` 按字典序比 `\"abcc\"` 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 `d` 在字母表中的出现顺序位于 `c` 之后。\n\n##### 解决方案\n\n从 `word1` 和 `word2` 的首字符中挑选更大的一个加入到答案字符串中。如果字符相同，则比较两个字符串剩下的子串，选取字典序更大的一个字符串的首字符加入答案中，如果两者相等，则任取一个字符串中的首字符。\n\n**代码**\n\n```cpp\nclass Solution {\npublic:\n    string largestMerge(string word1, string word2) {\n        string ans;\n        int index1 = 0;\n        int index2 = 0;\n        int flag = 0;\n        while(index1 < word1.size() && index2 < word2.size()){\n            if(word1[index1] > word2[index2]){\n                ans += word1[index1];\n                index1++;\n            }\n            else if(word1[index1] < word2[index2]){\n                ans += word2[index2];\n                index2++;\n            }\n            // 如果当前字符相等，取字典序更大的子串中的第一个字符\n            else{\n                string word1Helper = word1.substr(index1, word1.size() - index1);\n                string word2Helper = word2.substr(index2, word2.size() - index2);\n                if(word1Helper > word2Helper){\n                    ans += word1[index1++];\n                }\n                else if(word1Helper < word2Helper){\n                    ans += word2[index2++];\n                }\n                // 如果子串相等，任取一个字符\n                else{\n                    ans += word1[index1++];\n                }\n            }\n        }\n        if(index2 != word2.size()) ans += word2.substr(index2, word2.size() - index2);\n        else if(index1 != word1.size()) ans += word1.substr(index1, word1.size() - index1);\n        return ans;\n    }\n};\n```\n\n#### 最接近目标值的子序列和\n\n给你一个整数数组 `nums` 和一个目标值 `goal` 。\n\n你需要从 `nums` 中选出一个子序列，使子序列元素总和最接近 `goal` 。也就是说，如果子序列元素和为 `sum` ，你需要 最小化绝对差 `abs(sum - goal)` 。\n\n返回 `abs(sum - goal)` 可能的 最小值 。\n\n##### 解决方案\n\n1. 将序列均分为两部分，分别求其相应的所有子集之和（这里使用**位运算**求子集）；\n2. 将其中的一个子集之和进行排序；\n3. 遍历另外一个子集之和，每个元素记为 `x`，求出每个 `goal - x`，在排好序的子集之和中进行二分查找，循环更新，找到差值绝对值的最小值。\n\n对于步骤 3：\n\n设已排序数组元素为 `y`，未排序数组为 `x`，差值的绝对值为 `a`，则有：\n$$\n|goal - (x + y)|=a\n$$\n化简可得：\n$$\ngoal - x = y + \\pm a\n$$\n即：步骤 3 中找到的就是 `y`，找到后将其与 `goal - x` 作差，再取绝对值就是当前**差值绝对值的最小值**。\n\n由于使用 `lower_bound` 查找的值不一定存在，需要比较 `goal - x` 与**插入位置的值**和**插入位置之前的值**的差值中哪个的绝对值更小一点；如果插入位置为起点或者末尾，则只需要与插入位置的值进行对比即可。以上都是更新差值绝对值的最小值：\n$$\nans = min(ans, {待比较值})\n$$\n**代码**\n\n```cpp\nclass Solution {\npublic:\n    int minAbsDifference(vector<int>& nums, int goal) {\n        int ans = INT_MAX;\n        int len = nums.size();\n        // 分成两部分\n        vector<int> nums1(nums.begin(), nums.begin() + len / 2);\n        vector<int> nums2(nums.begin() + len / 2, nums.end());\n        // 分别求和的子集\n        vector<int> sum1;\n        subVecSum(nums1, sum1);\n        vector<int> sum2;\n        subVecSum(nums2, sum2);\n        sort(sum1.begin(), sum1.end());\n        for(auto &x : sum2){\n            int val = goal - x;\n            auto it = lower_bound(sum1.begin(), sum1.end(), val);\n            // 注意如何更新ans\n            if(it == sum1.begin()) ans = min(ans, abs(val - *it));\n            else if(it == sum1.end()) ans = min(ans, abs(val - *--it));\n            else ans = min(ans, min(abs(val - *it), abs(val - *--it)));\n        }\n        return ans;\n    }\n    void subVecSum(vector<int> &vec, vector<int> &vecSum){\n        int len = vec.size();\n        int end = 1 << len;\n        int mask = 0;\n        for(mask; mask < end; ++mask){\n            int sum = 0;\n            int flag = 0;\n            for(int i = 0; i < len; ++i){\n                if((1 << i) & mask){\n                    flag = 1;\n                    sum += vec[i];\n                }\n            }\n            if(flag) vecSum.push_back(sum);\n            else vecSum.push_back(0);\n        }\n    }\n};\n```\n\n\n\n","tags":["位运算","贪心算法","数组","分治算法"],"categories":["LeetCode周赛"]},{"title":"LeetCode1423-可获得的最大点数","url":"/blog/2021/02/06/LeetCode1423-可获得的最大点数/","content":"\n#### 题目描述\n\n几张卡牌 **排成一行**，每张卡牌都有一个对应的点数。点数由整数数组 `cardPoints` 给出。\n\n每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 `k` 张卡牌。\n\n你的点数就是你拿到手中的所有卡牌的点数之和。\n\n给你一个整数数组 `cardPoints` 和整数 `k`，请你返回可以获得的最大点数。\n\n<!-- more-->\n\n<img src=\"LeetCode1423-可获得的最大点数\\1423.png\"  />\n\n#### 思路\n\n由于每次都是从端点取数，所以取到的数是连续的（将数组首尾连接为一个循环数组）。\n\n可以维护一个长度为 `n - k` 的窗口在 `cardPoints` 数组上滑动，当窗口内值的和最小时，剩下的 `k` 个数和最大，也就是可以获得的最大点数。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxScore(vector<int>& cardPoints, int k) {\n        if(cardPoints.size() == 1) return cardPoints[0];\n        int len = cardPoints.size() - k;\n        int left = 0, right = len - 1;\n        int ans = 0;\n        int sum = accumulate(cardPoints.begin(), cardPoints.end(), 0);\n        int windowSum = accumulate(cardPoints.begin(), cardPoints.begin() + len, 0);\n        while(right != cardPoints.size() - 1){ // 注意最后一次未比较\n            ans = max(ans, sum - windowSum);\n            windowSum -= cardPoints[left++];\n            windowSum += cardPoints[++right];\n        }\n        // 最后一组窗口的和还没进行比较，这里需要再比较一次\n        ans = max(ans, sum - windowSum);\n        return ans;\n    }\n};\n```\n\n","tags":["滑动窗口"],"categories":["LeetCode"]},{"title":"LeetCode1208-尽可能使字符串相等","url":"/blog/2021/02/05/LeetCode1208-尽可能使字符串相等/","content":"\n#### 题目描述\n\n给你两个长度相同的字符串，`s` 和 `t`。\n\n将 `s` 中的第 `i` 个字符变到 `t` 中的第 `i` 个字符需要 `|s[i] - t[i]|` 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。\n\n用于变更字符串的最大预算是 `maxCost`。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。\n\n如果你可以将 `s` 的子字符串转化为它在 `t` 中对应的子字符串，则返回可以转化的最大长度。\n\n如果 `s` 中没有子字符串可以转化成 `t` 中对应的子字符串，则返回 `0`。\n\n<!-- more-->\n\n<img src=\"LeetCode1208-尽可能使字符串相等\\1208.png\"  />\n\n#### 思路\n\n使用一个变量 `cost` 记录当前子串的总消耗，`start` 和 `end` 分别为子串的起始位置和终点位置。如果此时：\n\n* `cost > maxCost`，更新字符串的长度，选择之前子串与当前子串中长度更大的一个。同时从总消耗 `cost` 中减去当前子串起始位置 `start` 的消耗，并使起始位置 `start` 加 1。\n* `cost <= maxCost`，满足消耗要求时，使终点位置 `end` 加 1，同时加上此时 `end` 处的消耗。\n* 循环上述步骤，直到 `end` 到达字符串尾。\n\n如果此时 `cost <= maxCost`，说明还剩下最后一个子串消耗符合要求，选择**此时的子串长度**和**之前子串长度最大值**中较大的一个，即为答案。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int equalSubstring(string s, string t, int maxCost) {\n        int start = 0, end = 0;\n        int cost = abs(s[0] - t[0]);\n        int maxLen = 0;\n        while(end < s.size()){\n            if(cost > maxCost){\n                maxLen = max(maxLen, end - start);\n                cost -= abs(t[start] - s[start]);\n                start++;\n            }\n            end++;\n            cost += abs(t[end] - s[end]);\n        }\n        if(cost <= maxCost) return max(end - start, maxLen);\n        return maxLen;\n    }\n};\n```\n\n#### 其它\n\n一开始把题目想复杂了，导致这道题花了一个小时，还需要继续努力！\n\n","tags":["双指针"],"categories":["LeetCode"]},{"title":"C++操作重载与类型转换","url":"/blog/2021/02/04/C-操作重载与类型转换/","content":"\n#### 本次学习要点\n\n1. 基本概念\n2. 输入和输出运算符\n3. 算术和关系运算符\n4. 赋值运算符\n5. 下标运算符\n6. 递增和递减运算符\n7. 成员访问运算符\n8. 函数调用运算符\n9. 重载、类型转换与运算符\n\n<!-- more-->\n\n#### 基本概念\n\n对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。\n\n当一个重载的运算符是成员函数时，`this` 绑定到左侧运算对象。成员运算符函数的参数数量比运算对象的数量少一个。\n\n**可以被重载的运算符**\n\n<img src=\"C-操作重载与类型转换\\可重载的运算符.png\"  />\n\n##### 直接调用一个重载的运算符函数\n\n```cpp\n// 一个非成员运算符函数的等价调用\ndata1 + data2;\noperator+(data1, data2);\n// 成员运算符函数\ndata1 += data2;\ndata1.operator+=(data2);\n```\n\n##### 某些运算符不应被重载\n\n<img src=\"C-操作重载与类型转换\\不应该被重载的运算符.png\"  />\n\n##### 选择作为成员或者非成员\n\n* 赋值（=）、下标（[ ]）、调用（( )）、和成员访问箭头（->）运算符必须为成员。\n* 复合赋值运算符一般为成员。\n* 递增、递减、解引用通常为成员。\n* 对称性运算符通常为非成员函数，如算术、相等性、关系和位运算符等。\n\n#### 输入和输出运算符\n\n##### 重载输出运算符<<\n\n第一个形参是一个非常量 `ostream` 对象的引用；第二个形参是一个常量的引用，该常量是我们想要打印类类型。为了和其他输出运算符保持一致，`operator<<` 一般要返回它的 `ostream` 形参。 \n\n```cpp\nostream &operator<<(ostream &os, Sales_data &item){\n    os << item.isbn() << \" \" << item.units_sold << \" \"\n       << item.revenue << \" \" << item.avg_price();\n    return os;\n}\n```\n\n###### 输入输出运算符必须是非成员函数\n\n除此之外，`I/O`运算符一般被声明为友元。\n\n##### 重载输出运算符>>\n\n第一个形参是将要读取的流的引用；第二个形参是将要读入到的（非常量）对象的引用。该运算符返回某个给定流的引用。 \n\n```cpp\nistream &operator>>(istream &is, Sale_data &item){\n\tdouble price;\n    is >> item.bookNo >> item.units_sold >> price;\n    if(is) // 输入成功\n        item.revenue = item.units_sold * price;\n    else // 失败，对象被赋予默认状态\n        item = Sales_data();\n    return is;\n}\n```\n\n<img src=\"C-操作重载与类型转换\\输入输出运算符.png\"  />\n\n#### 算术和关系运算符\n\n算术和关系运算符通常定义为非成员函数。\n\n##### 相等运算符\n\n```cpp\nbool operator==(const Sales_data &lhs, const Sales_data &rhs){\n    return lhs.isbn() == rhs.isbn() &&\n           lhs.units_sold == rhs.units_sold &&\n           lhs.revenue == rhs.revenue;\n}\nbool operator!=(const Sales_data &lhs, const Sales_data &rhs){\n    return !(lhs == rhs);\n}\n```\n\n<img src=\"C-操作重载与类型转换\\相等运算符.png\"  />\n\n##### 关系运算符\n\n<img src=\"C-操作重载与类型转换\\关系运算符.png\"  />\n\n#### 赋值运算符\n\n赋值运算符必须定义为类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。\n\n#### 下标运算符\n\n下标运算符必须是成员函数。\n\n<img src=\"C-操作重载与类型转换\\下标运算符.png\"  />\n\n```cpp\nclass StrVec{\npublic:\n\tstd::string& operator[](std::size_t n){\n        return elements[n];\n    }\n    cosnt std::string& operator[](std::size_t n) const{\n        return elements[n];\n    }\nprivate:\n    std::string *elements;\n}\n/********************************/\nconst StrVec cvec = svec; // 假设svec是一个StrVec对象\nif(svec.size() && svec[0].empty()){\n    svec[0] = \"zero\"; // 正确：下标运算符返回string的引用\n    cvec[0] = \"Zip\"; // 错误：对cvec区取下标返回是常量引用\n}\n```\n\n#### 递增和递减运算符\n\n建议将它们设为成员函数。\n\n##### 定义前置递增/递减运算符\n\n为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。\n\n```cpp\nclass StrBlobPtr{\npublic:\n\tStrBlobPtr& operator++();\n\tStrBlobPtr& operator--();\n}\n```\n\n##### 区分前置和后置运算符\n\n为了和前置区分，后置接受一个额外的（不被使用）`int` 类型的形参。\n\n为了和内置版本保持一致，后置运算符应该返回对象的原值，返回的是一个值而非引用。\n\n```cpp\nclass StrBlobPtr{\npublic:\n\tStrBlobPtr operator++(int);\n\tStrBlobPtr operator--(int);\n}\n```\n\n##### 显示的调用后置运算符\n\n```cpp\nStrBlobPtr p(a1); // p 指向 a1 中的 vector\np.operator(0); // 调用后置版本的 operator\np.operator(); // 前置版本\n```\n\n#### 成员访问运算符\n\n箭头运算符必须是类的成员，解引用运算符通常是类的成员。\n\n**重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象**。\n\n#### 函数调用运算符\n\n函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。\n\n* 如果类定义了调用运算符，则该类的对象称作**函数对象**。这些对象“行为像函数一样”。\n\n ##### lambda是函数对象\n\n```cpp\n// 根据单词长度对其进行排序，对于长度相同的单词按照字母表顺序排序\nstable_sort(words.begin(), words.end(), [](const string &a, const string &b){\n\treturn a.size() < b.size();\n});\n```\n\n其行为类似与下面这个类的一个未命名对象：\n\n```cpp\nclass ShorterString{\npublic:\n\tbool operator()(const string &s1, const string &s2) const{\n\t\treturn s1.size() < s2.size();\n\t}\n};\n/*****************************/\nstable_sort(words.begin(), words.end(), ShorterString());\n```\n\n###### 表示lambda及相应捕获行为的类\n\n引用捕获变量不需多加考虑。\n\n值捕获的变量被拷贝到 `lambda` 中：\n\n```cpp\n// 获得第一个指向满足条件的迭代器，该元素满足其size() >= sz\nauto wc = find_if(words.begin(), words.end(), [sz](const string &a){\n\treturn a.size() >= sz;\n};\n```\n\n该 `lambda` 表达式产生的类将形如：\n\n```cpp\nclass SizeComp{\n\tSizeComp(size_t n): sz(n){};\n\tbool operator()(const string &s) const{\n\t\treturn s.size() >= sz;\n\t}\nprivate:\n\tsize_t sz;\n}\n/*****************************/\nauto wc = find_if(word.begin(), words.end(), SizeComp(sz));\n```\n\n##### 标准库定义的函数对象\n\n<img src=\"C-操作重载与类型转换\\标准库函数对象.png\" style=\"zoom:80%;\" />\n\n* `greater` 类型的对象执行降序排列（`>`）。\n\n##### 可调用对象与function\n\n不同类型可能具有相同的调用形式，下述可调用对象共享调用形式 `int(int, int)`：\n\n```cpp\n// 普通函数\nint add(int i, int j){ return i + j; }\n// lambda\nauto mod = [](int i, int j){ return i % j; };\n// 函数对象类\nstruct divide{\n\tint operator()(int denominator, int divisor){\n\t\treturn denominator / divisor;\n\t}\n};\n```\n\n如果使用 `map<string, int(*)(int,int) binops;`：\n\n```cpp\nbinops.insert({\"+\", add}); // 正确\n// 但是不能将 mod 和 divide 存入 binops，类型不匹配\n```\n\n 为了解决上述问题，可以使用 `function`。\n\n###### 标准库function类型\n\n`function` 定义在头文件 `functional` 中。\n\n<img src=\"C-操作重载与类型转换\\function.png\" style=\"zoom:80%;\" />\n\n使用 `funtion` 可以解决上小节问题：\n\n```cpp\nfunction<int(int, int)> f1 = add;\nfunction<int(int, int)> f2 = divide();\nfunction<int(int, int)> f3 = [](int i, int j){ return i * j; };\n```\n\n可以用 `map<string, function<int(int, int)>> binops` 将上述类型添加。\n\n**不能直接将重载函数的名字存入function类型的对象中**。\n\n#### 重载、类型转换与运算符\n\n##### 类型转换运算符\n\n是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型：\n\n```cpp\noperator type() const;\n```\n\n其中，`type` 表示某种类型。\n\n<img src=\"C-操作重载与类型转换\\类型转换运算符note.png\"  />\n\n###### 类型转换运算可能产生意外结果\n\n```\nint i = 42;\ncin << i; // 如果 bool 的类型转换不是显式的，则编译可通过\n```\n\n该代码使用 `istream` 的 `bool` 类型转换运算符将 `cin` 转换成 `bool`（P516）。\n\n###### 显式的类型转换运算符（explicit conversion operator）\n\n```cpp\nclass SmallInt{\npublic:\n\t// 编译器不会自动执行这一类型转换\n\texplicit operator int() const { return val; }\n};\n```\n\n```Cpp\nSmallInt si = 3;\nsi + 3; // 错误，无隐式类型转换\nstatic_cast<int>(si) + 3; // 正确\n```\n\n**该规定存在一个例外**，如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它：\n\n1. `if`、`while `及 `do` 语句的条件部分。\n2. `for` 语句头的条件表达式。\n3. `!`、`||`、`&&` 的运算对象。\n4. `?:` 的条件表达式。\n\n###### 转换为bool\n\n无论何时在条件中使用流对象，都会使用为 `IO` 类型定义的 `operator bool`。\n\n<img src=\"C-操作重载与类型转换\\转换为bool.png\"  />\n\n##### 避免有二义性的类型转换\n\n1. 最好不要在两个类之间构建相同的类型转换。\n2. 最好不要创建两个转换源/转换对象都是算术类型的类型转换。\n\n<img src=\"C-操作重载与类型转换\\二义性类型转换note.png\"  />\n\n##### 函数匹配与重载运算符\n\n<img src=\"C-操作重载与类型转换\\函数匹配与重载运算符.png\"  />\n\n","tags":["Class"],"categories":["C++"]},{"title":"C++拷贝控制","url":"/blog/2021/02/03/C-拷贝控制/","content":"\n#### 本次学习要点\n\n1. 拷贝、赋值与销毁\n2. 拷贝控制和资源管理\n3. 交换操作\n4. 拷贝控制示例\n5. 动态内存管理类\n6. 对象移动\n\n<!-- more-->\n\n#### 拷贝、赋值与销毁\n\n##### 拷贝构造函数\n\n如果一个构造函数的第一个参数是自身类型的引用，且任何额外的参数都有默认值，则此构造函数是拷贝构造函数。\n\n```cpp\nclass Foo{\npublic:\n    Foo(); // 默认构造函数\n    Foo(const Foo&); // 拷贝构造函数\n};\n```\n\n###### 合成拷贝构造函数\n\n如果没有为一个类定义拷贝构造函数，编译器会自动定义一个，称为合成拷贝构造函数。\n\n对某些类来说，**合成拷贝构造函数用来阻止拷贝该类型的对象**。除此之外，合成拷贝构造函数会将参数的成员依次拷贝到正在创建的对象中。\n\n###### 拷贝初始化\n\n```cpp\nstring dots(10, '.'); // 直接初始化\nstring s(dots); // 直接初始化\n// 拷贝初始化，将右侧的对象拷贝到新创建的对象中\nstring s2 = dots; \n```\n\n###### 参数和返回值\n\n在函数调用过程中，具有**非引用类型**的参数要进行拷贝初始化。\n\n拷贝构造函数被用来初始化**非引用类型参数**，所以拷贝构造函数自己的参数必须是**引用类型**，从而可以拷贝实参。\n\n###### 拷贝初始化的限制\n\n拷贝构造函数通常不应该是 `explicit` 的。\n\n###### 编译器可以绕过拷贝构造函数\n\n```cpp\nstring null_book = \"9-999-99999-9\"; // 拷贝初始化\n// 等价\nstring  null_book(\"9-999-99999-9\"); // 编译器忽略拷贝构造函数\n```\n\n拷贝/移动构造函数必须是存在且可访问的（不能为 `private` ）。\n\n##### 拷贝赋值运算符\n\n###### 重载赋值运算符\n\n赋值运算符就是一个 `operator=` 的函数，它有一个返回类型和一个参数列表。并且必须定义为成员函数，其左侧运算对象绑定到隐式的 `this` 参数。\n\n```cpp\nclass Foo{\npublic:\n    Foo& operator=(const Foo&); // 赋值运算符 \n}\n```\n\n**赋值运算符应该返回一个指向其左侧运算对象的引用**。\n\n###### 合成拷贝赋值运算符\n\n如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝运算符。\n\n对某些类来说，**合成拷贝赋值运算符用来阻止该类型对象的赋值**。除此之外，合成拷贝赋值运算符会将右侧运算对象的每个非 `static` 成员赋予左侧对象的对应成员。\n\n下述代码等价于合成拷贝赋值运算符：\n\n```cpp\nSales_data &Sales_data::operator=(const Sales_data &rhs){\n    bookNo = rhs.bookNo;\n    units_sold = rhs.units_sold;\n    revenue = rhs.revenue;\n    return *this;\n}\n```\n\n##### 析构函数\n\n析构函数释放对象所使用的资源，并销毁对象的非 `static` 数据成员。\n\n###### 合成析构函数\n\n当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。如果其作用不是为了阻止某些类对象被销毁，那么它的函数体就为空。\n\n##### 三/五法则\n\n* 需要析构函数的类也需要拷贝和赋值操作。\n* 需要拷贝操作的类也需要赋值操作，反之亦然。\n\n##### 使用=default\n\n将拷贝控制成员定义为 `=default` 来显式地要求编译器生成合成的版本。\n\n##### 阻止拷贝\n\n某些类的拷贝构造函数和拷贝赋值运算符操作是没有意义的，如：`iostream` 类阻止拷贝，以避免多个对象写入或读取相同的 `IO` 缓冲。\n\n新标准下，可以在函数参数列表后加上 `=delete` 表示它是**删除**的。且 `=delete` 必须出现在函数第一次声明时。\n\n```cpp\nstruct NoCopy{\n\tNoCopy() = default; // 使用合成的默认构造函数\n    NoCopy(const NoCopy&) = delete; // 阻止拷贝\n    NoCopy &operator=(const NoCopy&) = delete; // 阻止赋值\n    ~NoCopy() = default; // 使用合成的析构函数\n};\n```\n\n###### **析构函数不能是删除的成员**\n\n###### **合成的拷贝控制成员可能是删除的**\n\n###### **private拷贝控制**\n\n通过声明（但不定义）`private` 的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图。\n\n#### 拷贝控制和资源管理\n\n##### 行为像值的类\n\n类的行为像一个值，表示它有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。\n\n**关键概念：赋值运算符**\n\n* 如果将一个对象赋予它自身，赋值运算符必须能正常工作。\n* 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。\n\n##### 行为像指针的类\n\n行为像指针的类则共享状态，当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。\n\n除了使用 `shared__ptr` 来管理类中的资源，如果想要直接管理资源，需要使用**引用计数**。\n\n#### 交换操作\n\n如果使用重排元素顺序的算法来操作类，那么定义一个 `swap` 就很重要了，算法在需要交换两个元素时调用 `swap`。\n\n##### 编写我们自己的swap函数\n\n我们希望交换指针而不是分配新副本。\n\n```cpp\nclass HasPtr{\n    friend void swap(HasPtr&, HasPtr&);\n};\ninline void swap(HasPtr &lhs, HasPtr &rhs){\n    using std::swap;\n    swap(lhs.ps, rhs.ps); // 交换string指针\n    swap(lhs.i, rhs.i); // 交换int成员\n}\n```\n\n每个调用都应该是 `swap` 而不是 `std::swap` 。\n\n##### 在赋值运算符中使用swap\n\n```cpp\n// rhs按值传递，HasPtr拷贝构造函数将右侧运算对象中的string拷贝到rhs\nHasPtr& HasPtr::operator(HasPtr rhs){\n    swap(*this, rhs);\n    return *this; // rhs被销毁\n}\n```\n\n#### 拷贝控制示例\n\n实例，写为工程。\n\n#### 动态内存管理类\n\n实例，写为工程。\n\n#### 对象移动\n\n很多情况下发生对象拷贝后就立即销毁了，如果此时进行移动而非拷贝对象会大幅度提升性能。\n\n<img src=\"C-拷贝控制\\对象移动_note.png\"  />\n\n##### 右值引用\n\n右值引用就是必须绑定到右值的引用，使用 `&&` 而不是 `&` 来获取右值引用。\n\n**右值引用有一个重要的性质——只能绑定到一个将要销毁的对象，因此，我们可以将一个右值引用的资源移动到另一个对象中。**\n\n* 一般而言，一个左值表达式表示的是一个对象的身份，而右值表达式表示的对象的值。\n\n```cpp\nint i = 42;\nint &r = i; // 正确，r 引用 i\nint &&rr = i; // 错误，不能将一个右值引用绑定到一个左值上\nint &r2 = i * 42; // 错误，i*42是一个右值\nconst int &r3 = i * 42; // 正确， 可以将一个 const 的引用绑定到一个右值上\nint &&rr2 = i * 42; // 正确，将 rr2 绑定到乘法结果上\n```\n\n###### 左值持久，右值短暂\n\n右值要么是字面值常量，要么是在表达式求值过程中创建的临时对象。\n\n###### 变量是左值\n\n###### 标准库move函数\n\n头文件 `utility` 中，名为 `move` 的函数可以显式地将一个左值转换为对应地右值引用。使用 `move` 时应使用 `std::move` ，避免潜在的名字冲突。\n\n```cpp\nint &&rr3 = std::move(rr1); // 调用move意味着：除了对rr1赋值或销毁它外，我们将不再使用它\n```\n\n<img src=\"C-拷贝控制\\move_note.png\"  />\n\n##### 移动构造函数和移动赋值运算符\n\n###### 移动操作、标准库容器和异常\n\n移动操作不会抛出任何异常，我们应将此事通知给标准库，一种方法为在构造函数中指明 `noexcept`。\n\n```cpp\nclass StrVec{\npublic:\n\tStrVec(StrVec&&) noexcept; // 移动构造函数\n};\nStrVec::StrVec(StrVec &&s) noexcept : /*成员初始化器*/\n{ /* 构造函数体 */}\n```\n\n###### 移动赋值运算符\n\n如果我们的移动赋值预算符不抛出任何异常，我们就应该将其标记为 `noexcept`。\n\n###### 移后源对象必须可析构\n\n在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。\n\n###### 合成的移动操作\n\n<img src=\"C-拷贝控制\\合成的移动操作_note.png\"  />\n\n定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地定义为删除的。\n\n###### 移动右值，拷贝左值\n\n###### 如果没有移动构造函数，右值也被拷贝\n\n<img src=\"C-拷贝控制\\右值拷贝.png\"  />\n\n###### 移动迭代器\n\n新标准库中定义了一种**移动迭代器**适配器，其解引用运算符生成一个右值引用。我们通过调用标准库中的 `make_move_iterator` 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个迭代器。\n\n<img src=\"C-拷贝控制\\不要随意使用移动操作.png\"  />\n\n##### 右值引用和成员函数\n\n如果一个成员函数同时提供拷贝和移动版本，其中一个版本接受一个指向 `const` 的左值引用，第二个版本接受一个指向非 `const` 的右值引用。\n\n```cpp\nvoid push_back(const X&); // 拷贝，绑定到任意类型的X\nvoid push_back(X&&); // 移动，只能绑定到类型X可修改的右值\n```\n\n###### **引用限定符**\n\n引用限定符可以是 `&` 或 `&&`，分别指出 `this` 可以指向一个左值或右值，只能用于非 `static` 成员函数，且必须同时出现在函数的声明和定义中。一个函数可以同时用 `const` 和引用限定，引用限定必须跟随在 `const` 限定符之后：\n\n```cpp\nclass Foo{\npublic:\n\tFoo someMem() & const; // 错误，const 限定符必须在前\n\tFOO anotherMem() const &; // 正确，const 限定符在前\n};\n```\n\n当我们对一个右值进行排序时，可以安全的直接对 `data` 成员进行排序；当对一个 `const` 右值或一个左值执行排序时，我们不能改变对象，因此需要在排序前拷贝 `data`。\n\n<img src=\"C-拷贝控制\\引用限定符_note.png\"  />","tags":["Class"],"categories":["C++"]},{"title":"LeetCode424-替换后的最长重复字符","url":"/blog/2021/02/03/LeetCode424-替换后的最长重复字符/","content":"\n#### 题目描述\n\n给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 *k* 次。在执行上述操作后，找到包含重复字母的最长子串的长度。\n\n注意：字符串长度 和 *k* 不会超过 10^4。\n\n<!-- more-->\n\n<img src=\"LeetCode424-替换后的最长重复字符\\424.PNG\"  />\n\n#### 思路\n\n第一眼看上去像动态规划，实际上是双指针，或者说滑动窗口。\n\n我们记 `left` 为左指针，`right` 为右指针：\n\n1. 固定 `left`，`right` 向右滑动的同时，记录遍历过的每个字符出现的次数，同时记录所遍历的字符中，出现次数最多的字符的数量。\n2. 如果出现次数最多的字符 + k 小于 `right - left` ，说明在 `[left, right)` 区间中，**除出现最多的字符外，需要修改的其他字符的总数已经大于 k 了**。\n3. 此时，需要将左指针 `left` 向右滑动，下一个字符与当前相同或者不同，都不会影响结果，记录此时的 `right - left` 表示当前可以连续的字符串长度。重复步骤 1，直到 `right` 指向字符串末尾。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        if(s.empty()) return 0;\n        int ans = 0;\n        int left = 0, right = 0;\n        int maxCount = 0;\n        int freq[26] = {0};\n        while(right < s.size()){\n            freq[s[right] - 'A']++;\n            // 找到出现次数最多的字母\n            maxCount = max(maxCount, freq[s[right] - 'A']);\n            right++;\n            // 除了最多字母外，不够修改k次其他字母\n            if(right - left > maxCount + k){\n                freq[s[left] - 'A']--;\n                left++;\n            }\n            ans = max(ans, right - left);\n        }\n        return ans;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/","tags":["双指针"],"categories":["LeetCode"]},{"title":"I/O控制（二）","url":"/blog/2021/02/02/I-O控制（二）/","content":"\n#### 本次学习要点\n\n1. 假脱机技术（SPOOLing技术）\n2. 设备的分配与回收\n3. 缓冲区管理\n\n<!-- more-->\n\n#### 假脱机技术（SPOOLing技术）\n\n##### 什么是脱机技术\n\n脱离主机的控制进行输入/输出操作。\n\n##### 假脱机技术\n\n又称SPOOLing技术，使用软件方式模拟脱机技术。组成如下：\n\n<img src=\"I-O控制（二）\\输入井和输出井.png\" style=\"zoom:80%;\" />\n\n输入进程模拟脱机输入时的外围控制机，在其控制下，输入缓冲区暂存从输入设备输入的数据，之后再转存到输入井中。\n\n输出进程模拟脱机输出时的外围控制机，在其控制下，输出缓冲区暂存从输出井送来的数据，之后再传送到输出设备上。\n\n输入缓冲区和输出缓冲区是在**内存中**的缓冲区。\n\n#### 设备的分配与回收\n\n设备可分为三种：独占设备、共享设备、虚拟设备。\n\n独占设备：一个时段只能分配给一个进程（如打印机）。\n\n共享设备：可同时分配给多个进程使用，宏观同时使用设备，微观交替使用设备（如磁盘）。\n\n虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程（共享打印机）。\n\n##### 设备分配时应考虑因素\n\n安全分配方式：为进程分配一个设备后将其阻塞，直到本次 I/O 完成后才将其唤醒。\n\n* 优点：不会死锁。\n* 缺点：同一进程 CPU 与 I/O 串行工作。\n\n不安全分配方式：进程发出 I/O 请求后，系统为其分配 I/O 设备，进程可继续执行，之后还可以发出新的 I/O 请求。只有某个 I/O 请求得不到满足时才将其阻塞。\n\n* 优点：进程的计算任务和 I/O 任务可并行处理。\n* 缺点：可能发生死锁。\n\n##### 静态/动态分配\n\n静态分配：进程运行前为其分配所需资源，运行结束后归还资源。\n\n动态分配：进程运行过程中动态申请设备资源。\n\n##### 设备分配管理中的数据结构\n\n设备、控制器、通道之间的关系：\n\n<img src=\"I-O控制（二）\\设备、控制器、通道关系.png\" style=\"zoom:80%;\" />\n\n一个通道可以控制多个设备控制器，每个设备控制器可控制多个设备。\n\n###### 设备控制表（DCT）\n\n系统为每个设备配置一张 DCT，用于记录设备情况。\n\n<img src=\"I-O控制（二）\\DCT.PNG\" style=\"zoom:80%;\" />\n\n###### 控制器控制表（COCT）\n\n每个设备控制器都会对应一张 COCT，操作系统根据 COCT 的信息对控制器进行操作和管理。\n\n<img src=\"I-O控制（二）\\COCT.PNG\" style=\"zoom:80%;\" />\n\n###### 通道控制表（CHCT）\n\n每个通道都会对应一张 CHCT，操作系统根据 CHCT 的信息对通道进行操作和管理。\n\n<img src=\"I-O控制（二）\\CHCT.PNG\" style=\"zoom:80%;\" />\n\n###### 系统设备表（SDT）\n\n记录了系统中全部设备的情况，每个设备对应一个表目。\n\n<img src=\"I-O控制（二）\\SDT.PNG\" Style=\"zoom:80%;\" />\n\n##### 设备分配的步骤\n\n1. 根据进程请求的逻辑设备名查找 SDT (注：用户变成时提供的逻辑设备名就是“设备类型”)。\n2. 根据 SDT 找到用户进程**指定类型且空闲的设备**，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。\n3. 根据 DCT 找到 COCT，若控制器忙碌则将进程 PCB 挂到控制器等待队列中，不忙碌则将控制器分配给进程。\n4. 根据 COCT 找到 CHCT ，若通道忙碌则将进程 PCB 挂到通道等待队列中，不忙碌则将通道分配给进\n   程。\n\n<img src=\"I-O控制（二）\\设备分配的步骤.PNG\" style=\"zoom:80%;\" />\n\n**逻辑设备表（LUT）**\n\n建立逻辑设备名与物理设备名之间的映射关系。\n\n<img src=\"I-O控制（二）\\LUT.PNG\"  />\n\n##### 小结\n\n<img src=\"I-O控制（二）\\设备的分配与回收小结.PNG\"  />\n\n#### 缓冲区管理\n\n##### 缓冲区概念及作用\n\n缓冲区：一个存储区域，可以由专门的硬件组成，也可利用内存作为缓冲区，一般使用内存作为缓冲区。\n\n作用：\n\n1. 缓和 CPU 与 I/O 设备之间速度不匹配的矛盾。\n2. 减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制。\n3. 解决数据粒度不匹配的问题（输出进程每次生成一块数据，而 I/O 设备每次只能输出一个字符）。\n4. 提高 CPU 与 I/O 设备之间的并行性。\n\n##### 单缓冲\n\n操作系统在主存中为其分配一个缓冲区（一般为一个块）。\n\n**缓冲区写满之后才能读，读空之后才能写**。\n\n处理一块数据平均耗时：$MAX(C,T) + M$。字符意思如下：\n\n<img src=\"I-O控制（二）\\单缓冲区.PNG\" style=\"zoom:80%;\" />\n\n##### 双缓冲\n\n操作系统在主存中为其分配两个缓冲区。\n\n<img src=\"I-O控制（二）\\双缓冲区.PNG\" style=\"zoom:80%;\" />\n\n处理一块数据平均耗时：$MAX(T,C+M)$。\n\n##### 使用单/双缓冲在通信时的区别\n\n单缓冲区同一时间只能单向传输，而双缓冲区同一时刻可以实现双向的数据传输。\n\n##### 循环缓冲区\n\n将多个大小相等的缓冲区链接成一个**循环队列**。\n\n<img src=\"I-O控制（二）\\循环缓冲区.PNG\" style=\"zoom:80%;\" />\n\n##### 缓冲池\n\n缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可分为：空缓冲队列、装满输入数据的缓冲队列（输出队列）、装满输出数据的缓冲队列（输出队列）。\n\n<img src=\"I-O控制（二）\\缓冲池.PNG\" style=\"zoom:80%;\" />\n\nhin：用于收容输入数据的工作缓冲区。\n\nsin：用于提取收入数据的工作缓冲区。\n\nhout：用于收容输出数据的工作缓冲区。\n\nsout：用于提取输出数据的工作缓冲区。\n\n<img src=\"I-O控制（二）\\队列.PNG\" style=\"zoom:80%;\" />\n\n1. 输入进程请求输入数据：\n\n<img src=\"I-O控制（二）\\输入进程请求输入数据.PNG\" style=\"zoom:80%;\" />\n\n2. 计算进程想要取得一块输入数据：\n\n<img src=\"I-O控制（二）\\计算进程想要取得一块输入数据.PNG\" style=\"zoom:80%;\" />\n\n3. 计算进程想要将准备好的数据冲入缓冲区：\n\n<img src=\"I-O控制（二）\\计算进程想要将准备好的数据冲入缓冲区.PNG\" style=\"zoom:80%;\" />\n\n4. 输出进程请求输出数据：\n\n<img src=\"I-O控制（二）\\输出进程请求输出数据.PNG\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"I-O控制（二）\\缓冲区管理小结.PNG\"  />","categories":["操作系统"]},{"title":"I/O控制（一）","url":"/blog/2021/02/02/I-O控制（一）/","content":"\n#### 本次学习要点\n\n1. I/O设备的基本概念和分类\n2. I/O控制器\n3. I/O控制方式\n4. I/O软件层次结构\n5. I/O核心子系统\n\n<!-- more-->\n\n#### I/O设备的基本概念和分类\n\n##### 什么是I/O设备？\n\nI/O设备就是可以将数据输入到计算机，或从计算机接收数据的外部设备，属于计算机中的硬件部件。\n\n* `write` 操作：向外部设备写出数据。\n* `read` 操作：从外部设备读入数据。\n\n##### I/O设备分类\n\n**按使用特性分类**：\n\n1. 人机交互类设备\n2. 存储设备\n3. 网络通信设备\n\n**按传输速率分类**：\n\n1. 低速设备\n2. 中速设备\n3. 高速设备\n\n**按信息交换的单位分类**：\n\n1. 块设备（传输快，可寻址）\n2. 字符设备（传输慢，不可寻址，常采用中断驱动方式）\n\n#### I/O控制器\n\nI/O设备由**机械设备**和**电子设备**构成。\n\n**机械部件**：执行具体的 I/O 操作，如鼠标键盘等。\n\n**电子部件**：插入主板扩充槽的印刷电路板。\n\n---\n\n电子部件（I/O控制器）\n\nI/O 控制器是 CPU 和 I/O 设备机械部件之间的**桥梁**。CPU 可控制 I/O 控制器，再由 I/O 控制器来控制设备的机械部件。\n\n---\n\n##### I/O控制器的功能\n\n1. 接受和识别 CPU 发出的命令（I/O 控制器中的**控制寄存器**存放命令和参数）。\n2. 向 CPU 报告设备的状态（I/O 控制器中的**状态寄存器**记录 I/O 设备的当前状态）。\n3. 数据交换（I/O 控制器中的 **数据寄存器**，作为 CPU 与设备数据交换的桥梁）。\n4. 地址识别（I/O 控制器通过 CPU 提供的地址来判断 CPU 读写哪个寄存器）。\n\n##### I/O控制器的组成\n\n<img src=\"I-O控制（一）\\I-O控制器的组成.png\" style=\"zoom: 67%;\" />\n\n上述寄存器如果地址占用内存地址的一部分，称为**内存映像 I/O** ；如果采用 I/O 专用地址，称为**寄存器独立编址**。\n\n两者区别如下：\n\n<img src=\"I-O控制（一）\\内存映像与寄存器独立编址.png\" style=\"zoom: 67%;\" />\n\n##### 小结\n\n<img src=\"I-O控制（一）\\I-O控制器小结.png\"  />\n\n#### I/O控制方式\n\n##### 程序直接控制方式\n\n<img src=\"I-O控制（一）\\程序直接控制方式.png\" style=\"zoom: 67%;\" />\n\n1. CPU 干预的频率高，等待 I/O 的过程中一直轮询检查。\n2. 每次读写一个**字**。\n3. 数据流向：\n   1. 数据输入： I/O 设备 -> CPU -> 内存\n   2. 数据输出： 内存 -> CPU ->  I/O 设备\n4. 优点：实现简单。\n5. 缺点：CPU 和 I/O设备只能串行工作，CPU 长期处于**忙等**状态，利用率低。\n\n##### 中断驱动方式\n\n<img src=\"I-O控制（一）\\中断驱动方式.png\"  />\n\n1. I/O 操作开始前、完成后需要 CPU 介入。\n2. 每次读写一个**字**。\n3. 数据流向：\n   1. 数据输入： I/O 设备 -> CPU -> 内存\n   2. 数据输出： 内存 -> CPU ->  I/O 设备\n\n4. 优点：CPU 和 I/O 设备可并行工作。\n5. 缺点：每个字传输时，都需要中断，频繁中断消耗较多的 CPU 时间。\n\n##### DMA方式\n\nDMA（Direct Memory Access，直接存储器存取），主要用于**块设备** I/O 控制，**不需要经过 CPU**。\n\n<img src=\"I-O控制（一）\\DMA方式.png\" style=\"zoom:80%;\" />\n\n**DMA控制器**\n\n<img src=\"I-O控制（一）\\DMA控制器.PNG\" style=\"zoom:80%;\" />\n\nDR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据，**也是一个字一个字的存入**。\nMAR（Memory Address Register，内存地址寄存器）：在输入时，MAR 表示数据应放到内存中的什么位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。\nDC（Data Counter，数据计数器）：表示剩余要读/写的字节数。\nCR（Command Register，命令/状态寄存器）：用于存放 CPU 发来的 I/O 命令，或设备的状态信息。\n\n1. 仅在传送开始或结束时，才需要 CPU 干预。\n2. 每次读写**一个或多个块（必须连续）**。\n3. 数据流向：\n   1. 数据输入： I/O 设备  -> 内存\n   2. 数据输出： 内存 ->  I/O 设备\n\n4. 优点：数据传输以**块**为单位，且 CPU 接入频率进一步降低，进一步提高了 CPU 和 I/O 设备的并行性。\n5. 缺点：只能读写一个或多个连续的数据块。如果数据块离散，CPU 需发出多次 I/O 指令。\n\n##### 通道控制方式\n\n通道：一种硬件，可以理解为**弱化版的 CPU**，可以识别并执行一系列的通道指令，通道执行的指令很单一，与 CPU 共享内存。\n\n<img src=\"I-O控制（一）\\通道.PNG\" style=\"zoom:80%;\" />\n\n1. CPU 干预频率极低，通道完成一组数据块的读写后才发出中断信号。\n\n2. 每次读写**一组数据块**。\n3. 数据流向：\n   1. 数据输入： I/O 设备  -> 内存\n   2. 数据输出： 内存 ->  I/O 设备\n4. 优点：CPU、通道、I/O 设备并行工作，资源利用率高。\n5. 缺点：实现复杂，，需要专门的通道硬件支持。\n\n##### 小结\n\n<img src=\"I-O控制（一）\\I-O控制方式.PNG\" style=\"zoom: 67%;\" />\n\n#### I/O软件层次结构\n\n<img src=\"I-O控制（一）\\I-O软件层次结构.PNG\" style=\"zoom: 80%;\" />\n\n##### 用户层软件\n\n实现与用户交互的接口，用户可直接使用该层提供的，与 I/O 操作相关的库函数对设备进行操作。用户层软件将用户请求翻译为格式化的 I/O 请求，通过**系统调用**请求操作系统内核的服务。\n\n##### 设备独立性软件\n\n又称设备无关性软件，与设备的硬件特性无关的功能几乎都在这一层实现。\n\n主要实现的功能：\n\n1. 向上层提供统一的调用接口。\n2. 设备的保护。设备被看作是一种特殊的文件，不同用户的访问权限不同。\n3. 差错处理。\n4. 设备的分配与回收。\n5. 数据缓冲区管理。\n6. 建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序。\n\n设备独立性软件需要通过**逻辑设备表（LUT， Logical Unit Table）**来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。有两种方式：①整个系统只设置一张 LUT，只适合单用户操作系统；②为每个用户设置一张 LUT。\n\n**不同设备需要不同设备驱动程序的原因**？\n\n答：不同设备有不同的硬件特性，具体细节只有厂家知道。驱动程序一般会以一个独立进程的方式存在。\n\n##### 中断处理程序\n\n<img src=\"I-O控制（一）\\中断处理程序.png\" style=\"zoom:80%;\" />\n\n##### 其他\n\n中断处理程序和设备驱动程序会和硬件打交道。\n\n#### I/O核心子系统\n\n I/O 核心子系统要实现的功能就是中间三层要实现的功能，主要有： I/O 调度、设备保护、设备分配与回收、缓冲区管理，还有假脱机技术（SPOOLing技术），**其中假脱机技术是在用户层软件实现的**。\n\n##### I/O调度\n\n用某种算法确定一个好的顺序来处理各个 I/O 请求。\n\n如磁盘调度：先来先服务算法、最短寻道优先算法等确定 I/O 请求的顺序。\n\n同理，打印机等设备也可以用先来先服务、优先级算法等确定 I/O 请求的顺序。\n\n##### 设备保护\n\n不同用户对各个文件拥有不同的访问权限。可参考**文件保护**小节。","categories":["操作系统"]},{"title":"LeetCode888-公平的糖果交换","url":"/blog/2021/02/01/LeetCode888-公平的糖果交换/","content":"\n#### 题目描述\n\n爱丽丝和鲍勃有不同大小的糖果棒：`A[i]` 是爱丽丝拥有的第 `i` 根糖果棒的大小，`B[j]` 是鲍勃拥有的第 `j` 根糖果棒的大小。\n\n因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）\n\n返回一个整数数组 `ans`，其中 `ans[0]` 是爱丽丝必须交换的糖果棒的大小，`ans[1]` 是 `Bob` 必须交换的糖果棒的大小。\n\n如果有多个答案，你可以返回其中任何一个。保证答案存在。\n\n本题和[两数之和](https://leetcode-cn.com/problems/two-sum/)并无本质区别。\n\n<!-- more-->\n\n<img src=\"LeetCode888-公平的糖果交换\\888.png\"  />\n\n#### 思路\n\n记 A 糖果总数为 sum1，B 糖果总数为 sum2，A 需要交换的糖果棒大小为 x，B 需要交换的糖果棒大小为 y，那么可以得到以下等式：\n$$\nsum1-x+y=sum2-y+x\n$$\n经过化简可得：\n$$\nx=y-\\frac{sum2-sum1}{2}\n$$\n将 A 的所有糖果棒长度存入哈希表，遍历 B，找到哈希表中满足上述等式的值后，返回此时的 x, y 即可。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) {\n        // vector<int> ans(2);\n        int sum1 = accumulate(A.begin(), A.end(), 0);\n        int sum2 = accumulate(B.begin(), B.end(), 0);\n        int sum = (sum2 - sum1) / 2;\n        unordered_set<int> set(A.begin(), A.end());\n        for(auto &y : B){\n            if(set.count(y - sum))\n                return {y - sum, y};\n        }\n        // 总是有解的，所以返回什么无所谓\n        return {1,2,3,4,5};\n    }\n};\n```\n\n","tags":["哈希表"],"categories":["LeetCode"]},{"title":"LeetCode839-相似字符串组","url":"/blog/2021/01/31/LeetCode839-相似字符串组/","content":"\n#### 题目描述\n\n如果交换字符串 `X` 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 `X` 和 `Y` 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。\n\n例如，`\"tars\"` 和 `\"rats\"` 是相似的 (交换 `0` 与 `2` 的位置)； `\"rats\"` 和 `\"arts\"` 也是相似的，但是 `\"star\"` 不与 `\"tars\"`，`\"rats\"`，或 `\"arts\"` 相似。\n\n总之，它们通过相似性形成了两个关联组：`{\"tars\", \"rats\", \"arts\"}` 和 `{\"star\"}`。注意，`\"tars\"` 和 `\"arts\"` 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。\n\n给你一个字符串列表 `strs`。列表中的每个字符串都是 `strs` 中其它所有字符串的一个字母异位词。请问 `strs` 中有多少个相似字符串组？\n\n<!-- more-->\n\n<img src=\"LeetCode839-相似字符串组\\839.png\"  />\n\n**备注：**\n\n​\t字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。\n\n#### 思路\n\n本题如果理解了题目的意思，就不难。\n\n**给你一个字符串列表 `strs`。列表中的每个字符串都是 `strs` 中其它所有字符串的一个字母异位词**。再结合备注可知：所有的字符串都是由**相同的字母**组成，无非就是字母顺序不一样罢了。\n\n题目要求**相似**的字符串为一组，何为相似？有两种情况：\n\n1. 两个字符串相同。\n2. 其中一个字符串交换一对字母后与另一字符串相同。\n\n**如何操作**？\n\n使用一个变量统计两个字符串对应位置字母不相同的个数。如果计数等于 0 或者 2，说明这两个字符串是相似的，使用并查集进行合并即可。\n\n返回合并后的连通集数就是最终答案。\n\n#### 代码\n\n暴力遍历即可。35% 99%\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        parent[pRoot] = qRoot;\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int numSimilarGroups(vector<string>& strs) {\n        int n = strs.size();\n        int len = strs[0].size();\n        unionFind uf(n);\n        for(int i = 0; i < n; ++i){\n            for(int j = i + 1; j < n; ++j){\n                int cnt = 0;\n                for(int k = 0; k < len; ++k){\n                    if(strs[i][k] != strs[j][k])\n                        cnt++;\n                }\n                // 对比完一个后，如果只有两个字母不同，说明在同一个分组里面\n                if(cnt == 2 || cnt == 0) uf.unionElem(i, j);\n            }\n        }\n        return uf.getCount();\n    }\n};\n```\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode778-水位上升的游泳池中游泳","url":"/blog/2021/01/30/LeetCode778-水位上升的游泳池中游泳/","content":"\n#### 题目描述\n\n在一个 N x N 的坐标方格 `grid` 中，每一个方格的值 `grid[i][j]` 表示在位置 `(i,j)` 的平台高度。\n\n现在开始下雨了。当时间为 `t` 时，此时雨水导致水池中任意位置的水位为 `t` 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。\n\n你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 `(N-1, N-1)`？\n\n本题与[LeetCode1631-最小体力消耗路径]()基本一致。\n\n<!-- more-->\n\n<img src=\"LeetCode778-水位上升的游泳池中游泳\\778.png\"  />\n\n#### 思路\n\n将本题抽象为一个图论模型：\n\n* 将每个位置抽象为一个节点，共有 `n * n` 个节点。\n* 每个节点与其上下左右构成带权无向图（存在此节点的话）。\n* 当存在一条从左上角到右下角的路径时，所需要的最小时间 T。\n\n设置一个时间阈值 t，如果存在一条路径可以由左上角到右下角，那么可以继续缩短时间 t。直到找到最短的时间。本题高度范围是 `[0, N*N - 1]`，从 0 到 N*N - 1 设置阈值，进行二分搜索。\n\n* 如果当前高度大于 t，说明此路不通，需要跳过。\n* 当前高度小于等于 t，并且其四个方向也存在小于等于 t 的高度，才可以继续搜索。\n\n**对于图论的最短路径问题，考虑使用广度优先搜索（BFS）**。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int dx[4] = {-1,1,0,0};\n    int dy[4] = {0,0,-1,1};\n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int left = 0, right = n * n - 1;\n        int ans = 0;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            queue<pair<int, int>> q;\n            q.emplace(0, 0);\n            vector<bool> vis(n * n, 0);\n            vis[0] = true;\n            while(!q.empty()){\n                auto [x, y] = q.front();\n                q.pop();\n                if(grid[x][y] > mid) continue;\n                for(int i = 0; i < 4; ++i){\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if(nx >= 0 && nx < n && ny >= 0 && ny < n && !vis[nx * n + ny] && grid[nx][ny] <= mid){\n                        vis[nx * n + ny] = true;\n                        q.emplace(nx, ny);\n                    }\n                }\n            }\n            if(vis[n * n - 1]){\n                ans = mid;\n                right = mid - 1;\n            }\n            else{\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["图论","BFS","二分法"],"categories":["LeetCode"]},{"title":"LeetCode1631-最小体力消耗路径","url":"/blog/2021/01/29/LeetCode1631-最小体力消耗路径/","content":"\n#### 题目描述\n\n你准备参加一场远足活动。给你一个二维 `rows x columns` 的地图 `heights` ，其中 `heights[row][col]` 表示格子 `(row, col)` 的高度。一开始你在最左上角的格子 `(0, 0)` ，且你希望去最右下角的格子 `(rows-1, columns-1)` （注意下标从 **0** 开始编号）。你每次可以往 **上**，**下**，**左**，**右** 四个方向之一移动，你想要找到耗费 **体力** 最小的一条路径。\n\n一条路径耗费的 **体力值** 是路径上相邻格子之间 **高度差绝对值** 的 **最大值** 决定的。\n\n请你返回从左上角走到右下角的最小 **体力消耗值** 。\n\n<!-- more-->\n\n<img src=\"LeetCode1631-最小体力消耗路径\\1631.png\"  />\n\n<img src=\"LeetCode1631-最小体力消耗路径\\1631-提示.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n将本题抽象为一个图论模型：\n\n* 将每个位置抽象为一个节点，共有 `m * n` 个节点。\n* 每个节点与其上下左右构成带权无向图（存在此节点的话），其权值为节点间高度差的绝对值。\n* 寻找一条从左上角到右下角的最短路径，一条路径的长度定义为所有边权的最大值。\n\n我们可以设置一个阈值 x，看是否存在一条路径，从左上角到右下角所累加的权值小于等于 x；如果小于等于 x，说明可能存在更小的阈值，使路径存在，并进一步缩小阈值范围。\n\n本题高度差范围是 `[1,1000000]`，从 0 到 999999 设置阈值，进行二分搜索。\n\n**对于图论的最短路径问题，考虑使用广度优先搜索（BFS）**。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int dx[4] = {-1,1,0,0};\n    int dy[4] = {0,0,-1,1};\n    int minimumEffortPath(vector<vector<int>>& heights) {\n        int m = heights.size(); \n        int n = heights[0].size();\n        int ans = 0;\n        int left = 0, right = 1000000 - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            queue<pair<int, int>> q;\n            q.push({0, 0});\n            vector<bool> vis(m * n, 0);\n            vis[0] = true;\n            while(!q.empty()){\n                auto [x, y] = q.front();\n                q.pop();\n                for(int i = 0; i < 4; ++i){\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if(nx >= 0 && nx < heights.size() && ny >= 0 && ny < heights[0].size() && !vis[nx * n + ny] && abs(heights[nx][ny] - heights[x][y]) <= mid){\n                        vis[nx * n + ny] = true;\n                        q.emplace(nx, ny);\n                    }\n                }\n            }\n            if(vis[m * n - 1]){\n                ans = mid;\n                right = mid - 1;\n            }\n            else{\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/","tags":["图论","BFS","二分法"],"categories":["LeetCode"]},{"title":"文件管理（四）","url":"/blog/2021/01/28/文件管理（四）/","content":"\n#### 本次学习要点\n\n1. 磁盘的结构\n2. 磁盘调度算法\n3. 减少磁盘延迟时间的方法\n4. 磁盘的管理\n\n<!-- more-->\n\n#### 磁盘的结构\n\n##### 磁盘、磁道、扇区\n\n磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。\n\n磁道与扇区：\n\n<img src=\"文件管理（四）\\磁道与扇区.png\" style=\"zoom:80%;\" />\n\n##### 如何在磁盘中读/写数据\n\n将**磁头**移动到想要读/写扇区所在的磁道，磁盘转动，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。\n\n##### 盘面、柱面\n\n<img src=\"文件管理（四）\\盘面、柱面.png\" style=\"zoom:80%;\" />\n\n##### 磁盘的物理地址\n\n地址形式：（柱面号，盘面号，扇区号）。\n\n**如何读写？**\n\n1. 根据柱面号移动磁臂，让磁头指向指定柱面。\n2. 激活指定盘面对应的磁头。\n3. 磁盘旋转的过程中，指定的扇区会从磁头下面划过，完成读写。\n\n##### 小结\n\n<img src=\"文件管理（四）\\磁盘的结构小结.png\"  />\n\n#### 磁盘调度算法\n\n##### 一次磁盘读写操作需要的时间\n\n**寻道时间** $T_s$：在读写数据前，将磁头移动到指定磁道所花的时间。\n$$\nT_s = s + m\\times n\n$$\n其中，$s$ 为启动磁头臂时间；$m$ 为跨越一个磁道耗时；$n$ 为跨越磁道总数。\n\n**延迟时间** $T_R$：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。\n$$\nT_R = \\frac{1}{2} \\times \\frac{1}{r} = \\frac{1}{2r}\n$$\n其中，$\\frac{1}{2}$ 为平均找到目标扇区所走的圈数；$r$ 为磁盘转速。\n\n**传输时间** $T_t$：从磁盘读写数据所需时间。\n$$\nT_t = \\frac{1}{r} \\times \\frac{b}{N} = \\frac{b}{rN}\n$$\n其中，$r$ 为磁盘转速；$b$ 为此次读写的字节数；$N$ 为每个磁道上的字节数。\n\n**后两个是磁盘固有时间消耗，无法优化**。总消耗时间 $T_a$ 如下：\n$$\nT_a = T_s + \\frac{1}{2r} + \\frac{b}{rN}\n$$\n**消耗时间的优化主要从寻道时间入手**。\n\n##### 先来先服务算法（FCFS）\n\n根据进程请求访问磁盘的先后顺序进行调度。\n\n* 优点：公平；如果请求访问的磁道比较集中，性能还行。\n* 缺点：如果大量进程竞争使用磁盘且较分散，性能差，寻到时间长，\n\n##### 最短寻找时间优先（SSTF）\n\n此算法优先处理与当前磁头最近的磁道。可保证每次的寻道时间最短，但不保证总寻道时间最短。\n\n* 优点：性能较好，平均寻道时间短。\n* 缺点：可能产生**饥饿**现象。\n\n##### 扫描算法（SCAN）\n\n在 SSTF 算法的基础上规定：只有磁头移动到嘴最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动，也叫电梯算法。\n\n* 优点：性能较好，平均寻道时间短，不会产生饥饿现象。\n* 缺点：①只有到最边上才会改变磁头方向；②各个位置磁道的响应频率不平均，靠边的响应频率更高一些。\n\n##### LOOK 调度算法\n\n**为解决 SCAN 缺点①。**\n\n在 SCAN 算法的基础上规定：如果在磁头移动的方向上已经没有别的请求，就可以立即改变磁头移动方向。\n\n* 优点：较 SCAN 算法寻道时间进一步缩短。\n\n##### 循环扫描算法（C-SCAN）\n\n**为解决 SCAN 缺点②。**\n\n在 SCAN 算法的基础上规定：只有朝某个方向移动磁头时才处理磁道访问请求，返回时直接移动至起始端。\n\n* 优点：磁道响应平均。\n* 缺点：到最边上才改变磁头方向。\n\n##### C-LOOK 调度算法\n\n在 C-SCAN 算法的基础上规定：如果磁头移动的方向上已经没有磁道访问请求了，可以让磁头立即返回有磁道访问请求的位置。\n\n##### 小结\n\n<img src=\"文件管理（四）\\磁盘调度算法小结.png\"  />\n\n#### 减少延迟时间的方法\n\n磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，需要较长延迟时间。\n\n##### 交替编号\n\n让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。\n\n<img src=\"文件管理（四）\\交替编号.png\"  style=\"zoom:80%;\" />\n\n##### 错位命名\n\n相邻盘面的扇区编号错位。\n\n<img src=\"文件管理（四）\\错位命名.png\" style=\"zoom:80%;\" />\n\n##### 磁盘地址结构的设计\n\n为什么磁盘的物理地址是 （柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？\n\n答：读取地址连续的磁盘块时，采用前者可以减少磁头移动消耗的时间。\n\n#### 小结\n\n<img src=\"文件管理（四）\\减少延迟时间的方法.png\"  />\n\n#### 磁盘的管理\n\n##### 磁盘初始化\n\n1. 低级初始化（物理格式化）：将磁盘的各个磁道划分为扇区。一个扇区分为 头、数据区域（如512B大小）、尾 三个部分。\n2. 将磁盘分区，每个分区由若干**柱面**组成（C、D、E盘等）。\n3. 逻辑格式化，创建文件系统。创建文件根目录，初始化存储空间管理所用的数据结构，如位示图、空闲分区表等。\n\n##### 引导块\n\n计算机开机时需要初始化，通过执行**初始化程序（自举程序）**完成。\n\n<img src=\"文件管理（四）\\自举程序.png\" style=\"zoom:80%;\" />\n\n完整的自举程序放在磁盘的启动块（引导块/启动分区）上，启动块位于磁盘的固定位置，拥有启动分区的磁盘称为启动磁盘或系统磁盘（C盘）。\n\n##### 坏块的管理\n\n简单磁盘可以在**逻辑格式化**时，对磁盘进行坏块检查，标明坏扇区，如：在 FAT 表上标明，坏块对操作系统不透明。\n\n复杂磁盘会有一个**磁盘控制器**（磁盘中的一个硬件）来维护坏块链表。同时会保留一些“备用扇区”，用于替换坏块。此种方式坏块对操作系统透明。\n\n##### 小结\n\n<img src=\"文件管理（四）\\磁盘的管理.png\"  />","tags":["磁盘"],"categories":["操作系统"]},{"title":"文件管理（三）","url":"/blog/2021/01/28/文件管理（三）/","content":"\n#### 本次学习要点\n\n1. 文件的基本操作\n2. 文件共享\n3. 文件保护\n4. 文件系统的层次结构\n\n<!-- more-->\n\n#### 文件的基本操作\n\n##### 创建文件\n\n使用 **create** 系统调用，需要提供几个主要参数：\n\n1. 所需的外存空间大小。\n2. 文件存放路径。\n3. 文件名。\n\n操作系统在处理 **create** 系统调用时，主要做了两件事：\n\n1. 在外存中找到文件所需的空间（空闲链表法等）。\n2. 根据文件存放路径信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。\n\n##### 删除文件\n\n使用 **delete** 系统调用，需要提供几个主要参数：\n\n1. 文件存放路径。\n2. 文件名。\n\n操作系统在处理 **delete** 系统调用时，主要做了三件事：\n\n1. 从目录中找到文件名对应的目录项。\n2. 根据目录项记录的文件信息，回收文件占用的磁盘块。\n3. 从目录表中删除文件对应的目录项。\n\n##### 打开文件\n\n使用 **open** 系统调用，需要提供几个主要参数：\n\n1. 文件存放路径。\n2. 文件名。\n3. 要对文件的操作类型（如：r 只读；rw 读写等）。\n\n操作系统在处理 **open** 系统调用时，主要做了两件事：\n\n1. 从目录中找到文件名对应的目录项，并检查该用户是否有指定的操作权限。\n2. 将目录项复制到内存中的**打开文件表**中。并返回对应的编号返回。之后用户使用打开文件表的编号来知名要操作的文件。这样做可以加快文件的访问速度。\n\n##### 关闭文件\n\n进程使用完文件后，要关闭文件，操作系统在处理 **close** 系统调用时，需要做以下三件事：\n\n1. 将**用户进程的打开文件表**相应表项删除。\n2. 回收分配给该文件的内存空间等资源。\n3. **系统打开文件表（整个系统只有一张）**的打开计数器 count 减一，若 count = 0，则删除对应表项。\n\n##### 读文件\n\n使用 **read** 系统调用，需要提供几个主要参数：\n\n1. 指明是哪个文件。\n2. 指明要读入多少数据。\n3. 指明读入的数据放在内存何处。\n\n操作系统从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。\n\n##### 写文件\n\n使用 **write** 系统调用，需要提供几个主要参数：\n\n1. 指明是哪个文件。\n2. 指明要写出多少数据。\n3. 写回外存的数据放在内存中的什么位置。\n\n操作系统从用户指定的内存区域中，将指定大小的数据写回指针指向的外存。\n\n##### 小结\n\n<img src=\"文件管理（三）\\文件基本操作小结.png\"  />\n\n#### 文件共享\n\n操作系统提供给用户文件共享功能，可以让多个用户共享的使用同一个文件。\n\n##### 基于索引结点的共享方式（硬链接）\n\n由于检索时只需用到文件名，所以将除了文件名之外的其他信息放到索引结点中，目录项仅包含文件名和索引结点指针。\n\n<img src=\"文件管理（三）\\索引结点.png\" style=\"zoom:80%;\" />\n\ncount 记录链接到本索引结点上的用户目录项数，当 count = 0 时，系统删除该文件。\n\n##### 基于符合链的共享方式（软链接）\n\n使用 **link** 类型文件，记录**文件的路径**。\n\n<img src=\"文件管理（三）\\符号链.png\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"文件管理（三）\\文件共享小结.png\" style=\"zoom:80%;\" />\n\n#### 文件保护\n\n保护文件数据的安全。\n\n##### 口令保护\n\n为文件设置一个口令，用户请求访问该文件时必须提供口令。\n\n* 优点：保存口令的空间开销不多，验证口令的时间开销小。\n* 缺点：正确的口令存放在系统内部，不够安全。\n\n##### 加密保护\n\n使用某个密码对文件进行加密，访问文件时需提供正确密码。例如：异或加密。\n\n* 优点：保密性强，不需要在系统中存储密码。\n* 缺点：编/解码，加/解密需要花费一定时间。\n\n##### 访问控制\n\n在每个文件的 FCB 中增加一个**访问控制列表（Access-Control List, ACL）**，该表记录各个用户可以对该文件进行的操作。\n\n<img src=\"文件管理（三）\\访问控制.png\" style=\"zoom:80%;\" />\n\n精简访问列表：可将用户以**组**为单位，来管理用户可以进行哪些操作。\n\n<img src=\"文件管理（三）\\精简访问列表.png\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"文件管理（三）\\文件保护小结.png\" style=\"zoom:80%;\" />\n\n#### 文件系统的层次结构\n\n<img src=\"文件管理（三）\\文件系统的层次结构.png\"  />\n\n##### 一个例子\n\n某用户请求删除文件 `test.txt` ：\n\n1. 用户通过操作系统提供的接口发出删除请求——**用户接口**。\n2. 用户提供的是文件存放路径，操作系统需查找目录，找到目录项——**文件目录系统**。\n3. 不同用户的操作权限不同，需要检查用户的权限——**存取控制模块（存取控制验证层）**。\n4. 验证权限后，操作系统将用户提供的**记录号**转变为对应的逻辑地址——**逻辑文件系统与文件信息缓冲区**。\n5. 将逻辑地址转换为物理地址——**物理文件系统**。\n6. 要删除这条记录，需要对磁盘设备发出请求——**设备管理程序模块**。\n7. 删除后，会有一些磁盘空闲，因此需要将其回收——**辅助分配模块**。","tags":["文件共享","文件保护"],"categories":["操作系统"]},{"title":"LeetCode1579-保证图可完全遍历","url":"/blog/2021/01/27/LeetCode1579-保证图可完全遍历/","content":"\n#### 题目描述\n\nAlice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边：\n\n* 类型 1：只能由 Alice 遍历。\n* 类型 2：只能由 Bob 遍历。\n* 类型 3：Alice 和 Bob 都可以遍历。\n\n给你一个数组 $edges$ ，其中 $edges[i] = [type_i, u_i, v_i]$ 表示节点 $u_i$ 和 $v_i$ 之间存在类型为 $type_i$ 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。\n\n返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1。\n\n<!-- more-->\n\n<img src=\"LeetCode1579-保证图可完全遍历\\1567.png\" style=\"zoom:120%;\" />\n\n#### 思路\n\n本题和[LeetCode1319-连通网络的操作次数](http://www.xingyuzhao.ltd/blog/2021/01/23/LeetCode1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/#more)很相似，可以说是1319的加强版。这道题需要给两位主角分别建立一个并查集，并且要解决下面三个问题：\n\n**1. 如何判断边重复？**\n\n在进行 `union` 操作前后，如果 `count` 变化（减一），代表进行了合并；否则，说明此边重复，可以删掉。\n\n**2. 什么是公共边？**\n\n对于此题来说，$type$ 为 3 的边既可以被 Alice 遍历，也可以被 Bob 遍历。所以此种类型的边就是公共边。\n\n**3. 如何处理公共边？**\n\n这是本题的重点，对 Alice 和 Bob 分别根据公共边进行合并。\n\n* 如果先对 Alice 根据公共边合并，当发现边重复时，就需要删掉此边，不会对节点之间的连通性造成任何影响。\n* 再对 Bob 根据公共边合并时，就不需要删边了，因为上一步已经删去了重复公共边，不需要再一次删除了。两者的联通集是一致的。\n\n总而言之，**公共边只能删除一次。**\n\n经历上述操作后，再分别对两个人按照自己可以遍历的类型进行合并，同样遇到了重复边可以删掉。将重复公共边总数和非公共边重复总数求和，就是最终结果了。\n\n当然，如果合并结束后，两个并查集中有一个或多个不止一个联通集，说明无法全部遍历，返回 -1。\n\n#### 代码\n\n顺序可能不太一致，但不影响最终结果。\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\n        unionFind Alice(n);\n        unionFind Bob(n);\n        int cnt = 0;\n        // Alice\n        for(auto &edge : edges){\n            int type = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            if(type != 3) continue;\n            int count = Alice.getCount();\n            Alice.unionElem(u - 1, v - 1);\n            if(Alice.getCount() == count)\n                cnt++;\n        }\n        for(auto &edge : edges){\n            int type = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            if(type != 1) continue;\n            int count = Alice.getCount();\n            Alice.unionElem(u - 1, v - 1);\n            if(Alice.getCount() == count)\n                cnt++;\n        }\n        // Bob\n        for(auto &edge : edges){\n            int type = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            if(type != 3) continue;\n            Bob.unionElem(u - 1, v - 1);\n        }\n        for(auto &edge : edges){\n            int type = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            if(type != 2) continue;\n            int count = Bob.getCount();\n            Bob.unionElem(u - 1, v - 1);\n            if(Bob.getCount() == count)\n                cnt++;\n        }\n        return Alice.getCount() == 1 && Bob.getCount() == 1 ? cnt : -1;\n    }\n};\n```\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode959-由斜杠划分区域","url":"/blog/2021/01/25/LeetCode959-由斜杠划分区域/","content":"\n#### 题目描述\n\n在由 1 x 1 方格组成的 N x N 网格 `grid` 中，每个 1 x 1 方块由 `/`、`\\` 或空格构成。这些字符会将方块划分为一些共边的区域。\n\n（请注意，反斜杠字符是转义的，因此 `\\` 用 `\"\\\\\"` 表示。）。\n\n返回区域的数目。\n\n<!-- more-->\n\n<img src=\"LeetCode959-由斜杠划分区域\\959.png\"  />\n\n#### 思路\n\n输入 `grid` 的长度 `n` 就是网格的**边长**。比如示例中 `grid` 的长度为2，那么就是对 $2\\times2$ 的网格中的每一小格，通过字符确定如何划分这一小格。\n\n将一个小格分为**4**个部分，分别为 `0,1,2,3`，如下：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_1.png\"  />\n\n* 如果输入字符为 `\"/\"` ，则将 `0-1` 与 `3-2` 分别连接。\n* 如果输入字符为 `\"\\\\\"` ，则将 `0-3` 与 `1-2` 分别连接。\n\n* 如果输入字符为 ` \" \"`，则将 `0-1-2-3` 全部连接。\n\n左右相邻的两个小格需要将左边的 `1` 与右边的 `3` 相连：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_2.png\" style=\"zoom:80%;\" />\n\n上下相邻的两个小格需要将上面的 `2`  与下边的 `0` 相连：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_3.png\"  />\n\n除了第一行和第一列，其他的行和列都需要考虑上述两种相邻的情况。\n\n合并结束后，连通集的个数就是区域的数目。\n\n以示例4为例：\n\n* 仅对于每个字符合并：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_4.png\"  />\n\n* 对行和列相邻的小格进行合并：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_5.png\"  />\n\n如上图所示，区域一共有5个。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(0);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int genCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic: \n    int regionsBySlashes(vector<string>& grid) {\n        int n = grid.size();\n        unionFind uf(4 * n * n);\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                int start = 4 * (i * n + j); // 0号位置\n                switch(grid[i][j]){\n                    case ' ':\n                        uf.unionElem(start, start + 1);\n                        uf.unionElem(start + 1, start + 2);\n                        uf.unionElem(start + 2, start + 3);\n                        break;\n                    case '/':\n                        uf.unionElem(start, start + 3);\n                        uf.unionElem(start + 1, start + 2);\n                        break;\n                    case '\\\\':\n                        uf.unionElem(start, start + 1);\n                        uf.unionElem(start + 2, start + 3);\n                        break;\n                }\n                // 连接同一列2-0\n                if(i > 0) uf.unionElem(start, start - 4 * n + 2);\n                // 连接同一行1-3\n                if(j > 0) uf.unionElem(start + 3, start - 3);\n            }\n        }\n        return uf.genCount();\n    }\n};\n```\n\n#### Reference\n\n评论区：https://leetcode-cn.com/problems/regions-cut-by-slashes/comments/","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode1319-连通网络的操作次数","url":"/blog/2021/01/23/LeetCode1319-连通网络的操作次数/","content":"\n#### 题目描述\n\n用以太网线缆将 `n` 台计算机连接成一个网络，计算机的编号从 `0` 到 `n-1`。线缆用 `connections` 表示，其中 `connections[i] = [a, b]` 连接了计算机 `a` 和 `b`。\n\n网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。\n\n给你这个计算机网络的初始布线 `connections`，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。\n\n<!-- more-->\n\n<img src=\"LeetCode1319-连通网络的操作次数\\1319.png\"  />\n\n#### 思路\n\n首先我们需要得到**多余**的边的总数：先判断两个节点是否处于同一个连通集，如果处于同一个连通集并且当前还有一条边连接它们，那么就将**可用边**计数加1。\n\n其次，我们需要得到连通集的个数，连通集的总数减去1就是要将它们连接起来**所需要边**的个数。\n\n如果**可用边**小于**所需要边**的个数，就返回-1，代表无法使所有计算机连通。否则，取两者中的较小值，就是最小需要移动边的个数。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(0);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[qRoot] < rank[pRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        unionFind uf(n);\n        int lines = 0;\n        for(int i = 0; i < connections.size(); ++i){\n            int count = uf.getCount();\n            uf.unionElem(connections[i][0], connections[i][1]);\n            if(count == uf.getCount()) lines++;\n        }  \n        int need = uf.getCount() - 1;\n        // cout << lines << \" \" << need;\n        if(lines >= need){\n            return min(lines, need);\n        }\n        return -1;\n    }\n};\n```\n\n\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"C++动态数组","url":"/blog/2021/01/20/C-动态数组/","content":"\n#### 本次学习要点\n\n1. `new` 和数组\n2. `allocator` 类\n3. 使用标准库：文本查询程序\n\n<!-- more-->\n\n#### new和数组\n\n使用 `new` 分配一个对象数组，在类型名后跟一对方括号，在其中指明要分配的对象的数目：\n\n```cpp\nint *pia = new int[get_size()]; // pia指向第一个int\n// 类型别名\ntypedef int arrT[42]; // arrT表示42个int的数组类型\nint *p = new arrT; // 分配一个42个int的数组；p指向第一个int\n```\n\n##### 分配一个数组会得到一个元素类型的指针\n\n分配的内存不是一个数组类型，因此不能对动态数组调用 `begin` 和 `end` ，也不能用范围 `for`。\n\n##### 初始化动态分配对象的数组\n\n动态数组中的元素可以进行值初始化：\n\n```cpp\nint *pi = new int[10]; // 未初始化\nint *pia = new int[10](); // 值初始化（0）\nstring *ps = new string[10]; // 10个空string\nstring *psa = new string[10](); // 同上\n```\n\n新标准下还可以用花括号列表进行初始化：\n\n```cpp\nint *pia = new int[10]{0,1,2,3,4,5,6,7,8,9};\n// 前四个用给定的初始化器初始化，剩余的进行值初始化\nstring *pia = new string[10]{\"a\",\"an\",\"the\",string(3, 'x')};\n```\n\n同时，动态分配一个空数组是合法的。\n\n##### 释放动态数组\n\n在指针前加上一个空方括号对：\n\n```cpp\ndelete []pa; // pa必须指向一个动态分配的数组或为空\n```\n\n##### 智能指针和动态数组\n\n```cpp\n// up指向一个包含10个未初始化int的数组\nunique_ptr<int[]> uo(new int[10]);\nup.release(); // 自动用delete[]销毁其指针\n```\n\n当一个 `unique_ptr` 指向一个数组时，可以使用下标运算符来访问数组中的元素：\n\n```cpp\nfor(size_t i = 0; i != 10; ++i)\n\tup[i] = i; // 为每个元素赋予一个新值\n```\n\n<img src=\"C-动态数组\\指向数组的unique_ptr.png\"  />\n\n*如果希望使用 `shared_ptr` 管理一个动态数组，必须提供自己定义的删除器。*\n\n#### allocator类\n\n标准库 `allocator` 类定义在 `memory` 中，它将内存分配和对象构造分离开来。当一个 `allocator` 对象分配内存时，它会根据给定的**对象类型**来确定恰当的内存大小和对齐位置：\n\n```cpp\nallocator<string> alloc; // 可以分配string的allocator对象\nauto const p = alloc.allocate(n); // 分配n个未初始化的string\n```\n\n<img src=\"C-动态数组\\标准库allocator类及其算法.png\"  />\n\n##### allocator 分配未构造的内存\n\n`allocator` 分配的内存是未构造的，我们按需要在此内存中使用 `construct` 构造对象：\n\n```cpp\nauto q = p; // q指向最后构造的元素之后的位置\nalloc.construct(q++); // *q为空字符串\nalloc.construct(q++, 10, 'c'); // *q为cccccccccc\nalloc.construct(q++, \"hi\"); // *q为hi\n```\n\n<img src=\"C-动态数组\\alloc_warning.png\"  />\n\n使用完对象后，必须对**每个构造**的元素调用 `destory` 来销毁它们。其接受一个指针，对指向的对象执行析构函数：\n\n```cpp\nwhile(q != p)\n\talloc.destory(--q); // 第一次调用时，q指向最后一个构造的元素\n```\n\n元素被销毁后，可以将这部分内存来保存其他 `string`，也可将其归还给系统，使用 `deallocate` 完成：\n\n```cpp\nalloc.deallocate(p, n);\n```\n\n##### 拷贝和填充未初始化内存的算法\n\n标准库还定义了两个伴随算法，可以在未初始化内存中创建对象：\n\n<img src=\"C-动态数组\\allocator算法.png\"  />\n\n#### 使用标准库：文本查询程序\n\n在一个给定的文件中查询单词，结果是单词在文件中出现的次数及其所在行。如果一个单词一行中出现多次，只列出一次。行会按照升序输出。\n\n读入一个英文文本，在其中查询单词 `element` ，输出结果的前几行如下图：\n\n<img src=\"C-动态数组\\example.png\"  />\n\n##### 查询类TextQuery\n\n```cpp\nclass TextQuery {\npublic:\n    using line_no = vector<string>::size_type;\n    TextQuery(ifstream&);\n    QueryResult query(const string&) const;\nprivate:\n    shared_ptr<vector<string>> file; // 输入文件，需要两个类共享\n    // 每个单词到它所在的行号的集合的映射\n    map<string, shared_ptr<set<line_no>>> wm;\n};\nTextQuery::TextQuery(ifstream &is): file(new vector<string>) {\n    string text;\n    while(getline(is, text)){ // 对文件中每一行\n        file->push_back(text); // 保存此行文本\n        int n = file->size() - 1; // 当前行号\n        istringstream line(text); // 将文本分解为单词\n        string word;\n        while(line >> word){ // 对行中的每个单词\n            // 如果单词不在wm中，以之为下标在wm中添加一项\n            // lines是一个引用，改变lines也会改变wm中的元素\n            auto &lines = wm[word];\n            if(!lines) // 在我们第一次遇到这个单词时，此指针为空\n                lines.reset(new set<line_no>); // 分配一个新的set\n            lines->insert(n); // 将此行号插入set中\n        }\n    }\n}\nQueryResult TextQuery::query(const string &sought) const {\n    // 如果未找到sought，返回一个指向此set的指针\n    static shared_ptr<set<line_no>> nodata(new set<line_no>);\n    // 使用find而不是下标运算符来查找单词，避免将单词添加到wm中\n    auto loc = wm.find(sought);\n    if(loc == wm.end())\n        return QueryResult(sought, nodata, file); // 未找到\n    else\n        return QueryResult(sought, loc->second, file);\n}\n```\n\n##### 查询结果类QueryResult\n\n```cpp\nstring make_plural(size_t ctr,const string &word, const string &ending);\n\nclass QueryResult {\n    friend ostream& print(ostream&, const QueryResult&); // 友元函数\npublic:\n    using line_no = vector<string>::size_type;\n    QueryResult(string s, shared_ptr<set<line_no>> p, shared_ptr<vector<string>> f):\n                sought(s), lines(p), file(f){ }\nprivate:\n    string sought; // 查询单词\n    shared_ptr<set<line_no>> lines; // 出现的行号\n    shared_ptr<vector<string>> file; // 输入文件\n};\nostream &print(ostream &os, const QueryResult &qr){\n    // 如果找到了单词，打印出现次数和所有出现的位置\n    os << qr.sought << \" occurs \" << qr.lines->size() << \" \"\n       << make_plural(qr.lines->size(), \"time\", \"s\") << endl;\n    // 打印单词出现的每一行\n    for(auto num : *qr.lines)\n        // 行号从1开始\n        os << \"\\t(lines \" << num + 1 << \") \"\n           << *(qr.file->begin() + num) << endl;\n    return os;\n}\nstring make_plural(size_t ctr, const string &word, const string &ending)\n{\n    return (ctr == 1) ? word : word + ending;//make_plural(wc, \"word \", \"s \")当输入中文本中\n    //word数大于一是在word后加s，为words为word的复数！\n}\n```\n\n##### 主函数\n\n```cpp\nvoid runQueries(ifstream &infile);\nint main() {\n    ifstream infile(\"test.txt\");\n    runQueries(infile);\n    return 0;\n}\nvoid runQueries(ifstream &infile){\n    TextQuery tq(infile);\n    while(true){\n        cout << \"输入要查询的单词，或按q退出：\";\n        string s;\n        if(!(cin >> s) || s == \"q\") break;\n        print(cout, tq.query(s)) << endl;\n    }\n}\n```\n\n##### 完整工程\n\nhttps://gitee.com/settlezxy/learning-cpp.git","tags":["动态数组"],"categories":["C++"]},{"title":"C++动态内存与智能指针","url":"/blog/2021/01/20/C-动态内存与智能指针/","content":"\n#### 本次学习要点\n\n1. `shared_ptr` 类\n2. 直接管理内存\n3. `shared_ptr` 和 `new` 结合使用\n4. 智能指针和异常\n5. `unique_ptr`\n6. `weak_ptr`\n\n<!-- more-->\n\n静态内存：保存局部 `static` 对象、类 `static` 数据成员及定义在任何函数之外的变量。\n\n栈内存：保存和定义在函数内的非 `static` 对象。\n\n除了静态内存和栈内存，程序还拥有一个内存池，被称为**自由空间**或**堆**。程序用堆来存储**动态分配**的对象，当动态对象不再使用时，必须用代码显式的销毁它们。\n\n**动态内存与智能指针**\n\n* `new` ：在动态内存中为对象分配空间并返回一个指向该对象的指针。\n* `delete` ：接受一个动态对象的指针，销毁该对象，并释放相关内存。\n\n不合理时释放内存会出现内存泄漏（忘记释放）或产生引用非法内存的指针（有指针还在引用内存时就释放了它）。\n\n标准库提供两种**智能指针**管理动态对象，它们可以自动释放所指向的对象。\n\n1. `shared_ptr` 允许多个指针指向同一个对象。\n2. `unique_ptr` 则**独占**所指向的对象。\n\n标准库还定义了一个名为 `weak_ptr` 的伴随类，它是一种弱引用（**?**），指向 `shared_ptr` 所管理的对象。这三种类型都定义在 `memory` 头文件中。\n\n#### shared_ptr类\n\n智能指针也是模板，必须提供指针可以指向的类型：\n\n```cpp\nshared_ptr<string> p1; // 指向string\nshared_ptr<list<int>>  p2; // 指向int的list\n```\n\n如果在一个条件判断中使用智能指针，效果就是检测它是否为空：\n\n```cpp\n// 如果p1不为空，并且指向一个空的string\nif(p1 && p1->empty())\n\t*p1 = \"hi\";\n```\n\n`shared_ptr `和 `unique_ptr` 都支持的操作：\n\n<img src=\"C-动态内存与智能指针\\shared_ptr与unique_ptr都支持的操作.png\"  />\n\n`shared_ptr` 独有的操作：\n\n<img src=\"C-动态内存与智能指针\\shared_ptr独有的操作.png\"  />\n\n##### make_shared函数\n\n此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 `shared_ptr`：\n\n```cpp\n// 指向一个值为42的int的shared_ptr\nshared_ptr<int> p3 = make_shared<int>(42);\n// 指向一个值初始化的int，即，值为0\nshared_ptr<int> p4 = make_shared<int>();\n// 也可以用auto\n```\n\n**调用make_shared<T>时必须与T的某个构造函数相匹配**。\n\n##### shared_ptr的拷贝和赋值\n\n当进行拷贝或赋值操作时，每个 `shared_ptr` 都会记录又多少个其他 `shared_ptr` 指向相同的对象：\n\n```cpp\nauto p = make_shared<int>(42);\nauto q(p); // p和q指向相同对象，此对象有两个引用者\n```\n\n每个 `shared_ptr` 都有要给**引用计数**，只要我们拷贝一个 `shared_ptr` ，计数器就会增加，当我们给 `shared_ptr` 赋予一个新值或是 `shared_ptr` 被销毁，计数器递减。\n\n一旦计数器变为0，它就会自动释放自己所管理的对象：\n\n```cpp\nauto r = make_shared<int>(42);\nr = q; // 给r赋值，令它指向另一个地址\n\t   // 递增q指向的对象的引用计数\n\t   // 递减r原来指向的对象的引用计数\n\t   // r原来指向的对象已经没有引用者，会自动释放\n```\n\n##### shared_ptr自动销毁所管理的对象\n\n当指向一个对象的最后一个 `shared_ptr` 被销毁时，`shared_ptr` 类会通过**析构函数**销毁此对象。`shared_ptr` 的析构函数会递减它所指向的对象的引用计数，如果引用计数变为0， `shared_ptr` 的析构函数就会销毁对象，并释放它占用的内存。\n\n##### shared_ptr还会自动释放相关联的内存\n\n<img src=\"C-动态内存与智能指针\\note_shared_ptr释放内存.png\"  />\n\n##### 使用了动态生存期的资源的类\n\n程序使用动态内存出于一下三种原因之一 ：\n\n1. 程序不知道自己需要使用多少对象。\n2. 程序不知道所需对象的准确类型。\n3. 程序需要在多个对象间共享数据。\n\n一般而言，如果两个对象共享底层的数据，当某个对象被销毁时，我们不能单方面的销毁底层数据：\n\n```cpp\nBlob<string> b1; // 空Blob\n{\t新作用域\n    Blob<string> b2 = {\"z\",\"zx\",\"zxy\"};\n \tb1 = b2; // b1和b2共享相同的元素\n} // b2被销毁了，但b2中的元素不能销毁\n  // b1指向最初由b2创建的元素\n```\n\n此例中，`b1` 和 `b2` 共享相同的元素。当 `b2` 离开作用域时，这些元素必须保留，`b1` 仍然在使用它们。\n\n#### 直接管理内存\n\n##### 使用new动态分配和初始化对象\n\n使用传统构造方式（使用圆括号），或列表初始化（使用花括号）初始化一个动态分配的对象：\n\n```cpp\nint *pi = new int(1024); // pi指向的对象的值为1024\nstring *ps = new string(10, '9'); // *ps为\"9999999999\"\n// vector有10个元素，值以此从0到9\nvector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};\n```\n\n对动态分配的对象进行值初始化：\n\n```cpp\nstring *ps = new string(); // 值初始化为空string\nint *pi = new int(); // 值初始化为0；*pi为0\n```\n\n##### 动态分配的const对象\n\n用 `new` 分配 `const` 是合法的，但必须进行初始化，返回一个指向 `cosnt` 的指针：\n\n```cpp\nconst int *pci = new const int(1024);\nconst string *pcs = new const string;\n// const对象是可以销毁的\ndelete pci;\n```\n\n##### 内存耗尽\n\n如果 `new` 不能分配所要求的内存空间，它会抛出一个类型为 `bad_alloc` 的异常，但是可以使用 `new`  的方式阻止其抛出异常，称这种形式的 `new` 为**定位new**：\n\n```cpp\n// 如果分配失败，new返回一个空指针\nint *p1 = new int; // 如果分配失败，new抛出std:bad_alloc;\nint *p2 = new (nothrow) int; // 如果分配失败，new返回要给空指针\n```\n\n##### 释放动态内存\n\n```cpp\ndelete p; // p必须指向一个动态分配的对象或是一个空指针\n```\n\n释放一块非 `new` 分配的内存，或者将相同的指针值释放多次，其行为是未定义的：\n\n```cpp\nint i;\nint *pi1 = &i;\ndelete pi1; // 未定义：pi1指向一个局部变量\nint *pi2 = nullptr;\ndelete pi2; // 正确：释放一个空指针总是没有错误的\n```\n\n##### 动态对象的生存期直到被释放时为止\n\n<img src=\"C-动态内存与智能指针\\warning_释放动态对象.png\"  />\n\n##### 使用new和delete管理动态内存存在的三个常见问题\n\n1. 忘记 `delete` 内存，会导致**内存泄漏**，因为这种内存永远不可能被归还给自由空间了，只有真正耗尽内存时，才能检测到这种错误。\n2. 使用已释放掉的内存。\n3. 同一块内存释放两次。\n\n##### delete之后重置指针值\n\n在 `delete` 之后，指针就变成了**空悬指针**，即，指向一块曾经保存数据对象但现在已经无效的内存的指针。\n\n#### shared_ptr和new结合使用\n\n我们可以使用 `new` 返回的指针来初始化智能指针：\n\n```cpp\nshared_ptr<int> p2(new int(42)); // p2指向一个值为42的int\n```\n\n接受指针参数的智能指针的构造函数是 `explicit` 的，因此必须使用直接初始化形式来初始化一个智能指针：\n\n```cpp\nshared_ptr<int> p1 = new int(1024); // 错误\nshared_ptr<int> p2(new int(1024)); // 正确\n```\n\n<img src=\"C-动态内存与智能指针\\定义和改变shared_ptr的其他方法1.png\"  />\n\n<img src=\"C-动态内存与智能指针\\定义和改变shared_ptr的其他方法2.png\"  />\n\n##### get使用注意\n\n<img src=\"C-动态内存与智能指针\\warning_get_use.png\"  />\n\n##### 其他shared_ptr操作\n\n我们可以同 `reset` 来将一个新的指针赋予一个 `shared_ptr` ：\n\n```cpp\np = new int(1024); // 错误，不能将一个指针赋予shared_ptr\np.reset(new int(1024)); // 正确，p指向一个新对象\n```\n\n`reset` 成员常与 `unique` 一起使用：\n\n```cpp\nif(!p.unique()){\n\tp.reset(new string(*p)); // 不是唯一用户，分配新的拷贝\n}\n*p += newVal; // 现在唯一，可以改变对象的值\n```\n\n#### 智能指针和异常\n\n如果使用智能指针，即使程序块过早结束，智能指针也能确保在内存不再需要时将其释放；而 `new` 和 `delete` 之间发生异常，且异常未被捕获，则内存就永远不会被释放了。\n\n##### 使用自己的释放操作\n\n有些类未定义析构函数，需要用户显示地释放所使用的任何资源。假定我们正在使用一个C和C++都使用的网络库，使用这个库的代码可能如下：\n\n```cpp\nstruct destination; // 表示我们正在连接什么\nstruct connection; // 使用连接所需的信息\nconnection connect(destination *); // 打开连接\nvoid disconnect(connect); // 关闭给定的连接\nvoid f(destination &d /* 其他参数 */){\n    // 获得一个连接，记住使用完之后要关闭！\n    connection c = connect(&d);\n    // 使用连接\n    // 如果我们在f推出前忘记调用disconnect，就无法关闭c了\n}\n```\n\n使用 `shared_ptr` 来保证 `connection` 被正确关闭：\n\n```cpp\n// 定义一个函数来代替delete\n// 这个「删除器」函数必须能够完成对shared_ptr中保存的指针进行释放的操作\nvoid end_connection(connection *p) { disconnect (*p); };\n// 创建shared_ptr时，可以传递一个（可选的）指向删除器函数的参数\nvoid f(destination &d /* 其他参数 */){\n    connection c = connect(&d);\n    shared_ptr<connection> p(&c, end_connection);\n    // 使用连接\n    // 当f退出时（即使时因为异常而退出），connection会被正确关闭\n}\n```\n\n#### unique_ptr\n\n当我们定义一个 `unique_ptr` 时，需要将其绑定到一个 `new` 返回的指针上。如果进行初始化，必须是直接初始化：\n\n```cpp\nunique_ptr<double> p1; // 可以指向一个double的unique_ptr\nunique_ptr<int> p2(new int(42)); // p2指向一个值为42的int\n```\n\n`unique` 不支持普通的拷贝或赋值操作：\n\n```cpp\nunique_ptr<string> p1(new string(\"zxy\"));\nunique_ptr<string> p2(p1); // 错误，不能拷贝\nunique_ptr<string> p3;\np3 = p2; // 错误，不能赋值\n```\n\n<img src=\"C-动态内存与智能指针\\unique_str操作.png\"  />\n\n可以通过 `release` 或 `reset` 将指针的所有权（非const）从一个 `unique_ptr` 转移给另一个 `unique_ptr`：\n\n```cpp\n// 将所有权从p1转移给p2，并将p1置空\nunique_ptr<string> p2(p1.release());\n// 将所有权从p3转移给p2，并将p3置空\nunique_ptr<string> p3(new string(\"Zxy\"));\np2.reset(p3.release()); // reset释放了p2原来指向的内存\n```\n\n需要注意：\n\n```cpp\np2.release(); // 错误，p2不会释放内存，而且我们丢失了指针\nauto p = p2.release(); // 正确，但必须记得delete(p);\n```\n\n##### 传递unique_ptr参数和返回unique_ptr\n\n不能拷贝 `unique_ptr` 规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 `unique_ptr` 。如下：\n\n```cpp\nunique_ptr<int> clone(int p){\n\treturn unique_ptr<int>(new int(p));\n}\n// 返回局部对象的拷贝\nunique_ptr<int> clone(int p){\n\tunique_ptr<int> ret(new int(p));\n    // ...\n    return ret;\n}\n```\n\n##### 向unique_ptr传递删除器\n\n用 `unique_ptr` 来代替 `shared_ptr` ，如下所示：\n\n```cpp\nvoid end_connection(connection *p) { disconnect (*p); };\n// 创建shared_ptr时，可以传递一个（可选的）指向删除器函数的参数\nvoid f(destination &d /* 其他参数 */){\n    connection c = connect(&d);\n    unique_ptr<connection, decltype(end_connection)*> \n        p(&c, end_connection);\n    // 使用连接\n    // 当f退出时（即使时因为异常而退出），connection会被正确关闭\n}\n```\n\n由于 `decltype(end_connection)` 返回一个函数类型，所以我们必须添加一个 `*` 来指出我们正在使用该类型的一个指针。\n\n#### weak_ptr\n\n`weak_ptr` 是一种不控制所指向对象生存期的智能指针，它指向一个由 `shared_ptr` 管理的对象。将一个 `weak_ptr` 绑定到一个 `shared_ptr` 不会改变 `shared_ptr` 的引用计数。一旦最后一个指向对象的 `shared_ptr` 被销毁，对象就会被释放。\n\n<img src=\"C-动态内存与智能指针\\weak_ptr.png\"  />\n\n创建一个 `weak_ptr` 时，要用一个 `shared_ptr` 来初始化它：\n\n```cpp\nauto p = make_shared<int>(42);\nweak_ptr<int> wp(p); // wp弱共享p，p的引用计数未改变\n```\n\n由于对象可能不存在，不能使用 `weak_ptr` 直接访问对象，必须调用 `lock`。如果对象存在， `lock` 返回一个指向共享对象的 `shared_ptr`。例如：\n\n```cpp\nif(shared_ptr<int> np = wp.lock()){ // 如果np不为空则条件成立\n\t// 在if中，np与p共享对象\n}\n```\n\n","tags":["智能指针"],"categories":["C++"]},{"title":"文件管理（二）","url":"/blog/2021/01/20/文件管理（二）/","content":"\n#### 本次学习要点\n\n1. 文件的物理结构\n3. 文件存储空间管理\n\n<!-- more-->\n\n#### 文件的物理结构\n\n对非空闲磁盘块的管理。磁盘中的存储单元被划分为一个个的“块、磁盘块、物理块”。**磁盘块的大小与内存块、页面的大小相同**。\n\n##### 连续分配\n\n连续分配方式要求每个文件在磁盘上占有一组连续的块。\n\n<img src=\"文件管理（二）\\连续分配目录.png\"  />\n\n优点：\n\n* 支持**顺序访问和直接访问（即随机访问）**。\n* 连续分配的文件在顺序访问时速度最快。\n\n缺点：\n\n* 不方便文件拓展。\n* 存储空间利用率低，会产生磁盘碎片。\n\n##### 链接分配\n\n链接分配采取**离散**分配的方式，可以为文件分配离散的磁盘块。分为**隐式链接**和显示链接。\n\n###### 隐式链接\n\n除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。\n\n<img src=\"文件管理（二）\\隐式链接.png\" style=\"zoom:80%;\" />\n\n优点：\n\n* 方便文件拓展，不会有碎片问题，外存利用率高。\n\n缺点：\n\n* 只能顺序访问，查找效率低，指向下一个盘块的指针也需要消耗少量的存储空间。\n\n###### 显式链接\n\n把用于链接文件各物理块的指针显式地存放在一张表中，即**文件分配表（FAT，File Allocation Table）**。\n\n<img src=\"文件管理（二）\\显式链接.png\" style=\"zoom:80%;\" />\n\n*一个磁盘仅设置一张FAT，开机时，将FAT读入内存，并常驻内存*。\n\n优点：\n\n* 方便文件拓展，不会有碎片问题，外存利用率高，并且支持**随机访问**。\n* 相比于隐式链接，地址转换不需要访问磁盘，因此文件的访问效率更高。\n\n缺点：\n\n* 文件分配表需要占用一定的存储空间。\n\n##### 索引分配\n\n索引分配允许文件离散地分配在各个磁盘块中，系统会为**每个文件**建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为**索引块**。文件数据存放的磁盘块称为**数据块**。\n\n<img src=\"文件管理（二）\\索引分配.png\" style=\"zoom:80%;\" />\n\n###### 链接方案\n\n如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。\n\n<img src=\"文件管理（二）\\索引分配-链接方案.png\" style=\"zoom:80%;\" />\n\n缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，导致磁盘 I/O 过多，查找效率低下。\n\n###### 多层索引\n\n建立多层索引（类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。\n\n<img src=\"文件管理（二）\\索引分配-多层索引.png\" style=\"zoom:80%;\" />\n\n*采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操作*。\n\n缺点：即使是小文件，访问一个数据块依然需要 K + 1 次读磁盘。\n\n###### 混合索引\n\n多种索引分配方式的结合。例如，一个文件的顶级索引中，既包含**直接地址索引（直接指向数据块）**，又包含**一级、二级间接索引**。\n\n<img src=\"文件管理（二）\\索引分配-混合索引.png\" style=\"zoom:80%;\" />\n\n优点：对于小文件来说，访问要给数据块所需的读磁盘次数更少。\n\n##### 文件的物理结构小结\n\n<img src=\"文件管理（二）\\文件的物理结构小结.png\"  />\n\n#### 文件存储空间管理\n\n对空闲磁盘块的管理。\n\n存储空间的初始化：将各个文件卷划分为目录区、文件区。\n\n* 目录区存放文件目录信息（FCB）、用于词牌存储空间管理的信息。\n* 文件区用于存放文件数据。\n\n##### 存储空间管理——空闲表法\n\n适用于连续分配方式。\n\n**如何分配连续的存储空间**：与内存管理中的动态分区分配类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。\n\n**如何回收磁盘块**：\n\n1. 回收区前后都没有相邻空闲区。\n2. 回收区的前后都是空闲区。\n3. 回收区前面是空闲区。\n4. 回收区后面是空闲区。\n\n*回收时注意表项的合并问题*。\n\n##### 存储空间管理——空闲链表法\n\n###### 空闲盘块链\n\n<img src=\"文件管理（二）\\空闲盘块链.png\" style=\"zoom:80%;\" />\n\n操作系统保存着**链头、链尾指针**。\n\n**如何分配**：若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针。\n\n**如何回收**：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。\n\n###### 空闲盘区链\n\n<img src=\"文件管理（二）\\空闲盘区链.png\" style=\"zoom:80%;\" />\n\n**如何分配**：若某文件申请 K 个盘块，可采用首次适应、最佳适应等算法从链头开始检索，找到符合的一个空闲盘区；若没有合适的连续空闲块，可将不同盘区的盘块分配给文件。\n\n**如何回收**：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为一个单独的空闲盘区挂到链尾。\n\n##### 存储空间管理——位示图法\n\n<img src=\"文件管理（二）\\位示图法.png\"  />\n\n**位示图**：每个二进制位对应一个盘号，空闲为 0，已分配为 1。位示图用**字**来表示，上图字长为16。可以用**（字号，位号）**对应一个盘块号。\n\n* $（字号，位号）=(i,j)$ 的**二进制位**对应的**盘块号** $b=n\\times i + j$。\n\n* $b$ 号**盘块**对应的**字号** $i=b/n$，位号 $j=b\\%n$。\n\n**如何分配**：若文件需要 K 个块：\n\n1. 顺序扫描位示图，找到 K 个相邻或不相邻的 0。\n2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件。\n3. 将相应位设置为 1。\n\n**如何回收**：\n\n1. 根据回收的盘块号计算出对应的字号、位号。\n2. 将相应的二进制位设为 0。\n\n##### 存储空间管理——成组链接法\n\n文件卷目录区用一个磁盘块作为**超级块**，系统启动时将其调入内存，并保证内外存超级块数据一致。\n\n<img src=\"文件管理（二）\\超级块.png\"  />\n\n**超级块（空闲盘块号栈）**\n\n① 存放下一组空闲盘块的**盘块号**（不超过100）。\n\n② 此组空闲盘的**空闲块总数** N。\n\n**我的理解**：超级块大小等于其他块中的第一个空闲块。都是用来存储下一组空闲块信息的，主要针对**分配时只剩下一个空闲块**（此空闲块存储了下一组空闲块信息）或**回收时已经回收够100个空闲块**的特殊情况。**类似于链表中的哑节点**。\n\n<img src=\"文件管理（二）\\超级块1.png\" style=\"zoom:120%;\" />\n\n最后一组的 `s.free[0] = -1`，表示空闲盘块链的结尾标志。\n\n**N 兼做栈顶指针**\n\n例如，当 `N = 100` 时，它指向`s.free(99)`，即 N 指向 `s.free(N - 1)`。\n\n###### 空间分配\n\n将盘块 `4` 分配给文件，先将 `4` 出栈，再将 N 减1。同理再将 `3` 分配给文件，可得：\n\n<img src=\"文件管理（二）\\超级块2.png\" style=\"zoom:120%;\" />\n\n如果此时还要将 `2` 分配给文件（`2` 保存了下一个盘块的信息），需要进行以下操作：\n\n1. 将 `2` 的信息保存到超级块中，将 `2` 分配给文件。\n2. 更新指针。\n\n<img src=\"文件管理（二）\\超级块3.png\" style=\"zoom:120%;\" />\n\n###### 空间回收\n\n假如回收盘块 `4`，先将 `4` 压入栈中，再更新 N：\n\n<img src=\"文件管理（二）\\超级块4.png\" style=\"zoom:120%;\" />\n\n当栈满时，**会将超级块的内容复制到新回收的块中**，再更新指针，假如新回收的盘块为 `3`，可以得到下图:\n\n<img src=\"文件管理（二）\\超级块5.png\" style=\"zoom:120%;\" />\n\n再根据磁盘块 `3` 更新超级块中的栈和 N，显然 N 为1，超级块指向的下一个盘块只有 `3`，将 `3` 压入栈中，此时新回收盘块 `2`，将其压入栈中，N 再加1即可：\n\n<img src=\"文件管理（二）\\超级块6.png\" style=\"zoom:120%;\" />\n\n##### 文件的存储空间管理小结\n\n<img src=\"文件管理（二）\\文件的存储空间管理小结.png\"  />\n\n#### Reference\n\n成组链接法bilibili：https://www.bilibili.com/video/av71840093/\n\n实例讲解成组链接法：https://blog.csdn.net/smartab/article/details/81285353\n\n","categories":["操作系统"]},{"title":"LeetCode1584-连接所有点的最小费用","url":"/blog/2021/01/19/LeetCode1584-连接所有点的最小费用/","content":"\n#### 题目描述\n\n给你一个 `points` 数组，表示 2D 平面上的一些点，其中 `points[i] = [xi, yi]` 。\n\n连接点 `[xi, yi]` 和点 `[xj, yj]` 的费用为它们之间的 **曼哈顿距离** ：`|xi - xj| + |yi - yj|` ，其中 `|val|` 表示 `val` 的绝对值。\n\n请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。\n\n<!-- more-->\n\n<img src=\"LeetCode1584-连接所有点的最小费用\\1584.png\"  />\n\n#### 思路\n\n`points` 数组中两两节点相连构成一个完全图，根据 `Kruskal` 算法（并查集）找到完全图中的最小生成树，这棵树上的权值之和就是题目要求的最小费用。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\npublic:\n    unionFind(int n){\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n   bool unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return false;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[qRoot] < rank[pRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        return true;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n};\nstruct Edge{\n    int v, w;\n    int weight;\n    Edge(int v, int w, int weight) : v(v), w(w), weight(weight){}\n};\nclass Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        auto f = [](vector<int> &v1, vector<int> &v2) -> int{\n            return abs(v1[0] - v2[0]) + abs(v1[1] - v2[1]);\n        };\n        unionFind uf(points.size());\n        vector<Edge> edges;\n        for(int i = 0; i < points.size(); ++i){\n            for(int j = i + 1; j < points.size(); ++j){\n                edges.emplace_back(i, j, f(points[i], points[j]));\n            }\n        }\n        int res = 0;\n        int num = 0; // 记录最小生成树边的个数\n        // 每条边按照权值排序\n        sort(edges.begin(), edges.end(), [](Edge &a, Edge &b){\n            return a.weight < b.weight;\n        });\n        for(auto &[v, w, weight] : edges){\n            if(uf.isConnected(v, w)) continue;\n            res += weight;\n            num++;\n            uf.unionElem(v, w);\n            if(num == points.size() - 1) break;\n        }\n        return res;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/lian-jie-suo-you-dian-de-zui-xiao-fei-yo-kcx7/\n\n#### Appendix\n\n$\\text{Kruskal}$ 算法是一种常见并且好写的最小生成树算法，由 $\\text{Kruskal}$ 发明。该算法的基本思想是根据边的权值从小到大加入边，是一个贪心算法。\n\n其算法流程为：\n\n1. 将图 $G=\\{V,E\\}$ 中的所有边按照长度由小到大进行排序，等长的边可以按任意顺序。\n\n2. 初始化图 $G'$ 初始化为 $\\{V,\\varnothing\\}$，从前向后扫描排序后的边，如果扫描到的边 $e$ 在 $G'$ 中连接了两个不同的连通块,则将它插入 $G'$ 中。\n\n3. 最后得到的图 $G'$ 就是图 $G$ 的最小生成树。\n\n","tags":["并查集","图论","最小生成树"],"categories":["LeetCode"]},{"title":"LeetCode721-合并账户","url":"/blog/2021/01/18/LeetCode721-合并账户/","content":"\n#### 题目描述\n\n给定一个列表 `accounts`，每个元素 `accounts[i]` 是一个字符串列表，其中第一个元素 `accounts[i][0]` 是 名称 *(name)*，其余元素是 *emails* 表示该账户的邮箱地址。\n\n现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。\n\n合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。\n\n<!-- more-->\n\n<img src=\"LeetCode721-合并账户\\721.png\"  />\n\n#### 思路\n\n根据邮箱之间的连通性可以找到同一名字下的所有邮箱地址。可以将字符串映射到数字域方便建立并查集，同时需要建立反向哈希表，可以从数字得到字符串（数字必须唯一）。\n\n**算法如下**：\n\n* 使用并查集将同一名字下的邮箱地址进行合并。\n\n* 再次遍历 `accounts`，找到每个邮箱地址对应的根节点，根据根节点建立节点间的连通关系。\n\n* 从根节点邮箱找到对应的名字，然后再根据上一步的连通关系找到所有邮箱。\n\n细节详见代码。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\npublic:\n    unionFind(int n){\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(qRoot == pRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n    }\n};\nclass Solution {\npublic:\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\n        unordered_map<string, string> map; // 建立邮箱对名字的映射\n        unordered_map<string, int> stoi; // 将邮箱映射为数字，方便并查集处理\n        unordered_map<int, string> itos; // 将上面的数字映射为邮箱，反向映射\n        // 邮箱与数字之间的相互映射\n        int cnt = 0;\n        for(auto &account : accounts){\n            for(int i = 1; i < account.size(); ++i){\n                if(!stoi.count(account[i])){\n                    stoi[account[i]] = cnt;\n                    itos[cnt++] = account[i];\n                }\n            }\n        }\n        // 邮箱对名字的映射\n        for(auto &account : accounts){\n            for(int i = 1; i < account.size(); ++i){\n                if(!map.count(account[i])){\n                    map[account[i]] = account[0];\n                }\n            }\n        }\n        // 建立并查集，对同一名字下的所有邮箱进行合并\n        // 使不同的accounts之间，有相同的名字时必定在一个集合中\n        unionFind uf(stoi.size());\n        for(auto &account : accounts){\n            for(int i = 2; i < account.size(); ++i){\n                uf.unionElem(stoi[account[i]], stoi[account[i - 1]]);\n            }\n        }\n        // 找到邮箱对应的根节点，建立根节点与所有相连节点的映射\n        // 此处根节点是数字，下一步需要转换为相应的邮箱（itos），再根据邮箱得到名字（map）\n        unordered_map<int, set<string>> fin;\n        for(auto &account : accounts){\n            for(int i = 1; i < account.size(); ++i){\n                // 找到当前邮箱的根节点\n                int root = uf.find(stoi[account[i]]);\n                // 根据根节点建立连通关系\n                fin[root].insert(account[i]);\n            }\n        }\n        vector<vector<string>> res;\n        for(auto m = fin.begin(); m != fin.end(); ++m){\n            vector<string> buf;\n            // 根节点数字->根节点字符串->根节点对应的名字\n            buf.push_back(map[itos[m->first]]);\n            // 将根节点相连通的所有邮箱加入答案中，set已经进行排序\n            auto vec = vector<string>(m->second.begin(), m->second.end());\n            buf.insert(buf.end(), vec.begin(), vec.end());\n            res.push_back(buf);\n        }\n        return res;\n    }\n};\n```\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"文件管理（一）","url":"/blog/2021/01/16/文件管理（一）/","content":"\n#### 本次学习要点\n\n1. 初识文件管理\n2. 文件的逻辑结构\n3. 文件目录\n\n<!-- more-->\n\n#### 初识文件管理\n\n文件：一组有意义的信息/数据集合。\n\n##### 文件的属性\n\n文件名：由创建文件的用户决定，同一目录下不允许有重名文件。\n\n标识符：操作系统用于区分各个文件（文件名相同更应如此）的一种内部名称。\n\n类型：指明文件的类型。\n\n位置：文件存放的路径、在外存中的地址。\n\n大小：指明文件的大小。\n\n创建时间、上次修改时间、文件所有者信息。\n\n保护信息：对文件进行保护的访问控制信息。\n\n##### 文件内部数据的组织\n\n<img src=\"文件管理（一）\\文件内部数据的组织.png\"  />\n\n##### 操作系统应该向上提供的功能\n\n<img src=\"文件管理（一）\\操作系统应该向上提供的功能.png\"  />\n\n* 创建文件：新建后，图形化交互进程调用了**create系统调用**。\n* 读文件：使用**read系统调用**，将文件数据从外存读入内存。\n* 写文件：使用**write系统调用**，将文件数据从内存写回外存。\n* 删除文件：删除后，图形化交互进程调用了**delete系统调用**。\n\n* 打开文件：读/写文件之前，需要打开文件，使用**open系统调用**。\n* 关闭文件：读/写文件结束之后，需要关闭文件，使用**close系统调用**。\n\n##### 从上往下看，文件应如何存放在外存？\n\n类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址。每个存储单元对应一个物理地址。\n\n##### 其他需要由操作系统实现的功能\n\n* 文件共享：使多个用户可以共享使用要给文件。\n* 文件保护：不同的用户对文件有不同的操作权限。\n\n##### 小结\n\n<img src=\"文件管理（一）\\初识文件管理小结.png\"  />\n\n#### 文件的逻辑结构\n\n<img src=\"文件管理（一）\\文件的逻辑结构.png\" style=\"zoom:80%;\" />\n\n##### 无结构文件\n\n文件内部的数据就是一系列的二进制流或字符流组成。又称**流式文件**。如 `txt` 文件。\n\n##### 有结构文件\n\n由一组相似的记录组成，又称**记录式文件**。每条记录由若干个数据项组成，如数据库表文件。一般每条记录有一个数据项可作为**关键字**。根据各条记录的长度是否相等，可分为**定长记录**和**可变长记录**。\n\n##### 有结构文件的逻辑结构\n\n<img src=\"文件管理（一）\\有结构文件的逻辑结构.png\" style=\"zoom:80%;\" />\n\n###### 顺序文件\n\n文件中记录连续排列（逻辑上），记录可以是**定长**或**可变长**的。各个记录再物理上可以是**顺序存储**或**链式存储**。\n\n<img src=\"文件管理（一）\\顺序文件存储方式.png\"  />\n\n* 串结构：记录之间的顺序与关键字无关。\n* 顺序结构：记录之间的顺序按关键字顺序排列。\n\n<img src=\"文件管理（一）\\顺序文件存储方式+结构.png\" style=\"zoom:80%;\" />\n\n结论：定长记录的顺序文件，若物理上采用顺序存储，可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索。\n\n###### 索引文件\n\n**可变长记录**文件时查找第 `i` 个记录必须先查找前 `i-1` 个记录，如何解决这个问题？\n\n---\n\n索引表：**定长记录**的**顺序文件**，可以快速找到第 `i` 个记录对应的索引项。应用于对信息处理的及时性要求比较好的场合。\n\n<img src=\"文件管理（一）\\索引表.png\" style=\"zoom:80%;\" />\n\n###### 索引顺序文件\n\n与索引文件不同的是，不对每个记录都建立索引表项，而是**一组记录对应一个索引表项**。下图中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不许眼按关键字排序。**索引顺序文件指索引表中的项是按关键字排列的**。\n\n<img src=\"文件管理（一）\\索引顺序文件.png\" style=\"zoom:80%;\" />\n\n**多级索引顺序文件**\n\n为了进一步提高检索效率，可以为顺序文件建立多级索引表。\n\n<img src=\"文件管理（一）\\多级索引顺序文件.png\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"文件管理（一）\\文件的逻辑结构小结.png\"  />\n\n#### 文件目录\n\n<img src=\"文件管理（一）\\文件目录.png\" style=\"zoom:80%;\" />\n\n##### 文件控制块\n\n<img src=\"文件管理（一）\\文件控制块FCB.png\" style=\"zoom:80%;\" />\n\n**FCB**的有序集合称为“文件目录”，一个**FCB**就是一个文件**目录项**。\n\n**FCB**包含了文件的基本信息（文件名、物理地址、逻辑地址、物理结构等），存储控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（文件的建立时间、修改时间等）。\n\n**最基本的是**：文件名、文件存放的物理地址。\n\n对目录进行的操作：\n\n* 搜索：系统根据文件名搜索目录，找到该文件对应的目录项。\n* 创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项。\n* 删除文件：当删除一个文件时，需要在目录中删除对应的目录项。\n* 显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性。\n* 修改目录：目录中保存了某些文件属性，这些属性变化时需要修改相应的目录项（如文件重命名）。\n\n##### 目录结构\n\n###### 单级目录结构\n\n实现了**按名存取**，但是**不允许文件重名**。不适合多用户操作系统\n\n<img src=\"文件管理（一）\\单级目录结构.png\" style=\"zoom:80%;\" />\n\n###### 两级目录结构\n\n分为**主文件目录**和**用户文件目录**。\n\n<img src=\"文件管理（一）\\两级目录结构.png\" style=\"zoom:80%;\" />\n\n###### 多级目录结构（树形目录结构）\n\n文件路径名是个字符串，各级目录之间用”/“隔开， 从根目录出发的路径称为**绝对路径**。系统根据绝对路径一层一层的找到下一级目录。树形结构**不利于实现文件共享**。\n\n<img src=\"文件管理（一）\\多级目录结构.png\" style=\"zoom:80%;\" />\n\n`自拍.jpg`的绝对路径为`/照片/2015-0/自拍.jpg`。找到此文件需要3次读磁盘I/O操作。\n\n每次从根目录查找很低效，可以设置**当前目录**，当用户访问某个文件时，可以使用**从当前目录出发**的**相对路径**。\n\n###### 无环图目录结构\n\n<img src=\"文件管理（一）\\无环图目录结构.png\" style=\"zoom:80%;\" />\n\n用户提出删除节点时，只删除该用户的PCB，并使共享计数器减1，不会直接删去共享节点。只要共有计数器减为0时才删除节点。\n\n##### 索引节点（FCB的改进）\n\n一般查找只需要用到**文件名**这个信息，文件名匹配时才需要读出文件的其他信息，所以可以使目录表包含最有用的信息来提高效率，如下图：\n\n<img src=\"文件管理（一）\\索引节点.png\" style=\"zoom:80%;\" />\n\n存放在**外存**的索引节点称为**磁盘索引节点**，当索引节点**放入内存**后称为**内存索引节点**。内存索引节点需要增加一些信息，如：文件是否被修改，此时有几个进程在访问该文件等。\n\n##### 小结\n\n<img src=\"文件管理（一）\\文件目录小结.png\"  />\n\n","categories":["操作系统"]},{"title":"LeetCode947-移除最多的同行或同列石头","url":"/blog/2021/01/15/LeetCode947-移除最多的同行或同列石头/","content":"\n#### 题目描述\n\n`n` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。\n\n如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。\n\n给你一个长度为 `n` 的数组 `stones` ，其中 `stones[i] = [xi, yi]` 表示第 `i` 块石头的位置，返回 **可以移除的石子** 的最大数量。\n\n<!-- more-->\n\n<img src=\"LeetCode947-移除最多的同行或同列石头\\947.png\"  />\n\n#### 思路\n\n这个题的意思是：某行或者某列上最多只能存在一个石头，求移除的石头总数。\n\n对于 `stones` 中任意两个位置，如果相对应的位置有一个相等，说明两个位置存在**相同的**行或者列，可以合并为一个集合。根据上述条件，使用双重循环将 `stones` 两两结合，最终合并的次数就是移除的石头个数，可以由 `stones` 的长度减去并查集中连通分量个数得到。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(0);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int removeStones(vector<vector<int>>& stones) {\n        int n = stones.size();\n        unionFind uf(n);\n        for(int i = 0; i < n; ++i){\n            for(int j = i + 1; j < n; ++j){\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\n                    uf.unionElem(i, j);\n            }\n        }\n        return stones.size() - uf.getCount();\n    }\n};\n```\n\n时间复杂度为 `O(n^2)`。\n\n#### 更进一步\n\n如果将 `stones` 中的位置与其相应的行或者列绑定，那么可以将二维降为一维，将行和列当作一个数字，降低了时间复杂度。\n\n* 当遍历到点 `[x,y]` 时，直接将 `x` 和 `y` 进行合并，表示该行和该列的点属于同一个并查集（根节点相同）。\n* `x` 和 `y` 的值可能相等，相等时不能进行合并（一维情况下，行与列需要区分开），根据题目范围，将 `y` 加上10001，两者不会重合。\n\n##### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    unordered_map<int, int> parent, rank;\n    int count;\npublic:\n    unionFind():count(0){};\n    int find(int p){\n        // 当不存在p时，创建p并且指向自身，根节点数加1\n        if(!parent.count(p)){\n            parent[p] = p;\n            count++;\n        }\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int removeStones(vector<vector<int>>& stones) {\n        int n = stones.size();\n        unionFind uf;\n        for(auto &stone : stones){\n            uf.unionElem(stone[0], stone[1] + 10001); \n        }\n        return stones.size() - uf.getCount();\n    }\n};\n```\n\n#### Reference\n\n题解：https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode684-冗余连接","url":"/blog/2021/01/13/LeetCode684-冗余连接/","content":"\n#### 题目描述\n\n在本问题中, 树指的是一个连通且无环的无向图。\n\n输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以边组成的二维数组。每一个边的元素是一对 `[u, v]`，满足 `u < v`，表示连接顶点 `u` 和 `v` 的无向图的边。\n\n返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。\n\n<!-- more-->\n\n<img src=\"LeetCode684-冗余连接\\684.png\"  />\n\n#### 思路\n\n并查集中使用 `count` 记录当前还有多少个根节点，如果**上一次的根节点数等于本次的根节点数**，说明本次的合并无效，记录当前坐标即可。一次遍历结束后，找到了不需要进行合并的最后一个边。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--; // 合并一次，根节点数减1\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        unionFind uf(edges.size());\n        int pre; // 上一次根节点数\n        int index; // 不需要合并的最后一个边的位置\n        for(int i = 0; i < edges.size(); ++i){\n            pre = uf.getCount();\n            uf.unionElem(edges[i][0] - 1, edges[i][1] - 1);\n            // 上次根节点数等于本次合并后根节点数，更新index\n            if(pre == uf.getCount()) index = i;\n        }\n        return edges[index];\n    }\n};\n```\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode1203-项目管理","url":"/blog/2021/01/12/LeetCode1203-项目管理/","content":"\n#### 题目描述\n\n公司共有 `n` 个项目和  `m` 个小组，每个项目要不无人接手，要不就由 `m` 个小组之一负责。\n\n`group[i]` 表示第 `i` 个项目所属的小组，如果这个项目目前无人接手，那么 `group[i]` 就等于 `-1`。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。\n\n请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：\n\n同一小组的项目，排序后在列表中彼此相邻。\n项目之间存在一定的依赖关系，我们用一个列表 `beforeItems` 来表示，其中 `beforeItems[i]` 表示在进行第 `i` 个项目前（位于第 `i` 个项目左侧）应该完成的所有项目。\n如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 **空列表** 。\n\n<!-- more-->\n\n<img src=\"LeetCode1203-项目管理\\1203.png\"  />\n\n#### 思路\n\n这道题是真的难，看了别人的题解才勉强写出来。\n\n##### 拓扑排序\n\n在有向无环图（DAG）问题中，如果节点之间含有**依赖关系**，比如要完成 `B` 工作，必须先完成 `A` 工作，考虑进行**拓扑排序**，有关知识点参考[这里](https://www.cnblogs.com/bigsai/p/11489260.html)。\n\n**C++模板**：\n\n```cpp\n// 图，节点入度，节点编号\nvector<int> topSort(vector<vector<int>> &G, vector<int> &inDegree, vector<int> &id){\n    queue<int> q;\n    for(auto &i : id){\n        if(inDegree[i] == 0) q.push(i);\n    }\n    int times = 0; // 记录已经出队多少个点，小于节点数说明有环\n    vector<int> afterSort;\n    while(!q.empty()){\n        // 取出第一个入度为0的点\n        int cur = q.front();\n        afterSort.push_back(cur);\n        q.pop();\n        times++;\n        // 遍历图\n        for(int i = 0; i < G[cur].size(); ++i){\n            inDegree[G[cur][i]]--;\n            if(inDegree[G[cur][i]] == 0)\n                q.push(G[cur][i]);\n        }\n    }\n    if(times < id.size()) return {};\n    return afterSort;\n}\n```\n\n##### 关于本题\n\n从宏观来看，本题要求同一小组所处理的项目是相邻的，**小组与小组之间**是有依赖关系的，根据 `Before` 得到。同时，**项目与项目之间**也是有依赖关系的，也是由 `Before` 得到。以示例1为例：\n\n* 项目与项目之间：对于小组0，3必须在6之后，4必须在3和6之后。\n* 小组与小组之间：小组-1中的1必须在小组0中的6之后。\n\n根据以上两条信息，可以先对所有小组进行拓扑排序，再对排好序的小组集合中的每个小组进行一个拓扑排序，就可以得到结果了。**所有小组号为-1的表示当前未进行处理，可以给其分配一个新的组号，从m开始递增**，只要拓扑排序时无环，所有的项目都会被处理掉。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems){      \n        // 将同一组的放一起\n        // 比如3, 4, 6分组为0，则sameGroup[0] = {3,4,6}\n        vector<vector<int>> sameGroup(n + m);\n        int samegroup = m;\n        for(int i = 0; i < group.size(); ++i){\n            if(group[i] == -1) group[i] = samegroup++;\n            sameGroup[group[i]].push_back(i);\n        }\n        // 最多会有n + m个小组（比如m=2, 所有分组都为-1）\n        // n + m个小组的序号\n        vector<int> groupid;\n        for(int i = 0; i < n + m; ++i) groupid.push_back(i);\n        // 建立group图和item图及其入度\n        vector<vector<int>> itemGraph(n);\n        vector<vector<int>> groupGraph(n + m);\n        vector<int> itemIndegree(n, 0);\n        vector<int> groupIndegree(n + m, 0);\n        for(int i = 0; i < beforeItems.size(); ++i){\n            int curId = group[i];\n            for(auto &item : beforeItems[i]){\n                // 如果是同一个组，那么有item->i\n                // i入度+1，同时节点item可达i\n                if(group[item] == curId){ \n                    itemIndegree[i]++;\n                    itemGraph[item].push_back(i);\n                }\n                // 不同组，有小组group[item]->curId\n                // 小组curId入度+1，同时小组group[item]可达curId\n                else{ \n                    groupIndegree[curId]++;\n                    groupGraph[group[item]].push_back(curId);\n                }\n            }\n        }\n        // 对group图进行topSort，得到小组之间的拓扑关系\n        auto outGroup = topSort(groupGraph, groupIndegree, groupid);\n        // 对每个小组进行topSort，得到组内的拓扑关系\n        vector<int> ret;\n        for(auto &g : outGroup){\n            auto id = sameGroup[g];\n            if(id.empty()) continue;\n            auto res = topSort(itemGraph, itemIndegree, id);\n            if(res.empty()) return {};\n            for(auto &r : res)\n                ret.push_back(r);\n        }\n        return ret;\n    }\n    // 参数：图，入度，当前的节点集合\n    vector<int> topSort(vector<vector<int>> &G, vector<int> &inDegree, vector<int> &id){\n        queue<int> q;\n        for(auto &i : id){\n            if(inDegree[i] == 0) q.push(i);\n        }\n        int times = 0; // 记录已经出队多少个点，小于id数说明有环\n        vector<int> afterSort;\n        while(!q.empty()){\n            // 取出第一个入度为0的点\n            int cur = q.front();\n            afterSort.push_back(cur);\n            q.pop();\n            times++;\n            // 遍历图\n            for(int i = 0; i < G[cur].size(); ++i){\n                inDegree[G[cur][i]]--;\n                if(inDegree[G[cur][i]] == 0)\n                    q.push(G[cur][i]);\n            }\n        }\n        if(times < id.size()) return {}; // 有环，返回空\n        return afterSort;\n    }\n};\n```\n\n#### Reference\n\n题解：https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/chao-xiang-xi-shuang-ceng-tuo-bu-pai-xu-5cyuc/\n\n拓扑排序：https://www.cnblogs.com/bigsai/p/11489260.html","tags":["拓扑排序","图论"],"categories":["LeetCode"]},{"title":"LeetCode1202-交换字符串中的元素","url":"/blog/2021/01/11/LeetCode1202-交换字符串中的元素/","content":"\n#### 题目描述\n\n给你一个字符串 `s`，以及该字符串中的一些「索引对」数组 `pairs`，其中 `pairs[i] = [a, b]` 表示字符串中的两个索引（编号从 0 开始）。\n\n你可以 **任意多次交换** 在 `pairs` 中任意一对索引处的字符。\n\n返回在经过若干次交换后，`s` 可以变成的按字典序最小的字符串。\n\n<!-- more-->\n\n<img src=\"LeetCode1202-交换字符串中的元素\\1202.png\"  />\n\n#### 思路\n\n~~不看提示我都没想到用并查集去解决这个问题~~。\n\n以示例三为例：`s = \"cba\", pairs = [[0,1],[1,2]]`，输出为 `\"abc\"`。可以看出 `pairs` 中 `0,1,2` 三个点是相连的。相连的点在 `s` 中对应的元素 `\"cba\"` 可以任意排序，我们需要让这些元素的组合字典序最小，可以得到 `\"abc\"`。\n\n将上述例子扩充，`s = \"cbafd\", pairs = [[0,1],[1,2],[4,3]]`，输出为 `\"abcdf\"`。其中 `0,1,2` 相连，`4,3` 相连，分别将两个集合中对应的位置**升序排序**得到 `0,1,2` 和 `3,4`，再将 `s` 中对应位置元素取出来按照**字典序排序**，再根据对应位置修改 `s` 中的元素。所以**一共需要进行两次排序**。\n\n---\n\n我们将 `pairs` 中的**每一个**元素想象成一个孤立的点，对于 `pairs` 中的**每一对**元素，表示两个点相连，所有相连的点构成不同的集合（只需要知道是否相连，不需要知道如何相连），所以使用并查集即可。\n\n**算法如下**：\n\n* 将 `pairs` 中的**每一对**元素进行 `union` 操作，再将它们根据共同祖先分为**若干集合**。\n* 将每个集合中的序列**升序排列**，再找到 `s` 中对应的元素，将这些元素按**字典序**排序。\n* 将按字典序排列的元素按照集合中序列的顺序依次修改 `s`。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count; // 未用到\npublic:\n    unionFind(string &s){\n        this->count = 0; // 未用到\n        int n = s.size();\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[qRoot] < rank[pRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[qRoot] = pRoot;\n            rank[pRoot]++;\n        }\n    }\n};\nclass Solution {\npublic:\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\n        if(pairs.size() == 0) return s;\n        unionFind uf(s);\n        for(int i = 0; i < pairs.size(); ++i){\n            uf.unionElem(pairs[i][0], pairs[i][1]);\n        }\n        auto rootIdx = vector<vector<int>>(s.size());\n        // 如果祖先相同，代表在同一个集合中\n        for(int i = 0; i < s.size(); ++i){\n            int root = uf.find(i);\n            rootIdx[root].push_back(i);\n        }\n        for(int i = 0; i < rootIdx.size(); ++i){\n            if(rootIdx[i].empty()) continue;\n            // 将同一个祖先的序列升序排列\n            sort(rootIdx[i].begin(), rootIdx[i].end());\n            string buf;\n            // 根据排好序的序列取出s中的元素\n            for(auto &v : rootIdx[i]){\n                buf += s[v];\n            }\n            // 再将取出的元素按照字典序排列\n            sort(buf.begin(), buf.end());\n            int j = 0;\n            // 将排好序的字符串根据排好序的序列修改s中相应的位置\n            for(auto &v : rootIdx[i]){\n                s[v] = buf[j++];\n            }\n        }\n        return s;\n    }\n};\n```\n\n","tags":["并查集"],"categories":["LeetCode"]},{"title":"LeetCode228-汇总区间","url":"/blog/2021/01/10/LeetCode228-汇总区间/","content":"\n#### 题目描述\n\n给定一个无重复元素的有序整数数组 `nums` 。\n\n返回 **恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。\n\n列表中的每个区间范围 `[a,b]` 应该按如下格式输出：\n\n* `\"a->b\"` ，如果 `a != b`\n* `\"a\"` ，如果 `a == b`\n\n<!-- more-->\n\n<img src=\"LeetCode228-汇总区间\\228.png\"  />\n\n#### 思路\n\n如果序列满足 `nums[i] == nums[i - 1]` 代表它们是同一个区间。\n\n需要记录区间的起始位置的终止位置，使用双指针，`i` 代表当前区间的起始位置， `j` 代表当前区间的终止位置。\n\n遍历结束时，还需要**把最后一个区间加入答案中**，如果最后一个区间的 `j - i == 1`，说明最后一个区间只有一个数，否则，需要再加入一个新的区间。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        if(nums.empty()) return {};\n        vector<string> ret;\n        int i = 0, j = 1;\n        while(j < nums.size()){\n            if(nums[j] == nums[j - 1] + 1){\n                j++;\n            }\n            else{\n                if(j == i + 1){\n                    ret.push_back(to_string(nums[i]));\n                    j++;\n                    i++;\n                }\n                else{\n                    ret.push_back(to_string(nums[i]) + \"->\" + to_string(nums[j - 1]));\n                    i = j;\n                    j++;\n                }\n            }\n        }\n        if(i == j - 1) ret.push_back(to_string(nums[i]));\n        if(i != j - 1) ret.push_back(to_string(nums[i]) + \"->\" + to_string(nums[j - 1]));\n        return ret;\n    }\n};\n\n```\n\n","tags":["双指针"],"categories":["LeetCode"]},{"title":"LeetCode189-旋转数组","url":"/blog/2021/01/08/LeetCode189-旋转数组/","content":"\n#### 题目描述\n\n给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。\n\n**进阶**：\n\n* 尽可能想出更多的解决方案，~~至少有三种不同的方法可以解决这个问题~~。\n* 你可以使用空间复杂度为 O(1) 的 **原地** 算法解决这个问题吗？\n\n<!-- more-->\n\n<img src=\"LeetCode189-旋转数组\\189.png\"  />\n\n#### 思路\n\n根据 `k` 值，将 `nums` 数组分为前后两个部分。将后 `k` 个值截取出来得到的数组，拼接到剩余数组之前即可。空间复杂度为 `O(n)`。\n\n#### 代码\n\n```cpp\n// 99% 9%\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size(); // 如果k大于nums的长度，取余之后再进行处理\n        vector<int> buf1(nums.begin() + nums.size() - k, nums.end());\n        vector<int> buf2(nums.begin(), nums.begin() + nums.size() - k);\n        buf1.insert(buf1.end(), buf2.begin(), buf2.end());\n        nums = buf1;\n    }\n};\n```\n\n#### 更进一步\n\n上述的空间复杂度为 `O(n)`，可以进一步压缩空间，使空间复杂度降为 `O(1)`。\n\n##### 思路\n\n具体思路如下：\n\n```\nk = 3;\n---->--> 移动后得到 -->---->\n可以对原始序列进行如下操作：\n---->--> 反转后 <--<----\n其中<-- 反转后 --><----\n其中<---- 反转后 -->---->\n```\n\n##### 代码\n\n````cpp\n// 库函数 50.50% 84.77%\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    }\n};\n// 非库函数 50.50% 74.88%\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        reverse(nums, 0, nums.size() - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.size() - 1);\n    }\n    void reverse(vector<int> &nums, int start, int end){\n        while(start < end){\n            swap(nums[start], nums[end]);\n            start++;\n            end--;\n        }\n    }\n};\n````\n\n虽然速度慢了点（实际上为 `O(2n) = O(n)` ），不过空间使用较之前还是低了很多。\n\n#### Reference\n\n官方题解及其评论区：https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/","tags":["数组"],"categories":["LeetCode"]},{"title":"内存管理（五）","url":"/blog/2021/01/08/内存管理（五）/","content":"\n#### 本次学习要点\n\n1. 虚拟内存基本概念\n2. 请求分页管理方式\n3. 页面置换算法\n4. 页面分配策略\n\n<!-- more-->\n\n#### 虚拟内存基本概念\n\n##### 传统存储管理方式的特征、缺点\n\n传统存储管理特点：\n\n1. 一次性：作业必须**一次性全部装入内存**才能开始运行。\n2. 驻留性：一旦作业被装入内存，就**会一直驻留在内存中**。\n\n很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。\n\n##### 局部性原理\n\n* 时间局部性\n* 空间局部性\n\n##### 虚拟内存的定义和特征\n\n虚拟内存：若内存空间不够，由**操作系统**负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**。虚拟性体现在：实际的物理内存大小没有变，只是在逻辑上进行了扩充。\n\n* 虚拟内存最大容量：计算机的地址结构（CPU寻址范围）确定。\n* 虚拟内存实际容量：*min*(内存和外存容量之和，CPU寻址范围)。\n\n虚拟内存有以下三个特征：\n\n1. 多次性（对应一次性）：允许作业被分成多次调入内存。\n2. 对换性（对应驻留性）：允许作业运行中，将作业换出、换入内存。\n3. 虚拟性：从逻辑上扩充了内存的容量。\n\n##### 如何实现虚拟内存技术\n\n<img src=\"内存管理（五）\\虚拟内存的实现.png\"  />\n\n虚拟内存技术基于**离散分配**的内存管理方式。**请求分页存储管理**与**基本分页存储管理**的**主要区别**是：操作系统需要提供**请求调页**和**页面置换**功能。\n\n* 请求调页：程序执行过程中，当所访问信息**不在内存中**时，由操作系统负责**将所需信息从外存调入内存**。\n* 页面置换：若内存空间不够，由操作系统将**内存中暂时用不到的信息换出到外存**。\n\n##### 小结\n\n<img src=\"内存管理（五）\\虚拟内存基本概念小结.png\" style=\"zoom:120%;\" />\n\n#### 请求分页管理方式\n\n<img src=\"内存管理（五）\\请求分页管理方式.png\"  />\n\n##### 页表机制\n\n* 为了实现**请求调页**，操作系统需要知道每个页面是否已经调入内存；如果没调入，那么也需要知道该页面在外存中存放的位置。\n* 为了实现**内存置换**，操作系统需要通过某些指标来决定到底换出哪个页面。需要记录各个页面是否被修改过，修改过才需要换出，将外存中的旧数据覆盖。\n\n<img src=\"内存管理（五）\\页表机制.png\"  />\n\n##### 缺页中断机构\n\n请求分页系统中，若访问页面**不在内存中**时，便产生一个**缺页中断**。然后由操作系统的**缺页中断处理程序**处理中断。此时**缺页的进程阻塞**，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。\n\n* 如果内存中**有空闲块**，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中对应页表项。\n\n* 如果内存中**无空闲块**，则由**页面置换算法**选择**淘汰**一个页面，若该页面在内存期间被**修改过**，则要将其**写回外存**。未修改过的页面不用写回外存。\n\n缺页中断是由于当前指令想要访问的目标页面未调入内存而产生的，因此属于**内中断**。一条指令在执行期间，可能产生**多次**缺页中断。\n\n<img src=\"内存管理（五）\\缺页中断机构.png\"  />\n\n##### 地址变换机构\n\n<img src=\"内存管理（五）\\地址变化机构.png\"  />\n\n* 新增步骤1：请求调页（查到页表项时进行判断）。\n* 新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）。\n* 新增步骤3：需要修改请求页表中新增的表项。\n\n<img src=\"内存管理（五）\\地址变化机构步骤.png\" style=\"zoom:120%;\" />\n\n补充：\n\n1. 换入/换出页面需要启动慢速I/O操作，如果过于频繁，会有很大开销。\n2. 页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。\n\n在具有快表的请求分页系统中，访问一个逻辑地址时，若发生缺页，地址变换步骤为：\n\n```\n查快表（未命中）->查慢表（发现未调入内存）->调页（调入的页面对应的表项会直接加入快表）\n->查快表（命中）->访问目标内存单元\n```\n\n##### 小结\n\n<img src=\"内存管理（五）\\地址变化机构小结.png\" style=\"zoom:120%;\" />\n\n#### 页面置换算法\n\n<img src=\"内存管理（五）\\页面置换算法.png\" style=\"zoom:80%;\" />\n\n##### 最佳置换算法（OPT）\n\n每次选择淘汰的页面**以后永不使用**或**最长时间内不再被访问**，保证最低缺页率。\n\n缺点：只有进程执行的过程中才能知道接下来会访问到哪个页面，操作系统无法提前预判访问序列。因此，最佳置换算法**无法实现**。\n\n##### 先进先出置换算法（FIFO）\n\n每次选择淘汰的页面是**最早进入内存的页面**。\n\nBelady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。\n\n缺点：只有FIFO算法会产生**Belady异常**，虽然其实现简单，但是与进程实际运行时规律不适应，因为先进入的页面也有可能最经常被访问。因此算法**性能差**。\n\n#####  最近最久未使用置换算法（LRU）\n\n每次选择淘汰的页面是**最近最久未使用的页面**。用每个页面页表项中的**访问字段**记录该页面自上次被访问以来所经历的时间 t 。淘汰时选择 t 最大的页面。\n\n缺点：实现需要专门的硬件支持，虽然算法性能好，但**实现困难，开销大**。\n\n##### 时钟置换算法（CLOCK）\n\n此算法是一种性能和开销较均衡的算法，也称**最近未用算法（NRU，Not Recently Used）**。\n\n简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个**循环队列**。当某页被访问时，其**访问位置为1**。**当需要淘汰一个页面时，只需检查页的访问位**。\n\n<img src=\"内存管理（五）\\简单clock.png\"  />\n\n* 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面。\n* 若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）。\n\n###### 改进型的时钟置换算法\n\n简单的CLOCK算法**仅考虑一个页面最近是否被访问过**，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。**只有被淘汰的页面被修改过，才需要写回外存**。\n\n因此，在其他条件都相同时，应**优先淘汰没有修改过的页面**，避免I/O操作。修改位为0时表示没有修改过，修改位为1，表示页面被修改过。\n\n改进型CLOCK置换算法选择一个淘汰页面最多会进行**四轮扫描**。\n\n##### 小结\n\n<img src=\"内存管理（五）\\页面置换算法小结.png\"  />\n\n#### 页面分配策略\n\n##### 页面分配、置换策略\n\n驻留集：请求分页存储管理中给进程分配的物理块的集合。驻留集大小一般小于进程的总大小。\n\n* 若驻留集太小，会导致缺页频繁。\n* 若驻留集太大，会导致多道程序并发度下降。\n\n固定分配：操作系统为每个进程分配一组固定数目的物理块。进程运行期间驻留集**大小不变**。\n\n可变分配：驻留集**大小可变**。\n\n局部置换：缺页时只能选进程自己的物理块进行置换。\n\n全局置换：操作系统保留的空闲物理块和别的进程持有的物理块（先置换到外存）都可以分配给缺页进程。\n\n<img src=\"内存管理（五）\\页面置换策略.png\"  />\n\n可变分配**全局**置换：只要缺页就给分配新物理块。\n\n可变分配**局部**置换：根据**缺页的频率**来动态地增加或减少进程的物理块。\n\n##### 何时调入页面\n\n1. 预调页策略：根据空间局部性，一次调入若干相邻的页面可能比一次调入一个页面更高效。主要用于**进程的首次调入**，由程序员指出（**运行前调入**）。\n2. 请求调页策略：进程在**运行期间**发现缺页时才将所缺页面调入内存。I/O开销较大（每次只能调入一页，每次调页都要进行磁盘I/O）。\n\n##### 何处调入页面\n\n###### 系统拥有足够的对换区空间\n\n<img src=\"内存管理（五）\\何处调入1.png\"  />\n\n###### 系统缺少足够的对换区空间\n\n<img src=\"内存管理（五）\\何处调入2.png\"  />\n\n###### UNIX方式\n\n<img src=\"内存管理（五）\\何处调入3.png\"  />\n\n##### 抖动（颠簸）现象\n\n刚换出的页面马上要换入内存，或刚换入的需要换出，这种频繁的页面调度行为称为**抖动（颠簸）**。主要原因是进程频繁访问的页面数目高于可用的物理块数（**分配给进程的物理块不够**）。\n\n##### 工作集\n\n驻留集：指请求分页存储管理中给进程分配的内存块的集合。\n\n工作集：指在某段时间间隔里，进程实际访问页面的集合。\n\n<img src=\"内存管理（五）\\工作集.png\"  />\n\n**窗口尺寸为4**。\n\n**工作集大小**可能小于窗口尺寸，一般来说，驻留集大小不能**小于**工作集大小，否则进程运行过程中将频繁缺页。\n\n##### 小结\n\n<img src=\"内存管理（五）\\页面分配策略小结.png\" style=\"zoom:120%;\" />","categories":["操作系统"]},{"title":"LeetCode547-省份数量","url":"/blog/2021/01/07/LeetCode547-省份数量/","content":"\n#### 题目描述\n\n有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。\n\n**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\n\n给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。\n\n返回矩阵中 **省份** 的数量。\n\n<!-- more-->\n\n<img src=\"LeetCode547-省份数量\\547.png\"  />\n\n#### 思路\n\n此题的核心问题是**节点之间是否相连**。如果找到了这个核心点，就可以想到两种解决方案。一种是图论中，计算**连通分量**的个数；另一种是并查集，找到大家的**公共祖先**的个数。\n\n考虑到我们并不需要知道节点与节点之间**如何连接**，只需要知道节点与节点之间**是否连接**，所以使用**并查集**来解决这个问题就足够了。\n\n并查集的相关知识可参考[这里]([http://www.xingyuzhao.ltd/blog/2020/09/06/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find/)，建议先看！\n\n输入矩阵的长或者宽（其实就是一个邻接矩阵）的大小就是城市的个数，所以对于并查集的初始化，我们只需要设置长度与城市个数相等的`parent`数组即可，并且指向自身，同时可以初始化当前祖先的总数，即城市的个数。\n\n在遍历`isconnected`矩阵时，遇到`isconnected[i][j]`为 1 时，代表`i, j`两节点相连，进行`union(i, j)`操作。同时祖先数减去 1 。否则不相连，不进行任何操作。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(vector<vector<int>> &grid){\n        this->count = 0;\n        int m = grid.size();\n        for(int i = 0; i < m; ++i){\n            parent.push_back(i);\n            count++;\n            rank.push_back(0);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot){\n            return;\n        }\n        // 根不同，将其相连，计数减1\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot; // 随便指一个\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        if(isConnected.empty()) return 0;\n        unionFind uf(isConnected);\n        int m = isConnected.size();\n        int n = isConnected[0].size();\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(isConnected[i][j] == 1){\n                    uf.unionElem(i, j);\n                }         \n            }\n        }\n        return uf.getCount();\n    }\n};\n```\n\n","tags":["并查集"],"categories":["LeetCode"]},{"title":"LeetCode399-除法求值","url":"/blog/2021/01/06/LeetCode399-除法求值/","content":"\n#### 题目描述\n\n给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。\n\n另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。\n\n返回 所有问题的答案 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。\n\n**注意**：输入总是有效的。你可以假设除法运算中不会出现除数为 `0` 的情况，且不存在任何矛盾的结果。\n\n<!-- more-->\n\n<img src=\"LeetCode399-除法求值\\399.png\"  />\n\n#### 思路\n\n首先得理解题目意思：\n\n* `equations`和`values`：`equations`中每个一维序列表示一对数进行相除（前 / 后），得到的结果就是`values`中相应位置的值，以上作为已知条件。\n* `queries`：包含两个元素，目的是要我们求：第一个元素 / 第二个元素 = ？\n\n我们可以将其抽象为一个**带权图**问题，对于`queries`中的两个元素 `x`, `y` ，是否有一条路径可以从 `x` 到 `y` ，并求出经过这条路径的消耗是多少。由于两个元素的比值是一个常量，所以**如果有多条路径，消耗是一样的**，选其中一条就可以。\n\n以示例1为例，对于`a/c`，可以由`a/b * b/c`得到，也就是`a->b`与`b->c`两条路径的权值相乘得到，所以路径上的消耗，就是**所走过的每条路径的权值之积**。\n\n由于每个基本元素类型都是`string`，所以先对所有的元素映射到数字域，方便查找：\n\n```cpp\n// 将equations中的string映射到0，1，2，3...\nunordered_map<string, int> map;\nint cnt = 0;\nfor(auto &s : equations){\n    for(auto &ch : s){\n    \tif(!map.count(ch)) map[ch] = cnt++;\n    }\n}\n```\n\n下一步就是建图，使用邻接表，并且路径之间是**双向**的，权值**互为倒数**：\n\n```cpp\nvector<vector<int>> G;\nvector<vector<double>> W;\nG = vector<vector<int>>(map.size());\nW = vector<vector<double>>(map.size());\nfor(int i = 0; i < equations.size(); ++i){\n    G[map[equations[i][0]]].push_back(map[equations[i][1]]);\n    W[map[equations[i][0]]].push_back(values[i]);\n    G[map[equations[i][1]]].push_back(map[equations[i][0]]);\n    W[map[equations[i][1]]].push_back(1 / values[i]);\n}\n```\n\n建好图之后，就可以用**深度优先搜索（DFS）**和**回溯算法**来找路了，需要用一个数组记录走过的节点，防止重复走过，还需要一个变量`flag`表示起点与终点之间是否存在路径：\n\n```cpp\nint flag = 0; // 初始为0，表示起点与终点之间没有路径。设置为全局变量，在函数中不用调用。\nvector<bool> vis;\nvis = vector<bool>(map.size());\nfor (auto& querie : queries) {\n    string s1 = querie[0];\n    string s2 = querie[1];\n    // 如果两个元素相同并且存在于map中，结果就是1\n    if (s1 == s2 && map.count(s1)) {\n        res.push_back(1.0);\n        continue;\n    }\n    // 如果有一个元素不存在于map中，结果就是-1，因为没有这条路径\n    if (!map.count(s1) || !map.count(s2)) {\n        res.push_back(-1.0);\n        continue;\n    }\n    // 将起点标记为已使用\n    vis[map[s1]] = true;\n    // 参数：图，权值，标记数组，起点，终点，当前计算结果（初始为1）\n    dfs(G, W, vis, map[s1], map[s2], 1);\n    // 使用过后，再次标记为未使用\n    vis[map[s1]] = false;\n    // 没有路径，结果为-1\n    if (flag == 0) res.push_back(-1.0);\n    // 已经有路径，将flag置为0，结果已经在DFS中记录过，所以不用再次记录了\n    else {\n        flag = 0;\n    }\n}\n```\n\nDFS+回溯：\n\n```cpp\nvoid dfs(vector<vector<int>> &G, vector<vector<double>> &W, vector<bool> &vis, int start, int end, double val){\n    if(start == end){\n        res.push_back(val);\n        // 有路径，flag为1\n        flag = 1;\n        return;\n    }\n    for(int i = 0; i < G[start].size(); ++i){\n        // 如果flag已经为1了，说明找到一条路径了，就不需要再找了\n        // 剩下的就是一般的回溯算法\n        if(vis[G[start][i]] || flag == 1) continue;\n        vis[G[start][i]] = true;\n        val *= W[start][i];\n        dfs(G, W, vis, G[start][i], end, val);\n        val /= W[start][i];\n        vis[G[start][i]] = false;\n    }\n}\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<double> res;\n    int flag = 0;\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        vector<vector<int>> G;\n        vector<vector<double>> W;\n        vector<bool> vis;\n        unordered_map<string, int> map;\n        // set<pair<int, int>> set;\n        int cnt = 0;\n        for(auto &s : equations){\n            for(auto &ch : s){\n                if(!map.count(ch)) map[ch] = cnt++;\n            }\n        }\n        // cout << map.size();\n        // 建图\n        G = vector<vector<int>>(map.size());\n        W = vector<vector<double>>(map.size());\n        vis = vector<bool>(map.size());\n        for(int i = 0; i < equations.size(); ++i){\n            G[map[equations[i][0]]].push_back(map[equations[i][1]]);\n            // cout << map[equations[i][0]] << \" \" << map[equations[i][1]];\n            W[map[equations[i][0]]].push_back(values[i]);\n            G[map[equations[i][1]]].push_back(map[equations[i][0]]);\n            W[map[equations[i][1]]].push_back(1 / values[i]);\n        }\n        // for(auto &g : G){\n        //     for(auto &gg : g){\n        //         cout << gg << \" \";\n        //     }\n        //     cout << \"    \";\n        // }\n        // for(auto &w : W){\n        //     for(auto &ww : w){\n        //         cout << ww << \" \";\n        //     }\n        //     cout << \"    \";\n        // }\n        for(auto &querie : queries){\n            string s1 = querie[0];\n            string s2 = querie[1];\n            if(s1 == s2 && map.count(s1)){\n                res.push_back(1.0);\n                continue;\n            }   \n            if(!map.count(s1) || !map.count(s2)){\n                res.push_back(-1.0);\n                continue;\n            }\n            vis[map[s1]] = true;\n            dfs(G, W, vis, map[s1], map[s2], 1);\n            vis[map[s1]] = false;\n            if(flag == 0) res.push_back(-1.0);\n            else {\n                flag = 0;\n            }\n        }\n        // int count = queries.size() - res.size();\n        // while(count--){\n        //     res.insert(res.begin(), -1.0);\n        // }\n        return res;\n    }\n    void dfs(vector<vector<int>> &G, vector<vector<double>> &W, vector<bool> &vis, int start, int end, double val){\n        if(start == end){\n            res.push_back(val);\n            // cout << val << \" \";\n            flag = 1;\n            return;\n        }\n        for(int i = 0; i < G[start].size(); ++i){\n            if(vis[G[start][i]] || flag == 1) continue;\n            vis[G[start][i]] = true;\n            val *= W[start][i];\n            dfs(G, W, vis, G[start][i], end, val);\n            val /= W[start][i];\n            vis[G[start][i]] = false;\n        }\n    }\n};\n```\n\n#### 后续补充\n\n可以使用并查集解决。\n\n\n\n","tags":["图论","DFS","回溯算法"],"categories":["LeetCode"]},{"title":"LeetCode830-较大分组的位置","url":"/blog/2021/01/05/LeetCode830-较大分组的位置/","content":"\n#### 题目描述\n\n在一个由小写字母构成的字符串 `s` 中，包含由一些连续的相同字符所构成的分组。\n\n例如，在字符串 `s = \"abbxxxxzyy\"` 中，就含有 `\"a\"`, `\"bb\"`, `\"xxxx\"`, `\"z\"` 和 `\"yy\"` 这样的一些分组。\n\n分组可以用区间 `[start, end]` 表示，其中 `start` 和 `end` 分别表示该分组的起始和终止位置的下标。上例中的 `\"xxxx\"` 分组用区间表示为 `[3,6]` 。\n\n我们称所有包含大于或等于三个连续字符的分组为 **较大分组** 。\n\n找到每一个 **较大分组** 的区间，**按起始位置下标递增顺序排序后**，返回结果。\n\n<!-- more-->\n\n<img src=\"LeetCode830-较大分组的位置\\830.png\"  />\n\n#### 思路\n\n寻找每个重复字符出现的起始位置和终止位置，如果长度大于等于3，记录一下结果就可以了。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> largeGroupPositions(string s) {\n        vector<vector<int>> res;\n        int i = 0;\n        char ch = s[i];\n        i++;\n        int start = 0;\n        while(i < s.size()){\n            // 此位置的前一个位置就是上一个重复字符的终止位置\n            if(s[i] != ch){\n                ch = s[i];\n                if(i - 1 - start + 1 >= 3) res.push_back({start, i - 1});\n                // 更新起始位置\n                start = i;\n            }\n            // 字符重复\n            else{\n                i++;\n            }\n        }\n        if(i - 1 - start + 1 >= 3) res.push_back({start, i - 1});\n        return res;\n    }\n};\n```\n\n","tags":["数组"],"categories":["LeetCode"]},{"title":"LeetCode509-斐波那契数","url":"/blog/2021/01/04/LeetCode509-斐波那契数/","content":"\n#### 题目描述\n\n斐波那契数，通常用 `F(n)` 表示，形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n```\nF(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n > 1\n```\n\n\n给你 `n` ，请计算 `F(n)` 。\n\n<!-- more-->\n\n<img src=\"LeetCode509-斐波那契数\\509.png\"  />\n\n#### 思路\n\n这个算是动态规划的入门题目。给定 $F(0)$ 和 $F(1)$ 之后，后面的数都是前面两个数之和。比如 $F(2)=F(0)+F(1)$，$F(3)=F(1)+F(2)$...\n\n基于此，其实已经告诉了我们状态转移方程：\n$$\ndp[i]=dp[i-1]+dp[i-2]\\quad i\\geq2\n$$\n当 $i=0,1$ 时，函数值已经给定：\n\n```cpp\ndp[0] = 0;\ndp[1] = 1;\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        vector<int> dp(n + 1);\n        dp[0] = 0;\n        dp[1] = 1;\n        for(int i = 2; i <= n; ++i){\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n};\n```\n\n实际上只用三个变量就可以表示每种状态：\n\n```cpp\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        // 最终结果\n        int fin = 0;\n        // dp[i - 2]\n        int fir = 0;\n        // dp[i - 1]\n        int sec = 1;\n        for(int i = 2; i <= n; ++i){\n            fin = fir + sec;\n            fir = sec;\n            sec = fin;\n        }\n        return fin;\n    }\n};\n\n```\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"内存管理（四）","url":"/blog/2021/01/04/内存管理（四）/","content":"\n#### 本次学习要点\n\n1. 基本分段存储管理方式\n2. 段页式管理方式\n\n<!-- more-->\n\n#### 基本分段存储管理方式\n\n与分页存储管理方式区别为：离散分配时所分配地址空间的基本单位不同。\n\n##### 分段\n\n进程的地址空间：按照程序**自身的逻辑**关系划分为若干个段，每个段都有一个段名，每段从0开始编址。\n\n内存分配规则：以段位单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。\n\n<img src=\"内存管理（四）\\分段-逻辑编程.png\"  />\n\n分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）组成：\n\n<img src=\"内存管理（四）\\分段逻辑地址.png\"  />\n\n* 段号的位数决定每个进程最多可分几个段。\n* 段内地址位数决定了每个段的最大长度是多少。\n\n##### 段表\n\n<img src=\"内存管理（四）\\段表.png\"  />\n\n##### 地址变换\n\n<img src=\"内存管理（四）\\地址变换.png\"  />\n\n④处与**分页存储**不同。\n\n##### 分段、分页管理对比\n\n###### 基本单位\n\n* **页是信息的物理单位**。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要,完全是系统行为，**对用户是不可见的**。\n* **段是信息的逻辑单位**。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。\n\n###### 大小\n\n* 页的大小**固定**且由**系统**决定。\n* 段的长度却**不固定**，决定于**用户编写的程序**。\n\n###### 地址空间\n\n* 分页的用户进程地址空间是**一维**的，程序员只需给出一个记忆符即可表示一个地址。\n* 分段的用户进程地址空间是**二维**的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。\n\n分段比分页**更容易实现信息的共享和保护**。不能被修改的代码称为**纯代码**或**可重入代码**（不属于临界资源），这样的代码可以共享，可修改的代码不可共享。\n\n##### 小结\n\n<img src=\"内存管理（四）\\分段存储管理小结.png\" style=\"zoom:120%;\" />\n\n#### 段页式管理方式\n\n<img src=\"内存管理（四）\\段页式管理方式.png\" style=\"zoom:80%;\" />\n\n##### 分页、分段优缺点分析\n\n<img src=\"内存管理（四）\\分页、分段优缺点分析.png\"  />\n\n##### 段页式管理\n\n<img src=\"内存管理（四）\\段页式管理.png\"  />\n\n将进程按逻辑模块分段，再将各段分页，再装入大小相同的内存块（页框/页帧/物理块）中。\n\n##### 段页式管理的逻辑地址结构\n\n<img src=\"内存管理（四）\\段页式管理的逻辑地址结构.png\"  />\n\n* 段号的位数决定每个进程最多可分几个段。\n* 页号位数决定了每个段最大有多少页。\n* 页内偏移量决定了页面大小、内存块大小是多少。\n\n**分段**对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将**各段**进行**分页**对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此段页式管理的地址结构是二维的。\n\n##### 段表、页表\n\n<img src=\"内存管理（四）\\段表、页表.png\"  />\n\n每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，**段号是隐含的**。\n\n每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，**页号是隐含的**。\n\n<img src=\"内存管理（四）\\段表、页表寻址.png\"  />\n\n##### 小结\n\n<img src=\"内存管理（四）\\段页式管理方式小结.png\"  style=\"zoom:120%;\" />","categories":["操作系统"]},{"title":"LeetCode86-分隔链表","url":"/blog/2021/01/03/LeetCode86-分隔链表/","content":"\n#### 题目描述\n\n给你一个链表和一个特定值 `x` ，请你对链表进行分隔，使得所有小于 `x` 的节点都出现在大于或等于 `x` 的节点之前。\n\n你应当保留两个分区中每个节点的初始相对位置。\n\n<!-- more-->\n\n<img src=\"LeetCode86-分隔链表\\86.png\"  />\n\n#### 思路\n\n将链表一分为二，为小于 `x` 的部分和大于等于 `x` 的部分分别建立一个新链表，然后再将小链表的表尾连接至大链表的表头即可。\n\n#### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        if(!head) return nullptr;\n        ListNode *dummyNodeSmall = new ListNode(0);\n        ListNode *dummyNodeLarge = new ListNode(0);\n        ListNode *small = dummyNodeSmall;\n        ListNode *large = dummyNodeLarge;\n        for(auto iter = head; iter != nullptr; iter = iter->next){\n            if(iter->val < x){\n                small->next = iter;\n                small = small->next;\n            }\n            else{\n                large->next = iter;\n                large = large->next;\n            }\n        }\n        large->next = nullptr;\n        small->next = dummyNodeLarge->next;\n        return dummyNodeSmall->next;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/partition-list/solution/fen-ge-lian-biao-by-leetcode-solution-7ade/","tags":["链表"],"categories":["LeetCode"]},{"title":"LeetCode239-滑动窗口的最大值","url":"/blog/2021/01/02/LeetCode239-滑动窗口的最大值/","content":"\n#### 题目描述\n\n给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n<!-- more-->\n\n<img src=\"LeetCode239-滑动窗口的最大值\\239.png\"  />\n\n#### 思路\n\n首先使用优先队列存储 `nums` 的前 `k` 个值，队首就是第一个窗口最大的值。\n\n接着从第 `k` 个位置开始，将序列入队，每次最大的值都出现在队首。但是**当前的队首不一定是当前窗口中的元素**，此时队列的长度可能大于 `k`。如下：\n\n```\nnums = {3,1,1}, k = 2;\n1. {3,1} max = 3; // 队列中元素为3,1\n2. {1,1} max = 1; // 队列中元素为3,1,1，此时需要将3出队\n```\n\n如果不是当前窗口中的元素，只有可能是上一个窗口中的最大值，它一定是在当前窗口左端点的左侧，就需要将队首出队，直到队首元素在当前窗口内。\n\n所以优先队列需要同时存储当前序列的值和坐标。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        priority_queue<pair<int, int>> q;\n        for(int i = 0; i < k; ++i){\n            q.push({nums[i], i});\n        }\n        vector<int> ans{q.top().first};\n        for(int i = k; i < nums.size(); ++i){\n            q.push({nums[i], i});\n            // 队首元素不在当前窗口内\n            while(q.top().second <= i - k){\n                q.pop();\n            }\n            ans.push_back(q.top().first);\n        }\n        return ans;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/","tags":["优先队列"],"categories":["LeetCode"]},{"title":"LeetCode605-种花问题","url":"/blog/2021/01/01/LeetCode605-种花问题/","content":"\n#### 题目描述\n\n假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。\n\n给你一个整数数组  `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false`。\n\n<!-- more-->\n\n<img src=\"LeetCode605-种花问题\\605.png\"  />\n\n#### 思路\n\n除了首尾位置，只要当前位置的前一个位置和下一个位置没有种花，那么当前位置就可以种花。\n\n对于首尾位置，只有其相邻位置没有种花，在它的位置就可以种花。\n\n**当前位置如果没有种花，才需要考虑上述问题**。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        if(n == 0) return true;\n        if(flowerbed.size() == 1) return flowerbed[0] == 0;\n        for(int i = 0; i < flowerbed.size(); ++i){\n            if(i == 0 && flowerbed[i] == 0 && flowerbed[i + 1] == 0){\n                flowerbed[i] = 1;\n                n--;\n            }\n            else if(i == flowerbed.size() - 1 && flowerbed[i] == 0 && flowerbed[i - 1] == 0){\n                flowerbed[i] = 1;\n                n--;\n            }\n            else if(i != 0 && i != flowerbed.size() - 1 && flowerbed[i] == 0 && flowerbed[i - 1] != 1 && flowerbed[i + 1] != 1){\n                flowerbed[i] = 1;\n                n--;\n            }\n            if(n == 0) return true;\n        }\n        return false;\n    }\n};\n```\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode435-无重叠区间","url":"/blog/2020/12/31/LeetCode435-无重叠区间/","content":"\n#### 题目描述\n\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n\n**注意**:\n\n可以认为区间的终点总是大于它的起点。\n区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n\n<!-- more-->\n\n<img src=\"LeetCode435-无重叠区间\\435.png\"  />\n\n#### 思路\n\n首先对二维数组排序，对其中的每个一维数组，先按照元素的第一个升序排列，如果第一个元素相同，再按照第二个升序排列。\n\n如此一来，为了使移除的区间数最小，那么就需要**从重叠的区间中选出右端点最小的一个**，那样就可以尽可能留下更多不重叠的空间（所以说只按照第二个元素升序排列也是可以的）。\n\n排序后，如果前一个数组的第二个元素在第二个数组范围之内，就留下前一个数组，用它把第二个数组覆盖；如果前一个数组第二个元素大于第二个数组的后一个元素，那么留下第二个数组，不用进行覆盖，但是前一个数组是需要移除的。这两种情况下，都需要移除操作。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), [](vector<int> &v1, vector<int> &v2) -> bool{\n            if(v1[0] < v2[0])\n                return true;\n            else if(v1[0] == v2[0])\n                return v1[1] < v2[1];\n            else\n                return false;\n        });\n        // sort(intervals.begin(), intervals.end());\n        // for(auto &v1 : intervals){\n        //     for(auto &v2 : v1)\n        //         cout << v2 << \" \";\n        // }\n        int cnt = 0;\n        for(int i = 1; i < intervals.size(); ++i){\n            if(intervals[i - 1][1] > intervals[i][0] && intervals[i - 1][1] <= intervals[i][1]){\n                intervals[i][0] = intervals[i - 1][0];\n                intervals[i][1] = intervals[i - 1][1];\n                cnt++;\n            }\n            else if(intervals[i - 1][1] > intervals[i][0] && intervals[i - 1][1] > intervals[i][1]){\n                cnt++;\n            }\n            else continue;\n        }\n        return cnt;\n    }\n};\n```\n\n#### Reference\n\nC++ STL sort作用于二维vector 效果和应用：\n\nhttps://blog.csdn.net/y625658683/article/details/104154089\n\n#### Appendix\n\n对于二维数组，`sort`是把`vector<int>`作为一个一维数组对象，整体进行比较和排序。\n\n默认比较两个`int`向量的规则是：\n\n从第一个元素开始比，第一个元素小的，整个向量就小，如果第一个元素一样，再比较第二个，第二个元素小的，整个向量小，依此类推。`sort`默认按从小到大排序。\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode1046-最后一块石头的重量","url":"/blog/2020/12/30/LeetCode1046-最后一块石头的重量/","content":"\n#### 题目描述\n\n有一堆石头，每块石头的重量都是正整数。\n\n每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n\n如果 `x == y`，那么两块石头都会被完全粉碎；\n如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。\n\n<!-- more-->\n\n#### 思路及代码\n\n##### 链表\n\n###### 思路\n\n每次寻找最大的两个石头重量进行碰撞，直到链表为空或只剩下一个元素：\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        if(stones.size() <= 1) return stones.empty() ? 0 : stones[0];\n        list<int> li(stones.begin(), stones.end());\n        while(!li.empty()){\n            auto it1 = max_element(li.begin(), li.end());\n            int val1 = *it1;\n            li.erase(it1);\n            auto it2 = max_element(li.begin(), li.end());\n            int val2 = *it2;\n            if(val2 != val1)\n                *it2 = abs(val1 - val2);\n            else li.erase(it2);\n            if(li.size() == 1) break;\n        }\n        return li.empty() ? 0 : *li.begin();\n    }\n};\n```\n\n##### 优先队列\n\n###### 思路\n\n大顶堆，每次前两个出队元素就是石头中重量最大的两个。\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        priority_queue<int, vector<int>, less<int>> p_q(stones.begin(), stones.end());\n        while(!p_q.empty()){\n            if(p_q.size() == 1) break;\n            int v1 = p_q.top();\n            p_q.pop();\n            int v2 = p_q.top();\n            p_q.pop();\n            int v = abs(v1 - v2);\n            if(v != 0) p_q.push(v);\n        }\n        return p_q.empty() ? 0 : p_q.top();\n    }\n};\n```\n\n","tags":["链表","优先队列"],"categories":["LeetCode"]},{"title":"LeetCode330-按要求补齐数组","url":"/blog/2020/12/29/LeetCode330-按要求补齐数组/","content":"\n#### 题目描述\n\n给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 `[1, n]` 区间内选取任意个数字补充到 $nums$ 中，使得 `[1, n]` 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。\n\n<!-- more-->\n\n<img src=\"LeetCode330-按要求补齐数组\\330.png\"  />\n\n#### 思路\n\n如果区间 $[1,x)$ 的所有数都被覆盖了：\n\n*  如果$nums[i]\\in[1,x)$，那么区间 $[1+nums[i],x+nums[i])$ 中所有数也会被覆盖。由于 $nums[i]\\geq1$ ，则此时 $x\\in[1+nums[i],x+nums[i])$，覆盖区间可以更新为 $[1,x+nums[i])$。\n*  如果 $nums[i]$ 恰好等于 $x$ ，那么覆盖区间变为 $[1,x+nums[i])$。不需要补充 $x$ 。\n* 否则，补充 $x$ ，则区间 $[1,x]$ 全部覆盖；并且可以得到覆盖区间 $[1+x,x+x)=[x+1,2x)$。两者取交集得到此时覆盖数字区间 $[1,2x)$，此时覆盖的数字最多（如果取小于 $x$ 的数，覆盖区间会变小，这是不希望看到的， $x$ 不能取两次，每个数字只能取一次）。\n* 当 $x>n$ 时，就可以结束了。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minPatches(vector<int>& nums, int n) {\n        // 初始区间为空，表示已经覆盖\n        long long x = 1;\n        int index = 0;\n        int times = 0;\n        while(x <= n){\n            if(index < nums.size() && nums[index] < x){\n                x += nums[index++];\n            }\n            else if(index < nums.size() && nums[index] == x){\n                x += nums[index++];\n            }\n            else{\n                x <<= 1;\n                times++;\n            }\n        }\n        return times;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/","tags":["贪心算法","数学"],"categories":["LeetCode"]},{"title":"LeetCode309-最佳买卖股票时机含冷冻期","url":"/blog/2020/12/28/LeetCode309-最佳买卖股票时机含冷冻期/","content":"\n#### 题目描述\n\n给定一个整数数组，其中第 $i$ 个元素代表了第 $i$ 天的股票价格 。\n\n* 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n* 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n  卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n<!-- more-->\n\n<img src=\"LeetCode309-最佳买卖股票时机含冷冻期\\309.png\"  />\n\n#### 思路\n\n本题与其他股票问题不同之处在于**卖出之后至少间隔一天才能够买入**，可以多次买入卖出。\n\n##### 定义dp数组\n\n$dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益。\n\n$dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。\n\n##### 状态转移方程\n\n* 如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：\n  $$\n  dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])\n  $$\n\n* 如果当天持有股票，那么前一天可以持有股票或者前两天未持有股票，当天买入（如果前一天持有且卖出股票，当天就不能买入了；前一天如果未持有且没有卖出股票，就与前两天未持有，当天买入等价了）：\n  $$\n  dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i])\n  $$\n\n##### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。假设有第零天，那么收益应也为 $0$。\n\n```cpp\ndp[0][0] = 0;\ndp[0][1] = -prices[0];\ndp[-1][0] = 0; // 用dp_0 = 0代替\n```\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        int dp_0 = 0;\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(dp[i - 1][1], (i - 2 < 0 ? dp_0 : dp[i - 2][0]) - prices[i]);\n        }\n        return dp[prices.size() - 1][0];\n    }\n};\n```\n\n##### 空间优化\n\n由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        int profit = 0;\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, profit - prices[i]);\n            profit = profit0;\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode121-买卖股票的最佳时机","url":"/blog/2020/12/28/LeetCode121-买卖股票的最佳时机/","content":"\n#### 题目描述\n\n给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n**注意**：你不能在买入股票前卖出股票。\n\n<!-- more-->\n\n<img src=\"LeetCode121-买卖股票的最佳时机\\121.png\"  />\n\n#### 思路\n\n##### 贪心算法\n\n###### 策略\n\n从前往后遍历找到最小的价格买入，再往后找到最大的价格卖出即可。\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        stack<int> st;\n        int res = 0;\n        st.push(prices[0]);\n        for(int i = 1; i < prices.size(); i++)\n        {\n            if(prices[i] <= st.top())\n            {\n                st.pop();\n                st.push(prices[i]);\n            }\n            else\n            {\n                int m = prices[i] - st.top();\n                res = res > m ? res : m;\n            }\n        }\n        return res;\n    }\n};\n```\n\n##### 动态规划\n\n本题是[LeetCode122-买卖股票的最佳时机II]()的简化版，这道题与其最大的区别在于限制交易次数为 **一次**，找到最小的起点之后，再去找最大的终点即可。\n\n###### 定义dp数组\n\n$dp[i][0]$ 表示第 $i$ 天不持有股票可获得的最大收益。\n\n$dp[i][1]$ 表示第 $i$ 天持有股票可获得的最大收益。\n\n###### 状态转移方程\n\n* 如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：\n  $$\n  dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])\n  $$\n\n* 如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入（只能持有一次，所以第一次持有时的利润为$-prices[i]$）：\n  $$\n  dp[i][1]=max(dp[i-1][1],-prices[i])\n  $$\n\n###### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。\n\n```cpp\ndp[0][0] = 0;\ndp[0][1] = -prices[0];\n```\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(dp[i - 1][1], -prices[i]);\n        }\n        return dp[prices.size() - 1][0];\n    }\n};\n```\n\n###### 空间优化\n\n由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, -prices[i]);\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)\n\n","tags":["动态规划","贪心算法","栈","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode123-买卖股票的最佳时机III","url":"/blog/2020/12/28/LeetCode123-买卖股票的最佳时机III/","content":"\n#### 题目描述\n\n给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。\n\n**注意**: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n<!-- more-->\n\n<img src=\"LeetCode123-买卖股票的最佳时机III\\123.png\"  />\n\n#### 思路\n\n本题是[LeetCode122-买卖股票的最佳时机II]()的升级版，这道题与其最大的区别在于限制交易次数为 **两次**，所以选择哪两次交易至关重要。\n\n##### 定义dp数组\n\n需要记录当前还剩下多少次交易次数，还有当天是否持有股票（ $k=0,1,2$ ）。\n\n$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。\n\n$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。\n\n##### 状态转移方程\n\n* 第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：\n  $$\n  dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);\n  $$\n\n* 第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：\n  $$\n  dp[i][j][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);\n  $$\n\n##### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：\n\n```cpp\n// 剩余交易i次，获得收益初始化\nfor(int i = 0; i <= k; ++i){\n    dp[0][i][0] = 0;\n    dp[0][i][1] = -prices[0];\n}\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2 + 1, vector<int>(2)));\n        for(int i = 0; i <= 2; ++i){\n            dp[0][i][0] = 0;\n            dp[0][i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = 2; j > 0; --j){\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n        return dp[prices.size() - 1][2][0];\n    }\n};\n```\n\n#### 空间优化\n\n由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(2 + 1, vector<int>(2));\n        for(int i = 0; i <= 2; ++i){\n            dp[i][0] = 0;\n            dp[i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = 2; j > 0; --j){\n                dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]);\n                dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]);\n            }\n        }\n        return dp[2][0];\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)\n\n","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode122-买卖股票的最佳时机II","url":"/blog/2020/12/28/LeetCode122-买卖股票的最佳时机II/","content":"\n#### 题目描述\n\n给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n<!-- more-->\n\n<img src=\"LeetCode122-买卖股票的最佳时机II\\122.png\"  />\n\n#### 思路\n\n##### 贪心算法\n\n###### 策略\n\n本题要求尽可能地完成更多地交易，所以可以使用贪心策略，在局部价格最低时买入，在局部价格最高时卖出，重复此操作直到最后一天，最后一天不持有股票时收益最大。\n\n* 局部最低：如果后一天价格低于前一天价格，更新局部最低，否则已经是局部最低\n* 局部最高：在持有股票后，当前价格的下一天价格降低，说明已经达到局部最高\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0;\n        int val = prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            if(prices[i] <= val) {\n                val = prices[i];\n            }\n            else{\n                if(i + 1 < prices.size() && prices[i + 1] < prices[i]){\n                    res += prices[i] - val;\n                    val = prices[i + 1];\n                    i++;\n                }\n                // 最后一天如果还持有股票应该卖出\n                if(i + 1 == prices.size()){\n                    res += prices[i] - val;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n###### 另一种策略\n\n把股票的交易价格看成曲线图，找出图中上升的部分，即为交易获利。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int> prices)\n    {\n        int sum = 0;\n        for(int i=0; i<prices.size()-1; i++)\n        {\n            if(prices[i] < prices[i + 1])\n            sum += prices[i + 1] - prices[i];\n        }\n        return sum;\n    }\n};\n```\n\n##### 动态规划\n\n###### 定义dp数组\n\n每天的状态可以为持有股票或不持有股票，所以使用 $dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益； $dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。本题交易次数 **+∞** 。\n\n######  状态转移方程\n\n* 如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：\n  $$\n  dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])\n  $$\n\n* 如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入：\n  $$\n  dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])\n  $$\n\n###### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。\n\n```cpp\ndp[0][0] = 0;\ndp[0][1] = -prices[0];\n```\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n        }\n        return dp[prices.size() - 1][0];\n    }\n};\n```\n\n###### 空间优化\n\n由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, profit0 - prices[i]);\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)\n\n","tags":["动态规划","贪心算法","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode188-买卖股票的最佳时机IV","url":"/blog/2020/12/28/LeetCode188-买卖股票的最佳时机IV/","content":"\n#### 题目描述\n\n给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。\n\n**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n<!-- more-->\n\n<img src=\"LeetCode188-买卖股票的最佳时机IV\\188.png\"  />\n\n#### 思路\n\n本题是[LeetCode122-买卖股票的最佳时机II]()的升级版，这道题与其最大的区别在于限制交易次数为 **k** 次，所以选择在何时交易至关重要。\n\n因为买入卖出至少得两天，所以最大的交易次数不会超过 $prices.size()/2$ 。如果 $k\\geq{prices.size()/2}$ ，那么本题就退化为122题。\n\n##### 定义dp数组\n\n需要记录当前还剩下多少次交易次数，还有当天是否持有股票。\n\n$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。\n\n$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。\n\n##### 状态转移方程\n\n* 第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：\n  $$\n  dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);\n  $$\n\n* 第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：\n  $$\n  dp[i][j][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);\n  $$\n\n##### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：\n\n```cpp\n// 剩余交易i次，获得收益初始化\nfor(int i = 0; i <= k; ++i){\n    dp[0][i][0] = 0;\n    dp[0][i][1] = -prices[0];\n}\n// 在没有进行股票交易时不允许持有股票\n// 这个系列中没有用到，记录学习一下\ndp[-1][k][1] = -INF;\ndp[i][0][1] = -INF;\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if(k == 0 || prices.empty()) return 0;\n        if(k >= prices.size() / 2){\n            return maxprofit(prices);\n        }\n        vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(k + 1, vector<int>(2, 0)));\n        // 最多交易i次，获得的收益\n        for(int i = 0; i <= k; ++i){\n            dp[0][i][0] = 0;\n            dp[0][i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = k; j > 0; --j){\n                // 第i天不持有，前一天不持有或前一天持有今天卖出\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                // 第i天持有，前一天持有或前一天不持有今天买入\n                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n        return dp[prices.size() - 1][k][0];\n    }\n    int maxprofit(vector<int> &prices){\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, profit0 - prices[i]);\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### 空间优化\n\n由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if(k == 0 || prices.empty()) return 0;\n        if(k >= prices.size() / 2){\n            return maxprofit(prices);\n        }\n        vector<vector<int>> dp(k + 1, vector<int>(2));\n        // 最多交易i次，获得的收益\n        for(int i = 0; i <= k; ++i){\n            dp[i][0] = 0;\n            dp[i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = k; j > 0; --j){\n                // 第i天不持有，前一天不持有或前一天持有今天卖出\n                dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]);\n                // 第i天持有，前一天持有或前一天不持有今天买入\n                dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]);\n            }\n        }\n        return dp[k][0];\n    }\n    int maxprofit(vector<int> &prices){\n        if(prices.empty()) return 0;\n        int fit0 = 0;\n        int fit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(fit0, fit1 + prices[i]);\n            int new1 = max(fit1, fit0 - prices[i]);\n            fit0 = new0;\n            fit1 = new1;\n        }\n        return fit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode205-同构字符串","url":"/blog/2020/12/27/LeetCode205-同构字符串/","content":"\n#### 题目描述\n\n给定两个字符串 ***s*** 和 ***t***，判断它们是否是同构的。\n\n如果 ***s*** 中的字符可以被替换得到 ***t*** ，那么这两个字符串是同构的。\n\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\n\n本题是[LeetCode290-单词规律](http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more)的简化版。\n\n<!--more-->\n\n<img src=\"LeetCode205-同构字符串\\205.png\"  />\n\n#### 思路\n\n##### 方法一\n\n与[LeetCode290-单词规律](http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more)基本一致。\n\n##### 方法二\n\n此题字母大小写均可，数组初始化时为0，每对字符都应唯一映射为同一个数。如果两个数不同，返回`false`，否则返回`true`。\n\n#### 代码\n\n##### 方法一\n\n```cpp\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        unordered_map<char, unordered_set<char>> map1;\n        unordered_map<char, unordered_set<char>> map2;\n        for(int i = 0; i < s.size(); ++i){\n            map1[s[i]].insert(t[i]);\n            map2[t[i]].insert(s[i]);\n            if(map1[s[i]].size() > 1 || map2[t[i]].size() > 1) return false;\n        }\n        return true;\n    }\n};\n```\n\n##### 方法二\n\n```cpp\nclass Solution {\npublic:\n    int map1[256];\n    int map2[256];\n    bool isIsomorphic(string s, string t) {\n        for(int i = 0; i < s.size(); ++i){\n            if(map1[s[i]] != map2[t[i]]) return false;\n            map1[s[i]] = i + 1;\n            map2[t[i]] = i + 1;\n        }\n        return true;\n    }\n};\n```\n\n#### Reference\n\n官方题解评论区：\n\nhttps://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/","tags":["哈希表","字符串"],"categories":["LeetCode"]},{"title":"LeetCode85-最大矩形","url":"/blog/2020/12/26/LeetCode85-最大矩形/","content":"\n#### 题目描述\n\n给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。\n\n本题与[LeetCode84-柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)基本一致。\n\n <!-- more-->\n\n<img src=\"LeetCode85-最大矩形\\85.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n如图，使坐标值竖向移动，求出每个坐标轴下的矩形最大面积，再从中取最大值就是最大的矩形：\n\n<img src=\"LeetCode85-最大矩形\\坐标轴.png\" style=\"zoom:80%;\" />\n\n很明显在图三中得到最大矩形，面积为6。求当前坐标轴下的最大矩形面积与[LeetCode84-柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/c-dan-diao-zhan-si-lu-qing-xi-you-tu-you-ip3c/)方法一致。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        if(matrix.empty()) return 0;\n        int res = 0;\n        vector<int> preHeights;\n        for(int i = 0; i < matrix.size(); ++i){\n            vector<int> heights;\n            for(int j = 0; j < matrix[0].size(); ++j){\n                if(i == 0){\n                    heights.push_back(matrix[i][j] - '0');    \n                }\n                else{\n                    if(matrix[i][j] == '1') \n                        heights.push_back(preHeights[j] + matrix[i][j] - '0');\n                    else\n                        heights.push_back(0);\n                }\n            }\n            preHeights = heights;\n            res = max(res, maxArea(heights));\n        }\n        return res;\n    }\n    int maxArea(vector<int> &heights){\n        heights.push_back(0);\n        stack<int> st;\n        int mArea = 0;\n        for(int i = 0; i < heights.size(); ++i){\n            int area = 0;\n            while(!st.empty() && heights[i] < heights[st.top()]){\n                int v = st.top();\n                st.pop();\n                int right = i;\n                int left = st.empty() ? 0 : st.top() + 1;\n                area = heights[v] * (right - left);\n                mArea = max(mArea, area);\n            }\n            st.push(i);\n        }\n        return mArea;\n    }\n};\n```\n\n#### Reference\n\n评论区：https://leetcode-cn.com/problems/maximal-rectangle/comments/","tags":["贪心算法","单调栈"],"categories":["LeetCode"]},{"title":"LeetCode84-柱状图中最大的矩形","url":"/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/","content":"\n#### 题目描述\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n<!-- more-->\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\84.png\"  />\n\n#### 思路\n\n找到当前高度下的最大矩形面积，然后从所有得到的面积中挑出最大的那一个就是能够勾勒出来矩形的最大面积，如下：\n\n1. 第1个高度，当前面积为2。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-1.png\"  />\n\n2. 第2个高度，当前面积为6。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-2.png\"  />\n\n3. 第3个高度，当前面积为10。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-3.png\"  />\n\n4. 第4个高度，当前面积为6。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-4.png\"  />\n\n5. 第5个高度，当前面积为8。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-5.png\"  />\n\n6. 第6个高度，当前面积为3。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-6.png\"  />\n\n综上，面积最大出现在第三个高度，此时面积为5。\n\n我们需要找到当前高度下可以构成矩形的左边界和右边界，再去计算矩形的面积，使用单调栈来实现：\n\n* 计算高度：如果当前高度小于栈顶元素，此时的栈顶就是上一次高度的最大值（准确一点，是上一次高度最大值的坐标），将其记录并出栈，这时候就可以计算上一个高度面积的最大值了，直到遇到栈顶元素小于等于当前元素或者栈为空，在此之前会一直计算高度\n\n* 寻找边界：当前遍历到的坐标 $i$ 就是右边界，左边界就是 $st.top()+1$（对于示例，当遍历到第二个2时，坐标为4，作为**右边界**；经过一系列的出栈操作，栈中**最后剩下**的元素坐标为1，而**左边界**就应该是**1+1​**而不是1），**如果栈为空，那么左边界就是0**。如下图：\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-边界.png\"  />\n\n所以为了提供坐标6，还需要给高度矩阵后面续上一个0。\n\n由于找到了下一个小于栈顶高度的值时才会计算面积，所以对于示例，最后得到的结果及顺序如下：\n\n|       坐标       |  0   |  1   |  2   |  3   |  4   |  5   |\n| :--------------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|       高度       |  2   |  1   |  5   |  6   |  2   |  3   |\n| 当前坐标最大面积 |  2   |  6   |  10  |  6   |  8   |  3   |\n|  面积出现的顺序  |  1   |  6   |  3   |  2   |  5   |  4   |\n\n即，真正得到的面积结果为`2, 6, 10, 3, 8, 6`。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        heights.push_back(0);\n        stack<int> st;\n        int mArea = 0;\n        for(int i = 0; i < heights.size(); ++i){\n            int area = 0;\n            while(!st.empty() && heights[i] < heights[st.top()]){\n                int v = st.top();\n                st.pop();\n                int right = i;\n                int left = st.empty() ? 0 : st.top() + 1;\n                area = heights[v] * (right - left);\n                mArea = max(mArea, area);\n            }\n            st.push(i);\n        }\n        return mArea;\n    }\n};\n```\n\n#### Reference\n\nCSDN：https://blog.csdn.net/Zolewit/article/details/88863970","tags":["贪心算法","单调栈"],"categories":["LeetCode"]},{"title":"LeetCode365-水壶问题","url":"/blog/2020/12/25/LeetCode365-水壶问题/","content":"\n#### 题目描述\n\n有两个容量分别为 `x` 升和 `y` 升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 `z` 升的水？\n\n如果可以，最后请用以上水壶中的一或两个来盛放取得的 `z` 升水。\n\n你允许：\n\n* 装满任意一个水壶\n* 清空任意一个水壶\n* 从一个水壶向另外一个水壶倒水，直到装满或者倒空\n\n<!-- more-->\n\n<img src=\"LeetCode365-水壶问题\\365.png\"  />\n\n#### 思路\n\n这道题实际上是一个数学问题，需要有先验知识——[贝祖定理](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&fromid=5185441)：若 $a, b$ 是整数，且$gcd(a,b)=d$，那么对于任意的整数 $x$$，y$，$ax+by$ 都一定是 $d$ 的倍数，特别地，一定存在整数 $x$,  $y$，使 $ax+by=d$ 成立。$gcd(a,b)$ 用来求 $a, b$ 的最大公约数，称为辗转相除法。\n\n实际上，每次操作只会让桶里的水增加`x`或增加`y`，减少`x`或减少`y`，两个桶不可能同时有水且不满，观察所有的操作都至少有一个桶是空的或满的。如果往一个不满的桶里加水或将其倒空是没有意义的，这是因为：\n\n* 向有水且不满的桶加水是没有意义的：\n  * 另一个桶满，加水等价于从初始状态给两个桶加满水\n  * 另一个桶空，加水等价于将不满的桶加满\n* 将有水且不满的桶倒掉是没有意义的：\n  * 另一个桶满，倒水等价于从初始状态给另一个桶加满水\n  * 另一个桶空，倒水等价于两个桶都没水，回到初始状态\n\n所以每次操作只会给水的总量带来`x`或`y`的变化量，所以目标为找到一组 $a, b$ ，满足：\n$$\nax+by=z\n$$\n根据贝祖定理，当且仅当`z`是  $a, b$ 最大公约数倍数时，有解。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int gcd(int a, int b){\n        if(a < b) swap(a, b);\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    bool canMeasureWater(int x, int y, int z) {\n        if(x + y < z) return false;\n        if(x == 0 || y == 0){\n            return z == 0 || x + y == z;\n        }\n        if(z % gcd(x, y) == 0) return true;\n        return false;\n    }\n};\n```\n\n#### Reference\n\n官方题解：\n\nhttps://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/\n\n#### 附录\n\n要满足$z\\le{x+y}$，且这样的 $a, b$ 存在，目标就可以达成，是因为：\n\n* 若 $a\\ge0, b\\ge0$时，可以达成\n\n* 若 $a<0$ ，那么执行以下操作：\n\n  * 将`y`壶倒满\n  * 将`y`壶中水倒入`x`壶\n  * 如果`y`不为空，那么`x`肯定是满的，把`x`**倒空**，再把`y`剩下的倒入`x`壶\n\n  重复以上操作直到某一步`x`壶进行了 $a$ 次倒空，`y`壶进行了 $b$ 次倒水操作。\n\n* 若 $b<0$，方法同上，`x`与`y`互换。\n\n","tags":["数学"],"categories":["LeetCode"]},{"title":"LeetCode12-整数转罗马数字","url":"/blog/2020/12/25/LeetCode12-整数转罗马数字/","content":"\n#### 题目描述\n\n罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n<img src=\"LeetCode12-整数转罗马数字\\12.png\"  />\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n* `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n* `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n* `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n<!-- more-->\n\n#### 思路\n\n主要是处理那些特殊的样例，结合代码，对于示例中的1994，去掉1000后还剩下994，这个900的表示是特殊的，所以如果当前 $num$ 范围是900-999，就需要加上\"CM\"；$num$ 还剩下94，这个90也是特殊的，所以如果当前 $num$ 范围是90-99，就需要加上\"XC\"；最后剩下4，所以加上\"IV\"，得到结果\"MCMXCIV\"。\n\n**需要注意`if`语句的顺序不能改变，就像状态机一样，执行完一个状态后才能执行下一个状态**。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        // 前面几行针对特定案例，注释了也不影响\n        if(num == 4) return \"IV\";\n        if(num == 9) return \"IX\";\n        if(num == 40) return \"XL\";\n        if(num == 90) return \"XC\";\n        if(num == 400) return \"CD\";\n        if(num == 900) return \"CM\";\n        string res;\n        while(num){\n            if(num / 1000 != 0){\n                res += string(num / 1000, 'M');\n                num -= num / 1000 * 1000;\n            }\n            else if(num >= 900 && num < 1000){\n                res += \"CM\";\n                num -= 900;\n            }\n            else if(num / 500 != 0){\n                res += string(num / 500, 'D');\n                num -= num / 500 * 500;\n            }\n            else if(num >= 400 && num < 500){\n                res += \"CD\";\n                num -= 400;\n            }\n            else if(num / 100 != 0){\n                res += string(num / 100, 'C');\n                num -= num / 100 * 100;\n            }\n            else if(num >= 90 && num < 100){\n                res += \"XC\";\n                num -= 90;\n            }\n            else if(num / 50 != 0){\n                res += string(num / 50, 'L');\n                num -= num / 50 * 50;\n            }\n            else if(num >= 40 && num < 50){\n                res += \"XL\";\n                num -= 40;\n            }\n            else if(num / 10 != 0){\n                res += string(num / 10, 'X');\n                num -= num / 10 * 10;\n            }\n            else if(num == 9){\n                res += \"IX\";\n                break;\n            }\n            else if(num / 5 != 0){\n                res += string(num / 5, 'V');\n                num -= num / 5 * 5;\n            }\n            else if(num == 4){\n                res += \"IV\";\n                break;\n            }\n            else if(num / 1 != 0){\n                res += string(num / 1, 'I');\n                num = 0;\n            }\n        }\n        return res;\n    }\n};\n```\n\n","tags":["贪心算法","状态机"],"categories":["LeetCode"]},{"title":"内存管理（三）","url":"/blog/2020/12/25/内存管理（三）/","content":"\n#### 本次学习要点\n\n1. 基本分页存储管理的基本概念\n2. 基本地址变换机构\n3. 具有快表的地址变换机构\n4. 基本分段存储管理方式\n5. 段页式管理方式\n\n<!-- more-->\n\n#### 基本分页存储管理的基本概念\n\n##### 连续分配方式的缺点\n\n1. 固定分区分配：内存利用率低，会产生大量的内部碎片。\n2. 动态分区分配：会产生很多外部碎片，可以通过“紧凑”处理，但代价很高。\n\n如果允许将一个程序分散的装入到许多不相邻的分区中，便可充分利用内存——非连续分配方式（离散分配方式）。\n\n##### 基本分页存储管理思想\n\n把内存分为一个个相等的小分区，再按照分区大小把进程拆分为一个个小部分。\n\n*如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高*。\n\n##### 分页存储的基本概念\n\n**页框**：将内存空间分为一个个**大小相等的分区**，每个分区就是一个页框，也称为”页帧“、”内存块“、”物理块“。\n\n**页框号**：每个页框的编号，其他名称同上。从0开始。\n\n**页**：将用户进程的地址空间分为**与页框大小相等**的一个个区域，称为”页“或者”页面“。\n\n**页号**：每个页面的编号，也是从0开始。\n\n操作系统**以页框为单位为各个进程分配**内存空间。进程的**页面**与内存的**页框**有**一一对应**的关系。\n\n##### 地址转换\n\n###### 进程在内存中连续存放\n\n重定位寄存器：存放装入模块的起始位置。\n\n思想：模块在内存中的“起始地址” + 目标内存单元相对于起始位置的“偏移量”。\n\n###### 进程在内存中非连续存放\n\n<img src=\"内存管理（三）\\进程在内存中非连续存放.png\" style=\"zoom:80%;\" />\n\n如何计算进程在内存中的存放位置？\n\n1. 计算出逻辑地址对应的页号：\n   $$\n   页号=逻辑地址/页面长度（取整）\n   $$\n\n2. 该页号对应页面在内存中的起始位置： 操作系统的某种数据结构记录\n\n3. 逻辑地址在页面内的偏移量：\n   $$\n   页内偏移量=逻辑地址\\%页面长度\n   $$\n\n4. 物理地址 = 页面地址+ 页内偏移量\n\n对于逻辑地址为80的内存单元：\n\n1. 在1号页 : $80 / 50 = 1$\n2. 该页在内存中的起始地址为450\n3. 内存单元相对于该页起始地址偏移量为 $80\\%50=30$\n4. 实际物理地址为 $450+30=480$\n\n为了方便计算页号、页内偏移量，**页面大小**一般取**2的整数幂**。\n\n假设用32个二进制位表示逻辑地址，页面大小为 $2^{12}B=4096B=4KB$。\n\n* 0号页逻辑地址空间为0~4095，用二进制表示为：\n\n  `0000_0000_0000_0000_0000_0000_0000_0000~0000_0000_0000_0000_0000_1111_1111_1111`\n\n* 1号页逻辑地址空间为4096~8191，用二进制表示为：\n\n  `0000_0000_0000_0000_0001_0000_0000_0000~0000_0000_0000_0000_0001_1111_1111_1111`\n\n* 2号页逻辑地址空间为4096~8191，用二进制表示为：\n\n  `0000_0000_0000_0000_0010_0000_0000_0000~0000_0000_0000_0000_0010_1111_1111_1111`\n\neg：逻辑地址4097，用二进制表示为：`0000_0000_0000_0000_0001_0000_0000_0001`。\n\n若1号页在内存中的起始地址为X，则逻辑地址4097对应的物理地址为：`X+0000_0000_0001`。\n\n结论：\n\n如果每个页面大小为 $2^KB$，用二进制数表示逻辑地址，则末尾的 $K$ 位为**页内偏移量**，其余部分就是**页号**。所以让**每个页面的大小为2的整数幂**。\n\n###### 分页存储管理的逻辑地址结构\n\n<img src=\"内存管理（三）\\分页存储管理的逻辑地址结构.png\"  />\n\n**如果有 $K$ 位表示“页内偏移量”，则说明系统中一个页面的大小是 $2^K$ 个内存单元**。\n\n**如果有 $M$ 位表示“页号”，则说明在该系统中，一个进程最多允许有 $2^M$ 个页面**。\n\n##### 页表\n\n为了能知道进程的每个页面在内存中存放的位置，操作系统要为**每个进程建立一张页表**。\n\n<img src=\"内存管理（三）\\页表.png\"  />\n\n上述的第五条，是因为：\n\n假设内存大小位4GB，页面大小位4KB，则每个页表项至少为多少个字节？\n\n$4GB=2^{32}B$\n\n$4KB=2^{12}B$\n\n $4GB$ 内存会被划分为 $2^{32}/2^{12}=2^{20}$ 个内存块，所以内存块号的范围是 $0\\sim2^{20}-1$ ，所以至少需要20个二进制位才能表示内存块号，即至少需要3个字节。\n\n各页表项会**按顺序且连续的**存在在内存中，如果该页表在内存中存放的起始位置为X，则M号页对应的页表项一定是存放在内存地址为 $X+3*M$ 处。\n\n因此，只需要知道**页表存放的起始位置**和**页表项长度**。即可找到各个页号对应的页表项存放的位置。\n\n##### 小结\n\n<img src=\"内存管理（三）\\分页存储管理小结.png\"  />\n\n#### 基本地址变换机构\n\n用于实现逻辑地址到物理地址转换的一组硬件机构。\n\n在**系统中**设置一个**页表寄存器（PTR）**，存放：\n\n* 页表在内存中的起始地址F\n* 页表长度M\n\n进程还未执行时，上述两个参数存放在**进程控制块（PCB）**中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。**页面大小是2的整数幂**。\n\n##### 地址变换过程\n\n设页面大小为L，逻辑地址A到物理地址E的变换过程如下：\n\n<img src=\"内存管理（三）\\逻辑地址2物理地址.png\"  />\n\n1. 计算页号P和页内偏移量W\n2. 比较页号P和页表长度M，若 $P\\geq{M}$ ，则产生越界\n3. 页表中页号P对应的 $页表项地址=页表起始地址F+页号P\\times页表项长度M$ ，取出该页表项内容b即为内存块号\n4. 计算 $E=b\\times L+W$，用得到的物理地址E去访问内存\n\n**注意**：\n\n* 页表长度：当前页表中总共有几个页表项，即总共有几个页（用户进程）\n* 页表项长度：每个页表项占多大的存储空间\n* 页面大小：一个页面占多大的存储空间（与页框大小一致，用户进程）\n\n##### 一个例题\n\n若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。\n\n等价描述：某系统**按字节寻址**，逻辑地址结构中，**页内偏移量占10位**（说明一个页面的大小位2^10B=1KB），页号2对应的内存块号b=8，将逻辑地址A=2500转换位物理地址E。\n\n1. 计算页号P、页内偏移量W\n\n$$\nP=A/L=2500/1024=2\\\\\\\\\nW=A\\%L=2500\\%1024=452\n$$\n\n2. 页号2没有越界，存放内存块号为b=8\n3. 计算物理地址E\n\n$$\nE=b\\times L+W=8\\times 1024+425=8644\n$$\n\n分页式存储管理系统中，只要确定每个页面的大小，逻辑地址结构就确定了。因此，**页式管理中地址是一维的**。即，只要给出逻辑地址，系统会自动算出页号、页内偏移量，**不需要**显示的告诉系统页内偏移量占多少位。\n\n##### 对页表项大小的进一步探讨\n\n之前说过一个页表项占据3B的内存，如果一个页面为4KB，则每个页框可以存放4096/3=1365个页表项，则会剩下4096%3=1B的页内碎片，如果**每个页表项占4个字节**，则每个页框刚好可存放1024个页表项。\n\n除此之外，如果**每个页表项占据3个字节**，则1365号页表项地址为 $X+3\\times1365+1$。如果**每个页表项占4个字节**，则1024号页表项地址为 $X+4\\times1024$，更方便计算。\n\n理论上，页表项长度为3B即可表示内存块号的范围，但是**为了方便页表查询，常常会让一个页表项占据更多的字节，使得每个页面恰好可以装得下整数个页表项**。\n\n##### 小结\n\n<img src=\"内存管理（三）\\基本地址变换机构.png\"  />\n\n#### 具有快表的地址变换机构\n\n基本地址变换机构的改进版本。\n\n##### 局部性原理\n\n* 时间局部性：如果程序执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很有可能再次被访问（程序中一般存在大量循环）。\n* 空间局部性：如果程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（数据在内存中连续存放）。\n\n之前提到的**基本地址变换机构**中，每访问一个逻辑地址，都**需要查询内存中的页表**。由于局部性原理，可能**连续很多次查到的都是同一个页表项**。可以利用这个特性减少访问页表的次数。\n\n##### 快表（TLB）\n\n也称联想寄存器（TLB），是一种**访问速度比内存快很多**的**高速缓冲存储器**，存储当前访问的若页表项，加速地址变换过程。相对应的**内存**中的页表称为**慢表**。\n\n##### 引入快表后，地址的变换过程\n\n<img src=\"内存管理（三）\\引入快表后的地址变换过程.png\"  />\n\n1. CPU给出逻辑地址，由**硬件**得到页号、页内偏移量，将页号与快表中的所有页号进行比较。\n2. 找到匹配的页号，直接从**快表**中取出该页对应的内存块号，将内存块号和页内偏移量拼接成物理地址，再访问该物理地址对应的内存单元。因此**快表命中**，访问某个逻辑地址仅需**一次访存**。\n3. 未找到匹配的页号，访问**内存中的页表**，找到对应页表项，根据页表项得到页面存放的内存块号，再将内存块号和页内偏移量拼接得到物理地址，再根据物理地址访问对应的内存单元。因此**快表未命中**，访问某个逻辑地址需要**两次访存**（找到页表项后，同时将其**存入快表**，若快表已满，则按照一定算法对旧的页表进行替换）。\n\n由于局部性原理，快表命中率可达**90%**以上。\n\n##### 小结\n\n<img src=\"内存管理（三）\\快表小结.png\"  />","categories":["操作系统"]},{"title":"LeetCode455-分发饼干","url":"/blog/2020/12/25/LeetCode455-分发饼干/","content":"\n#### 题目描述\n\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n\n对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j]` >= `g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n<!-- more-->\n\n<img src=\"LeetCode455-分发饼干\\455.png\"  />\n\n#### 思路\n\n先将两个数组分别排序，使用两个指针分别指向两个数组的首元素，当饼干值满足胃口值时，两个指针后移；否则只需要将饼干数组的指针进行后移，直到满足胃口值或到达数组末尾。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int i = 0, j = 0;\n        int cnt = 0;\n        while(i < g.size() && j < s.size()){\n            if(s[j] >= g[i]){\n                cnt++;\n                i++;\n                j++;\n            }\n            else j++;\n        }\n        return cnt;\n    }\n};\n```\n\n","tags":["贪心算法","双指针"],"categories":["LeetCode"]},{"title":"LeetCode135-分发糖果","url":"/blog/2020/12/24/LeetCode135-分发糖果/","content":"\n#### 题目描述\n\n老师想给孩子们分发糖果，有 *N* 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。\n\n你需要按照以下要求，帮助老师给这些孩子分发糖果：\n\n* 每个孩子至少分配到 1 个糖果。\n* 相邻的孩子中，评分高的孩子必须获得更多的糖果。\n\n那么这样下来，老师至少需要准备多少颗糖果呢？\n\n<!-- more-->\n\n<img src=\"LeetCode135-分发糖果\\135.png\"  />\n\n#### 思路\n\n用数组 $store$ 记录每个孩子得到的糖果数，$store[i]$ 表示第 $i$ 个孩子获得的糖果数。\n\n首先找到最低的评分，这个位置记为 $pos$，最低分孩子的糖果数必为1，所以可以得到 $store[pos]=1$ ，以 $pos$为界，将评分数组分为两个部分分别操作，两个部分是**互不影响**的。\n\n<img src=\"LeetCode135-分发糖果\\评分数组.png\" style=\"zoom:80%;\" />\n\n1. 对于 $pos$ 之前（包括 $pos$），往回遍历评分数组，在不越界的条件下可以得到：\n\n   <img src=\"LeetCode135-分发糖果\\从后往前1.png\" style=\"zoom:80%;\" />\n\n   1. 如果前一个评分小于当前评分：\n\n      1. 当前糖果数不为1，那么前一个孩子获得的糖果置为1，结束；\n\n      2. 当前糖果数为1，那么前一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于前一个孩子获得的糖果数（前一个评分小于当前评分）。所以需要从前一个位置开始往后遍历：\n\n         1. 如果遇到**后一个评分大于当前评分，并且后一个的糖果等于当前糖果数（上图红线）**，需要给后一个糖果数加1，保证后一个的糖果大于当前糖果数。\n\n            <img src=\"LeetCode135-分发糖果\\从后往前2.png\" style=\"zoom:80%;\" />\n\n         2. 如果后一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。\n\n            <img src=\"LeetCode135-分发糖果\\从后往前3.png\" style=\"zoom:80%;\" />\n\n   2. 如果前一个评分等于当前评分，前一个糖果数为1\n\n   3. 如果前一个评分大于当前评分，前一个糖果数为当前糖果数加1\n\n2. 对于 $pos$ 之后（包括 $pos$），往后遍历评分数组，在不越界的条件下：\n\n   <img src=\"LeetCode135-分发糖果\\从前往后1.png\" style=\"zoom:80%;\" />\n\n   1. 如果后一个评分小于当前评分：\n\n      1. 当前糖果数不为1，那么后一个孩子获得的糖果置为1，结束；\n\n      2. 当前糖果数为1，那么后一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于后一个孩子获得的糖果数（后一个评分小于当前评分）。所以需要从后一个位置开始往前遍历：\n\n         1. 如果遇到**前一个评分大于当前评分，并且前一个的糖果等于当前糖果数（上图红线）**，需要给前一个糖果数加1，保证前一个的糖果大于当前糖果数。\n\n            <img src=\"LeetCode135-分发糖果\\从前往后2.png\" style=\"zoom: 80%;\" />\n\n         2. 如果前一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。\n\n            <img src=\"LeetCode135-分发糖果\\从前往后3.png\" style=\"zoom:80%;\" />\n\n   2. 如果后一个评分等于当前评分，后一个糖果数为1\n\n   3. 如果后一个评分大于当前评分，后一个糖果数为当前糖果数加1\n\n最终结果：\n\n| ratings | 2    | 3    | 3    | 1    | 3    | 2    | 2    | 1    |\n| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| store   | 1    | 2    | 2    | 1    | 2    | 1    | 2    | 1    |\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        if(ratings.empty()) return 0;\n        auto iter = min_element(ratings.begin(), ratings.end());\n        int val = *iter;\n        int pos = iter - ratings.begin();\n        vector<int> store(ratings.size(), 0);\n        store[pos] = 1;\n        // 从pos往前\n        for(int i = pos; i >= 0; --i){\n            if(i - 1 >= 0 && ratings[i - 1] < ratings[i]){\n                if(store[i] != 1) store[i - 1] = 1;\n                else{\n                    store[i - 1] = 1;\n                    for(int j = i - 1; j < pos; ++j){\n                        // 往后走\n                        // 下一个评分比当前评分高，并且下一个的糖果又没当前糖果多\n                        if(ratings[j + 1] > ratings[j] && store[j + 1] <= store[j]){\n                            store[j + 1] += 1;\n                        }\n                        if(ratings[j + 1] == ratings[j]) break;                        \n                    }\n                }\n            }\n            else if(i - 1 >= 0 && ratings[i - 1] == ratings[i]){\n                store[i - 1] = 1;\n            }\n            else if(i - 1 >= 0 && ratings[i - 1] > ratings[i]){\n                store[i - 1] = store[i] + 1;\n            }\n        }\n        // 从pos往后\n        for(int i = pos; i < ratings.size(); ++i){\n            if(i + 1 < ratings.size() && ratings[i + 1] < ratings[i]){\n                if(store[i] != 1) store[i + 1] = 1;\n                else{\n                    store[i + 1] = 1;\n                    for(int j = i + 1; j > pos; --j){\n                        // 往前走\n                        // 上一个评分比当前评分高，并且上一个的糖果又没当前糖果多\n                        if(ratings[j - 1] > ratings[j] && store[j - 1] <= store[j]){\n                            store[j - 1] += 1;\n                        }\n                        if(ratings[j - 1] == ratings[j]) break;\n                    }\n                }\n            }\n            else if(i + 1 < ratings.size() && ratings[i + 1] == ratings[i]){\n                store[i + 1] = 1;\n            }\n            else if(i + 1 < ratings.size() && ratings[i + 1] > ratings[i]){\n                store[i + 1] = store[i] + 1;\n            }\n        }\n        // for(auto &v : store) cout << v << \" \";\n        int sum = accumulate(store.begin(), store.end(), 0);\n        return sum;\n    }\n};\n```\n\n#### 更进一步\n\n##### 思路\n\n**相邻的孩子中，评分高的孩子必须获得更多的糖果**。这句话可以拆为两个规则分别处理：\n\n* 左规则：当 $ratings[i-1]<ratings[i]$ 时，$i$ 获得的糖果要多于 $i-1$ 。\n* 右规则：当 $ratings[i]>ratings[i+1]$ 时，$i$ 获得的糖果要多于 $i+1$ 。\n\n遍历数组两次，分别得到每一个孩子满足左规则和右规则的糖果数，取两者之间的最大值就是这个孩子最少分配的糖果数。\n\n在实际代码中，我们先计算出左规则 $left$ 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        if(ratings.empty()) return 0;\n        vector<int> left(ratings.size());\n        for(int i = 0; i < ratings.size(); ++i){\n            if(i - 1 >= 0 && ratings[i] > ratings[i - 1]){\n                left[i] = left[i - 1] + 1;\n            }\n            else\n                left[i] = 1;\n        }\n        int right = 0, ret = 0;\n        for(int i = ratings.size() - 1; i >= 0; --i){\n            if(i + 1 < ratings.size() && ratings[i] > ratings[i + 1]){\n                right++;\n            }\n            else{\n                right = 1;\n            }\n            ret += max(left[i], right);\n        }\n        return ret;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode387-字符串中的第一个唯一字符","url":"/blog/2020/12/23/LeetCode387-字符串中的第一个唯一字符/","content":"\n#### 题目描述\n\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n<!-- more-->\n\n<img src=\"LeetCode387-字符串中的第一个唯一字符\\387.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n用一个哈希表记录一下每个字母出现的次数，返回第一个出现次数为1的字母位置即可。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        int cnt[26] = {0};\n        for(auto &ch : s)\n            cnt[ch - 'a']++;\n        int pos = -1;\n        for(int i = 0; i < s.size(); ++i){\n            if(cnt[s[i] - 'a'] == 1){\n                pos = i;\n                break;\n            }      \n        }\n        return pos;\n    }\n};\n```\n\n","tags":["哈希表","字符串"],"categories":["LeetCode"]},{"title":"LeetCode103-二叉树的锯齿形层序遍历","url":"/blog/2020/12/22/LeetCode103-二叉树的锯齿形层序遍历/","content":"\n#### 题目描述\n\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n<!-- more-->\n\n例如：\n给定二叉树 `[3,9,20,null,null,15,7]`,\n\n<img src=\"LeetCode103-二叉树的锯齿形层序遍历\\103.png\"  />\n\n#### 思路\n\n这道题和二叉树的层序遍历很相似，无非就是遍历完每一层需要改变一次方向，使用一个标志位标记从前往后或者从后往前遍历。可以使用双端队列，根据标志位决定从队列的那一头开始遍历。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if(!root) return {};\n        vector<vector<int>> res;\n        deque<TreeNode*> deq;\n        deq.push_back(root);\n        int dir = 0;\n        while(!deq.empty()){\n            vector<int> buf;\n            // 前往后\n            if(dir == 0){\n                dir = 1;\n                int n = deq.size();\n                for(int i = 0; i < n; ++i){\n                    TreeNode* tmp = deq.front();\n                    buf.push_back(tmp->val);\n                    // 前向时需要先将左边的点入队，保证下次遍历的顺序正确\n                    if(tmp->left) deq.push_back(tmp->left);\n                    if(tmp->right) deq.push_back(tmp->right);\n                    deq.pop_front();\n                }\n                res.push_back(buf);\n            }\n            // 后往前\n            else{\n                dir = 0;\n                int n = deq.size();\n                for(int i = 0; i < n; ++i){\n                    TreeNode* tmp = deq.back();\n                    buf.push_back(tmp->val);\n                    // 后向时需要先将右边的点入队，保证下次遍历的顺序正确\n                    if(tmp->right) deq.push_front(tmp->right);\n                    if(tmp->left) deq.push_front(tmp->left);\n                    deq.pop_back();\n                }\n                res.push_back(buf);\n            }        \n        }\n        return res;\n    }\n};\n```\n\n#### 附录\n\n[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)：\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(!root) return {};\n        vector<vector<int>> res;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int n = q.size();\n            vector<int> buf;\n            for(int i = 0; i < n; ++i){\n                TreeNode *node = q.front();\n                q.pop();\n                buf.push_back(node->val);\n                if(node->left) q.push(node->left);\n                if(node->right) q.push(node->right);\n            }\n            res.push_back(buf);\n        }\n        return res;\n    }\n};\n```\n\n","tags":["二叉树"],"categories":["LeetCode"]},{"title":"C++关联容器","url":"/blog/2020/12/21/C-关联容器/","content":"\n#### 本次学习要点\n\n1. 使用关联容器\n2. 关联容器概述\n3. 关联容器操作\n4. 无序容器\n\n<!-- more-->\n\n关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是**map**和**set**。\n\n* `map`中元素是一些关键字-值（key-value）对，关键字起到索引的作用，值则表示于索引相关联的数据。\n* `set`中每个元素只包含一个关键字，支持高效的关键字查询操作-检查一个给定的关键字是否在set中。\n\n<img src=\"C-关联容器\\关联容器类型.png\"  />\n\n类型`map`和`multimap`定义在头文件`map`中；`set`和`multiset`定义在头文件`set`中；无序容器定义在头文件`unordered_map`和`unordered_set`中。\n\n#### 使用关联容器\n\n##### 使用map\n\n单词计数程序：\n\n```cpp\nmap<string, size_t> word_count;\nstring count;\nwhile(cin >> word)\n\t++word_count[word];\nfor(const auto &w : word_count)\n    cout << w.first << \" occurs \" << w.second\n    << ((w.second > 1) ? \" times\" : \" time\") << endl;\n```\n\n此程序读取输入，报告每个单词出现多少次。`map`保存的每个元素中，关键字是`string`，值是`size_t`类型。如果`word`还未在`map`中。下标运算符会创建一个新元素。从`map`中提取一个元素时，会得到一个`pair`类型的对象，`pair`用`first`成员保存关键字，用`second`成员保存对应的值。\n\n##### 使用set\n\n对上一个程序扩展，忽略常见单词，如“the”、“and”、“or”等。可以用`set`保存想忽略的单词，只对不在集合中的单词统计出现次数：\n\n```cpp\nmap<string, size_t> word_count;\nset<string> exclude = {\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\",\n                       \"the\", \"but\", \"and\", \"or\", \"an\", \"a\"};\nstring count;\nwhile(cin >> word)\n    if(exclude.find(word) == exclude.end())\n\t\t++word_count[word];\n```\n\n在`if`中，`find`返回一个迭代器。如果给定关键字在`set`中，迭代器指向该关键字。否则，`find`返回尾后迭代器。\n\n#### 关联容器概述\n\n##### 定义关联容器\n\n当定义一个`map`时，必须指明**关键字类型**和**值类型**；而定义一个`set`时，只需要指明**关键字类型**。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。\n\n```cpp\nmap<string, size_t> word_count; // 空容器\n// 列表初始化\nset<string> exclude = {\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\",\n                       \"the\", \"but\", \"and\", \"or\", \"an\", \"a\"};\n// 三个元素；authors将姓映射为名\nmap<string, string> authors = { {\"zhao\", \"xingyu\"},\n                                {\"zhou\", \"yanxuan\"}};\n```\n\n初始化`map`时，每对映射用花括号包含：{*key*, *value*}。\n\n##### 初始化multimap或multiset\n\n`map`和`set`的关键字都是唯一的。容器`multiset`和`multimap`没有此限制，它们都允许多个元素具有相同的关键字。\n\n```cpp\n// 定义一个有20哥元素的vector，保存0到9每个整数的两个拷贝\nvector<int> ivec;\nfor(vector<int>::size_type i = 0; i != 10; ++i){\n    ivec.push_back(i);\n    ivec.push_back(i);\n}\n// iset包含来自ivec的不重复的元素；miset包含所有20个元素\nset<int> iset(ivec.begin(), ivec.end());\nmultiset<int> miset(ivec.begin(), ivec.end());\ncout << ivec.size() << endl;\ncout << iset.size() << endl;\ncout << miset.size() << endl;\n```\n\n##### 关键字类型的要求\n\n###### 有序容器的关键字类型\n\n所提供的操作必须在关键字类型上定义一个**严格弱序**。可以将严格弱序看作“小于”（**书上是\"小于等于\"，网上查到为小于**），它必须具备以下性质：\n\n* 两个关键字不能同时“小于”对方\n* 如果k1\"小于\"k2，k2“小于”k3，那么k1必须”小于“k3\n* 如果存在两个关键字，任何一个都不”小于“另一个，那么我们称这两个关键字是”等价“的。并且等价具有传递性。\n\n如果两个关键字等价，那么容器将它们视作相等来处理。\n\n###### 使用关键字类型的比较函数\n\n在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数的形式提供真正的比较操作（其类型必须与尖括号中指定的类型相吻合）。\n\n例如：我们不能直接定义一个`Sales_data`的`multiset`，因为`Sales_data`没有`<`运算符。以下函数在`ISBN`成员上定义一个严格弱序：\n\n```cpp\nbool compareIsbn(const Sales_data &lhs, const Sales_data &rhs){\n    return lhs.isbn() < rhs.isbn();\n}\n```\n\n**要使用自己定义的操作**，在定义`multiset`时必须提供两个类型：**关键字类型**Sales_data以及**比较操作类型**——应该是一种函数指针类型，可以指向`compareIsbn`：\n\n```cpp\n// bookstore中多条记录可以有相同的ISBN\n// bookstore中的元素以ISBN的顺序进行排列\nmultiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);\n```\n\n**当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数的指针**。`bookstore`中的元素将按它们的`ISBN`成员的值升序排列。\n\n##### pair类型\n\n`pair`标注库类型定义在头文件`utility`中。`pair`保存两个数据成员，它是一个用来生成特定类型的模板。\n\n```cpp\npair<string, string > anon;\npair<string, size_t> word_count;\npair<string, vector<int>> line;\n```\n\n`pair`的默认构造函数对数据成员进行值初始化。以下三种初始化都是可以的：\n\n```cpp\npair<int, int> p = {1,1};\npair<int, int> q{1,1};\npair<int, int> m(1,1);\n```\n\n<img src=\"C-关联容器\\pair上的操作.png\"  />\n\n###### 创建pair对象的函数\n\n新标准下，可以对返回值进行列表初始化：\n\n```cpp\npair<string, int> process(vector<string> &v){\n\t// 处理v\n    if(!v.empty())\n        return {v.back(), v.back().size()}; // 列表初始化\n    else\n        return pair<string, int>(); // 隐式构造返回值\n}\n```\n\n早期版本必须显式的构造返回值：\n\n```cpp\nif(!v.empty())\n    return pair<string, int>(v.back(), v.back().size());\n```\n\n还可以使用`make_pair`来生成`pair`对象，`pair`的两个类型来自于`make_pair`的参数：\n\n```cpp\nif(!v.empty())\n\treturn make_pair(v.back(), v.back().size());\n```\n\n#### 关联容器操作\n\n<img src=\"C-关联容器\\关联容器额外的类型别名.png\"  />\n\n```cpp\nset<string>::value_type v1; // v1是一个string\nset<string>::key_value v2; // v2是一个string\nmap<string, int>::value_type v3; // v3是一个pair<const string, int>\nmap<string, int>::key_type v4; // v4是一个string\nmap<string, int>::mapped_type v5; // v5是一个int\n```\n\n只有`map`类型（`unordered_map、unordered_multimap、multimap、map`）才定义了`mapped_type`;\n\n##### 关联容器迭代器\n\n解引用一个关联容器的迭代器时，得到一个类型为容器的`value_type`的值的**引用**。对`map`而言，`value_type`是一个`pair`类型，其`first`成员保存`cosnt`的关键字，`second`成员保存值。\n\n```cpp\n// 获得指向word_count中一个元素的迭代器\nauto map_it = word_count.begin();\n// *map_it是指向一个pair<const string, size_t>对象的引用\n// 或者使用(*map_it).first，(*map_it).second\ncout << map_it->first; // 打印此元素的关键字\ncout << \" \" << map_it->second; // 打印此元素的值\nmap_it->first = \"new key\"; // 错误：关键字是const的\n++map_it->second; // 正确：可以通过迭代器改变元素 \n```\n\n###### set的迭代器是const的\n\n虽然`set`类型同时定义了`iterator`和`const_iterator`类型， 但两种类型都只允许读`set`中的元素。\n\n```cpp\nset<int> iset = {0,1,2,3,4,5,6};\nset<int>::iterator set_it = iset.begin();\nif(set_it != iset.end()){\n    *set_it = 42; // 错误：set中的关键字是只读的\n    cout << *set_it << endl; // 正确：可以读关键字\n}\n```\n\n###### 遍历关联容器\n\n`map`和`set`都支持之前所说的`begin`和`end`操作。\n\n```cpp\nauto map_it = word_count.cbegin();\nwhile(map_it != word_count.cbegin()){\n    cout << map_it->first << \" occurs\"\n         << map_it->second << \" times\" << endl;\n    ++map_it;\n}\n```\n\n###### 关联容器和算法\n\n通常不对关联容器使用泛型算法，有其专用算法。如果真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的位置。\n\n##### 添加元素\n\n使用关联容器的`insert`成员向容器中添加一个元素或一个元素范围：\n\n```cpp\nvector<int> ivec = {2,4,6,8,2,4,6,8}; // ivec有8个元素\nset<int> set2;\nset2.insert(ivec.cbegin(), ivec.cend()); // set2有4个元素\nset2.insert({1,3,5,7,1,3,5,7}); // set2现在有8个元素\n```\n\n###### 向map添加元素\n\n对一个`map`进行`insert`操作时，必须记住元素类型是`pair`。\n\n```cpp\n// 向word_count插入word的4种方法\nword_count.insert({word, 1});\nword_count.insert(make_pair(word, 1));\nword_count.insert(pair<string, size_t>(word, 1));\nword_count.insert(map<string, size_t>::value_type(word, 1));\n```\n\n<img src=\"C-关联容器\\关联容器insert操作.png\"  />\n\n###### 检测insert返回值\n\n`insert`(或`emplace`)返回的值依赖于容器类型和参数。对于**不包含重复关键字**的容器，添加单一元素的`insert`和`emplace`版本返回一个`pair`，告诉我们插入操作是否成功。`pair`的`first`成员是一个**迭代器**，指向**具有给定关键字的元素**；`second`成员是一个`bool`值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则`insert`什么事情也不做，且返回值中的`bool`部分为`false`。如果关键字不存在，元素被插入容器中，且`bool`值为`true`。\n\n例子，重写单词计数程序：\n\n```cpp\nmap<string, size_t> word_count;\nstring word;\nwhile(cin >> word){\n    auto ret = word_count.insert({word, 1});\n    if(!ret.second)\n        ++ret.first->second;\n}\n```\n\n###### 展开递增语句\n\n* **ret**：保存`insert`返回的值，是一个**pair**\n* **ret.first**：是一个`map`迭代器，指向具有给定关键字的元素\n* **ret.first->**：解引用此迭代器，提取`map`种元素，元素也是一个`pair`\n* **ret.first->second**：`map`中元素的值部分\n* **++ret.first->second**：递增此值\n\n###### 向multiset或multimap添加元素\n\n```cpp\nmultimap<string, string> authors;\n// 插入第一个元素，关键字为zxy\nauthors.insert({\"zxy\", \"c++泛型算法\"});\n// 正确：添加第二个元素，关键字也是zxy\"\nauthors.insert({\"zxy\", \"c++关联容器\"});\n```\n\n这里`insert`操作返回一个指向新元素的迭代器。无需返回一个`bool`值，因为`insert`总是向这类容器中加入一个新元素。\n\n##### 删除元素\n\n关联容器定义了三个版本的`erase`，如下：\n\n<img src=\"C-关联容器\\关联容器erase操作.png\"  />\n\n后两个与顺序容器一样，第一个是关联容器额外提供的，它接受一个`key_type`类型。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除元素的数量。\n\n* 对于保存不重复关键字的容器，`erase`的返回值总是0或1。0表示要删除的元素不在容器中\n* 对于允许重复关键字的容器，删除元素的数量可能大于1\n\n##### map的下标操作\n\n`map`和`unordered_map`容器提供了下标运算符和一个对应的`at`函数：\n\n<img src=\"C-关联容器\\map和unordered_map的下标操作.png\"  />\n\n**`set`类型不支持下标，因为`set`中元素本身就是关键字，同时也不能对`multimap`或者`unordered_multimap`进行下标操作，因为这些容器中可能有多个值与一个关键字相关联**。\n\n<img src=\"C-关联容器\\map_note.png\"  />\n\n###### 使用下标操作的返回值\n\n当对一个`map`进行下标操作时，会获得一个`mapped_type`对象；但当解引用一个`map`迭代器时，会得到一个`value_type`对象。与其他下标运算符相同的是，`map`的下标运算符返回一个左值，所以既可以读也可以写元素。\n\n<img src=\"C-关联容器\\map下标_note.png\"  />\n\n##### 访问元素\n\n关联容器提供多种查找一个指定元素的方法，应该使用哪个取决我们要解决什么问题。\n\n<img src=\"C-关联容器\\在一个关联容器种查找元素的操作.png\"  />\n\n```cpp\nset<int> iset{0,1,2,3,4,5,6};\niset.find(1); // 返回一个迭代器，指向key = 1的元素\niset.find(11); // 返回一个迭代器，其值等于iset.end()\niset.count(1); // 返回1\niset.count(11); // 返回0\n```\n\n###### 对map和find代替下标操作\n\n如果我们只是想知道一个给定的关键字是否在`map`中，而不想改变`map`（下标操作会插入一个未在`map`的元素）。这种情况下应该使用`find`：\n\n```cpp\nif(word_count.find(\"foobar\") == word_count.end())\n\tcout << \"foobar is not in the map\" << endl;\n```\n\n###### 在multimap或multiset中查找元素\n\n如果一个`multimap`或`multiset`中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。\n\n例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。可以用三种不同方法来解决这个问题。最直观的方法是使用`find`和`count`。\n\n```cpp\nstring search_item(\"zxy\"); // 作者\nauto entries = authors.count(search_item); // 元素的数量\nauto iter = authors.find(search_item); // 作者的第一本书\n// 查找此作者所有著作\nwhile(entries){\n    cout << iter->second << endl; // 打印书名\n    ++iter; // 下一本\n    --entries; // 打印一次，计数减一\n}\n```\n\n<img src=\"C-关联容器\\multimap或multiset中查找元素_note.png\"  />\n\n###### 一种不同的，面向迭代器的解决办法\n\n可以使用`lower_bound`和`upper_bound`来解决。\n\n* 关键字在容器中，`lower_bound`返回迭代器将指向第一个具有给定关键字的元素，`upper_bound`返回迭代器指向最后一个匹配关键字元素之后的位置\n* 关键字不在容器中，两者返回一个不影响排序的关键字插入位置\n\n因此，使用相同关键字调用`lower_bound`和`upper_bound`会得到关键字元素的范围。我们可以重写程序：\n\n```cpp\nfor(auto beg = authors.lower_bound(search_item),\n    end = authors.upper_bound(search_item);\n    beg != end; ++ beg)\n    cout << beg->second << endl;\n```\n\n<img src=\"C-关联容器\\lower_bound和upper_bound_note.png\"  />\n\n###### equal_range函数\n\n此函数接受一个关键字，返回一个**迭代器`pair`**（不是`pair`对象）。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。再次修改程序\n\n```cpp\nfor(auto pos = authors.equal_range(search_item);\n\tpos.first != pos.second; ++pos.first)\n    cout << pos.first->second << endl;\n```\n\n##### 一个单词转换的map\n\n程序功能：给定一个`string`，将它转换为另一个`string`。我们需要根据单词转换文件将待转换的文本转换为我们想要的样子：\n\n单词转换文件：\n\n```\nk okay?\ny why\nr are\nu you\npic picture\nthk thank!\nl8r later\n```\n\n待转换文本：\n\n```\nwhere r u\ny dont u send me a pic\nk thk l8r\n```\n\n转换结果：\n\n```\nwhere are you\nwhy dont you send me a picture\nokay? thanks! later\n```\n\n###### 单词转换程序\n\n```cpp\n// map_file 转换规则\n// input 待转换文本\nvoid word_transform(ifstream &map_file, ifstream &input, ofstream &output){\n    auto trans_map = buildMap(map_file);\n    string text; // 保存输入中的每一行\n    while(getline(input, text)){ // 读取每一行输入\n        istringstream stream(text); // 读取每个单词\n        string word;\n        bool firstword = true; // 控制是否打印空格\n        while(stream >> word){\n            if(firstword)\n                firstword = false;\n            else\n                output << \" \"; // 单词间打印一个空格\n            output << transform(word, trans_map); // 打印输出\n        }\n        output << endl; // 完成一行的转换\n    }\n}\n```\n\n###### 建立转换映射\n\n```cpp\nmap<string, string> buildMap(ifstream & map_file){\n\tmap<string, string> trans_map; // 保存转换规则\n    string key; // 要转换的单词\n    string value; // 替换后的内容\n    // 读取第一个单词存入key，剩余存入value（包括标点）\n    // map_file>>key流只读取第一个空格前string，剩下的流由getline读取到value中\n    while(map_file >> key && getline(map_file, value))\n        if(value.size() > 1) // 检查是否有转换规则\n            trans_map[key] = value.substr(1); // 跳过前导空格，getline不会跳过前导空格\n        else\n            throw runtime_error(\"no rule for \" + key);\n    return trans_map;\n}\n```\n\n###### 生成转换文本\n\n```cpp\nconst string& transform(const string &s, const map<string, string> &m){\n    auto map_it = m.find(s);\n    if(map_it != m.cend())\n        return map_it->second; // 使用替换短语\n    else return s; // 否则返回原string\n}\n```\n\n#### 无序容器\n\n新标准定义了**4**个**无序关联容器**，这些容器使用一个哈希函数和关键字类型的`==`运算符。\n\n###### 使用无序容器\n\n用于`map`和`set`的操作也能用于`unordered_map`和`unordered_set`，如`find、insert`等。无序容器也有允许重复关键字的版本。\n\n###### 管理桶\n\n无序容器在存储上组织为**一组桶**，每个桶保存零个或多个元素。**无序容器使用一个哈希函数将元素映射到桶**。\n\n* 为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。\n\n* 容器将具有一个特定哈希值的所有元素都保存在相同的桶中。\n* 如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。\n\n因此，无序容器的性能依赖于**哈希函数的质量**和**桶的数量和大小**。\n\n对于相同的参数，哈希函数必须总是产生相同的结果。**理想情况下，哈希函数将每个特定的值映射到唯一的桶**。但是，**将不同关键字的元素映射到相同的桶也是允许的**。\n\n* 当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。\n* 计算一个元素的哈希值和在桶中搜索通常都是很快的操作。\n* 如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。\n\n以下这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。\n\n<img src=\"C-关联容器\\无序容器管理操作.png\"  />\n\n###### 无序容器对关键字类型的要求\n\n默认情况下，无序容器使用关键字类型`==`运算符来比较元素，它们还使用一个`hash<key_type>`类型的对象来**生成每个元素的哈希值**。\n\n* 无序容器支持关键字是**内置类型(包括指针类型)**、**`string`**或者**智能指针**类型的无序容器。\n* 无序容器**不能**直接定义**关键字类型为自定义类类型的无序容器**。与容器不同，不能直接使用哈希模板，而必须提供我们自己的`hash`模板版本。\n* 不使用默认的`hash`，而是使用一种类似于**为有序容器重载关键字类型**的默认比较操作。\n\n为了能将`Sale_data`用作关键字，我们需要提供函数来替代`==`运算符和哈希值计算函数。我们从定义这些重载函数开始：\n\n```cpp\nsize_t hasher(const Sales_data &sd){\n    return hash<string>()(sd.isbn());\n}\nbool eqOp(const Sales_data &lhs, const Sales_data &rhs){\n    return lhs.isbn() == rhs.isbn();\n}\n```\n\n`hasher`函数使用标准库`hash`类型对象计算`ISBN`成员的哈希值，该哈希值建立在`string`之上。\n\n`eqOp`函数通过比较`ISBN`号来比较两个`Salas_data`。\n\n使用以上函数来定义一个`unordered_multiset`：\n\n```cpp\nusing SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;\n// 参数是桶大小、哈希函数指针和相等性判断运算符指针\nSD_miltiset bookstore(42, hasher, eqOp);\n```\n\n此集合的哈希和相等性判断操作与`hasher`和`eqOp`函数有着相同的类型。在定义`bookstore`时可以将我们希望它使用的函数的指针传递给它。\n\n如果类定义了`==`运算符，则可以只重载哈希函数：\n\n```cpp\n// 使用FooHash生成哈希值；Foo必须有==运算符\nunordered_set<Foo, decltype(FooHash)*> fooSet(10, FoolHash);\n```\n\n","categories":["C++"]},{"title":"LeetCode746-使用最小花费爬楼梯","url":"/blog/2020/12/21/LeetCode746-使用最小花费爬楼梯/","content":"\n#### 题目描述\n\n数组的每个索引作为一个阶梯，第`i`个阶梯对应着一个非负数的体力花费值 `cost[i]`(索引从0开始)。\n\n每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。\n\n您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。\n\n<!-- more-->\n\n<img src=\"LeetCode746-使用最小花费爬楼梯\\746.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n像这种爬楼梯问题考虑动态规划，当前状态花费 $dp[i]$ 可以由上一次 $dp[i-1]$ 或者上上次 $dp[i-2]$ 中的最小花费得到（对应爬一层台阶和爬两层台阶），其次当前状态还有体力消耗 $cost[i]$，所以可以定义状态转移方程：\n$$\ndp[i]=min(dp[i-1],dp[i-2])+cost[i]\n$$\n当楼梯只有两阶时，假定有第三阶，那么到达第三阶的花费就为0，初始化如下：\n\n``` cpp\ndp[0] = cost[0];\ndp[1] = cost[1];\ncost.push_back(0);\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        vector<int> dp(cost.size() + 1, 0);\n        cost.push_back(0);\n        dp[0] = cost[0];\n        dp[1] = cost[1];\n        for(int i = 2; i < dp.size(); ++i){\n            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];\n        }\n        return dp[dp.size() - 1];\n    }\n};\n```\n\n\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode316-去除重复字母","url":"/blog/2020/12/20/LeetCode316-去除重复字母/","content":"\n#### 题目描述\n\n给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。\n\n<!-- more-->\n\n<img src=\"LeetCode316-去除重复字母\\316.png\"  />\n\n#### 思路\n\n对于一个字符串来说，如果 $s[i]>s[i+1]$ ，去除此时的 $s[i]$ 可以使剩下的字符串字典序最小。我们将 $s[i]$ 称为**关键字符**。\n\n从前往后遍历字符串。假定在 $s[i-1]$ 之前所有的**关键字符**都已经去除，那么在扫描 $s[i]$ 时，新出现的**关键字符**只能出现在 $s[i]$ 或者其后的位置。\n\n所以用栈来维护去除**关键字符**后得到的字符串。如果栈顶字符大于 $s[i]$ ，说明栈顶字符应当被去除，此时新的栈顶字符就与 $s[i]$ 相邻（保持相对位置）。重复此操作，直到栈为空或者栈顶字符不大于 $s[i]$ 。\n\n还需要满足 $s$ 中的每个字符都出现在新字符串中且只出现一次，所以还需要考虑：\n\n* 如果字符 $s[i]$ 已经存在于栈中，则不再将此字符加入栈，所以需要记录字符是否被使用过\n* 弹出栈顶字符时，如果后面再没有此字符（此字符剩余数量为0），则不能弹出，所以需要记录每个字符出现的次数；如果可以弹出，需要将此字符再次置为未使用的状态\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n\tstring removeDuplicateLetters(string s) {\n        int cnt[26] = {0}; // 记录字符使用次数\n        bitset<26> vis; // 记录字符是否被使用\n        for(auto &ch : s) cnt[ch - 'a']++;\n        stack<char> st;\n        for(auto &ch : s){\n            // 如果字符没被使用\n            if(!vis[ch - 'a']){\n                // 如果栈不为空且栈顶字符大于当前字符，需要看是否弹出\n                while(!st.empty() && st.top() > ch){\n                    // 如果此字符串剩余次数不为0，可以弹出，并且此字符置为「未使用」\n                    if(cnt[st.top() - 'a'] > 0){\n                        vis[st.top() - 'a'] = 0;\n                        st.pop();\n                    }\n                    else break;\n                }\n                // 当前字符入栈，并且置为「已使用」\n                vis[ch - 'a'] = 1;\n                st.push(ch);\n            }\n            // 当前字符被使用了一次\n            cnt[ch - 'a']--;\n        }\n        // 取出栈中字符并输出\n        string res;\n        while(!st.empty()){\n            res += st.top();\n            st.pop();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n\t}\n};\n```\n\n\n\n#### Reference\n\n官方题解：\n\nhttps://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/","tags":["贪心算法","单调栈"],"categories":["LeetCode"]},{"title":"C++泛型算法（二）","url":"/blog/2020/12/19/C-泛型算法（二）/","content":"\n#### 本次学习要点\n\n1. 再探迭代器\n2. 泛型算法结构\n3. 特定容器算法\n\n<!-- more-->\n\n#### 再探迭代器\n\n标准库在头文件`iterator`中还定义了额外集中迭代器。包括：\n\n* **插入迭代器（insert iterator）**：这些迭代器被绑定在一个容器上，可用来向容器插入元素。\n* **流迭代器（stream iterator）**：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。\n* **反向迭代器（reverse iterator）**：这些迭代器向前而不是向后移动（**书上写的是向后而不是向前，疑问？**），除了`forward_list`之外的标准库容器都有反向迭代器。\n* **移动迭代器（move iterator）**：这些专用的迭代器不是拷贝其中的元素，而是移动它们。后面会提到。\n\n##### 插入迭代器\n\n插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。\n\n插入器有三种类型，差异在于元素插入的位置：\n\n* **back_inserter**：创建一个使用`push_back`的迭代器。\n* **front_inserter**：创建一个使用`push_front`的迭代器。\n* **inserter**创建一个使用`insert`的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。**元素将被插入到给定得到所表示的元素之前**。\n\n<img src=\"C-泛型算法（二）\\插入迭代器_note.png\"  />\n\n当调用`inserter(c, iter)`时，会得到一个迭代器，接下来使用它时，会将元素插入到`iter`原来所指向的元素之前的位置。即，如果`it`是由`iterator`生成的迭代器，则下面两段代码效果一样：\n\n```cpp\n*it = val;\n// 等价于\nit = c.insert(it, val); // it指向新加入的元素\n++it; // 递增it使它指向原来的元素\n```\n\n`front_inserter`生成的迭代器的行为于`inserter`生成的迭代器完全不一样。当我们使用`front_inserter`时，元素总是插入到容器第一个元素之前。即使我们传递给`inserter`的位置原来是指向第一个元素的，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：\n\n```cpp\nlist<int> lst{1,2,3,4};\nlist<int> lst2, lst3; // 空list\n// 拷贝完成后，lst2包含4 3 2 1\ncopy(lst.begin(), lst.end(), front_inserter(lst2));\n// 拷贝完成后，lst3包含1 2 3 4\ncopy(lst.begin(), lst.end(), inserter(lst3, lsr3.begin());\n```\n\n##### iostream迭代器\n\n虽然`iostream`不是迭代器，但标准库定义了一个可以用于这些IO类型对象的迭代器。**iostream_iterator**读入输入流，**ostream_iterator**向一个输出流写数据。这些迭代器将它们对应的流当作一个特定的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。\n\n###### istream_iterator操作\n\n当创建一个流迭代器时，必须指定将要读写的对象类型。一个`istream_iterator`使用`>>`来读取流。因此，`istream_iterator`要读取的类型必须定义了输入运算符。当创建一个`istream_iterator`时，我们可以将它绑定到一个流。\n\n```cpp\nistream_iterator<int> int_it(cin); // 从cin读取int\nistream_iterator<int> int_eof; // 尾后迭代器\nifstream in(\"afile\");\nistream_iterator<string> str_it; // 从\"afile\"读取字符串\n```\n\n下面是一个用`istream_iterator`从标准输入读取数据，存入一个`vector`的例子：\n\n``` cpp\nistream_iterator<int> in_iter(cin); // 从cin读取int\nistream_iterator<int> eof; // istream尾后迭代器\nwhile(in_iter != eof){\n    // 后置递增运算读取流，返回迭代器的旧值\n    // 解引用迭代器，获得从流读取的前一个值\n    vec.push_back(*in_iter++);\n}\n```\n\n`eof`被定义为空的`istream_iterator`，从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等。\n\n上述程序可以改写如下：\n\n```cpp\nistream_iterator<int> in_iter(cin), eof; // 从cin读取int\nvector<int> vec(in_iter, eof); // 从迭代器范围构造vec\n```\n\n<img src=\"C-泛型算法（二）\\istream_iterator操作.png\" style=\"zoom: 80%;\" />\n\n###### 使用算法操作流迭代器\n\n```cpp\nistream_iterator<int> in(cin), eof;\ncout << accumulate(in, eof, 0) << endl;\n```\n\n此调用会计算出从标准输入读取的值的和。\n\n###### istream_iterator允许使用懒惰求值\n\n当我们将一个`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流读取数据。可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。\n\n###### ostream_iterator操作\n\n我们可以对具有输出运算符`<<`的类型定义`ostream_iterator`。创建一个`ostream_iterator`时，可选第二个参数，它是一个**C**风格字符串（**即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）**。在输出的每个元素之后都会打印此字符串。并且必须将`ostream_iterator`绑定到一个指定的流，不允许空的或表示尾后位置的`ostream_iterator`。\n\n<img src=\"C-泛型算法（二）\\ostream_iterator操作.png\" style=\"zoom:80%;\" />\n\n我们可以用`ostream_iterator`来输出值的序列：\n\n```cpp\nostream_iterator<int> out_iter(cout, \" \");\nfor(auto e : vec)\n\t*out_iter++ = e; // 赋值语句实际上将元素写到cout\ncout << endl;\n// 下面的也行，但不推荐\nostream_iterator<int> out_iter(cout, \" \");\nfor(auto e : vec)\n\tout_iter = e; // 赋值语句将元素写到cout\ncout << endl;\n```\n\n运算符`*`和`++`不对`ostream_iterator`对象做任何操作。第一种写法流迭代器的使用与其他迭代器的使用保持一致。\n\n可以通过`copy`来打印`vec`中的元素，更简单：\n\n```cpp\ncopy(vec.begin(), vec.end(), out_iter);\ncout << endl;\n```\n\n###### 使用流迭代器处理类类型\n\n对于之前的`Sales_item`既有输入运算符也有输出运算符，可以使用IO迭代器重写书店程序：\n\n```cpp\n// 原始程序\nSales_item total; // 保存下一条交易记录的变量\n// 读入第一条交易记录，并确保有数据可以处理\nif(cin >> total){\n    Sales_item trans; // 保存和的变量\n    // 读入并处理剩余交易记录\n    while(cin >> trans){\n        // 如果我们仍在处理相同的书\n        if(total.isbn() == trans.isbn())\n            totao += trans; // 更新销售总额\n        else{\n            // 打印前一本书的结果\n            cout << total << endl;\n            total = trans; // total现在表示下一本书的销售额\n        }\n    }\n    cout << total << endl;\n}\n// 使用IO迭代器重写\nistream_iterator<Sales_item> item_iter(cin), eof;\nostream_iterator<Sales_item> out_iter(cout, \"\\n\");\n// 将第一笔交易记录存在sum中，并读取下一条记录\nSales_item sum = *item_iter++;\nwhile(item_iter != eof){\n    // 如果当前交易记录（存在item_iter中）有相同的ISBN号\n    if(item_iter->isbn() == sum.isbn())\n        sum += *item_iter++;\n    else{\n        out_iter = sum;\n        sum = *item_iter++;\n    }\n}\nout_iter = sum;\n```\n\n##### 反向迭代器\n\n顾名思义，反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增和递减含义会颠倒过来。递增一个反向迭代器（`++it`）会移动到前一个元素；递减一个反向迭代器（`--it`）会移动到后一个元素。反向迭代器也有`const`和非`const`版本。\n\n<img src=\"C-泛型算法（二）\\反向迭代器.png\" style=\"zoom:80%;\" />\n\n下面是一个例子：\n\n```cpp\nvector<int> vec = {1,2,3,4,5,6};\nfor(auto r_iter = vec.crbegin(); r_iter != vec.crend(); ++r_iter)\n    cout << *r_iter << endl;\n// 打印6，5，4，3，2，1\n```\n\n可以通过向`sort`传递一对反向迭代器来将`vector`整理为递减：\n\n```cpp\nsort(vec.begin(), vec.end()); // 递增\nsort(vec.rbegin(), vec.rend()); // 递减\n```\n\n###### 反向迭代器和其他迭代器间的关系\n\n假定有一个名为`line`的`string`，保存着以逗号分隔的单词列表，我们希望打印`line`中的第一个单词，可以使用`find`完成：\n\n```cpp\nauto comma = find(line.cbegin(), line.cend(), ',');\ncout << string(line.cbegin(), comma) << endl;\n```\n\n如果`line`中有逗号，那么`comma`将指向这个逗号，否则它指向`line.cend()`。如果希望打印最后一个单词：\n\n```cpp\nauto rcomma = find(line.crbegin(), line.crend(), ',');\n```\n\n当我们试图打印找到的单词时，不能用以下代码：\n\n```cpp\n// 错误，对于FIRST,MIDDLE,LAST会打印出TSAL\ncout << string(line.crbegin(), rcomma) << endl;\n```\n\n需要做的是，将`rcomma`转换为一个普通迭代器，能在`line`中正向移动。可以调用`reverse_iterator`中的`base`成员来完成这一转换，此成员函数会返回其对应的普通迭代器：\n\n```cpp\ncout << string(rcomma.base(), line.cend()) << endl;\n```\n\n<img src=\"C-泛型算法（二）\\反向迭代器_使用base.png\" style=\"zoom:80%;\" />\n\n需要注意的是：\n\n<img src=\"C-泛型算法（二）\\反向迭代器_note.png\" style=\"zoom: 80%;\" />\n\n#### 泛型算法结构\n\n算法所要求的迭代器操作可以分为5个迭代器类别：\n\n<img src=\"C-泛型算法（二）\\迭代器类别.png\" style=\"zoom:80%;\" />\n\n##### 5类迭代器\n\n对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。**而这种错误很多编译器不会给出任何警告和提示**。\n\n###### 输入迭代器（input iterator）\n\n可以读取序列中的元素。一个输入迭代器必须支持：\n\n* 用于比较两个迭代器的相等和不相等运算符（`==、!=`）\n* 用于推进迭代器的前置和后置递增运算（`++`）\n* 用于读取元素的解引用运算符（`*`）；解引用只会出现在赋值运算符的右侧\n* 箭头运算符（`->`），等价于`(*it).member`，即，解引用迭代器，并提取对象的成员\n\n输入迭代器只用于顺序访问，只能用于单边扫描算法。算法`find`和`accumulate`要求输入迭代器；而`istream_iterator`是一种输入迭代器。\n\n###### 输出迭代器（output iterator）\n\n可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：\n\n* 用于推进迭代器的前置和后置递增运算（`++`）\n* 解引用运算符（`*`），只出现在赋值运算符的左侧\n\n例如，`copy`函数的第三个参数就是输出迭代器；`ostream_iterator`是一种输出迭代器。\n\n###### 前向迭代器（forward iterator）\n\n可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法`replace`要求前向迭代器， `forward_list`上的迭代器是前向迭代器。\n\n###### 双向迭代器（bidirectional iterator）\n\n可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（`--`）。算法`reverse`要求双向迭代器，除了`forward_list`之外，其他标准库都提供符合双向迭代器要求的迭代器.\n\n###### 随机访问迭代器（random-access iterator）\n\n提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，还支持以下操作：\n\n* 用于比较两个迭代器相对位置的关系运算符（`<、<=、>`和`>=`) \n* 迭代器和一个整数值的加减运算（`+、+=、-`和`-=`），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置\n* 用于两个迭代器上的减法运算符（`-`），得到两个迭代器的距离\n* 下标运算符`iter[n]`，与`*(iter[n])`等价\n\n算法`sort`要求随机访问迭代器。`array、deque、string、vector`的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。\n\n##### 算法形参模式\n\n大多数算法具有如下4种形式之一：\n\n* ***alg*** ( beg, end, ***other args***)\n* ***alg*** ( beg, end, dest, ***other args***)\n* ***alg*** ( beg, end, beg2, ***other args***)\n* ***alg*** ( beg, end, be2, end2, ***other args***)\n\n##### 算法命名规范\n\n如何提供一个操作代替默认的`<`或`==`运算符，以及算法是将输出数据写入输入序列，还是写入分离的目的位置等问题。\n\n###### 一些算法使用重载形式传递一个谓词\n\n```cpp\nunique(beg, end); // 使用 == 运算符比较元素\nunique(beg, end, comp); // 使用comp比较元素\n```\n\n###### _if版本的算法\n\n接受一个元素值得算法通常有另一个不同名的版本（非重载），该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的`_if`前缀：\n\n```cpp\nfind(beg, end, val); // 查找输入范围种val第一次出现的位置\nfind_if(beg, end, pred);// 查找第一个令pred为真的元素\n```\n\n###### 区分拷贝元素的版本和不拷贝的版本\n\n默认情况下，重排元素的算法将重排后的元素写回给定的输入序列。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个`_copy`：\n\n```cpp\nreverse(beg, end); // 反转输入范围中元素的顺序\nreverse_copy(beg, end ,dest); // 将元素按逆序拷贝到dest\n```\n\n一些算法同时提供`_if`和`_copy`版本。\n\n```cpp\n// 从v1中删除奇数元素\nremove_if(v1.begin(), v1.end(), \n          [](int i) { return i % 2; });\n// 将偶数元素从v1拷贝到v2，v1不变\nremove_copy_if(v1.begin(), v1.end(), back_inserter(v2),\n              [](int i){ return i % 2});\n```\n\n#### 特定容器算法\n\n与其他容器不同，链表类型`list`和`forward_list`定义了几个成员函数形式的算法，它们定义了独有的`sort、merge、remove、reverse、unique`，这些独有的版本比通用版本好得多。\n\n<img src=\"C-泛型算法（二）\\特定容器算法.png\" style=\"zoom:80%;\" />\n\n算法如下：\n\n<img src=\"C-泛型算法（二）\\list.png\" style=\"zoom:80%;\" />\n\n##### splice成员\n\n<img src=\"C-泛型算法（二）\\splice.png\" style=\"zoom:80%;\" />\n\n##### 链表特有的操作会改变容器\n\n链表特有版本会改变底层的容器，例如`remove`会删除指定的元素。`unique`会删除第二个和后继的重复元素。\n\n类似的，通用版本`merge`将合并的序列写到一个给定的目的迭代器，两个输入序列是不变的。而链表版本的`merge`会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用`merge`的链表对象中。在`merge`之后，来自两个链表中的元素依然存在，但它们都已在同一个链表中。","categories":["C++"]},{"title":"C++泛型算法（一）","url":"/blog/2020/12/19/C-泛型算法（一）/","content":"\n#### 本次学习要点\n\n1. 概述\n2. 初识泛型算法\n3. 定制操作\n\n<!-- more-->\n\n#### 概述\n\n大多数算法都定义在头文件`algorithm`中。标准库还在头文件`numeric`中定义了一组数值泛型算法。\n\n##### 算法永远不会执行容器的操作\n\n泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。算法永远**不会改变**底层容器的大小。算法可能**改变**容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。\n\n标准库定义了一类特殊的迭代器，称为插入器（inserter）。它们会在底层的容器上执行插入操作。当一个算法操作这样的一个迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身**不会**做这样的操作。\n\n#### 初识泛型算法\n\n标准库算法都对一个范围内的元素进行操作。此范围称为“输入范围”。输入范围使用两个参数：要处理的第一个元素和尾元素之后的位置的迭代器。\n\n##### 只读算法\n\n此类算法只会读取其输入范围内的元素，而从不改变元素。如`find`，`count`。定义在`numeric`中有只读算法`accumulate`，前两个指出需要求和的元素的范围，第三个参数是和的初值。最好用`cbegin()`和`cend()`，除非打算用返回的迭代器来改变元素的值。\n\n```cpp\n// 对vec中的元素求和，和的初值为0\nint sum = accumulate(v.cbegin(), v.cend(), 0);\n```\n\n###### 算法和元素类型\n\n`accumulate`第三个参数为求和起点，包含了一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须和第三个参数匹配。由于`string`定义了`+`操作，所以可以将`vector`中的所有`string`连接起来：\n\n```cpp\nstring sum = accumulate(v.cbegin(), v.cend(), string(\"\"));\n```\n\n将空串当作一个字符串字面值传递给第三个参数是不可以的，会导致编译错误：\n\n```cpp\n// 错误：const char*上没有定义+运算符\nstring sum = accumulate(v.cbegin(), v.cend(), \"\");\n```\n\n###### 操作两个序列的算法\n\n只读算法`equal`用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素和第二个序列中的对应元素逐个比较，如果都相等返回`true`，否则返回`false`。此算法接受三个迭代器：前两个表示第一个序列范围，第三个表示第二个序列的首元素：\n\n```cpp\n// roster2中的元素数目应该至少于roster1一样多\nequal(roster1.cbegin(), roster1.cend(), roster2.cbegin());\n```\n\n`equal`基于假设：第二个序列至少与第一个序列一样长。\n\n***注意！！！****那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。*\n\n##### 写容器元素的算法\n\n一些算法将新值赋予序列中的元素，需要确保序列原大小至少不小于要求算法写入的元素数目。例如`fill`接受一对迭代器表示一个范围，还接受一个值作为第三个参数，将范围内的值置为第三个参数的值：\n\n```cpp\nfill(vec.begin(), vec.end(), 0); // 将每个元素重置为0\n// 将容器的一个子序列设置为10\nfill(vec.begin(), vec.begin() + vec.size() / 2, 0);\n```\n\n###### 算法不检查写操作\n\n一些算法接受一个迭代器来指出一个单独的目的位置，从目的位置开始，将新值赋予一个序列中的元素。例如`fill_n`接受一个单迭代器、一个计数值和一个值：\n\n```cpp\nfill_n(dest, n, val);\n```\n\n`fill_n`假定`dest`指向一个元素，从`dest`开始的序列至少包含n个元素。\n\n```cpp\nvector<int> vec; // 空vector\n// 正确\nfill_n(vec.begin(), vec.size(); 0);\n// 错误,vec并没有10个元素\nfill_n(vec.begin(), 10, 0);\n```\n\n###### 介绍back_inserter\n\n`back_inserter`定义在头文件`iterator`中，其接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中：\n\n```cpp\nvector<int> vec;\nauto it = back_inserter(vec);\n*it = 42;\n```\n\n常常使用`back_inserter`创建一个迭代器，作为算法的目的位置来使用。例如：\n\n```cpp\nvector<int> vec;\nfill_n(back_inserter(vec), 10, 0);\n```\n\n###### 拷贝算法\n\n此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。算法将输入范围中的元素拷贝到目的序列中。**传递给`copy`的目的序列至少要包含与输入序列一样多的元素**。\n\n```cpp\nint a1[] = {0,1,2,3,4,5,6,7,8,9};\nint a2[sizeof(a1) / sizeof(*a1)];\nauto ret = copy(begin(a1), end(a1), a2);\n```\n\n`copy`返回其目的位置迭代器（递增后）的值，即`ret`恰好指向拷贝到`a2`的尾元素之后的位置。\n\n多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放在输入序列的末尾，而是创建一个新序列保存这些结果。\n\n如`replace`，其读入一个序列，并将其中所有等于给定值元素都改为另一个值，此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值：\n\n```cpp\n// 将所有值为0的元素改为42\nreplace(ilist.begin(), ilist.end(), 0, 42);\n```\n\n对于它的“拷贝”版本`replace_copy`，此算法接受额外第三个迭代器参数，指出点整后序列的保存位置：\n\n```cpp\n// 使用back_inserter按需要增长目标序列\nreplace_copy(ilist.cbegin(), ilist.cend(),\n             back_inserter(ivec), 0, 42);\n```\n\n经过此调用，`ilist`并未改变，`ivec`包含`ilist`的一份拷贝，不过原来在`ilist`中值为0的元素在`ivec`中都变为42。\n\n##### 重排容器元素的算法\n\n假定已经有一个`vector`，保存了多个故事的文本，简化这个`vector`，使得每个单词只出现一次。输入如下：\n\n<img src=\"C-泛型算法（一）\\重排_输入.png\" style=\"zoom:80%;\" />\n\n要求得到的结果如下：\n\n<img src=\"C-泛型算法（一）\\重排_输出.png\"  />\n\n为了消除重复单词，先对`vector`排序，使得重复的单词相邻出现，之后可以使用另一个称为`unique`的标准库算法来重排`vector`，使得不重复的元素出现在`vector`的开始部分。由于算法不能执行容器的操作，可以使用`vector`的成员`erase`来完成真正的删除操作：\n\n```cpp\nvoid elimDups(vector<string> &words){\n\tsort(words.begin(), words.end());\n    auto end_unique(words.begin(), words.end());\n    words.erase(end_unique, words.end());\n}\n```\n\n`words`排序完毕后，使用`unique`算法重排输入序列，将相邻的重复项”消除“，并**返回一个指向最后一个不重复元素之后的位置的迭代器**。调用`unique`后，`vector`将变为：\n\n<img src=\"C-泛型算法（一）\\after_unique.png\"  />\n\n如上图所示，`unique`并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列的开始部分。`unique`返回的迭代器位置之后的元素依旧存在，但不知道是什么。\n\n**标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元。素**\n\n最后，使用`erase`删除从`end_unique`开始至`words`末尾的范围内的所有元素。即使`words`中没有重复单词，调用`erase`也是安全的，删除空的范围没什么不良后果。\n\n#### 定制操作\n\n详见[C++11之lambda表达式](http://www.xingyuzhao.ltd/blog/2020/08/02/C-11%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/)。","categories":["C++"]},{"title":"LeetCode48-旋转图像","url":"/blog/2020/12/19/LeetCode48-旋转图像/","content":"\n#### 题目描述\n\n给定一个 $n × n$ 的二维矩阵表示一个图像。\n\n将图像顺时针旋转 90 度。\n\n说明：\n\n你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。\n\n<!-- more-->\n\n<img src=\"LeetCode48-旋转图像\\48.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n不好意思，一开始我还是用了新的数组。\n\n从最后一列往前，从第一行往后，每一列都是由相应的行复制过来，如下图（示例二）：\n\n<img src=\"LeetCode48-旋转图像\\48_思路.png\" style=\"zoom:80%;\" />\n\n新建数组保存原始数组的拷贝，然后再根据原始数组拷贝来修改原始数组。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int scale = matrix.size();\n        auto matrixHelper = matrix;\n        int pos = 0; // 表示当前遍历到拷贝数组的第pos行\n        for(int j = scale - 1; j >= 0; --j){\n            for(int i = 0; i < scale; ++i){\n                // 前面的i表示原始数组的行，后面的i表示拷贝数组的列\n                matrix[i][j] = matrixHelper[pos][i];\n            }\n            pos++;\n        }\n    }\n};\n```\n\n时间复杂度和空间复杂度都是$O(N^2)$。\n\n#### 更进一步\n\n##### 思路\n\n仔细观察旋转后的图：\n\n<img src=\"LeetCode48-旋转图像\\48_思路.png\" style=\"zoom:80%;\" />\n\n对于矩阵中第 $i$ 行的第 $j$ 个元素，在旋转后，它出现在倒数第 $i $ 列的第 $j$ 个位置。即：\n$$\nmatrix_{new}[col][n-row-1]=matrix[row][col]\n$$\n这样可以得到以下代码：\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        auto matrixHelper = matrix;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                matrix[j][n - i - 1] = matrixHelper[i][j];\n            }\n        }\n    }\n};\n```\n\n这样也不是原地修改，但是可以得到上面那个重要等式。\n\n如果对矩阵先进行水平轴翻转，再进行主对角线翻转，也可以得到旋转后的矩阵，以示例二为例：\n\n1. 水平翻转：\n\n$$\n\\left[\n\\begin{matrix}\n\t5 & 1 & 9 & 11 \\\\\\\\\n\t2 & 4 & 8 & 10 \\\\\\\\\n    13 & 3 & 6 & 7 \\\\\\\\\n    15 & 14 & 12 & 16\n\t\\end{matrix}\n\t\\right]\\stackrel{\\Large水平翻转}{\\huge\\longrightarrow}\n\\left[\n\\begin{matrix}\n\t15 & 14 & 12 & 16\\\\\\\\\n    13 & 3 & 6 & 7 \\\\\\\\\n    2 & 4 & 8 & 10 \\\\\\\\\n    5 & 1 & 9 & 11\n\t\\end{matrix}\n\t\\right]\n$$\n\n$$\nmatrix[row][col]=matrix[n-row-1][col]\n$$\n\n2. 主对角线翻转：\n\n$$\n\\left[\n\\begin{matrix}\n\t15 & 14 & 12 & 16 \\\\\\\\\n    13 & 3 & 6 & 7 \\\\\\\\\n    2 & 4 & 8 & 10 \\\\\\\\\n    5 & 1 & 9 & 11\n\t\\end{matrix}\n\t\\right]\\stackrel{\\Large主对角线翻转}{\\huge\\longrightarrow}\n\\left[\n\\begin{matrix}\n\t15 & 13 & 2 & 5 \\\\\\\\\n    14 & 3 & 4 & 1 \\\\\\\\\n    12 & 6 & 8 & 9 \\\\\\\\\n    16 & 7 & 10 & 11\n\t\\end{matrix}\n\t\\right]\n$$\n\n$$\nmatrix[row][col]=matrix[col][row]\n$$\n\n综合以上两式，可以得到：\n$$\nmatrix[row][col]\\stackrel{\\large水平翻转}{\\large\\longrightarrow}matrix[n-row-1][col]\n$$\n\n$$\nmatrix[n-row-1][col]\\stackrel{\\large主对角线翻转}{\\large\\longrightarrow}matrix[col][n-row-1]\n$$\n\n即：\n$$\nmatrix[row][col]=matrix_{new}[col][n-row-1]\n$$\n这就与之前得到的重要等式相同了。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        // 水平翻转\n        for (int i = 0; i < n / 2; ++i) {\n            for (int j = 0; j < n; ++j) {\n                swap(matrix[i][j], matrix[n - i - 1][j]);\n            }\n        }\n        // 主对角线翻转\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n    }\n};\n\n```\n\n#### Reference\n\n官方题解：\n\nhttps://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/","tags":["数组"],"categories":["LeetCode"]},{"title":"LeetCode389-找不同","url":"/blog/2020/12/18/LeetCode389-找不同/","content":"\n#### 题目描述\n\n给定两个字符串 ***s*** 和 ***t***，它们只包含小写字母。\n\n字符串 ***t*** 由字符串 ***s*** 随机重排，然后在随机位置添加一个字母。\n\n请找出在 ***t*** 中被添加的字母。\n\n<!-- more-->\n\n<img src=\"LeetCode389-找不同\\389.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n用一个长为26的数组记录在 ***t*** 中所有字母的出现次数，然后再去遍历 ***s*** ，对每次遇到的字母对应的次数减一，最后再遍历这个数组，如果有出现次数为1的字母，那么这就是 ***t*** 中被添加的字母。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    char findTheDifference(string s, string t) {\n        int map[26] = {0};\n        for(auto &ch : t){\n            map[ch - 'a']++;\n        }\n        for(auto &ch : s){\n            map[ch - 'a']--;\n        }\n        for(int i = 0; i < 26; ++i){\n            if(map[i] == 1) return char(i + 'a');\n        }\n        return char(' ');\n    }\n};\n```\n\n","tags":["哈希表"],"categories":["LeetCode"]},{"title":"LeetCode714-买卖股票的最佳时机含手续费","url":"/blog/2020/12/17/LeetCode714-买卖股票的最佳时机含手续费/","content":"\n#### 题目描述\n\n给定一个整数数组 $prices$，其中第$i$个元素代表了第$i$天的股票价格 ；非负整数 $fee$ 代表了交易股票的手续费用。\n\n你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n\n返回获得利润的最大值。\n\n注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n\n<!-- more-->\n\n<img src=\"LeetCode714-买卖股票的最佳时机含手续费\\714.png\"  />\n\n#### 思路\n\n##### 定义$dp$数组\n\n使用两个数组$dp1[i]$和$dp2[i]$分别表示当天持有股票or当天不持有股票时的最大收益。\n\n##### 状态转移方程\n\n* $dp1[i]$表示第$i$天未持有的最大收益，由上一天未持有或者上一天持有当天卖出得到：\n\n$$\ndp1[i] = max(dp1[i - 1], dp2[i - 1] + prices[i] - fee)\n$$\n\n* $dp2[i]$表示第$i$天持有的最大收益，由上一天持有或者上一天不持有今天买入得到：\n\n$$\ndp2[i] = max(dp2[i - 1], dp1[i - 1] - prices[i])\n$$\n\n##### 初始化\n\n* 第一天未持有股票时，收益为0，$dp1[0] = 0$。\n* 第一天持有股票时，收益为当天买入所需要的钱，$dp2[0] = -prices[0]$。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        vector<int> dp1(prices.size());\n        vector<int> dp2(prices.size());\n        dp1[0] = 0;\n        dp2[0] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp1[i] = max(dp1[i - 1], dp2[i - 1] + prices[i] - fee);\n            dp2[i] = max(dp2[i - 1], dp1[i - 1] - prices[i]);\n        }\n        return dp1[prices.size() - 1];\n    }\n};\n```\n\n##### 更进一步\n\n注意到$dp1[i]$和$dp2[i]$只会从$dp1[i-1]$和$dp2[i-1]$转移而来，所以用两个变量$sell$以及$buy$分别表示$dp1[i]$和$dp2[i]$，空间复杂度降为$O(1)$。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int sell = 0;\n        int buy = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int tmp = sell;\n            sell = max(sell, buy + prices[i] - fee);\n            buy = max(buy, sell - prices[i]);\n        }\n        return sell;\n    }\n};\n```\n\n#### Reference\n\n评论区：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/comments/\n\n官方题解：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode290-单词规律","url":"/blog/2020/12/16/LeetCode290-单词规律/","content":"\n#### 题目描述\n\n给定一种规律 `pattern` 和一个字符串 `str` ，判断 `str` 是否遵循相同的规律。\n\n这里的 `遵循` 指完全匹配，例如， `pattern` 里的每个字母和字符串 `str` 中的每个非空单词之间存在着双向连接的对应规律。\n\n<!-- more-->\n\n<img src=\"LeetCode290-单词规律\\290.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n字母和单词一一对应时返回true，否则返回false。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        istringstream istr(s);\n        vector<string> str;\n        string word;\n        while(istr >> word){\n            str.push_back(word);\n        }\n        if(pattern.size() != str.size()) return false;\n        unordered_map<char, unordered_set<string>> map1;\n        unordered_map<string, unordered_set<char>> map2;\n        for(int i = 0; i < pattern.size(); ++i){\n            map1[pattern[i]].insert(str[i]);\n            map2[str[i]].insert(pattern[i]);\n            // 如果不是一一对应，返回false\n            if(map1[pattern[i]].size() > 1 || map2[str[i]].size() > 1) return false;\n        }\n        return true;\n    }\n};\n```\n\n","tags":["哈希表"],"categories":["LeetCode"]},{"title":"LeetCode738-单调递增的数字","url":"/blog/2020/12/15/LeetCode738-单调递增的数字/","content":"\n#### 题目描述\n\n给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。（当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）\n\n<!-- more-->\n\n<img src=\"LeetCode738-单调递增的数字\\738.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n这种思路太繁琐，不想看的话直接转至**更进一步**。\n\n---\n\n输入是一个非负整数，所以第一步要将其转换成可以遍历的形式，可以先将整数转换为字符串序列。\n\n从**输入序列**的第一个数开始，一个一个数的建立起**答案序列**。\n\n1. **输入序列单调不减**，答案序列的当前值最大可以取到输入序列的当前值。如输入为1234，那么答案序列的第一个位置最大可以取到1，继续遍历，取到当前位置最大值时，一直会大于等于上一个取到的值，所以最终可以得到答案1234：\n\n```cpp\nstring nums; // 输入序列\nstring res; // 答案序列\nint pre = -1; // 初始化为-1，保证第一个值可以取到\nint cur;\nfor(int i = 0; i < nums.size(); ++i){\n    cur = nums[i] - '0';\n    if(cur >= pre){\n        res += to_string(cur);\n        pre = nums[i] - '0';\n    }\n}\n```\n\n2. **输入序列非单调不减**，如果当前值小于上一个可以取到的最大值，就需要回退，直到当前值不小于上一个可以取到的最大值。如输入332。\n   1. 当取到2时小于上一个取到的值3，上一个值减去1作为当前值（得到2），`res`出栈一次，如果出栈后`res`为空，那么存下当前值并退出。否则，上一个值取`res`末尾的值（第一个3）。\n   2. 当前值为2，上一个值为第一个3，由于2小于3，那么再将上一个值减1作为当前值得到2），出栈一次，遍历回退一次，那么当前值变为2，此时`res`为空，记录2并且退出遍历。\n\n* 使用一个`flag`标记是否回退。\n* 如果`res == \"0\"`，说明第一个数为0，此时答案长度为输入序列的长度减去1，全部为9；否则，就在`res`后补充9直到和输入序列长度相同。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int monotoneIncreasingDigits(int N) {\n        string nums = to_string(N);\n        int pre = -1;\n        int cur;\n        int flag = 0;\n        string res;\n        int i;\n        for(i = 0; i < nums.size(); ++i){\n            if(flag == 0){\n                cur = nums[i] - '0';\n                if(cur >= pre){\n                    res += to_string(cur);\n                    pre = nums[i] - '0';\n                }\n                else{\n                    flag = 1;\n                    pre--;\n                    res.pop_back();\n                    if(res.empty()){\n                        res += to_string(pre);\n                        break;\n                    }\n                    cur = pre;\n                    pre = res.back() - '0';\n                    i--;\n                }\n            }\n            else{\n                if(cur >= pre){\n                    res += to_string(cur);\n                    break;\n                }\n                pre--;\n                res.pop_back();\n                if(res.empty()){\n                    res += to_string(pre);\n                    break;\n                }\n                cur = pre;\n                pre = res.back() - '0';\n                i--;\n            }\n        }\n        int resVal;\n        if(res == \"0\"){\n            int n = nums.size() - 1;\n            string buf(n, '9');\n            resVal = stoi(buf, 0, 10);\n        }\n        else{\n            for(int j = res.size(); j < nums.size(); ++j){\n                res += '9';\n            }\n            resVal = stoi(res, 0, 10);\n        }\n        return resVal;\n    }\n};\n```\n\n这种思路实现起来太繁琐了（我是sb）。\n\n#### 更进一步\n\n##### 思路\n\n局部最优：遇到`nums[i - 1] > nums[i]`的情况，让`nums[i - 1]--`，然后`nums[i]`值为9，可以保证这两位变成最大单调不减整数。\n\n全局最优：尽量使`nums[i - 1]--`靠后，这样做可以使整数尽可能的大，因为越后面减去1，对整数的损失越小，所以从后往前遍历。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int monotoneIncreasingDigits(int N) {\n        string nums = to_string(N);\n        int flag = nums.size();\n        for(int i = nums.size() - 1; i >= 1; --i){\n            if(nums[i - 1] > nums[i]){\n                nums[i - 1]--;\n                flag = i;\n            }\n        }\n        for(flag; flag < nums.size(); ++flag){\n            nums[flag] = '9';\n        }\n        return stoi(nums, 0, 10);\n    }\n};\n```\n\n#### Reference\n\n题解：\n\nhttps://leetcode-cn.com/problems/monotone-increasing-digits/solution/738-dan-diao-di-zeng-de-shu-zi-tan-xin-s-vq4r/","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode49-字母异位词分组","url":"/blog/2020/12/14/LeetCode49-字母异位词分组/","content":"\n#### 题目描述\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n<!-- more-->\n\n<img src=\"LeetCode49-字母异位词分组\\49.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n主要是理解哈希表的 $key$ 和 $value$ 表示什么数或者集合。对于字母构造相同的几个`string`，它们进行排序后的结果是一致的，所以可以将排序后的结果作为哈希表的 $key$，而对应的 $value$ 来存储排序后等于此 $key$ 的所有`string`。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> map;\n        vector<vector<string>> res;\n        for(int i = 0; i < strs.size(); ++i){\n            string str = strs[i];\n            sort(str.begin(), str.end());\n            map[str].push_back(strs[i]);\n        }\n        for(auto &m : map)\n            res.push_back(m.second);\n        return res;   \n    }\n};\n```\n\n#### 更进一步\n\n##### 思路\n\n**唯一分解定理**：任何一个大于1的**自然数**N,如果N不为**质数**，那么N可以唯一分解成**有限个质数**的乘积。\n\n用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。并且每个乘积只能是由这几个质数相乘得到。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<double, vector<string>> map;\n        vector<vector<string>> res;\n        double value[26]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};\n        for(int i = 0; i < strs.size(); ++i){\n            double v = 1;\n            for(auto &ch : strs[i]){\n                v *= value[ch - 'a'];\n            }\n            map[v].push_back(strs[i]);\n        }\n        for(auto &m : map)\n            res.push_back(m.second);\n        return res;   \n    }\n};\n```\n\n#### Reference\n\n评论区https://leetcode-cn.com/problems/group-anagrams/comments/","tags":["哈希表"],"categories":["LeetCode"]},{"title":"内存管理（二）","url":"/blog/2020/12/12/内存管理（二）/","content":"\n#### 本次学习要点\n\n1. 连续分配管理方式\n2. 动态分区分配算法\n\n <!-- more-->\n\n#### 连续分配管理方式\n\n连续分配：指为用户进程分配的必须是一个**连续的空间**。\n\n<img src=\"内存管理（二）\\连续分配.png\"  />\n\n##### 单一连续分配\n\n单一连续分配方式中，内存被分为**系统区**和**用户区**。\n\n<img src=\"内存管理（二）\\单一连续分配.png\" style=\"zoom:80%;\" />\n\n特点：内存中**只能有一道用户程序**，用户程序独占整个用户区空间。\n\n优点：实现简单，**无外部碎片**；可采用覆盖技术扩充内存；不一定需要采取内存保护\n\n缺点：只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低。\n\n*分配给某进程的内存区域中，如果有些部分没有用上，就是**内部碎片***。\n\n##### 固定分区分配\n\n将**用户空间**划分为**若干个固定大小的分区**，每个分区中**只装入一道作业**。\n\n有两种形式：分区大小相等和分区大小不等\n\n<img src=\"内存管理（二）\\固定分区分配.png\" style=\"zoom:80%;\" />\n\n* 分区大小相等：缺乏灵活性，适用于一台计算机控制多个相同模块的场合。\n* 分区大小不等：增加灵活性，可以满足不同大小进程需求。\n\n###### 分区说明表\n\n操作系统需要建立一个数据结构—分区说明表，每个表包括对应分区的**大小、起始地址、状态**：\n\n<img src=\"内存管理（二）\\固定分区分配-分区说明表.png\"  />\n\n当某用户程序要装入内存时，操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将其分配给该程序，然后修改状态为“已分配”。\n\n优点：实现简单，无外部碎片。\n\n缺点：用户程序太大时，所有分区都不能满足需求，此时得采用覆盖技术，会降低性能；会产生内部碎片，内存利用率低。\n\n##### 动态分区分配\n\n动态分区分配也称可变分区分配，这种方法不会预先划分内存分区，而是**在进程装入内存时，根据进程的大小动态的建立分区**，使分区的大小正好适合进程的需要。\n\n<img src=\"内存管理（二）\\动态分配数据结构.png\" style=\"zoom:80%;\" />\n\n###### 使用什么数据结构？\n\n1. 空闲分区表：每个空闲分区对应一个表项，表项中包含分区号、分区大小、分区起始地址等信息。\n\n<img src=\"内存管理（二）\\动态分配数据结构-空闲分区表.png\"  />\n\n2. 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可以记录分区大小等信息。\n\n<img src=\"内存管理（二）\\动态分配数据结构-空闲分区链.png\"  />\n\n###### 选择哪个分区？\n\n动态分区分配算法，之后会提到。\n\n###### 如何进行分区的分配与回收？\n\n1. 分配\n\n<img src=\"内存管理（二）\\动态分配数据结构-分配1.png\" style=\"zoom:80%;\" />\n\n如果此时一个大小为5MB的进程到来，按照一定的分配算法，将分区1的一部分分配给它运行，分区表更新如下：\n\n![image-20201218113548211](D:\\zxy543040659.github.io\\source\\_posts\\内存管理（二）\\动态分配数据结构-分配2.png)\n\n还有一种情况，如果到来的进程大小为4MB，且将分区3分配给它，那么分区表更新如下：\n\n<img src=\"内存管理（二）\\动态分配数据结构-分配3.png\"  />\n\n2. 回收\n\n   1. 情况一，回收区的后面有一个相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收1.png\" style=\"zoom: 80%;\" />\n\n   此时进程4执行完毕，释放其占用的4MB内存，更新分区表如下（二合一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收2.png\"  />\n\n   \n\n   2. 情况二，回收区的前面有一个相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收3.png\" style=\"zoom:80%;\" />\n\n   此时进程3执行完毕，释放其占用的18MB内存，更新分区表如下（二合一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收4.png\"  />\n\n   3. 情况三，回收区的前、后各有一个相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收5.png\" style=\"zoom:80%;\" />\n\n   此时进程4执行完毕，释放其占用的4MB内存，更新分区表如下（三合一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收6.png\"  />\n\n   4. 情况四，回收区的前、后都没有相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收7.png\" style=\"zoom:85%;\" />\n\n   此时进程2执行完毕，释放其占用的14MB内存，更新分区表如下（新增一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收8.png\"  />\n\n*各表项的顺序不一定按照地址递增顺序，具体由动态分区分配算法确定。*\n\n###### 小结\n\n动态分区分配**没有内部碎片**，但是有**外部碎片**。\n\n* 内部碎片：分配给某进程的内存区域中，有些部分没有用上。\n* 外部碎片：指内存中某些空闲分区由于太小而难以利用。\n\n如果内存中空闲空间的总和本来可以满足某进程的要求，但是进程需要一整块连续的内存空间，而碎片不连续，可以通过**紧凑（拼凑，Compaction）**技术解决外部碎片。\n\n##### 小结\n\n<img src=\"内存管理（二）\\连续分配小结.png\" style=\"zoom:120%;\" />\n\n#### 动态分区分配算法\n\n在动态分区分配方式中，当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？\n\n<img src=\"内存管理（二）\\动态分配算法.png\" style=\"zoom:80%;\" />\n\n##### 首次适应算法\n\n算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。\n\n如何实现：**空闲分区以地址递增的次序排列**。每次分配内存时顺序查找**空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区。\n\n##### 最佳适应算法\n\n算法思想：尽可能多的留下大片的空闲区，优先使用更小的空闲区。\n\n如何实现：**空闲分区以容量递增次序链接**。每次分配内存时顺序查找**空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区（能够满足但大小最小）。\n\n缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多外部碎片。\n\n##### 最坏适应算法\n\n又称最大适应算法。\n\n算法思想：每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小。\n\n如何实现：**空闲分区以容量递减次序链接**。每次分配内存时顺序查找**空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区。\n\n缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。之后如果有“大进程”到达，就没有内存分区可用了。\n\n##### 邻近适应算法\n\n算法思想：在首次适应算法基础上，每次都从上次查找结束的位置开始检索，减小查找的开销。\n\n如何实现：**空闲分区以地址递增的顺序排列（可排成一个循环链表）**。每次分配内存时**从上次查找结束的位置开始查找空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区。\n\n**首次适应算法**每次都会从头查找，每次都需要检索低地址的小分区。这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来。\n\n**邻近适应算法**的规则可能导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，被划分为小分区，最后导致无大分区可用。\n\n**综合来看，首次适应算法的效果反而最好**。\n\n##### 小结\n\n<img src=\"内存管理（二）\\动态分配算法小结.png\" style=\"zoom:120%;\" />\n\n\n\n","categories":["操作系统"]},{"title":"内存管理（一）","url":"/blog/2020/12/12/内存管理（一）/","content":"\n#### 本次学习要点\n\n1. 内存的基础知识\n2. 内存管理的概念\n3. 覆盖与交换\n\n<!-- more-->\n\n#### 内存的基本知识\n\n##### 什么是内存？有何作用？\n\n**内存**是用于存放数据的硬件。程序执行前**需要先放到内存中才能被CPU处理。**\n\n在多道程序环境下，系统中会有多个程序并发执行，会有多个程序的数据需要同时放到内存中。如何区分各个程序的数据在什么地方？——给内存的存储单元编地址。\n\n**内存地址**从0开始，每个地址对应一个存储单元。如果计算机按**字节**编址，则每个存储单元大小为1字节；如果**字长为16位**的计算机按**字**编址，则每个存储单元大小位1个字，也就是16个二进制位。\n\n常用的几个数量单位：\n\n```\n2^10 = 1K\n2^20 = 1M\n2^30 = 1G\n```\n\n##### 逻辑地址与物理地址\n\n编译时产生的指令只关心**相对地址**，实际放入内存中再想办法根据起始位置得到**绝对地址**。\n\neg：编译时只需确定变量x的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程*起始地址+100*即可。\n\n**相对地址**又称**逻辑地址**，**绝对地址**又称**物理地址**。\n\n##### 程序的装入和链接\n\n<img src=\"内存管理（一）\\程序的执行.png\" style=\"zoom:120%;\" />\n\n编译：由编译程序将用户源代码编译成若干个目标模块（高级语言->机器语言）。\n\n链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。\n\n装入（装载）：由装入程序将装入模块装入内存运行。\n\n##### 装入的三种方式\n\n<img src=\"内存管理（一）\\三种装入方式.png\" style=\"zoom:120%;\" />\n\n###### 绝对装入\n\n在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。\n\n绝对装入**只适用于单道程序环境**。\n\n程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。\n\n###### 静态重定位\n\n又称**可重定位装入**。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址仅从**重定位**，将逻辑地址变换为物理地址（地址变换实在装入时一次完成的）。\n\n静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**，也不能再申请内存空间。\n\n###### 动态重定位\n\n又称**动态运行时装入**。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行。**因此装入内存后所有的地址依然是逻辑地址，这种方式需要一个**重定位寄存器支持**。\n\n<img src=\"内存管理（一）\\重定位寄存器.png\" style=\"zoom:120%;\" />\n\n* 采取动态重定位时**允许程序在内存中发生移动**；\n* 可将程序分配到**不连续**的存储区中；\n* 程序运行前只需装入部分代码即可投入运行；\n* 运行期间根据需要动态申请分配内存。\n\n##### 链接的三种方式\n\n###### 静态链接\n\n在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。\n\n<img src=\"内存管理（一）\\静态链接.png\" style=\"zoom: 80%;\" />\n\n###### 装入时动态链接\n\n将各目标模块装入内存时，边装入边链接的链接方式。\n\n<img src=\"内存管理（一）\\装入时动态链接.png\" style=\"zoom:85%;\" />\n\n###### 运行时动态链接\n\n在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。\n\n<img src=\"内存管理（一）\\运行时动态链接.png\" style=\"zoom:90%;\" />\n\n##### 小结\n\n<img src=\"内存管理（一）\\内存的基本知识小节.png\" style=\"zoom:120%;\" />\n\n#### 内存管理的概念\n\n1. 操作系统负责**内存空间的分配与回收**。\n2. 操作系统需要提供某种技术从逻辑上**对内存空间进行扩充**。\n3. 操作系统需要提供**地址转换**功能，负责程序的**逻辑地址**与**物理地址**的转换。\n\n4. 操作系统需要提供**内存保护**功能。保证各进程在各自存储空间内运行，互不干扰。\n\n内存保护的两种方法：\n\n1. 在CPU中设置一对**上、下限寄存器**，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。\n2. 采用**重定位寄存器（基址寄存器）**和**界地址寄存器（限长寄存器）**进行越界检查。重定位寄存器存放进程的**起始物理地址**。界地址寄存器存放进程的**最大逻辑地址**。\n\n<img src=\"内存管理（一）\\内存保护方法二.png\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"内存管理（一）\\内存管理的概念.png\" style=\"zoom:100%;\" />\n\n#### 覆盖与交换\n\n##### 覆盖技术\n\n引入**覆盖技术**，解决**程序大小超过物理内存总和**的问题。\n\n覆盖技术的思想：将**程序分为多个段（多个模块）**。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为**一个固定区**和**若干个覆盖区**。\n\n* 需要常驻内存的段放在**固定区**中，**调入后就不再调出（除非运行结束）**。\n* 不常用的段放在**覆盖区**，**需要用到时调入内存，用不到时调出内存**。\n\n<img src=\"内存管理（一）\\覆盖技术.png\" style=\"zoom:80%;\" />\n\n*必须由程序员声明覆盖结构*，操作系统完成自动覆盖。\n\n**缺点**：对用户不透明，增加了用户编程负担，已成为历史。\n\n##### 交换技术\n\n交换技术的思想：内存空间紧张时，系统将内存中某些进程暂时**换出**外存，把外存中某些已具备运行条件的进程**换入**内存（进程在内存与磁盘间动态调度）。进行了中级调度（内存调度）：决定将哪个处于挂起状态的进程重新调入内存。\n\n1. 应该在外存（磁盘）的什么位置保存被换出的进程？\n\n   具有对换功能的操作系统中，通常把磁盘空间分为**文件区**和**对换区**两部分。**文件区**主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用**离散分配**方式；**对换区**空间只占磁盘空间的小部分，**被换出的进程数据就存放在对换区**。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用**连续分配**方式。总之，对换区的`I/O`速度比文件区的更快。\n\n2. 什么时候应该交换？\n\n   交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。\n\n3. 应该换出哪些进程？\n\n   可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。\n\n*PCB会常驻内存*，不会被换成外存。\n\n##### 小结\n\n<img src=\"内存管理（一）\\覆盖与交换小结.png\" style=\"zoom:120%;\" />\n\n","categories":["操作系统"]},{"title":"LeetCode376-摆动序列","url":"/blog/2020/12/12/LeetCode376-摆动序列/","content":"\n#### 题目描述\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。\n\n例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n\n给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。\n\n<!-- more-->\n\n<img src=\"LeetCode376-摆动序列\\376.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n可以找每次的拐点进行计数，最后再加上首尾两个点即可，比如序列$[1,7,4,9,2,5]$，有4个拐点，加上首尾一共6个点：\n\n<img src=\"LeetCode376-摆动序列\\1.png\" style=\"zoom:80%;\" />\n\n需要考虑特殊情况：\n\n1. 连续几个相同的数恰好都是拐点，如$[1,12,12,12,1]$：\n\n<img src=\"LeetCode376-摆动序列\\2.png\" style=\"zoom:80%;\" />\n\n2. 输入的序列没有拐点且全部是同一个数，如$[1,1,1]$：\n\n<img src=\"LeetCode376-摆动序列\\3.png\" style=\"zoom:80%;\" />\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        int guaidian = 0;\n        for(int i = 1; i < nums.size() - 1; ++i){\n            if(nums[i - 1] > nums[i] && nums[i + 1] > nums[i]){\n                guaidian++;\n            }\n            else if(nums[i - 1] < nums[i] && nums[i + 1] < nums[i]){\n                guaidian++;\n            }\n            // 这一步是为了去除相同的点，如果nums[i]与nums[i + 1]相同，\n            // 那么就让nums[i]等于nums[i - 1]，\n            // 可以保证nums[i + 1]与改变之后的nums[i]不同。\n            else if(i + 1 < nums.size() - 1 && nums[i] == nums[i + 1]){\n                nums[i] = nums[i - 1];\n            }\n        }\n        if(guaidian == 0){\n            auto f = unique(nums.begin(), nums.end());\n            // 输入的序列全部都是同一个数\n            if(f - 1 == nums.begin()){\n                return 1;\n            }\n        }\n        return guaidian + 2;\n    }\n};\n```\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode649-Dota2参议院","url":"/blog/2020/12/11/LeetCode649-Dota2参议院/","content":"\n#### 题目描述\n\nDota2 的世界里有两个阵营：`Radiant`(天辉)和 `Dire`(夜魇)\n\nDota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：\n\n1. `禁止一名参议员的权利`：\n\n参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。\n\n2. `宣布胜利`：\n\n如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。\n\n<!-- more-->\n\n给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。\n\n以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。\n\n假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `Radiant` 或 `Dire`。\n\n<img src=\"LeetCode649-Dota2参议院\\649.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n只想到了暴力法解决。首先记录$senate$中R和D出现次数，再用一个长与$senate$相同的$bool$数组来记录当前字母是否被**消灭**了，初始化都为0，代表没有被**消灭**。遍历$senate$，如果遇到了R，就从R开始找第一个D的位置，直到下一轮循环到它之前的位置；对于D也是一样。这样保证它们能行使自己的权力，除非自己的阵营已经获胜了。\n\n**消灭的策略是：尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴。**\n\n这样做的时间复杂度会很高，用时1452ms。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    string predictPartyVictory(string senate) {\n        int R_cnt = 0;\n        int D_cnt = 0;\n        int len = senate.size();\n        vector<bool> isUsed(senate.size(), 0);\n        for(auto &ch : senate){\n            if(ch == 'R') R_cnt++;\n            else D_cnt++;\n        }\n        while(R_cnt != 0 && D_cnt != 0){\n            for(int i = 0; i < senate.size(); ++i){\n                if(isUsed[i]) continue;\n                if(senate[i] == 'R'){\n                    for(int m = i + 1; m < i + len; ++m){\n                        int j = m % len;\n                        if(senate[j] == 'D' && isUsed[j] == false){\n                            isUsed[j] = true;\n                            D_cnt--;\n                            break;\n                        }\n                    }\n                }\n                else{\n                    for(int m = i + 1; m < i + len; ++m){\n                        int j = m % len;\n                        if(senate[j] == 'R' && isUsed[j] == false){\n                            isUsed[j] = true;\n                            R_cnt--;\n                            break;\n                        }\n                    }\n                }\n                if(R_cnt == 0 || D_cnt == 0) break;\n            }\n        }\n        return R_cnt != 0 ? \"Radiant\" : \"Dire\";\n    }\n};\n```\n\n#### 更进一步\n\n##### 思路\n\n使用一个变量来记录当前参议员之前有几个对手，从而判断自己是否被消灭了。\n\n这里使用$count>0$表示**R在D前面，R可以消灭D**，用$count<0$表示**D在R前面，D可以消灭R**。\n\n执行用时：4ms。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    string predictPartyVictory(string senate) {\n        int count = 0;\n        bool R = true, D = true;\n        while(R && D){\n            R = false;\n            D = false;\n            for(int i = 0; i < senate.size(); ++i){\n                // 如果没被完全消灭，本轮循环结束R和D都为true\n                if(senate[i] == 'R'){\n                    if(count < 0) senate[i] = '0';\n                    else R = true;\n                    // 如果被消灭了计数加一，代表抵挡了一次攻击\n                    // 如果没有被消灭，代表有多了一次消灭敌方机会\n                    // 无论如何都是需要++的，下面的--同\n                    count++;\n                }\n                else if(senate[i] == 'D'){\n                    if(count > 0) senate[i] = '0';\n                    else D = true;\n                    count--;\n                }\n            }\n        }\n        return R != 0 ? \"Radiant\" : \"Dire\";\n    }\n};\n```\n\n#### Reference\n\nhttps://leetcode-cn.com/problems/dota2-senate/solution/649-dota2-can-yi-yuan-tan-xin-suan-fa-ji-siha/","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode860-柠檬水找零","url":"/blog/2020/12/10/LeetCode860-柠檬水找零/","content":"\n#### 题目描述\n\n在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。\n\n顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。\n\n每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。\n\n注意，一开始你手头没有任何零钱。\n\n如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。\n\n<!-- more-->\n\n<img src=\"LeetCode860-柠檬水找零\\860.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n每位顾客付款只有5、10、20美元的选项：\n\n* 收到5元时记录5元零钱的个数；\n\n* 收到10元时需要找零5元并记录10元的个数；\n* 收到20元需要找零15元，但不用记录20元个数，因为不会发生找零20元的情况。\n\n*收到20元找零时应首先选10元零钱，10元用完后再选5元的。比如找零15元，如果只剩下两张5元，一张10元，先从5元开始无法刚好找零15（5+5+10）。*\n\n*需要找零的总数必须大于等于当前用到的零钱的面值，详见代码。*\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool lemonadeChange(vector<int>& bills) {\n        int map[11] = {0};\n        for(int i = 0; i < bills.size(); ++i){\n            if(bills[i] == 5){\n                map[5]++;\n            }\n            else{   \n                int val = bills[i] - 5;\n                for(int j = 10; j >= 5; j /= 2){\n                    // 需要找零的总数必须大于等于当前用到的零钱的面值，val >= j\n                    while(map[j] != 0 && val > 0 && val >= j){\n                        val -= j;\n                        map[j]--;\n                    }\n                    if(val == 0) break;\n                }\n                if(bills[i] <= 10) map[bills[i]]++;\n                if(val != 0) return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode62-不同路径","url":"/blog/2020/12/09/LeetCode62-不同路径/","content":"\n#### 题目描述\n\n一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n与此类似：[LeetCode-不同路径Ⅱ](http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/)，[LeetCode97-交错字符串](http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more)，[LeetCode174-地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)。\n\n<!-- more-->\n\n<img src=\"LeetCode62-不同路径\\62.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n机器人只能往右或者往下，考虑动态规划（如果四个方向都可以走就不可以用动态规划了，得用DFS或者BFS），对于机器人所在的行和列，都只有一条路径可以到达，初始化为1。而除此之外的位置都是可以由其上边和其左边到达，以此类推得到可以到达最终位置的路径总数。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 1));\n        for(int i = 1; i < m; ++i){\n            for(int j = 1; j < n; ++j){\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n```\n\n\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode842-将数组拆分成斐波那契序列","url":"/blog/2020/12/08/LeetCode842-将数组拆分成斐波那契序列/","content":"\n#### 题目描述\n\n给定一个数字字符串 `S`，比如 `S = \"123456579\"`，我们可以将它分成斐波那契式的序列 `[123, 456, 579]​`。\n\n形式上，斐波那契式序列是一个非负整数列表 `F​`，且满足：\n\n* `0 <= F[i] <= 2^31 - 1​`，（也就是说，每个整数都符合 32 位有符号整数类型）\n* `F.length >= 3​`；\n* 对于所有的 `0 <= i < F.length - 2​`，都有 ​`F[i] + F[i+1] = F[i+2]​`成立。\n\n**另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。**\n\n返回从 `S` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]`。\n\n<!-- more-->\n\n<img src=\"LeetCode842-将数组拆分成斐波那契序列\\842.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n不断地截取字符串，看当前字符串对应的数能不能和之前的两个数构成斐波那契序列，如果可以就继续找下一个，不行的话就进行回退。截取完最后一个字符后，如果截取到的数字的个数大于等于3，则说明此数组可以拆分成斐波那契序列。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> splitIntoFibonacci(string S) {\n        if(S.empty()) return {};\n        vector<int> buf;\n        backTrack(S, buf, 0);\n        return buf;\n    }\n    bool backTrack(string &S, vector<int> &buf, int index){\n        if(buf.size() >= 3 && index == S.size())\n            return true;\n        for(int i = index; i < S.size(); ++i){\n            // 不能以0开头\n            if(S[index] == '0' && i > index)\n                break;\n            // 取从index开始到i的字符串并转换为数字\n            string s = S.substr(index, i - index + 1);\n            long num = stol(s, 0, 10);\n            // 如果取出的数大于INT_MAX直接终止\n            if(num > INT_MAX) break;\n            int len = buf.size();\n            // 如果截取的数字大于前两个数字之后，直接终止，因为后面只会越取越大\n            if(len >= 2 && num > (long)buf[len - 1] + (long)buf[len - 2]) break;\n            // 刚开始时buf里不到2个数时，将num加入buf中\n            // 或者buf已经有2个及以上的数了，如果num等于buf的后两个数之和，加入buf中\n            if(len <= 1 || num == (long)buf[len - 1] + (long)buf[len - 2]){\n                buf.push_back(num);\n                if(backTrack(S, buf, i + 1))\n                    return true;\n                // 如果没找到，就将当前的num移除掉\n                buf.pop_back();\n            }\n        }\n        return false;\n    }\n};\n```\n\n#### Reference\n\nhttps://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/","tags":["贪心算法","回溯算法"],"categories":["LeetCode"]},{"title":"进程管理（四）-死锁","url":"/blog/2020/12/07/进程管理（四）-死锁/","content":"\n#### 本次学习要点\n\n1. 死锁的概念\n2. 预防死锁\n3. 避免死锁\n4. 死锁的检测和解除\n\n<!-- more-->\n\n#### 死锁的概念\n\n##### 什么是死锁？\n\n在并发的环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法推进的现象，就是**死锁**。发生死锁后若无外力干涉，这些进程都将无法向前推进。\n\n##### 死锁、饥饿、死循环区别\n\n<img src=\"进程管理（四）-死锁\\死锁、饥饿、死循环区别.png\" style=\"zoom:120%;\" />\n\n##### 死锁产生的必要条件\n\n产生死锁必须同时满足以下四个条件：\n\n* 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的。\n* 不剥夺条件：进程所获得的资源在未使用完之前，**不能由其他进程强行夺走**，只能主动释放。\n* 请求和保持条件：进程**已经保持了至少一个资源**，但又提出了新的资源要求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源**保持**不放。\n* 循环等待条件：存在一种进程**资源的循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。\n\n*注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁。*\n\n##### 什么时候会发生死锁？\n\n1. 对系统资源的竞争。\n2. 进程推进顺序非法。\n3. 信号量的使用不当。\n\n总之，对不可剥夺资源的不合理分配，可能导致死锁。\n\n##### 死锁的处理策略\n\n1. 预防死锁：破坏死锁产生的四个必要条件中的一个。\n2. 避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。\n3. 死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。\n\n<img src=\"进程管理（四）-死锁\\死锁的概念.png\" style=\"zoom:120%;\" />\n\n#### 预防死锁\n\n##### 破坏互斥条件\n\n如果把只能互斥使用的资源改造成允许共享使用，则系统不会进入死锁状态。如：`SPOOLing`技术。\n\n缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，**很多时候都无法破坏互斥条件**。\n\n##### 破坏不剥夺条件\n\n方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。\n\n方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。\n\n缺点：\n\n1. 实现复杂。\n2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法只适合已保存和恢复状态的资源，如CPU。\n3. 反复的申请和释放资源会增加系统开销，降低系统吞吐量。\n4. 若采用方案一，只要暂时得不到某个资源，之前获得的资源都要放弃，以后再重新申请。如果持续发生这种情况，会导致进程饥饿。\n\n##### 破坏请求和保持条件\n\n可以采用**静态分配方法**，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行后，资源归其所有，该进程就不会再请求别的资源了。\n\n缺点：有些资源可能使用很短的时间，如果进程执行期间一直保持所有资源，就会造成严重的资源浪费，资源利用率极低。另外也可能导致某些进程饥饿。\n\n##### 破坏循环等待条件\n\n可采用**顺序资源分配法**，给系统中的资源编号，规定每个进程**必须按编号递增的顺序请求资源**，同类资源（即编号相同的资源）一次申请完。\n\n原理：一个进程只有占有小编号的资源时才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。\n\n缺点：\n\n1. 不方便增加新的设备，因为可能需要重新分配所有的编号。\n2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源的浪费。\n3. 必须按规定的次序申请资源，用户编程麻烦。\n\n<img src=\"进程管理（四）-死锁\\预防死锁.png\" style=\"zoom:120%;\" />\n\n#### 避免死锁\n\n不破坏死锁的必要条件，而是在在资源动态分配的过程中，防止系统进入不安全状态。\n\n##### 系统安全状态\n\n指系统能按某种推进顺序（P1,P2,...,Pn）为每个进程Pi分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称P1,P2,...,Pn为安全序列，若系统无法找到一个安全序列，则称系统处于不安全状态。\n\n并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。\n\n##### 银行家算法\n\n数据结构：\n\n* 长度为m的一维数组Avaliable表示还有多少可用资源。\n* n*m矩阵Max表示各进程对资源的最大需求数。\n* n*m矩阵Allocation表示已经给各进程分配了多少资源。\n* Max - Alllcation = Need 矩阵表示各进程最多还需要多少资源。\n* 长度为m的一维数组Request表示进程此次申请的各种资源数。\n\n银行家算法步骤：\n\n1. 检查此次申请是否超过了之前声明的最大需求数。\n2. 检查此时系统剩余的可用资源是否还能满足这次请求。\n3. 试探着分配，更改各数据结构。\n4. 用安全性算法检查此次分配是否会导致系统进入不安全状态。\n\n安全性算法步骤：\n\n检查当前的剩余可用资源能否满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程只有的资源全部回收。\n\n不断重复上述过程，看最终是否能让所有进程都加入安全序列。\n\n*系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。*\n\n**举例（后面更新）：**\n\n#### 死锁的检测和解除\n\n当可能发生死锁时，系统应当提供两个算法：\n\n1. 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。\n2. 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。\n\n##### 死锁的检测\n\n为了能对系统是否已发生了死锁进行检测，必须：\n\n1. 用**某种数据结构**来保存资源的请求和分配信息。\n2. 提供**一种算法**，利用上述信息来检测系统是否已进入死锁状态。\n\n<img src=\"进程管理（四）-死锁\\死锁的检测.png\" style=\"zoom:120%;\" />\n\n<img src=\"进程管理（四）-死锁\\死锁的检测1.png\" style=\"zoom:80%;\" />\n\n检测死锁的算法：\n\n1. 在资源分配图中，找出既不阻塞又不是孤点的进程Pi (即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中己有空闲资源数景。如下图中，R1没有空闲资源，R2有 —个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中P1是满足这一条件的进程结点，于是将P1的所有边消去。\n2. 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。\n\n<img src=\"进程管理（四）-死锁\\死锁的检测2.png\" style=\"zoom:80%;\" />\n\n**死锁定理**：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统死锁。\n\n##### 死锁的解除\n\n—旦检测出死锁的发生，就应该立即解除死锁。\n补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程 。\n解除死锁的主要方法有：\n\n1. 资源剥夺法。挂起（哲时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。\n\n2. 撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能己经运行了很长时间，己经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。\n3. 进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程历史信息，设罝还原点。\n\n如何决定”对谁动手“？\n\n1. 进程优先级：牺牲优先级低的。\n2. 已执行多长时间：牺牲执行时间短的。\n3. 还要多久完成：让快结束的优先获得资源。\n4. 进程已经使用了多少资源：拥有更多资源的先牺牲。\n5. 进程是交互式的还是批处理式的？：先牺牲批处理式的。\n\n<img src=\"进程管理（四）-死锁\\总结.png\" style=\"zoom:120%;\" />","tags":["死锁"],"categories":["操作系统"]},{"title":"进程管理（三）","url":"/blog/2020/12/04/进程管理（三）/","content":"\n#### 本次学习要点\n\n1. 进程同步、进程互斥\n2. 进程互斥软件/硬件实现方法\n3. 信号量机制及用其实现进程同步等\n4. 管程\n\n<!-- more-->\n\n#### 进程同步、进程互斥\n\n##### 进程同步\n\n进程异步性：指各并发执行的进程以各自独立的、不可预知的速度向前推进。\n\n进程同步：指为完成某种任务而建立的两个或多个进程，这些进程因为需要再某些位置上协调它们的工作次序而产生制约关系。\n\n##### 进程互斥\n\n临界资源：一个时间段内只允许一个进程使用的资源。如摄像头、打印机等。对临界资源的访问必须**互斥**的进行。\n\n进程互斥：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。\n\n对临界资源的互斥访问，可以在逻辑上分为如下四个部分：\n\n```c\ndo{\n\tentry section; // 进入区\n    critical section; // 临界区\n    exit section; // 退出区\n    remainder section;// 剩余区\n}while(true)\n```\n\n1. 进入区：检查是否可以进入临界区，若可以进入，则设置正在访问临界资源的标志（上锁），防止其他进程同时进入临界区。\n2. 临界区：访问临界资源的代码。\n3. 退出区：解除正在访问临界资源的标志（解锁）。\n4. 剩余区：做其他处理。\n\n*临界区时进程中访问临界资源的代码段。*\n\n*进入区和退出区是负责实现互斥的代码段。*\n\n实现对临界资源的互斥访问需要遵循以下四项原则：\n\n1. 空闲让进。\n2. 忙则等待。\n3. 有限等待，请求访问的进程在有限时间内进入临界区（保证不会饥饿）。\n4. 让权等待，进程不能进入临界区时，应立即释放处理机，防止进程忙等待。\n\n<img src=\"进程管理（三）\\同步与互斥.png\" style=\"zoom:120%;\" />\n\n#### 进程互斥软件/硬件实现方法\n\n##### 软件实现方法\n\n###### 单标志法\n\n实现思想：两个进程在**访问完临界区后**会把临界区的使用权转交给另一个进程，**每个进程进入临界区的权限只能被另一个进程赋予**。\n\n主要问题：违背**空闲让进**原则。\n\n###### 双标志先检查\n\n实现思想：**设置**一个布尔型数组`flag[]`，数组中各个元素用来**标记各进程想要进入临界区的意愿**，比如`flag[0]=true`表示着0号进程P0想要进入临界区。每个进程在进入临界区之前先看有没有别的进程想要进入临界区，没有就将自身的`flag[i]`置为`true`，之后开始访问临界区。\n\n主要问题：违反**忙则等待**原则。原因在于进入区的检查和上锁不是一气呵成的，在**检查后，上锁前**可能发生进程切换。\n\n###### 双标志后检查\n\n实现思想：对比双标志先检查法，先进行上锁再进行检查。\n\n主要问题：虽然解决了**忙则等待**，但是违背了**空闲让进**和**有限等待**原则，会因各进程都长期无法访问临界资源而产生**饥饿**现象。\n\n###### Peterson算法\n\n实现思想：对比双标志后检查法，如果双方都争着想进入临界区，可以让进程主动让对方先使用临界区。\n\n主要问题：违背了**让权等待**原则。\n\n<img src=\"进程管理（三）\\进程互斥的软件实现方法.png\" style=\"zoom:120%;\" />\n\n##### 硬件实现方法\n\n###### 中断屏蔽方法\n\n实现思想：利用”开/关中断指令“实现。\n\n```\n>>>\n关中断；// 关中断后不允许当前进程被中断，也必然不会发生进程切换\n临界区；\n开中断；// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区\n>>>\n```\n\n* 优点：简单、高效。\n* 缺点：不适用于对处理机；只适用于操作系统内核进程，不适用于用户进程。\n\n###### TestAndSet(TS指令/TSL指令)\n\n简称TS指令，也称TestAndSetLock指令，或TSL指令。\n\n主要思想：使用硬件实现，将上锁和检查操作变为原子操作，执行过程中不允许被中断。\n\n* 优点：实现简单，适用于多处理机环境。\n* 缺点：不满足**让权等待**原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。\n\n###### Swap指令(XCHG指令)\n\n也叫Exchange指令，或者XCHG指令。\n\n逻辑上与TS指令相同。\n\n<img src=\"进程管理（三）\\进程互斥的硬件实现方法.png\" style=\"zoom:120%;\" />\n\n#### 信号量机制\n\n信号量机制时一种功能较强的机制，可以用来解决互斥和同步问题，它只能被两个标准的原语`wait(S)`和`signal(S)`访问，简称**P操作**和**V操作**。\n\n信号量其实就是一个变量，可以是一个整数，也可以是更复杂的记录型变量，可以用一个信号量来**表示系统中某种资源的数量**。\n\n##### 整型信号量\n\n用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。\n\n```c\nint S = 1; // 表示当前系统中可用的打印机数\nvoid wait(int S){ // wait原语，相当于进入区\n    while(S <= 0); // 资源不够，等待\n    S = S - 1; // 资源够，占用一个资源\n}\nvoid signal(int S){ // signal原语，相当于退出区 \n    S = S + 1; // 使用完资源后，在退出区释放资源\n}\n```\n\n1. 与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。\n2. **检查**和**上锁**一气呵成，避免并发、异步导致的问题。\n3. 存在问题：不满足**让权等待**原则，会发生**忙等**。\n\n##### 记录型信号量\n\n用记录型数据结构表示的信号量。\n\n```c\n/*记录型信号量的定义*/\ntypedef struct{\n    int value; // 剩余资源数\n    struct process *L;// 等待队列\n} semaphore;\n\n```\n\n```c\n/*某进程需要资源时，通过wait原语申请*/\nvoid wait(semaphore S){\n    S.value--;\n    // 如果剩余资源不够，使用block原语使进程由运行态进入阻塞态\n    // 并将其挂到信号量S的等待队列（即阻塞队列）中\n    // 遵循了让权等待原则，不会出现忙等\n    if(S.value < 0){\n\t\tblock(S.L);\n    }\n}\n```\n\n```c\n/*进程使用完资源后，通过signal原语释放*/\nvoid signal(semaphore S){\n    S.value++;\n    // 释放完资源后，若还有别的进程在等待这种资源\n    // 则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态\n    if(S.value <= 0){\n\t\twakeup(S.L);\n    }\n}\n```\n\n#####  用信号量机制实现进程互斥、同步、前驱关系\n\n###### 进程互斥\n\n1. 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）。\n2. 设置**互斥信号量**mutex，**初始值为1**。\n3. 在临界区之前执行P(mutex)。\n4. 在临界区之后执行V(mutex)。\n\n*注意：对不同的临界资源需要设置不同的互斥信号量，P、V操作必须成对出现*。\n\n###### 进程同步\n\n1. 分析什么地方需要实现”同步关系“，即必须保证”一前一后“执行的两个操作（或两句代码）。\n2. 设置**同步信号量**S，**初始值为0**。\n3. 在\"前操作\"之后执行V(S)。\n4. 在”后操作“之前执行P(S)。\n\n###### 信号量机制实现前驱关系\n\n其实每一对前驱关系都是一个进程同步问题（需要保证一前一后操作）。\n\n1. 要为每一对前驱关系各设置一个同步变量。\n2. 在”前操作“之后对相应的同步变量执行V操作。\n3. 在”后操作“之前对相应的同步变量执行P操作。\n\n<img src=\"进程管理（三）\\信号量实现同步与互斥.png\" style=\"zoom:120%;\" />\n\n常见的使用场景\n\n* 生产者消费者问题\n* 多生产者—多消费者模型\n* 吸烟者问题\n* 读者—写者问题\n* 哲学家进餐问题\n\n#### 管程\n\n引入管程的原因：信号量机制编写程序困难，易出错而导致死锁。\n\n管程是一种特殊的软件模块，由这些部分组成：\n\n1. 局部于管程的共享数据结构说明。\n2. 对该数据结构进行操作的一组过程（或函数）。\n3. 对局部于管程的共享数据设置的一组过程。\n4. 管程的名称。\n\n基本特征：\n\n1. 局部于管程的数据只能被局部于管程的过程所访问。\n2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。\n3. **每次仅允许一个进程在管程内执行某个内部过程，即同一时刻只有一个进程在管程内执行某个函数。**\n\n<img src=\"进程管理（三）\\管程.png\" style=\"zoom:120%;\" />\n\n","categories":["操作系统"]},{"title":"C++顺序容器","url":"/blog/2020/11/25/C-顺序容器/","content":"\n#### 本次学习要点\n\n1. 顺序容器概述\n2. 容器库概览\n3. 顺序容器操作\n4. `vector`对象是如何增长的\n5. 额外的`string`操作\n6. 容器适配器\n\n<!-- more-->\n\n#### 顺序容器概述\n\n<img src=\"C-顺序容器\\概述.png\" style=\"zoom:120%;\" />\n\n选择容器的基本原则：\n\n* 尽量使用`vector`。\n* 要求随机访问元素，使用`vector`或者`deque`。\n* 要求在中间插入或删除元素，使用`list`或者`forward_list`。\n* 要求在首尾插入或删除元素且不会在中间插入或者删除，使用`deque`。\n* 如果程序要读取输入，且必须在中间插入，使用`list`，随后拷贝到`vector`。\n\n#### 容器库概览\n\n<img src=\"C-顺序容器\\容器操作.png\" style=\"zoom:120%;\" />\n\n<img src=\"C-顺序容器\\容器操作1.png\" style=\"zoom:120%;\" />\n\n##### 迭代器\n\n`forward_list`迭代器不支持递减运算符。\n\n###### 迭代器范围\n\n**左闭合区间**：`[begin, end)`，表示范围自`begin`开始，于`end`之前结束。\n\n* 如果`begin`与`end`相等，则范围为空。\n* 如果`begin`与`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素。\n* 可以对`begin`递增若干次，使得`begin==end`。\n\n##### 容器类型成员\n\n```cpp\nlist<string>::iterator iter;\nvector<int>::difference_type count\n```\n\n##### begin与end成员\n\n```cpp\nlist<string> a = {\"abc\", \"bcd\", \"cde\"};\nauto it1 = a.begin(); // list<string>::iterator\nauto it2 = a.rbegin(); // list<string>::reverse_iterator\nauto it3 = a.cbegin(); // list<string>::const_iterator\nauto it4 = a.crbegin(); // list<string>::const_reverse_iterator\n```\n\n##### 容器定义及初始化\n\n<img src=\"C-顺序容器\\初始化.png\" style=\"zoom:120%;\" />\n\n**array的使用**\n\n```cpp\narray<int, 10> ia1; // 10个默认初始化的int\narray<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9};\narray<int, 10> ia3 = {42}; // ia3[0]为42， 其余为0\narray<int, 10> ia4 = {}; // 初始化为0\n```\n\n##### 赋值和swap\n\n<img src=\"C-顺序容器\\assign.png\" style=\"zoom:120%;\" />\n\n```cpp\n// assign第一种用法\nlist<string> names;\nvector<const char*> oldstyle;\nnames = oldstyle; // 错误，容器类型不匹配\n// 正确，可以将const char*转为string\nnames.assign(oldstyle.cbegin(), oldstyle.cend()); \n// assign的第二种用法\nlist<string> slist1(1); // 1个元素，为空string\nslist1.assign(10, \"Hiya!\"); // 10个元素，每个都是\"Hiya\"\n```\n\n###### 使用swap\n\nswap操作交换两个相同类型容器的内容\n\n```cpp\nvector<string> svec1(10);\nvector<string> svec2(24);\nswap(svec1, svec2);\n// 元素本身并未交换，swap只是交换了两个容器的内部数据结构\n```\n\n**除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间完成**。**对array会真正交换它们的元素**。\n\n##### 容器大小操作\n\n`size`：返回容器中元素数目。\n\n`empty`：容器是否为空。\n\n`max_size`：返回一个大于或等于该类型容器所能容纳的最大元素数的值。\n\n注：`forward_list`不支持`size`。\n\n##### 关系运算符\n\n```cpp\nvector<int> v1 = {1,3,5,7,9,12};\nvector<int> v2 = {1,3,9};\nvector<int> v3 = {1,3,5,7};\nvector<int> v4 = {1,3,5,7,9,12};\n// v1 < v2 true，在v1[2] < v2[2]\n// v1 < v3 false，所有元素相等，但是v3元素更少\n// v1 == v4 true，元素对应相等且长度相同\n// v1 == v2 false，v2元素比v1少\n```\n\n#### 顺序容器操作\n\n<img src=\"C-顺序容器\\添加元素.png\" style=\"zoom:120%;\" />\n\n##### 使用emplace操作\n\n当调用一个`emplace`成员函数时，将参数传递给元素类型的构造函数。`emplace`成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：\n\n```cpp\nc.emplace_back(\"978-0590353403\", 24, 15.99);\nc.push_back(Sales_data(\"978-0590353403\", 24, 15.99));\n// 错误\nc.push_back(\"978-0590353403\", 24, 15.99);\n```\n\n##### 访问元素\n\n<img src=\"C-顺序容器\\访问元素.png\" style=\"zoom:120%;\" />\n\n##### 删除元素\n\n<img src =\"C-顺序容器\\删除元素.png\" style=\"zoom:120%;\" />\n\n##### 改变容器大小\n\n<img src =\"C-顺序容器\\改变容器大小.png\" style=\"zoom:120%;\" />\n\n##### 容器操作可能使迭代器失效\n\n向容器中添加/删除元素可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。\n\n在向容器添加元素后：\n\n* 容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但插入位置之后的迭代器、指针和引用将会失效。\n* 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，指向存在元素的引用和指针不会失效。\n* 对于`list`和`forward_list`，指向容器的迭代器、指针和引用仍有效。\n\n删除元素时，指向被删除元素的迭代器、指针和引用都会失效。\n\n* 对于`list`和`forward_list`，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针都有效。\n* 对于`deque`，在首尾之外的任何位置删除元素，指向被删除元素外其他元素的迭代器、指针或引用也会失效。删除尾，尾后迭代器会失效，但其他迭代器、引用和指针不受影响；删除首，也不受影响。\n* 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍有效。\n\n*注意：当我们删除元素时，尾后迭代器总会失效*。\n\n#### vector对象是如何增长的\n\n`vector`会分配比新的空间需求更大的内存空间，作为备用。\n\n##### 管理容量的成员函数\n\n<img src=\"C-顺序容器\\管理vector.png\" style=\"zoom:120%;\" />\n\n*`reserve`不改变容器中元素的数量，只影响`vector`预先分配多大的内存空间。*\n\n#### 额外的string操作\n\n<img src=\"C-顺序容器\\额外string.png\" style=\"zoom:120%;\" />\n\n这些构造函数接受一个`string`或一个`const char*`参数，还接受（可选的）指定拷贝多少个字符的参数。\n\n从`const char*`创建`string`时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。且：\n\n* 如果同时传一个计数值，就不必以空字符结尾。\n* 如果未传递计数值且数组未以空字符结尾，或者计数值大于数组大小，则构造函数未定义。\n\n从`string`拷贝时，可选开始位置和计数值。位置大于`size`，构造函数抛出一个*out of range*异常。计数值代表从当前位置拷贝这么多个字符，最多拷贝到`string`结尾。\n\n##### sbustr\n\n<img src=\"C-顺序容器\\substr.png\" style=\"zoom:120%;\" />\n\n##### aapend和replace\n\n1. `append`操作是在`string`末尾进行插入操作的一种简写形式。\n\n```cpp\ns.append(\"123abc\"); // 将\"123abc\"追加在s之后\n```\n\n2. `replace`操作是调用`erase`和`insert`的一种简写形式。\n\n```cpp\ns.erase(11, 3);\ns.insert(11, \"5th\");\n// 等价于\ns.replace(11, 3, \"5th\");\n```\n\n还有`assign`：\n\n```cpp\ns.assign(arg); // 将s中字符替换未arg，返回指向s的引用\n```\n\n`assign`总是替换`string`中所有内容。\n\n##### string的搜索操作\n\n<img src=\"C-顺序容器\\string_find.png\" style=\"zoom:120%;\" />\n\n<img src=\"C-顺序容器\\string_find_form.png\" style=\"zoom:120%;\" />\n\n*`string`搜索返回`string::size_type`类型，是无符号的，因此用`int`表示不是很好的选择。*\n\n##### compare函数\n\n根据 `s` 是等于、大于还是小于参数指定的字符串，`s.compare` 返回 0、正数或负数。\n\n先根据字符字典序的大小比较，如果都相同，再比较字符串长度。\n\n<img src=\"C-顺序容器\\compare.png\" style=\"zoom:120%;\" />\n\n##### 数值转换\n\n```cpp\nstring s = \"pi = 3.14\";\n// 转换s中以数字开始的第一个字串，d=3.14\nd = stod(s.substr(s.find_first_of(\"+-.0123456789\")));\n```\n\n*如果`string`不能转换为数值，抛出`invalid_argument`异常。如果转换的数值无法用任何类型表示，则抛出一个`out_of_range`异常*。\n\n#### 容器适配器\n\n**适配器**是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。比如：`stack`、`queue`、`priority_queue`。\n\n<img src=\"C-顺序容器\\容器适配器.png\" style=\"zoom:120%;\" />\n\n每个适配器都定义了两个构造函数：\n\n1. 默认构造函数创建一个空对象，接受一个容器的构造函数拷贝来初始化适配器。\n\n```cpp\n// 假定dep使一个deque<int>\nstack<int> stk(dep); // 从deq拷贝元素到stk\n```\n\n2. 默认情况下，`stack`和`queue`基于`deque`实现，`priority_deque`基于`vector`。创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。\n\n```cpp\n// 基于vector实现空栈\nstack<string, vector<string>> str_stk;\n// str_stk2在vector上实现，初始化时保存svec的拷贝\nstack<string, vector<string>> str_stk2(svec);\n```\n\n##### 栈适配器\n\n`stack`类型定义在`stack`头文件中。\n\n<img src=\"C-顺序容器\\stack.png\" style=\"zoom:120%;\" />\n\n##### 队列适配器\n\n`queue`和`priority_queue`适配器定义在`queue`头文件中。\n\n<img src=\"C-顺序容器\\queue.png\" style=\"zoom:120%;\" />\n\n<img src=\"C-顺序容器\\queue1.png\" style=\"zoom:120%;\" />\n\n","categories":["C++"]},{"title":"LeetCode148-排序链表","url":"/blog/2020/11/22/LeetCode148-排序链表/","content":"\n#### 题目描述\n\n给你链表的头结点 `head` ，请将其按 升序 排列并返回 排序后的链表 。\n\n**进阶**：\n\n你可以在`O(nlogn)`时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n\n本题可与[LeetCode147-对链表进行插入排序](http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more)，[LeetCode143-重排链表](http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/)共同学习。\n\n<!-- more-->\n\n<img src=\"LeetCode148-排序链表\\示例.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n题目要求用`O(nlogn)`的时间复杂度来进行排序，所以不能用[LeetCode147-对链表进行插入排序](http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more)的方法来进行解，所以采用归并排序的思想对链表进行排序。\n\n使用归并排序首先得找到链表的中间节点，找到中间节点，根据中间节点的位置将链表分为两个部分，再进行归并排序。**中间节点在链表前半部分的末尾，将链表拆开后，要让中间节点的下一个指向空**，再分别对两个链表进行归并排序，最后再合并两个排序好的链表，如下：\n\n```cpp\nListNode* __mergeSort(ListNode *node){\n    // 如果节点为空或只有一个节点，返回当前节点即可\n    if(!node || !node->next)\n        return node;\n    ListNode *fast = node;\n    ListNode *slow = node;\n    while(fast->next && fast->next->next){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    ListNode *l2 = slow->next;\n    slow->next = nullptr;\n\n    ListNode* left = __mergeSort(node);\n    ListNode* right = __mergeSort(l2);\n    return __merge(left, right);\n}\n```\n\n合并的操作需要创建一个新的链表，新的链表根据两个链表的值建立。如果$l1$的值小于$l2$，那么将插入$l1$新的链表中，同时$l1$移动到它的下一个节点；否则将$l2$插入新的链表中，同时$l2$移动到它的下一个节点。插入操作结束后，再将新链表向后移动一个节点（也就是新插入的节点）。**如果两个链表长度不一样（两个链表长度最多差一个），还要判断插入操作结束后哪个链表不为空，如果不为空，它就是新链表的最后一个节点**。\n\n```cpp\nListNode* __merge(ListNode *l1, ListNode *l2){\n    ListNode *dummyNode = new ListNode(-1);\n    ListNode *cur = dummyNode;\n\n    while(l1 && l2){\n        if(l1->val < l2->val){\n            cur->next = l1;\n            l1 = l1->next;\n        }\n        else{\n            cur->next = l2;\n            // cout << l2->val;\n            l2 = l2->next;\n        }\n        cur = cur->next;\n    }\n    cur->next = l1 != nullptr ? l1 : l2;\n    return dummyNode->next;\n}\n```\n\n#### 代码\n\n```cpp\n// 主函数\nListNode* sortList(ListNode* head) {\n    return __mergeSort(head);\n}\n// 其余两个函数\nListNode* __mergeSort(ListNode *node);\nListNode* __merge(ListNode *l1, ListNode *l2);\n```\n\n\n\n","tags":["链表","归并排序"],"categories":["LeetCode"]},{"title":"LeetCode147-对链表进行插入排序","url":"/blog/2020/11/21/LeetCode147-对链表进行插入排序/","content":"\n#### 题目描述\n\n插入排序算法：\n\n1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。\n2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。\n3. 重复直到所有输入数据插入完为止。\n\n本题可与[LeetCode143-重排链表](http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/)，[LeetCode148-排序链表](http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/)共同学习。\n\n<!-- more-->\n\n<img src=\"LeetCode147-对链表进行插入排序\\description.png\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"LeetCode147-对链表进行插入排序\\示例.png\" style=\"zoom:100%;\" />\n\n#### 思路\n\n首先，使用一个指针记录下一个要进行排序的节点；对于当前节点，从头开始寻找插入位置，然后将当前节点插入。\n\n那么需要保存插入位置的前一个节点和后一个节点，从头开始，如果当前节点的值大于后一个节点，那么同时将两个节点后移，否则直接进行插入即可。\n\n最后再将当前节点更新为下一个要进行排序的节点。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        if(!head || !head->next) return head;\n        ListNode *dummyNode = new ListNode(0);\n        ListNode *node = head;\n        while(node){\n            ListNode *next = node->next;\n            // 对排好序的链表进行插入\n            ListNode *pre = dummyNode;\n            ListNode *sorted = dummyNode->next;\n            while(sorted){\n                // 当前点大于后一个点\n                if(node->val > sorted->val){\n                    pre = sorted;\n                    sorted = sorted->next;\n                }\n                else break;\n            }\n            // 此时当前点小于等于最后一个点，可以进行插入\n            // 此时sorted之前的点都已经排好序了\n            pre->next = node;\n            node->next = sorted;\n\n            node = next;\n        }\n        return dummyNode->next;\n    }\n};\n```\n\n","tags":["链表","插入排序"],"categories":["LeetCode"]},{"title":"C++标准库-I/O库","url":"/blog/2020/11/21/C-标准库-I-O库/","content":"\n#### 本次学习要点\n\n1. I/O类\n2. 文件输入输出\n3. string流\n\n<!-- more-->\n\n#### I/O类\n\n`iostream`定义了用于读写流的基本类型。\n\n`fstream`定义了用于读写命名文件的类型。\n\n`sstream`定义了用于读写内存`string`对象的类型。\n\n<img src=\"C-标准库-I-O库\\io类.png\" style=\"zoom:120%;\" />\n\n`I/O`对象无拷贝或赋值，传递和引用不能是`const`的。\n\n##### 条件状态\n\n<img src=\"C-标准库-I-O库\\条件状态.png\" style=\"zoom:120%;\" />\n\n上表是`I/O`类所定义的一些函数和标志，可以访问和操作流的**条件状态**。\n\n由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态最简单的方法是将它当作一个条件使用：\n\n```cpp\nwhile(cin >> word)\n\t// ok：读操作成功\n```\n\n##### 刷新输出缓冲区\n\n```cpp\ncout << \"hi!\" << endl;  // 输出hi和换行，然后刷新缓冲区\ncout << \"hi!\" << flush; // 输出hi后直接刷新缓冲区\ncout << \"hi!\" << ends;  // 输出hi和一个空字符再刷新缓冲区\n```\n\n#### 文件输入输出\n\n头文件`fstream`定义了三个类型来支持文件IO：\n\n1. **ifstream**从一个给定文件读取数据。\n2. **ofstream**向一个给定文件写入数据。\n3. **fstream**可以读写给定文件。\n\n<img src=\"C-标准库-I-O库\\fstream.png\" style=\"zoom:120%;\" />\n\n##### 使用文件流对象\n\n创建文件流对象时，可以提供文件名（可选）。\n\n```cpp\nifstream in(ifile); // 构造一个ifstream并打开给定文件\nofstream out; // 输出文件流未关联到任何文件\n```\n\n##### 成员函数open和close\n\nopen用来判断文件是否打开成功，一旦打开成功，它就保持与对应文件的关联，对于一个已经打开的文件流调用open会失败，直到使用close关闭文件，成功关闭后可以打开新的文件。\n\n```cpp\nifstream in(ifile);\nin.close();\nin.open(ifile + \"2\");\n```\n\n当一个`fstream`对象离开其作用域时，与之关联的文件会自动关闭。\n\n##### 文件模式\n\n<img src=\"C-标准库-I-O库\\文件模式.png\" style=\"zoom:120%;\" />\n\n指定文件模式有如下限制（部分）：\n\n* 只可以对`ofstream/fstream`对象设定out模式。\n* 只可以对`ifstream/fstream`对象设定in模式。\n\n在未指定文件模式时，与`ifstream`关联的文件默认以in模式打开；与`ofstream`关联的文件默认以out模式打开；与`fstream`关联的文件默认以in和out模式打开。\n\n默认情况下，**以out模式打开文件会丢去已有数据**。阻止一个`ofstream`清空给定文件内容的方法是同时指定app模式：\n\n```cpp\n// 在这几条语句中，file1都被截断\n// 隐含以输出模式打开文件并截断文件\nofstream out(\"file1\");\n// 隐含地截断文件\nofstream out1(\"file1\", ofstream::out);\nofstream out2(\"flie2\", ofstream::out | ofstream::trunc);\n// 为了保留文本内容，必须显示指定app模式\n// 隐含为输出模式\nofstream app(\"file1\", ofstream::app);\nofstream app1(\"file2\", ofstream::out | ofstream::app);\n```\n\n*保留被`ofstream`打开地文件中已有数据地唯一方法是显示指定app或in模式（17.5.3节，676页）*。每次调用`open`时都会确定文件模式。\n\n#### string流\n\n`istringstream`从`string`中读取数据。\n\n`ostringstream`向`string`中写入数据。\n\n`stringstream`既可从`string`中读数据也可以向`string`中写数据。\n\n<img src=\"C-标准库-I-O库\\stringstream.png\" style=\"zoom:120%;\" />\n\n##### 使用istringstream\n\n当我们的工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词，通常可以用`istringstream`。\n\n假如一个文件，列出了一些人和他们所拥有的电话号码（一个或多个），输入文件可能如下：\n\n<img src=\"C-标准库-I-O库\\输入文件.png\"  />\n\n定义一个类描述输入数据：\n\n```cpp\nstruct PersonInfo{\n\tstring name;\n\tvector<string> phones;\n};\n```\n\n使用程序读取数据文件如下：\n\n```cpp\nstring line, word; // 分别保存来自输入的一行和单词\nvector<PersonInfo> people;\n// 逐行从输入读取数据，直到cin遇到文件尾（或其他错误）\nwhile(getline(cin, line)){\n\tPersonInfo info;\n    // 将记录绑定到刚输入的行\n    istringstream record(line);\n    record >> info.name;\n    while(record >> word)\n        info.phones.push_back(word);\n    people.push_back(info);\n}\n```\n\n##### 使用ostringstream\n\n当我们逐步构造输出，最后一起进行打印时，可以使用ostringstream。对上一节的例子，逐个验证电话号码并将其格式化。将有效的号码输出到一个新文件中；对于无效的号码不输出到文件中，并打印一条包含人名和无效号码的错误信息。\n\n```cpp\nfor(const auto &entry : people){\n    ostringstream formatted, badNums;\n    for(const auto &nums : entry.phones){\n        // 如果号码无效，将数的字符串写入badNums\n        if(!valid(nums)){\n            badnums << \" \" << nums;\n        }\n        // 号码有效，将格式化的字符串写入formatted\n        else{\n            formatted << \" \" format(nums);\n        }  \n    }\n    // 没有错误的数，打印名字和格式化的数\n    if(badNums.str().empty())\n        os << entry.name << \" \" << formatted.str() << endl;\n    // 否则，打印名字和错误的数\n    else\n        cerr << \"input error:\" << entry.name  \n        << \"invalid number(s)\" << badNums.str() << endl;\n}\n```\n\n假设两个函数`valid`和`format`已知，分别完成电话号码的验证和格式化功能。","categories":["C++"]},{"title":"进程管理（二）","url":"/blog/2020/11/17/进程管理（二）/","content":"\n#### 本次学习要点\n\n1. 处理机调度概念、层次\n2. 进程调度的时机/切换与过程/方式\n3. 调度算法的评价指标\n4. 非交互性调度算法\n5. 交互性调度算法\n\n<!-- more-->\n\n#### 处理机调度概念、层次\n\n**处理机调度**是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理及分配给它运行，以实现进程并发的执行。\n\n**调度的三个层次**\n\n1. 高级调度（作业调度）\n   * 按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使他（们）获得竞争处理机的权利。\n   * **作业调入一次（建立PCB），调出一次（撤销PCB）。**\n   * 高级调度主要是指调入的问题，只有调入的时机需要操作系统来确定，调出必然是作业结束时刻。\n   * 执行频率低。\n\n2. 中级调度（内存调度）\n\n   * 引入虚拟存储技术后，可将在暂时不能运行的进程调至外存等待，此时状态称为**挂起态。**\n   * PCB不会调到外存，而是常驻内存，被挂起的进程PCB会被放到挂起队列中。\n   * 中级调度就是决定将哪个处于挂起态的进程重新调入内存。\n   * 一个进程可能会被多次调出、调入内存，中级调度频率高于高级调度。\n\n   * 进程的挂起态与七状态模型。\n\n   <img src=\"进程管理（二）\\7states.png\"  />\n\n3. 低级调度（进程调度）\n\n   * 按照某种方法从就绪队列中选取一个进程，将处理机分配给他。\n   * 是**最基本的一种调度。**\n   * 频率很高，一般几十毫秒一次。\n\n **三层调度的联系、对比**\n\n<img src=\"进程管理（二）\\三层调度的联系及对比.png\"  />\n\n*调度算法要研究的问题*：**高级调度、进程调度**\n\n#### 进程调度的时机/切换与过程/方式\n\n##### 进程调度的时机\n\n<img src=\"进程管理（二）\\进程调度的时机.png\"  />\n\n需要注意：\n\n1. 进程在**操作系统内核程序临界区**中*不能*进行调度与切换\n   * 内核程序临界区时用来访问某种内核数据结构的（如进程的就绪队列，由各就绪进程的PCB组成）。\n   * 内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。\n2. 进程处于**临界区**时*可以*进行处理机调度\n   * 如打印机在打印完成之前，进程一直处于临界区内并将临界资源上锁，但打印机是慢速设备，如果此时不允许进程调度会导致CPU一直空闲。\n   * 普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，因此普通临界区可以进行调度和切换。\n\n##### 进程调度的切换与过程\n\n*狭义的进程调度*指的是从就绪队列中选中一个要运行的进程，可以是刚刚被暂停的进程，也可能是另外一个进程，后者需要进程切换。\n\n*广义的进程调度*指包含了选择一个进程和进程切换两个步骤。\n\n*进程切换*是指一个进程让出处理机，由另一个进程占用处理机的过程。进程切换的过程主要完成了：\n\n1. 对原来运行进程各种数据的保存。\n2. 对新的进程各种数据的恢复。\n\n**注意**：进程切换时由代价的，过于频繁的进行进程调度、切换，会使整个系统的效率降低。\n\n##### 进程调度的方式\n\n1. 非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。\n2. 剥夺调度方式，又称抢占方式。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合与分时操作系统、实时操作系统。\n\n#### 调度算法的评价指标\n\n<img src=\"进程管理（二）\\调度算法的评价指标.png\"  />\n\n##### CPU利用率\n\n$$\n利用率=\\frac{忙碌的时间}{总时间}\n$$\n\n##### 系统吞吐量\n\n单位时间内完成作业的数量。\n$$\n系统吞吐量=\\frac{总共完成了多少道作业}{总共花了多少时间}、\n$$\n\n#####  周转时间\n\n从**作业被提交给系统开始**，到**作业完成为止**的这段时间间隔，它包括4个部分：\n\n1. 作业在外存后备队列上等待作业调度（高级调度）的时间。\n2. 进程在就绪队列上等待进程调度（低级调度）的时间。\n3. 进程在CPU上执行的时间。\n4. 进程等待I/O操作完成的时间。\n\n后三项可能发生多次。\n$$\n周转时间=作业完成时间-作业提交时间\n$$\n\n$$\n平均周转时间=\\frac{各作业周转时间之和}{作业数}\n$$\n\n$$\n带权周转时间=\\frac{作业周转时间}{作业实际运行的时间}=\\frac{作业完成时间-作业提交时间}{作业实际运行的时间}\n$$\n\n$$\n平均带权周转时间=\\frac{各作业带权周转时间之和}{作业数}\n$$\n\n后两个比较重要，带权周转时间和周转时间都是越短越好。\n\n##### 等待时间\n\n进程/作业处于等待处理机状态时间之和。\n\n对于**进程**来说，等待时间就是指建立进程后等待被服务的时间之和，在等待I/O完成的期间其实进程也是被服务的，不计入等待时间内。\n\n对于**作业**来说，不仅考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。\n\n##### 响应时间\n\n从用户**提交请求**到**首次产生响应**所用的时间。\n\n#### 非交互性调度算法\n\n##### 先来先服务（FCFS, First Come First Serve）\n\n<img src=\"进程管理（二）\\先来先服务.png\"  />\n\n##### 最短作业优先（SJF, Shortest Job First）\n\n最短作业/进程优先得到服务；既可用于作业调度，也可用于进程调度，用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”；SJF和SPF是**非抢占式的算法**，也有**抢占式的版本**—**最短剩余时间优先**算法（SRTN, Shortest Remaining Time Next）。\n\n短作业/进程优先调度算法：每次调度时选择**当前已到达**且**运行时间最短**的作业/进程，对比FCFS，SPF的平均等待/周转/带权周转的时间都要低。\n\n最短剩余时间优先算法：每当有进程加入，就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间**更短**，则由新进程**抢占**处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。对比非抢占式的算法，其平均等待/周转/带权周转的时间都要低。\n\n<img src=\"进程管理（二）\\SJF.png\"  />\n\n##### 最高响应比优先（HRRN, Highest Response Ratio Next）\n\n非抢占式的调度算法，只有当前运行的进程**主动放弃CPU时**，才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。\n$$\n响应比=\\frac{等待时间+要求服务时间}{要求服务时间}\n$$\n<img src=\"进程管理（二）\\HRRN.png\"  />\n\n #### 交互性调度算法\n\n ##### 时间片轮转（RR, Round-Robin）\n\n轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列头的进程），常用于分时操作系统。\n\n如果**时间片过大**，使得每个进程可以在一个时间片内完成，则时间片轮转调度算法退化为**先来先服务**算法，且会增加进程响应时间。\n\n如果**时间片过小**，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比列减少。\n\n一般来说，设计时间片时要让切换进程的开销占比不超过1%。\n\n<img src=\"进程管理（二）\\RR.png\"  />\n\n##### 优先级调度算法\n\n*非抢占式的优先级调度算法*：每次调度时选择当前已到达且优先级最高的进程。当前进程**主动**放弃处理机时发生调度。\n\n*抢占式的优先级调度算法*：每次调度时选择当前已到达且优先级最高的进程。当前进程**主动**放弃处理机时发生调度。另外，当**就绪队列发生改变时**也需要检查是否会发生抢占。\n\n1. *静态优先级*：创建进程时确定，之后一直不变。\n2. *动态优先级*：创建进程时有一个初始值，之后会根据情况动态的调整优先级。\n\n如何合理设置优先级，通常情况下：\n\n* 系统进程优先级**高于**用户进程\n* 前台进程优先级**高于**后台进程\n* 操作系统**更偏好I/O型进程（I/O繁忙型进程）**\n  * I/O设备和CPU可以并行工作，最好让其尽早投入工作\n\n采取动态优先级，何时调整：\n\n* 某进程在就绪队列中等待很长时间，可适当提高其优先级\n* 某进程占用处理机运行了很长时间，可适当降低其优先级\n* 某进程频繁进行I/O操作，可适当提升其优先级\n\n<img src=\"进程管理（二）\\优先级调度算法.png\"  />\n\n##### 多级反馈队列调度算法\n\n<img src=\"进程管理（二）\\多级反馈队列调度算法.png\"  />\n\n**总结**：\n\n<img src=\"进程管理（二）\\总结.png\"  />\n\n","categories":["操作系统"]},{"title":"进程管理（一）","url":"/blog/2020/11/11/进程管理（一）/","content":"\n#### 本次学习要点\n\n1. 进程的定义、组成、组织方式、特征\n2. 线程\n\n<!-- more-->\n\n#### 进程\n\n##### 一、进程的概念 \n\n多道程序环境下引入*进程*的概念，为了更好地描述和控制程序的并发执行，实现操作系统的并发行和共享性。\n\n1. 进程控制块(Process Control Block, PCB)：描述进程的基本情况和运行状态，进而控制和管理进程，**PCB是进程存在的唯一标志**。\n\n2. **进程映像（进程实体）**由程序段、相关数据段和PCB构成，进程映像是静态的，进程是动态的。\n\n3. **进程**是**进程实体**的运行过程，是系统进行资源分配和调度的一个独立单位。\n\n4. **进程的典型定义**：\n   1. 进程是程序的一次执行过程。\n   2. 进程是一个程序及其数据在处理及上顺序执行时所发生的活动。\n   3. 进程时具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。\n\n##### 二、进程的组成\n\n<img src=\"进程管理（一）\\进程的组成.png\"  />\n\n##### 三、进程的特征\n\n1. 动态性：进程是程序的一次执行过程，是动态地产生、变化和消失的，**最基本特征**\n2. 并发性：内存中有多个进程实体，各进程可并发执行\n3. 独立性：进程是能独立运行、独立获得资源、独立接受调度的**基本单位**\n4. 异步性：各进程按照独立的、**不可预知**的速度向前推进，操作系统要提供**进程同步机制**来解决异步问题\n5. 结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成\n\n##### 四、进程的状态与转换\n\n<img src=\"进程管理（一）\\进程的状态.png\"  />\n\n创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB\n\n终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB\n\n###### 进程的三种基本状态\n\n1. 运行态：占有CPU，并在CPU上运行（单核处理器下，每个时刻最多一个进程处于运行态）\n2. 就绪态：已经具备运行条件，但由于没有空闲CPU，暂时不能运行（万事俱备，只欠CPU）\n3. 阻塞态：又称等待态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机），或等待输入/输出完成。即使处理机空闲，该进程也不能运行\n\n###### 进程状态的转换\n\n<img src=\"进程管理（一）\\进程的状态转换.png\"  />\n\n就绪态->运行态：进程被调度\n\n运行态->就绪态：时间片到，或CPU被其他高优先级的进程抢占\n\n运行态->阻塞态：等待系统分配资源，或等到某事件发生（*主动行为*）\n\n阻塞态->就绪态：资源分配到位，等待的事件发生（*被动行为*）\n\n##### 五、进程控制\n\n进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为**原语**，**原语**的特点是在**执行期间不允许中断**，它是一个不可分割的基本单位，**原语采用关中断指令和开中断指令实现**。\n\n###### 进程的创建\n\n<img src=\"进程管理（一）\\进程的创建.png\"  />\n\n###### 进程的终止\n\n<img src=\"进程管理（一）\\进程的终止.png\"  />\n\n###### 进程的阻塞和唤醒\n\n进程的阻塞和唤醒要成对出现\n\n<img src=\"进程管理（一）\\进程的阻塞和唤醒.png\"  />\n\n###### 进程切换\n\n<img src=\"进程管理（一）\\进程的切换.png\"  />\n\n##### 六、进程通信\n\n<img src=\"进程管理（一）\\进程通信.png\"  />\n\n ###### 共享存储\n\n两个进程对共享空间的访问必须是互斥的，通过操作系统提供的工具实现。操作系统只负责提供共享空间和同步互斥工具（如P、V操作）。\n\n方法：\n\n1. 基于数据结构的共享，低级通信方式\n\n2. 基于存储区的共享，高级通信方式\n\n###### 消息传递\n\n进程间数据交换以**格式化的消息**为单位，包括消息头和消息体。进程通过操作系统提供的“发送信息/接受信息”两个原语进行数据交换。\n\n方法：\n\n1. 直接通信方式，发送进程将消息直接发送给接收进程，挂在接收进程的消息缓冲队列上\n2. 间接通信方式，消息要先发送到中间实体（信箱）中，也称“信箱通信方式”\n\n###### 管道通信\n\n1. 管道通信采用半双工，若要实现双向同时通信，需要设置两个管道\n2. 各进程要互斥地访问管道\n3. 管道满时，写进程write()系统调用被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程read()被阻塞\n4. 如果**没写满就不允许读**，如果**没读空就不允许写**\n5. 数据一旦被读出，就从管道中被抛弃，意味着读进程最多只能有一个\n\n#### 线程\n\n有的进程可能需要“同时”做很多事，而传统的进程只能串行的执行一系列程序。为此，引入了“线程”来增加并发度，**引入线程后，线程成为了程序执行流的最小单位**。\n\n引入线程后，进程只作为除CPU之外的系统资源的分配单位，线程则作为处理机的分配单元。\n\n<img src=\"进程管理（一）\\线程.png\"  />\n\n##### 一、线程的实现方式\n\n1. 用户级线程\n\n<img src=\"进程管理（一）\\用户级线程.png\" style=\"zoom:80%;\" />\n\n2. 内核级线程\n\n<img src=\"进程管理（一）\\内核级线程.png\" style=\"zoom:80%;\" />\n\n3. 二者组合方式，将n个用户级线程映射到m个内核级线程上（n>=m）\n\n<img src=\"进程管理（一）\\组合线程实现.png\" style=\"zoom:80%;\" />\n\n操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。\n\n##### 二、多线程模型\n\n有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。\n\n1. 多对一模型：多个用户级线程映射到一个内核级线程\n\n<img src=\"进程管理（一）\\多线程1.png\" style=\"zoom:80%;\" />\n\n优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。\n\n缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。\n\n2. 一对一模型：一个用户级线程映射到一个内核级线程\n\n<img src=\"进程管理（一）\\多线程2.png\" style=\"zoom:80%;\" />\n\n优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行。\n\n缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，线程管理成本高，开销大。\n\n3. 多对多模型：n个用户级线程映射到m个内核级线程（n>=m）\n\n<img src=\"进程管理（一）\\多线程3.png\" style=\"zoom:80%;\" />\n\n克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。","categories":["操作系统"]},{"title":"图论（二）","url":"/blog/2020/11/03/图论2/","content":"\n#### 本次学习要点\n\n1. 读取一个图\n2. 深度优先搜索DFS\n3. 广度优先搜索BFS\n\n<!-- more-->\n\n#### 从文件中读取一个图\n\n如果要从已有的文件中读取并构建一张图，需要使用到C++的IO库，使用头文件`fstream`和`sstream`，类型如下:\n\n**fstream:**\n\n* `ifstream, wifstream`从文件中读取数据\n* `ofstream, wofstram`向文件中写入数据\n* `fstream, wfstream`读写文件\n\n**sstream:**\n\n* `istringstream, wistringfstream`从`string`中读取数据\n* `ostringstream, wosringstream`向`string`中写入数据\n* `stringstream, wstringstream`读写`string`\n\n##### 读文件—类的实现\n\n```cpp\ntemplate <typename Graph>\nclass ReadGraph {\npublic:\n    ReadGraph(Graph &graph, const string &filename){\n        ifstream file(filename);\n        string line;\n        int V, E;\n\n        assert(file.is_open());\n        assert(getline(file, line));\n        // 首先读入顶点数和边数\n        stringstream ss(line);\n        ss >> V >> E;\n        assert(V == graph.V());\n        // 读入每一条边\n        for(int i = 0; i < E; ++i){\n            assert(getline(file, line));\n            stringstream ss(line);\n            int a, b;\n            ss >> a >> b;\n            assert(a >= 0 && a < V);\n            assert(b >= 0 && b < V);\n            graph.addEdge(a, b);\n        }\n    }\n};\n```\n\n###### 测试主函数\n\n```cpp\nint main(){\n    string filename = \"testG2.txt\";\n    // G2是有6个顶点的无向图\n    SparseGraph g1(6, false);\n    ReadGraph<SparseGraph> readGraph1(g1, filename);\n    // 在两种头文件中新加show函数打印结果\n    g1.show();\n\n    cout << endl;\n\n    DenseGraph g2(6, false);\n    ReadGraph<DenseGraph> readGraph2(g2, filename);\n    g2.show();\n\n    return 0;\n}\n// 输出\nvertex 0:       1 2 5\nvertex 1:       0 2 3 4\nvertex 2:       0 1\nvertex 3:       1 4 5\nvertex 4:       1 3\nvertex 5:       0 3\n\nvertex 0:       0 1 1 0 0 1\nvertex 1:       1 0 1 1 1 0\nvertex 2:       1 1 0 0 0 0\nvertex 3:       0 1 0 0 1 1\nvertex 4:       0 1 0 1 0 0\nvertex 5:       1 0 0 1 0 0\n```\n\n#### 深度优先搜索（DFS）\n\n与二叉树的深度优先搜索遍历不同，二叉树总会遇到空，但是图可能成环，或者无向图，所以遍历时应记录每个节点是否被遍历了。\n\n##### 连通分量\n\n无向图Graph的极大连通子图称为G的**连通分量**( Connected Component)。任何**连通图**的连通分量只有一个，即是其自身，**非连通的无向图**有多个连通分量。如图所示，无向图共有4个连通分量：\n\n<img src=\"图论2\\dfs1.png\"  />\n\n对于一个非连通的无向图来说，可以用DFS得到Graph共有几个连通分量。\n\n```cpp\ntemplate <typename Graph>\nclass Components {\nprivate:\n    Graph &G;\n    bool *visited; // 当前节点是否被遍历过\n    int ccount;\t// 记录连通分量总数\n    int *id;\n\n\tvoid dfs(int v){\n    \tvisited[v] = true;\n    \t// 相当于并查集，让同一个联通分量中的节点指向同一个数\n    \tid[v] = ccount;\n    \t// 编译器无法判断是Graph的一个类型还是一个成员变量，需加关键字typename\n    \ttypename Graph::adjIterator adj(G, v);\n    \tfor(int i = adj.begin(); !adj.end(); i = adj.next()){\n        \tif(!visited[i])\n            \tdfs(i);\n    \t}\n\t}\npublic:\n    Components(Graph &graph): G(graph){\n        visited = new bool[G.V()];\n        id = new int[G.v()];\n        ccount = 0;\n        // 初始化\n        for(int i = 0; i < G.V(); ++i){\n            visited[i] = false;\n            id[i] = -1;\n        }\n        for(int i = 0; i < G.V(); ++i){\n            if(!visited[i]){\n                dfs(i);\n                ccount++;\n            }\n        }\n    }\n    ~Components(){\n        delete[] visited;\n        delete[] id;\n    }\n    int count(){\n        return ccount;\n    }\n    // 查询两个节点是否相连\n    bool isConnected(int v, int w){\n        assert(v >= 0 && v < G.V());\n        assert(w >= 0 && w < G.V());\n        return id[v] == id[w];\n    }\n};\n```\n\n###### 测试主函数\n\n对于图`testG1.txt`和`testG2.txt`，先从文件中读取到稀疏图中，再对此图进行DFS得到连通分量的个数，两个文件内容分别为：\n\n* testG1:\n\n<img src=\"图论2\\testG1.png\"  />\n\n* testG2:\n\n<img src=\"图论2\\testG2.png\"  />\n\n```cpp\nint main(){\n    string filename1 = \"testG1.txt\";\n\n    SparseGraph g1(13, false);\n    ReadGraph<SparseGraph> readGraph1(g1, filename1);\n    Components<SparseGraph> component1(g1);\n    cout << \"TestG1.txt, Component Count: \"<< component1.count() << endl;\n\n    string filename2 = \"testG2.txt\";\n    SparseGraph g2(6, false);\n    ReadGraph<SparseGraph> readGraph2(g2, filename2);\n    Components<SparseGraph> component2(g2);\n    cout << \"TestG2.txt, Component Count: \" << component2.count() << endl;\n\n    return 0;\n}\n// 输出\nTestG1.txt, Component Count: 3\nTestG2.txt, Component Count: 1\n```\n\n##### 获得两点之间的一条路径\n\n使用DFS可以找连通图两点之间的一条路径，但不一定是最短路径。对于稀疏图，复杂度为O(V+E)，对于稠密图，复杂度为O(V^2)。对于下图，寻找节点0到节点6的一条路径。\n\n<img src=\"图论2\\dfs2.png\"  />\n\n在遍历每个节点时，可以存储当前节点是由哪个节点遍历到的，以此可以反推出原始节点到当前节点的一条路径。\n\n```cpp\ntemplate <typename Graph>\nclass Path {\nprivate:\n    Graph &G;\n    int s; // 源节点\n    bool *visited;\n    int *from; // 当前节点是由哪个节点遍历到的\n    void dfs(int v){\n        visited[v] = true;\n        typename Graph::adjIterator adj(G, v);\n        for(int i = adj.begin(); !adj.end(); i = adj.next()){\n            if(!visited[i]){\n                // 节点i是由节点v遍历到的\n                from[i] = v;\n                dfs(i);\n            }\n        }\n    }\npublic:\n    Path(Graph &graph, int s): G(graph){\n        // 算法初始化\n        assert(s >= 0 && s < G.V());\n\n        visited = new bool[G.V()];\n        from = new int[G.V()];\n        for(int i = 0; i < G.V(); ++i){\n            visited[i] = false;\n            from[i] = -1;\n        }\n        this->s = s;\n        // 寻路\n        dfs(s);\n    }\n    ~Path(){\n        delete [] visited;\n        delete [] from;\n    }\n    bool hasPath(int w){\n        assert( w >= 0 && w < G.V() );\n        return visited[w];\n    }\n    void path(int w, vector<int> &vec){\n        stack<int> s;\n        int p = w;\n        // 找到从源节点到目标节点所经过的每一个节点入栈\n        while(p != -1){\n            s.push(p);\n            // 将p更新为可以到达p的一个节点\n            p = from[p];\n        }\n        vec.clear();\n        while(!s.empty()){\n            // 出栈是正向路径\n            vec.push_back(s.top());\n            s.pop();\n        }\n    }\n    void showPath(int w){\n        vector<int> vec;\n        path(w, vec);\n        for(int i = 0; i < vec.size(); ++i) {\n            cout << vec[i];\n            if (i == vec.size() - 1)\n                cout << endl;\n            else\n                cout << \" -> \";\n        }\n    }\n};\n```\n\n###### 测试主函数\n\n```cpp\nint main() {\n    string filename = \"testG2.txt\";\n    SparseGraph g = SparseGraph(7, false);\n    ReadGraph<SparseGraph> readGraph(g, filename);\n    g.show();\n    cout << endl;\n\n    Path<SparseGraph> dfs(g, 0);\n    cout << \"DFS : \";\n    dfs.showPath(6);\n\n    return 0;\n}\n// 输出\nvertex 0:       1       2       5       6\nvertex 1:       0\nvertex 2:       0\nvertex 3:       4       5\nvertex 4:       3       5       6\nvertex 5:       0       3       4\nvertex 6:       0       4\n\nDFS : 0 -> 5 -> 3 -> 4 -> 6\n```\n\n#### 广度优先搜索（BFS）\n\n使用深度优先搜索可以找到无权图两个节点之间的最短路径，复杂度与DFS相同。\n\n##### 最短路径—类的实现\n\n```cpp\ntemplate <typename Graph>\nclass ShortestPath {\nprivate:\n    Graph &G;\n    int s;\n    bool *visited;\n    int *from;\n    int *ord; // 当前点到源节点的最短距离\npublic:\n    ShortestPath(Graph &graph, int s): G(graph){\n        // 算法初始化\n        assert(s >= 0 && s < G.V());\n\n        visited = new bool[graph.V()];\n        from = new int[graph.V()];\n        ord = new int[graph.V()];\n        for( int i = 0 ; i < graph.V() ; i ++ ){\n            visited[i] = false;\n            from[i] = -1;\n            ord[i] = -1;\n        }\n        this->s = s;\n\n        queue<int> q;\n        // 无向图最短路径算法\n        q.push(s);\n        visited[s] = true;\n        ord[s] = 0;\n        while(!q.empty()){\n            int v = q.front();\n            q.pop();\n            typename Graph::adjIterator adj(G, v);\n            for(int i = adj.begin(); !adj.end(); i = adj.next()){\n                if(!visited[i]){\n                    q.push(i);\n                    visited[i] = true;\n                    from[i] = v;\n                    ord[i] = ord[v] + 1;\n                }\n            }\n        }\n    }\n    ~ShortestPath(){\n        delete [] visited;\n        delete [] from;\n        delete [] ord;\n    }\n    bool hasPath(int w){\n        assert( w >= 0 && w < G.V() );\n        return visited[w];\n    }\n\n    void path(int w, vector<int> &vec){\n        assert( w >= 0 && w < G.V() );\n        stack<int> s;\n        int p = w;\n        while( p != -1 ){\n            s.push(p);\n            p = from[p];\n        }\n        vec.clear();\n        while( !s.empty() ){\n            vec.push_back( s.top() );\n            s.pop();\n        }\n    }\n    void showPath(int w){\n        assert( w >= 0 && w < G.V() );\n        vector<int> vec;\n        path(w, vec);\n        for( int i = 0 ; i < vec.size() ; i ++ ){\n            cout<<vec[i];\n            if( i == vec.size()-1 )\n                cout<<endl;\n            else\n                cout<<\" -> \";\n        }\n    }\n    int length(int w){\n        assert( w >= 0 && w < G.V() );\n        return ord[w];\n    }\n};\n```\n\n###### 测试主函数\n\n```cpp\nint main() {\n    string filename = \"testG2.txt\";\n    SparseGraph g = SparseGraph(7, false);\n    ReadGraph<SparseGraph> readGraph(g, filename);\n    g.show();\n    cout<<endl;\n\n    Path<SparseGraph> dfs(g,0);\n    cout<<\"DFS : \";\n    dfs.showPath(4);\n\n    ShortestPath<SparseGraph> bfs(g,0);\n    cout<<\"BFS : \";\n    bfs.showPath(4);\n    cout<< \"Shortest length : \" << bfs.length(4);\n    return 0;\n}\n// 输出\nvertex 0:       1 2 5 6\nvertex 1:       0\nvertex 2:       0\nvertex 3:       4 5\nvertex 4:       3 5 6\nvertex 5:       0 3 4\nvertex 6:       0 4\n\nDFS : 0 -> 5 -> 3 -> 4\nBFS : 0 -> 5 -> 4\nShortest Length : 2\n```\n\n#### 完整工程：\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git\n\n","categories":["算法与数据结构"]},{"title":"图论（一）","url":"/blog/2020/10/27/图论1/","content":"\n#### 本次学习要点\n\n1. 图的基本概念\n2. 图的两种表示方法及实现\n3. 对图进行遍历\n\n<!-- more-->\n\n#### 图的基本概念\n\n##### 基本组成\n\n* 节点（Vertex）\n* 边（Edge）\n\n使用场景：交通运输，社交网络，互联网，工作安排，脑区活动，程序状态执行（自动机）等。\n\n##### 图的分类\n\n* 无向图（Undirected Graph）\n* 有向图（Directed Graph）\n\n无向图是一种特殊的有向图，比如A指向B，同时B指向A\n\n* 无权图（Unweighted Graph）\n* 有权图（Weighted Graph）\n\n其他概念：图的连通性，简单图（无自环边与平行边）\n\n<img src=\"图论1/7-1-1.png\" style=\"zoom:80%;\" />\n\n#### 图的两种表示方法及实现（邻接矩阵与邻接表）\n\n##### 邻接矩阵（适合表示稠密图Dense Graph）\n\n<img src=\"图论1\\7-2-1.png\" style=\"zoom:80%;\" />\n\n**实现：**\n\n```cpp\nclass DenseGraph{\nprivate:\n    int n, m;      // 节点数和边数\n    bool directed; // 是否是有向图\n    vector<vector<bool>> g;\npublic:\n    DenseGraph(int n, bool directed){\n        this->n = n;\n        this->m = 0;\n        this->directed = directed;\n        for(int i = 0; i < n; i++){\n            g.push_back(vector<bool>(n, false));\n        }\n    }\n    ~DenseGraph(){};\n    int V(){ return n;} // 图的节点总数\n    int E(){ return m;} // 图的边总数\n    // 增加节点v与节点w之间的一条边\n    void addEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n        if(hasEdge(v, w)) return; // 处理了平行边，并且防止边数m多加一次\n        g[v][w] = true;\n        if(!directed) // 如果是无向图\n            g[w][v] = true;\n        m++;\n    }\n    bool hasEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n        return g[v][w];\n    }\n};\n```\n\n##### 邻接表（适合表示稀疏图Sparse Graph）\n\n<img src=\"图论1\\7-2-2.png\" style=\"zoom:80%;\" />\n\n**实现：**\n\n```cpp\nclass SparseGraph{\nprivate:\n    int n, m;\n    bool directed;\n    vector<vector<int>> g;\npublic:\n    SparseGraph(int n, bool directed){\n        this->n = n;\n        this->m = 0;\n        this->directed = directed;\n        for(int i = 0; i < n; ++i){\n            g.push_back(vector<int>());\n        }\n    }\n    ~SparseGraph(){}\n    int V(){ return n;} // 图的节点总数\n    int E(){ return m;} // 图的边总数\n    void addEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n\n        g[v].push_back(w);\n        if(v != w && !directed) // 处理了自环边，并且防止边数m多加一次\n            g[w].push_back(v);\n        m++;\n    }\n    bool hasEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n\n        for(int i = 0; i < g[v].size(); ++i){\n            if(g[v][i] == w) // 节点v与w相连\n                return true;\n            return false;\n        }\n    }\n};\n```\n\n#### 对图进行遍历——迭代器的实现\n\n```mermaid\ngraph LR\n\t0-->3;\n\t0-->5;\n\t0-->8;\n```\n\n在邻接矩阵中如下：\n\n| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 0    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | 1    |\n\n在邻接表中如下：\n\n| 0    | 1    | 2    | 3    |\n| ---- | ---- | ---- | ---- |\n| 0    | 3    | 5    | 8    |\n\n如果要遍历某个节点的所有邻边，可以借鉴迭代器的思想。\n\n##### 稠密图（邻接矩阵中）\n\n在`DenseGraph`类中实现：\n\n```cpp\n// 迭代器实现\n// 顶点的邻边按顺序输出\nclass adjIterator {\nprivate:\n    DenseGraph &G;\n    int index; // 遍历到的节点坐标\n    int v;\npublic:\n    adjIterator(DenseGraph &graph, int v) : G(graph) {\n        this->v = v;\n        this->index = -1;\n    }\n    int begin() {\n        index = -1;\n        return next();\n    }\n    int next() {\n        index += 1;\n        for (index; index < G.V(); index++) {\n            if (G.g[v][index]) // 如果v与index相连\n                return index;\n        }\n        return -1; // 没有邻边\n    }\n    bool end() {\n        return index >= G.V();\n    }\n};\n```\n\n##### 稀疏图（邻接表中）\n\n在`SparseGraph`类中实现：\n\n```cpp\nclass adjIterator{\nprivate:\n    SparseGraph &G;\n    int index;\n    int v;\npublic:\n    adjIterator(SparseGraph &graph, int v):G(graph){\n        this->v = v;\n        // 与稠密图不同的是，这里的index表示遍历到v的第index个节点，不表示节点index\n        this->index = index; \n    }\n    int begin(){\n        index = 0;\n        if(G.g[v].size())\n            return G.g[v].size();\n        return -1;\n    }\n    int next(){\n        index += 1;\n        if(index < G.g[v].size())\n            return G.g[v][index];\n        return -1; // 返回-1说明已经遍历结束，此时index = G.g[v].size()\n    }\n    bool end(){\n        return index >= G.g[v].size();\n    }\n};\n```\n\n**测试用主函数：**\n\n```cpp\nint main() {\n    int N = 10;\n    int M = 30;\n\n    srand(time(NULL));\n\n    // Sparse Graph\n    // 存在平行边\n    SparseGraph g1(N, false);\n    for(int i = 0; i < M; ++i){\n        int a = rand() % N;\n        int b = rand() % N;\n        g1.addEdge(a, b);\n    }\n    // O(E)\n    for(int v = 0; v < N; ++v){\n        cout << v << \" : \";\n        SparseGraph::adjIterator adj(g1, v);\n        for(int w = adj.begin(); !adj.end(); w = adj.next()){\n            cout << w << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n    // Dense Graph\n    // 存在自环边\n    DenseGraph g2(N, false);\n    for(int i = 0; i < M; ++i){\n        int a = rand() % N;\n        int b = rand() % N;\n        g2.addEdge(a, b);\n    }\n    // O(V^2)\n    for(int v = 0; v < N; ++v){\n        cout << v << \" : \";\n        DenseGraph::adjIterator adj(g2, v);\n        for(int w = adj.begin(); !adj.end(); w = adj.next()){\n            cout << w << \" \";\n        }\n        cout << endl;\n    }\n}\n```\n\n**测试结果**\n\n```\n// Sparse Graph\n// 可以看出存在平行边\n0 : 3 6 6 7 6\n1 : 9 2\n2 : 7 9 5 1 9\n3 : 5 0 5 6 4 9 5\n4 : 6 3 8 6 8\n5 : 9 7 3 2 3 3 9\n6 : 9 4 0 3 9 0 4 0\n7 : 5 2 8 9 0\n8 : 7 8 9 4 4\n9 : 5 2 6 1 7 3 6 8 5 2\n\n// Sparse Graph\n// 可以看出存在自环边\n0 : 0 2 4\n1 : 4 5 7 9\n2 : 0 4 8\n3 : 3 4 5 6\n4 : 0 1 2 3 6 7 9\n5 : 1 3 6\n6 : 3 4 5 7 8 9\n7 : 1 4 6 7\n8 : 2 6 8\n9 : 1 4 6\n```\n\n#### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git\n","categories":["算法与数据结构"]},{"title":"LeetCode143-重排链表","url":"/blog/2020/10/27/LeetCode143-重排链表/","content":"\n本题同时解决**LeetCode206-反转链表**和**LeetCode876-链表的中间结点**\n\n#### 题目描述\n\n给定一个单链表 $L$：$L0→L1→…→Ln-1→Ln$ ，\n将其重新排列后变为： $L0→Ln→L1→Ln-1→L2→Ln-2→…$\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n本题可与[LeetCode147-对链表进行插入排序](http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more)，[LeetCode148-排序链表](http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/)共同学习。\n\n<!-- more-->\n\n<img src=\"LeetCode143-重排链表\\示例.png\"  />\n\n#### 思路\n\n观察链表，对于长度为偶数的链表，如示例1，可以将2之后的子链表进行反转得到$4->3$，然后再与剩下的链表$1->2$交叉合并，得到$1->4->2->3$；\n\n长度为奇数的链表同理，找到中间结点3，将3之后的子链表反转得到$5->4$，再与剩下的链表$1->2->3$进行合并，得到$1->5->2->4->3$。\n\n#### 链表的中间结点\n\n```cpp\n// 对于偶数长度链表，找到的是中间靠后的一个\nListNode* midNode(ListNode *root){\n    if(!root || !root->next) \n        return root;\n    ListNode *fast = root;\n    ListNode *slow = root;\n    while(fast && fast->next){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    return slow;\n}\n// 对于偶数长度链表，找到的是中间靠前的一个\nListNode* midNode(ListNode *root){\n    if(!root || !root->next) \n        return root;\n    ListNode *fast = root;\n    ListNode *slow = root;\n    while(fast->next && fast->next->next){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    return slow;\n}\n```\n\n#### 反转链表\n\n```cpp\nListNode* reverseList(ListNode *root){\n    ListNode *pre = nullptr;\n    ListNode *cur = root;\n    while(cur){\n        ListNode *tmp = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = tmp;\n    }\n    return pre;\n}\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if(!head) return;\n        ListNode *mid = midNode(head);\n        ListNode *l2 = mid->next;\n        mid->next = nullptr; \n        l2 = reverseList(l2);\n        mergeList(head, l2);\n    }\n    ListNode* midNode(ListNode *root){\n        ListNode *fast = root;\n        ListNode *slow = root;\n        while(fast && fast->next){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n    ListNode* reverseList(ListNode *root){\n        ListNode *pre = nullptr;\n        ListNode *cur = root;\n        while(cur){\n            ListNode *tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp;\n        }\n        return pre;\n    }\n    void mergeList(ListNode *l1, ListNode* l2){\n        ListNode *tmp1;\n        ListNode *tmp2;\n        while(l1 && l2){\n            tmp1 = l1->next;\n            l1->next = l2;\n            tmp2 = l2->next;\n            l2->next = tmp1;\n            l1 = tmp1;\n            l2 = tmp2;\n        }\n    }\n};\n```\n\n","tags":["链表"],"categories":["LeetCode"]},{"title":"二叉树的三种遍历方法（迭代）","url":"/blog/2020/10/19/二叉树的三种遍历方法（迭代）/","content":"\n**概要**\n\n1. 二叉树的前序遍历\n2. 二叉树的中序遍历\n3. 二叉树的后序遍历\n\n<!-- more-->\n\n递归进行二叉树的遍历比较简单，学习使用迭代法进行二叉树的遍历，主要是使用栈这种数据结构。\n\n#### 二叉树的前序遍历\n\n前序遍历的顺序为：中—左—右\n\n```cpp\nvector<int> preorderTraversal(TreeNode* root) {\n    vector<int> preOrder;\n    stack<TreeNode*> st;\n    st.push(root);\n    while(!st.empty()){\n        TreeNode *node = st.top();\n        st.pop();\n        if(node){\n            preOrder.push_back(node->val);\n            // 这里需要注意，前序遍历第二次遍历的是左节点\n            // 所以先将右节点入栈，再将左节点入栈，保证左节点先出栈\n            st.push(node->right);\n            st.push(node->left);\n        }\n    }\n    return preOrder;\n}\n```\n\n#### 二叉树的中序遍历\n\n中序遍历的顺序为：左—中—右\n\n```cpp\nvector<int> inorderTraversal(TreeNode* root) {\n    vector<int> res;\n    stack<TreeNode*> st;\n    TreeNode *node = root;\n    // 先判断根节点不为空，进入迭代，后面再根据栈是否为空进行迭代\n    while(!st.empty() || node){\n        // 当前节点存在，查看其左节点情况，如果其左节点不存在，那就弹出当前节点\n        // 再查看其右节点情况，如果右节点也不存在，就弹出当前栈顶（也就是上一个左节点）\n        if(node){\n            st.push(node);\n            node = node->left;\n        }\n        else{\n            node = st.top();\n            st.pop();\n            res.push_back(node->val);\n            node = node->right;\n        }\n    }\n    return res;\n}\n```\n\n#### 二叉树的后序遍历\n\n后序遍历的顺序为：左—右—中\n\n##### 根据二叉树结构遍历\n\n```cpp\nvector<int> postorderTraversal(TreeNode* root) {\n    stack<TreeNode *> st;\n    vector<int> res;\n    TreeNode *cur = root;\n    TreeNode *pre;\n    while(cur || !st.empty()){\n        // 首先当前节点的左子树入栈\n        while(cur != nullptr){\n            st.push(cur);\n            cur = cur->left;\n        }\n        // 取出最后一个左节点\n        cur = st.top();\n        // 如果当前节点的右节点为空或者已经遍历过了，那么就记录当前节点\n        if(!cur->right || cur->right == pre){\n            res.push_back(cur->val);\n            pre = cur;\n            // 如果记录了当前节点，那么当前节点必须置为空，否则会陷入第一个while中死循环\n            cur = nullptr;\n            st.pop();\n        }\n        // 否则查看当前节点的右节点\n        else{\n            cur = cur->right;\n        }\n    }\n    return res;\n}\n```\n\n动画演示：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/di-gui-die-dai-qu-qiao-san-chong-fang-fa-quan-jie-/\n\n##### 破坏结构遍历\n\n```cpp\nvector<int> postorderTraversal(TreeNode* root) {\n    if(!root) return {};\n    stack<TreeNode*> st;\n    vector<int> res;\n    st.push(root);\n    while(!st.empty()){\n        TreeNode *node = st.top();\n        st.pop();\n        if(node){\n            res.push_back(node->val);\n            st.push(node->left);\n            st.push(node->right);\n        }\n    }\n    // 得到的结果是中—右—左，需要反转一下得到左—右—中\n    reverse(res.begin(), res.end());\n    return res;\n}\n```\n\n","tags":["二叉树"],"categories":["算法与数据结构"]},{"title":"C++类的一些知识点","url":"/blog/2020/10/18/C-类的一些知识点/","content":"\n1. 定义抽象数据类型\n2. 访问控制与封装\n3. 类的其他属性\n4. 类的作用域\n5. 构造函数再探\n6. 类的静态成员\n\n<!-- more-->\n\n类的基本思想：数据抽象、封装。\n\n**数据抽象**是一种依赖于接口和实现分类的编程技术。\n\n**封装**实现了类的接口和实现的分离。\n\n#### 7.1 定义抽象数据类型\n\n##### 7.1.1 设计 Sales_data 类\n\n##### 7.1.2 定义改进的 Sales_data 类\n\n###### 定义成员函数\n\n###### 引入 this\n\n成员函数通过一个名为 **this** 的额外的隐式参数来访问调用它的那个对象。\n\n###### 引入 const 成员函数\n\n成员函数参数列表后的 **const** 作用是：修改隐式 **this** 指针的类型为指向常量的指针。也就是指向常量的常量指针，提高函数的灵活性。\n\n默认情况下，**this** 的类型是**指向类类型非常量版本**的常量指针。\n\n常量对象，以及常量对量的引用或指针都只能调用常量成员函数。\n\n###### 类作用域和成员函数\n\n编译器分两步处理类：①编译成员的声明②成员函数体（有的话）。\n\n###### 定义一个返回 this 对象的函数\n\n##### 7.1.3 定义类相关的非成员函数\n\n一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。\n\n##### 7.1.4 构造函数\n\n类通过成员函数控制其对象初始化的过程，这些函数称为构造函数。\n\n###### 合成的默认构造函数\n\n如果类没有显示的定义构造函数，则编译器会隐式定义一个默认构造函数，也称为**合成的默认构造函数**，其规则如下：\n\n* 如果存在类内初始值，则用它来初始化成员。\n* 否则，默认初始化该成员。\n\n**一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。**\n\n###### = default 的含义\n\n在 C++11 新标准中，如果我们需要**默认**的行为，那么可以通过在参数列表后面写上 **= default** 来要求编译器生成构造函数。\n\n###### 构造函数初始值列表\n\n没有出现在   构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。\n\n##### 7.1.5 拷贝、赋值和析构\n\n如果我们不主动定义这些操作，则编译器将替我们合成它们。\n\n###### 某些类不能依赖于合成的版本\n\n当类需要分配类对象之外的资源时，合成的版本常常会失效。但是类包含 vector 或者 string 成员，则其拷贝、赋值和销毁的合成版本能够正常工作。\n\n#### 7.2 访问控制与封装\n\n使用 class 和 struct 定义类唯一的区别就是默认的访问权限。\n\n##### 7.2.1 友元\n\n* 类可以允许其他类或者函数访问它的非共有成员，方法是令其他类或者函数（可以是成员函数也可以是非成员函数）成为它的友元。一般来说，在类的开始或者结束前位置集中声明友元。如果希望类的用户能够调用某个友元函数，那么就需要在类中友元声明之外再进行一次声明。\n\n  ```cpp\n  class Sales_data{\n  friend Sales_data add(const Sale_data&, const Sale_data&);\n  public:\n      /.../\n  private:\n      /.../\n  };\n  // 非成员函数声明\n  Sales_data add(const Sale_data&, const Sale_data&);\n  ```\n\n* 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元的关系不具有传递性。\n\n  ```cpp\n  class Screen{\n      // Window_mgr的成员可以访问Screen类的私有部分\n      friend class Window_mgr;\n      /.../\n  }\n  // 也可以只为某个成员函数提供访问权限\n  class Screen{\n      // Window_mgr::clear必须再Screen类之前声明\n      friend void Window_mgr::clear(ScreenIndex);\n      /.../\n  }\n  ```\n\n#### 7.3 类的其他特性\n\n##### 7.3.1 类成员再探\n\n###### 可变数据成员\n\nconst 成员函数可以改变**可变数据成员**，在变量的声明中加入 `mutable` 即可。\n\n##### 7.3.4 友元再探\n\n###### 类之间的友元关系\n\n如果一个类指定了友元类，则友元类的成员函数可以访问此类的所有成员。\n\n**每个类负责控制自己的友元类或友元函数。**\n\n###### 令成员函数作为友元\n\n当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类（用类作用域限定符）。\n\n#### 7.4 类的作用域\n\n编译器处理完类的全部声明后才会处理成员函数的定义。\n\n#### 7.5 构造函数再探\n\n##### 为什么使用初始化列表？\n\n如果没有在构造函数的初始化列表中显式地初始化成员，**则该成员将在构造函数体之前执行默认初始化**。相当于进行了赋值操作。相较于在构造函数中初始化效率更高。\n\n##### 构造函数初始值必不可少的情况\n\n如果成员是 **const，引用**或者**某种未提供默认构造函数的类类型**，必须通过构造函数初始化列表为这些成员提供初值。\n\n##### 成员初始化的顺序\n\n构造函数初始化列表中的初始值的前后位置关系**不会**影响实际的初始化顺序。如果一个成员是用另一个成员来初始化的，那么需要考虑两者顺序。\n\n最好令构造函数初始化顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。\n\n##### 7.5.3 默认构造函数的作用\n\n###### 默认初始化\n\n* 在栈区对 int 声明后未定义，执行默认初始化，这个值随机，调用时编译器将提示未定义；如果对数组声明后可以直接使用，在没有赋值时数组元素的值随机，类中的 int 型数据成员也是如此。 \n* 类本身含有**类类型的成员**且使用合成的默认构造函数时。\n* 当类类型的成员没有在构造函数初始值列表中显式初始化时。\n\n###### 值初始化\n\n* 数组初始化过程中提供的初始值数量少于数组大小时：\n\n```cpp\nint a[3] = {1}; // a[0] = 1, a[1] = 0, a[2] = 0\n```\n\n* 不使用初始值定义一个局部静态变量时。\n* 显式地请求值初始化时。\n\n也就是说，非数组内置数据类型在静态/全局变量区进行**值初始化**为0；在栈区执行默认初始化，值随机。而非内置数据类型进行**默认初始化**，由各自决定其初始化对象的方式。例如 `string` 的默认初始化为空字符串。\n\n##### 7.5.4 隐式的类类型转换\n\n```cpp\nstring null_book = \"9-999\";\n// 构造一个临时的 Sales_data 对象，接收 string 的构造函数\n// 该对象的 units_sold 和 revenue 等于0，bookNo 等于 null_book\nitem.combine(null_book); // Sales_data 类对象\n```\n\n###### 抑制构造函数定义的隐式转换\n\n将构造函数声明为 `explicit` 加以阻止：\n\n```cpp\nexplicit Sales_data(const string &s): bookNo(s) {}\n```\n\n此时，没有任何构造函数能用于隐式的创建 `Sales_data` 对象。\n\n当我们用 `explicit` 关键字声明构造函数时，它将**只能以直接初始化的形式使用，而不能使用拷贝初始化**。\n\n#### 7.6 类的静态成员\n\n`static` 关键字只出现在类内部的声明语句中。\n\n我们可以使用静态成员作为默认实参。\n\n##### 静态成员的类内初始化\n\n```cpp\nstatic const int v = 0; // 类内可以初始化 const 静态成员\n```\n\n即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员：\n\n```cpp\nclass B{\npublic:\n    B() = default;\n    static const int v = 0;\n};\nconst int B::v;\n```\n","tags":["Class"],"categories":["C++"]},{"title":"LCP19-秋叶收藏集","url":"/blog/2020/10/11/LCP19-秋叶收藏集/","content":"\n### 题目描述\n\n小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。\n出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。\n\n<!-- more-->\n\n<img src=\"LCP19-秋叶收藏集\\image-20201011112801516.png\" style=\"zoom:80%;\" />\n\n### 思路\n\n用三个状态来标记其中的每一个部分，0和2表示前面和后面的红色，1表示中间的黄色，于是三部分结构为「0、1、2」。\n\n定义`dp[i][j]`表示：对**[0..i]**片叶子进行调整，并且第**i**片叶子处于**j**状态的最小操作数，所以有下面三种情况：\n\n1. 当**j = 0**时，第**i**片叶子应为红色，并且第**i - 1**片叶子也应该处于**j = 0**的状态：\n\n$$\ndp[i][0] = dp[i-1][0] + isYellow(i)\n$$\n\n$$\nisYellow(i)=\n\\begin{cases}\n1& \\text{leaves[i] = 'y'}\\\\\\\\\n0& \\text{leaves[i] = 'r'}\n\\end{cases}\n$$\n\n如果是黄色，那么需要进行一次操作修改颜色：\n\n2. 当**j = 1**时，第**i**片叶子应为黄色，第**i - 1**片叶子可以处于**j = 0**或**j = 1**的状态，所以取其中的较小值：\n\n$$\ndp[i][1] = min(dp[i-1][1], dp[i-1][0]) + isRed(i)\n$$\n\n$$\nisRed(i)=\n\\begin{cases}\n1& \\text{leaves[i] = 'r'}\\\\\\\\\n0& \\text{leaves[i] = 'y'}\n\\end{cases}\n$$\n\n​\t\t如果是红色，那么需要进行一次操作修改颜色：\n\n3. 当**j = 2**时，第**i**片叶子应为红色，第**i - 1**片叶子可以处于**j = 2**或**j = 1**的状态（不能取**j = 0**的状态，因为每种状态至少含有一片叶子，中间必须存在有黄色叶子），再取其中的较小值：\n\n$$\ndp[i][2] = min(dp[i-1][2], dp[i-1][1]) + isYellow(i)\n$$\n\n如果是黄色，那么需要进行一次操作修改颜色，公式同1\n\n最终答案为`dp[n-1][2]`。\n\n***初始化条件：***\n\n1. 要保证每种状态都有叶子，则叶子数量应大于等于状态数量，对于`dp[i][j]`，有**i >= j**；如果**i < j**，那么可以令`dp[i][j] = INT_MAX`；\n2. 对于**i = 0**，**j**也必须为0，于是有`dp[0][0] = isYellow(0)`。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minimumOperations(string leaves) {\n        vector<vector<int>> dp(leaves.size(), vector<int>(3));\n        dp[0][0] = leaves[0] == 'y';\n        // 不合要求的,实际上也不会遇到dp[0][2]这种情况\n        dp[0][1] = dp[0][2] = dp[1][2] = INT_MAX;\n        for(int i = 1; i < leaves.size(); ++i){\n            int isYellow = leaves[i] == 'y';\n            int isRed = leaves[i] == 'r';\n            dp[i][0] = dp[i - 1][0] + isYellow;\n            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0]) + isRed;\n            if(i >= 2) dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + isYellow;\n        }\n        return dp[leaves.size() - 1][2];\n    }\n}\n```\n\n也可以优化空间，使用3个变量来代替状态转移数组：\n\n```cpp\nclass Solution {\npublic:\n    int minimumOperations(string leaves) {\n        int n = leaves.size();\n        // dp[0][0]\n        int start = leaves[0] == 'y';\n        // dp[0][1]\n        int mid = INT_MAX;\n        // dp[1][2]\n        int last = INT_MAX;\n        // 初始化转移变量\n        int start2, mid2, last2 = INT_MAX, red = 0, yellow = 0;\n        for(int i = 1; i < n; ++i){\n            red = leaves[i] == 'r';\n            yellow = leaves[i] == 'y';\n            start2 = start + yellow;\n            mid2 = min(start, mid) + red;\n            if(i >= 2) last2 = min(mid, last) + yellow;\n\n            start = start2;\n            mid = mid2;\n            last = last2;\n        }\n        return last;\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/UlBDOe/solution/qiu-xie-shou-cang-ji-by-leetcode-solution/","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode701-二叉搜索树中的插入操作","url":"/blog/2020/10/09/LeetCode701-二叉搜索树中的插入操作/","content":"\n### 题目描述\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。\n\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。\n\n<!-- more-->\n\n<img src=\"LeetCode701-二叉搜索树中的插入操作\\示例.png\" style=\"zoom:80%;\" />\n\n* 给定的树上的节点数介于 0 和 10^4 之间\n* 每个节点都有一个唯一整数值，取值范围从 0 到 10^8\n* -10^8 <= val <= 10^8\n* 新值和原始二叉搜索树中的任意节点值都不同\n\n### 思路\n\n二叉搜索树满足父节点值大于其左孩子的值小于其右孩子的值，即当前节点大于以它为根节点的左子树的所有值，并且小于其右子树的所有值。根据这个性质，只需要判断`val`与当前节点的值的大小关系来寻找插入位置。\n\n### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if(!root) return new TreeNode(val);\n        if(val < root->val)\n            root->left = insertIntoBST(root->left, val);\n        if(val > root->val)\n            root->right = insertIntoBST(root->right, val);\n        return root;\n    }\n};\n```\n\n","tags":["二叉搜索树"],"categories":["LeetCode"]},{"title":"LeetCode106-从中序与后序遍历序列构造二叉树","url":"/blog/2020/09/27/LeetCode106-从中序与后序遍历序列构造二叉树/","content":"\n### 题目描述\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n**注意:**\n你可以假设树中没有重复的元素。\n\n<!--more -->\n\n<img src=\"LeetCode106-从中序与后序遍历序列构造二叉树\\示例.png\"  />\n\n\n\n### 思路\n\n对于二叉树的题，大部分都是通过递归来解决的，此题也不例外，需要注意的是，要充分利用二叉树中序遍历和后序遍历的性质。\n\n* 中序遍历二叉树(左子树—根节点—右子树)，根节点的左边是左子树，右边是右子树；\n* 后序遍历二叉树(左子树—右子树—根节点)，根节点是最后输出的。\n\n在后序遍历数组中找到根节点之后，再从中序遍历数组中搜索根节点的左边，由此坐标将数组分开，分别就是当前根节点下的左子树和右子树：\n\n<img src=\"LeetCode106-从中序与后序遍历序列构造二叉树\\pic1.png\"  />\n\n上图中`inorder`数组中，3是在`postorder`找到的根节点，由此节点分开，`inorder`数组中绿色部分是左子树，黄色部分是右子树，在`posorder`数组中也是一样的。\n\n* 定义`inorder`数组中3的位置为**rootIn**，数组起始位置为**iStart**，结束位置为**iEnd**；\n* 定义`postorder`数组数组起始位置为**pStart**，结束位置为**pEnd**；\n\n根据以上定义，`inorder`数组中左子树起止位置为`iStart->rootIn-1`，右子树起止位置为`rootIn+1->iEnd`；`postorder`数组中左子树起止位置为`pStart->pStart+rootIn-iStart-1`，右子树起止位置为`pStart+rootIn-iStart->pEnd-1`，图来自leetcode题解(https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/)：\n\n<img src=\"LeetCode106-从中序与后序遍历序列构造二叉树\\pic2.png\"  />\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    unordered_map<int, int> map;\n    vector<int> post;\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int cnt = 0;\n        // 使用一个map记录中序遍历数值的位置\n        for(auto &num : inorder){\n            map[num] = cnt++;\n        }\n        post = postorder;\n        TreeNode *node = dfs(0, inorder.size() - 1, 0, postorder.size() - 1);\n        return node;\n    }\n    TreeNode* dfs(int iStart, int iEnd, int pStart, int pEnd){\n        if(iStart > iEnd || pStart > pEnd) return nullptr;\n        int root = post[pEnd];\n        int rootIn = map[root];\n        TreeNode *node = new TreeNode(root);\n        node->left = dfs(iStart, rootIn - 1, pStart, pStart + rootIn - iStart - 1);\n        node->right = dfs(rootIn + 1, iEnd, pStart + rootIn - iStart, pEnd - 1);\n        return node;\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/","tags":["二叉树","递归"],"categories":["LeetCode"]},{"title":"LeetCode200-岛屿数量","url":"/blog/2020/09/20/LeetCode200-岛屿数量/","content":"\n### 题目描述\n\n给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n**使用并查集解决此问题**\n\n<!-- more-->\n\n<img src=\"LeetCode200-岛屿数量\\示例.png\" style=\"zoom:80%;\" />\n\n### 思路\n\n在`grid`中遇到`'1'`时，搜索其四周（上下左右），如果发现值也为`'1'`，那么将他们合并，同时将当前位置值置为`'0'`，直到遍历到最后一个元素。\n\n并查集进行初始化时，遇到`'1'`则增加计数值`count`，在后续的合并操作中，如果两者根节点不同，要进行合并时，计数值`count`要减1，说明两个节点进行了连接。\n\n### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(vector<vector<char>> &grid){\n        count = 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(grid[i][j] == '1'){\n                    parent.push_back(n * i + j);\n                    count++;\n                }\n                else parent.push_back(-1);\n                rank.push_back(0);\n            }\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 对于根不同的情况，将其相连，计数减1\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            // 随便指一个\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.empty()) return 0;\n        unionFind uf(grid);\n        int m = grid.size();\n        int n = grid[0].size();\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(grid[i][j] == '1'){\n                    grid[i][j] = '0';\n                    if(i - 1 >= 0 && grid[i - 1][j] == '1') uf.unionElem(n * i + j, n * (i - 1) + j);\n                    if(i + 1 < m && grid[i + 1][j] == '1') uf.unionElem(n * i + j, n * (i + 1) + j);\n                    if(j - 1 >= 0 && grid[i][j - 1] == '1') uf.unionElem(n * i + j, n * i + j - 1);\n                    if(j + 1 < n && grid[i][j + 1] == '1') uf.unionElem(n * i + j, n * i + j + 1);\n                }\n            }\n        }\n        return uf.getCount();\n    }\n};\n```\n\n","tags":["并查集"],"categories":["LeetCode"]},{"title":"并查集(Union Find)","url":"/blog/2020/09/06/并查集-Union-Find/","content":"\n### 本次学习要点\n\n1. 并查集的基本概念及实现(Quick_Find/Quick_Union)\n2. 基于size优化与基于rank优化\n3. 路径压缩\n\n<!-- more-->\n\n### 并查集的基本概念及实现\n\n#### 基本概念\n\n并查集是一种特殊的图，较图论而言要简单一些。对于图论来说，主要解决的问题是**连接问题和路径问题**，而并查集只是回答前者——连接问题。比如网络节点间的连接状态，数学中集合类的实现等。\n\n并查集支持两个动作（合并两个节点，查询某个节点）：\n\n* union(p, q)\n* find(p)\n\n用来回答一个问题（两个节点是否相连接）：\n\n* isConnected(p, q)\n\n并查集可以用数组来表示，基本数据表示如下（0-4，5-9互相连接）：\n\n|      |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  id  |  0   |  0   |  0   |  0   |  0   |  1   |  1   |  1   |  1   |  1   |\n\n#### 基本实现(Quick_Find)\n\n```cpp\nclass UnionFind1 {\nprivate:\n    int *id;\n    int count;\npublic:\n    UnionFind1(int n){\n        count = n;\n        id = new int[n];\n        for(int i = 0; i < n; i++)\n            id[i] = i;\n    }\n    ~UnionFind1(){\n        delete [] id;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        return id[p];\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pID = find(p);\n        int qID = find(q);\n        if(pID == qID) return;\n        // 让p指向q，复杂度O(n)\n        for(int i = 0; i < count; i++){\n            if(id[i] == pID)\n                id[i] = qID;\n        }\n    }\n};\n```\n\n#### 基本实现(Quick_Union)\n\n将每一个元素，看作是一个节点：\n\n<img src=\"并查集-Union-Find\\quickUnion.png\" style=\"zoom:67%;\" />\n\n对于上图，将7和3连接，只需要把7的根节点指向3的根节点（反过来也行）。\n\n|   i    |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| parent |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n\n`parent[i]`表示`i`指向的父亲元素是谁。\n\n```cpp\nclass UnionFind2 {\nprivate:\n    int *parent;\n    int count;\npublic:\n    UnionFind2(int count){\n        this->count = count;\n        parent = new int[count];\n        for(int i = 0; i < count; i++)\n            parent[i] = i;\n    }\n    ~UnionFind2(){\n        delete [] parent;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        // 寻找根节点，复杂度O(n)\n        while(p != parent[p])\n            p = parent[p];\n        return p;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 让p指向q，复杂度O(1)\n        parent[pRoot] = qRoot;\n    }\n};\n```\n\n### 并查集的优化\n\n#### 基于size的优化\n\n之前实现的并查集中`Union(p, q)`操作都是让p的根节点指向q，如下图：\n\n<img src=\"并查集-Union-Find\\size1.png\" style=\"zoom: 80%;\" />\n\n如果实现`union(9, 4)`，那么9的根节点9将指向4的根节点8；相应的如果实现`union(4, 9)`则会出现将4的根节点8指向了9，如此一来，查找4的根节点需要的时间就更多了，我们完全可以在`union`操作之前进行判断，将元素少的集合的根节点指向元素多的集合的根节点，用一个数组`sz[i]`来表示以i为根集合中元素的个数。\n\n```cpp\nclass UnionFind3 {\nprivate:\n    int *parent;\n    int *sz;\n    int count;\npublic:\n    UnionFind3(int count){\n        this->count = count;\n        parent = new int[count];\n        sz = new int[count];\n        for(int i = 0; i < count; i++) {\n            parent[i] = i;\n            sz[i] = 1;\n        }\n    }\n    ~UnionFind3(){\n        delete [] parent;\n        delete [] sz;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        // 寻找根节点，复杂度O(n)\n        while(p != parent[p])\n            p = parent[p];\n        return p;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 基于size优化\n        if(sz[pRoot] < sz[qRoot]){\n            parent[pRoot] = qRoot;\n            sz[qRoot] += sz[pRoot];\n        }\n        else{\n            parent[qRoot] = pRoot;\n            sz[pRoot] += sz[qRoot];\n        }\n    }\n};\n```\n\n#### 基于rank的优化\n\n基于size的优化会出现下面一个问题：\n\n<img src=\"并查集-Union-Find\\rank1\" style=\"zoom:80%;\" />\n\n根节点为7的size是大于根节点为8的size的，所以基于size的优化会使8指向7，如下图：\n\n<img src=\"并查集-Union-Find\\rank2\" style=\"zoom:80%;\" />\n\n这样一来，这棵树的层数变成了4，一种更合理的方式是根据当前根节点的树的高度来进行优化，如下图，这样树的层数为3：\n\n<img src=\"并查集-Union-Find\\rank3\" style=\"zoom:80%;\" />\n\n我们可以用一个数组`rank[i]`表示根节点为i的树的高度。\n\n```cpp\nclass UnionFind4 {\nprivate:\n    int *parent;\n    int *rank;\n    int count;\npublic:\n    UnionFind4(int count){\n        this->count = count;\n        parent = new int[count];\n        rank = new int[count];\n        for(int i = 0; i < count; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n    }\n    ~UnionFind4(){\n        delete [] parent;\n        delete [] rank;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        // 寻找根节点，复杂度O(n)\n        while(p != parent[p])\n            p = parent[p];\n        return p;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 基于size优化\n        if(rank[pRoot] < rank[qRoot]){\n            // 不用维护层数\n            parent[pRoot] = qRoot;\n        }\n        else if (rank[pRoot] > rank[qRoot]){\n            // 不用维护层数\n            parent[qRoot] = pRoot;\n        }\n        else{ \n            // rank[pRoot] == rank[qRoot]\n            // 层数加1\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n    }\n};\n```\n\n### 路径压缩(Path Compression)\n\n之前我们的`find(p)`操作中，递归查找的复杂度为`O(1)`，如下图，要查找4的根节点需要4次递归：\n\n<img src=\"并查集-Union-Find\\pathcompression1\" style=\"zoom:80%;\" />\n\n|        |  0   |  1   |  2   |  3   |  4   |\n| :----: | :--: | :--: | :--: | :--: | :--: |\n| parent |  0   |  0   |  1   |  2   |  3   |\n\n如果将4指向3的父节点2（指向其父节点的父节点），会得到下图：\n\n<img src=\"并查集-Union-Find\\pathcompression2\"  />\n\n由于根节点指向自己，所以不会出现无效的情况，继续将p更新为`parent[p]`，得到下图：\n\n<img src=\"并查集-Union-Find\\pathcompression3\"  />\n\n这样一来，所有节点的路径都进行了压缩，查找的时间复杂度近乎是`O(1)`的。\n\n```cpp\n// 循环\nint find(int p){\n    assert(p >= 0 && p < count);\n    // 路径压缩\n    while(p != parent[p]){\n        parent[p] = parent[parent[p]];\n        p = parent[p];\n    }\n    return p;\n}\n// 递归\nint find(int p){\n    assert(p >= 0 && p < count);\n    if(p != parent[p])\n        parent[p] = find(parent[p]);\n    return parent[p];\n}\n```\n\n### 测试\n\n对每种并查集的工程执行100w次`union`操作和100w次`find`操作：\n\n<img src=\"并查集-Union-Find\\test\" style=\"zoom:80%;\" />\n\n区别还是很明显的。\n\n### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git","categories":["算法与数据结构"]},{"title":"快速排序(Quick sort)","url":"/blog/2020/08/15/快速排序-quick-sort/","content":"\n### 本次学习要点\n\n1. 快速排序基本实现及优化\n2. 双路快速排序\n3. 三路快速排序\n\n<!-- more-->\n\n### 快速排序\n\n#### 基本实现\n\n快速排序的基本思想很简单，对于`l`处的数`val`，与`j`处的数进行交换，使得坐标小于`j`的所有数都小于`val`，而位于`j`之后的数都应该大于`val`，如下图所示：\n\n<img src=\"快速排序-quick-sort\\1-1\" style=\"zoom:80%;\" />\n\n而实现这一操作的过程称为`partition`，具体过程如下：\n\n<img src=\"快速排序-quick-sort\\1-2\"  />\n\n1. 对于上图，`arr[l+1...j] < v`，`arr[j+1...i-1] > v`，当前位置`i`的值为`e`；\n\n* 如果`e > v`，将`e`放在`> v`后面，同时`i++`；\n\n* 如果`e < v`，将`i`处的值`e`与`j`下一个位置的值进行交换，然后`j++,i++`；\n\n  <img src=\"快速排序-quick-sort\\1-3\"  />\n\n  <img src=\"快速排序-quick-sort\\1-4\"  />\n\n2. 继续步骤1，会得到以下结果：\n\n<img src=\"快速排序-quick-sort\\1-5\"  />\n\n3. 此时满足`arr[l+1...j] < v`，`arr[j+1...i-1] > v`，再将`l`和`j`位置进行交换：\n\n<img src=\"快速排序-quick-sort\\1-6\"  />\n\n4. 重复步骤1-3，直到递归结束。\n\n代码如下：\n\n```cpp\n//\n// Created by Zxy on 2020/8/16.\n//\n#include <iostream>\n#include <cassert>\n#include <ctime>\n#include \"sortHelper.h\"\nusing namespace std;\n\n// 对arr[l...r]部分进行partition操作\n// 返回p，使arr[l...p-1] < arr[p]; arr[p+1...r] > arr[p]\ntemplate <typename T>\nint partition(T arr[], int l, int r){\n    T v = arr[l];\n    // arr[l+1...j] < v; arr[j+1...i) > v\n    // 初始状态时两个区间都为空\n    int j = l;\n    for(int i = l + 1; i <= r; ++i){\n        // 实际上当前值大于等于v时，将e都直接放在<v后面\n        if(arr[i] < v){\n            swap(arr[j + 1], arr[i]);\n            j++;\n        }\n    }\n    swap(arr[l], arr[j]);\n    return j;\n}\n\n// 对arr[l...r]部分进行快速排序\ntemplate <typename T>\nvoid __quickSort(T arr[], int l, int r){\n    if(l >= r) return;\n    int p = partition(arr, l, r);\n    __quickSort(arr, l, p - 1);\n    __quickSort(arr, p + 1, r);\n}\n\ntemplate <typename T>\nvoid quickSort(T arr[], int n){\n    __quickSort(arr, 0, n - 1);\n}\n\nint main(){\n    int *arr = generateRandomArray(10, 1, 50); // 产生10个1到50间的随机数\n    cout << \"排序前数组为：\" << endl;\n    printArray(arr, 10); // 打印数组\n    cout << endl;\n    quickSort(arr, 10);\n    cout << \"排序后数组为：\" << endl;\n    printArray(arr, 10);\n    cout << endl;\n    return 0;\n}\n```\n\n输出结果为：\n\n<img src=\"快速排序-quick-sort\\1-7\"  />\n\n#### 优化\n\n对于上述的快速排序算法有一个很大的缺点，如果数组近乎有序，复杂度可能退化至O(n^2)，大于`v`或者小于`v`的部分分配不均匀。比如对于数组`[3,1,1,2,2,2]`，经过第一次`partition`时，3放在了数组的末尾，左边5个数全部小于3，而右边没有大于3的数。\n\n对于这种情况，我们可以不取数组`l`处的值作为`v`，而是在数组中随机取一个值作为分界点`v`，然后再进行`partition`操作，此时快速排序复杂度的数学期望为O(nlogn)，具体的推导百度一下。修改如下：\n\n```cpp\ntemplate <typename T>\nint partition(T arr[], int l, int r){\n\t// 修改\n    swap(arr[rand() % (r - l + 1) + l], arr[l]);\n    T v = arr[l];\n    // arr[l+1...j] < v; arr[j+1...i) > v\n    // 初始状态时两个区间都为空\n    int j = l;\n    for(int i = l + 1; i <= r; ++i){\n        if(arr[i] < v){\n            swap(arr[j + 1], arr[i]);\n            j++;\n        }\n    }\n    swap(arr[l], arr[j]);\n    return j;\n}\n\ntemplate <typename T>\nvoid quickSort(T arr[], int n){\n\t// 修改\n    srand(time(NULL));\n    __quickSort(arr, 0, n - 1);\n}\n```\n\n直观的对比一下两种思路对完全随机数组和近乎有序数组的排序速度（其中`swap time`表示对于产生一个有序数组，随机取两个数进行交换，一共交换的次数）：\n\n<img src=\"快速排序-quick-sort\\1-8\"  />\n\n### 双路快速排序\n\n虽然解决了近乎有序数组的排序问题，但是对于数组中存在大量重复键值时，复杂度也可能退化为O(n^2)，如下图所示：\n\n<img src=\"快速排序-quick-sort\\2-1\"  />\n\n我们之前的`partition`操作中，当前值大于等于v时，将e都直接放在小于v最后一个的后面，所以可能出现上述情况。现在我们对于等于v时两边都可以进行收缩，使得`partition`操作更加均匀：\n\n<img src=\"快速排序-quick-sort\\2-2\"  />\n\n话不多说，看代码更容易理解：\n\n```cpp\ntemplate <typename T>\nint partition2(T arr[], int l, int r){\n    swap(arr[rand() % (r - l + 1) + l], arr[l]);\n    T v = arr[l];\n    // arr[l+1...i) <= v; arr(j...r] => v\n    // 初始状态时两个区间都为空\n    int i = l + 1, j = r;\n    while(1){\n        while(i <= r && arr[i] < v) i++;\n        while(j >= l + 1 && arr[j] > v) j--;\n        // 此时i指向第一个大于等于v的位置，j指向最后一个小于等于v的位置\n        if(i > j) break;\n        swap(arr[i], arr[j]);\n        i++;\n        j--;\n    }\n    swap(arr[l], arr[j]);\n    return j;\n}\ntemplate <typename T>\nvoid __quickSort2(T arr[], int l, int r){\n    if(l >= r) return;\n    int p = partition2(arr, l, r);\n    __quickSort2(arr, l, p - 1);\n    __quickSort2(arr, p + 1, r);\n}\ntemplate <typename T>\nvoid quickSort2(T arr[], int n){\n    __quickSort2(arr, 0, n - 1);\n}\n```\n\n<img src=\"快速排序-quick-sort\\2-3\"  />\n\n### 三路快速排序\n\n要给含有大量重复键值的数组排序同时避免对等于v的值进行交换，还可以进行三路的快速排序：\n\n<img src=\"快速排序-quick-sort\\3-1\"  />\n\n现在根据v将数组分为三个部分，分别是：`arr[l+1...lt] < v`，`arr[lt+1...i-1] == v`，`arr[gt...r] > v`。\n\n* 如果`e == v`，`i++`；\n* 如果`e < v`，将e和`lt+1`位置交换，同时`lt++，i++`；\n* 如果`e > v`，将e和`gt-1`位置交换，成为大于v的第一个位置，`gt--`；\n* 最后将`l`和`lt`位置交换，再对小于v部分和大于v部分继续排序。\n\n<img src=\"快速排序-quick-sort\\3-2\"  />\n\n<img src=\"快速排序-quick-sort\\3-3\"  />\n\n数组中`arr[l...lt-1] < v`，`arr[lt...gt-1] == v`，`arr[gt...r] > v`。\n\n代码如下：\n\n```cpp\ntemplate <typename T>\nvoid __quickSort3(T arr[], int l, int r){\n    if(l >= r) return;\n    swap(arr[l], arr[rand() % (r - l +1 ) + l]);\n    T v = arr[l];\n    int lt = l;     // arr[l+1...lt] < v\n    int gt = r + 1; // arr[gt...r] > v\n    int i = l + 1;    // arr[lt+1...i) == v\n    while(i < gt){\n        if(arr[i] < v){\n            swap(arr[i], arr[lt+1]);\n            i++;\n            lt++;\n        }\n        else if(arr[i] > v){\n            swap(arr[i], arr[gt-1]);\n            gt--;\n        }\n        else i++; // arr[i] == v\n    }\n    swap( arr[l] , arr[lt] );\n    __quickSort3(arr, l, lt-1);\n    __quickSort3(arr, gt, r);\n}\ntemplate <typename T>\nvoid quickSort3(T arr[], int n){\n    srand(time(NULL));\n    __quickSort3( arr, 0, n-1);\n}\n```\n\n<img src=\"快速排序-quick-sort\\3-4\"  />\n\n双路快速排序和三路快速排序都是在对近乎有序数组优化的基础上，对数组存在大量重复键值时进行优化，所以时间复杂度都是O(nlogn)。\n\n### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git","categories":["算法与数据结构"]},{"title":"C++11之lambda表达式","url":"/blog/2020/08/02/C-11之lambda表达式/","content":"\n学习C++11标准中的新特性——lambda表达式\n\n<!-- more-->\n\n### 向算法传递函数\n\n***\n\n如果需要sort按照自己定义的方式进行排序，需要使用其第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个**谓词**。\n\n***\n\n#### 谓词\n\n1. 定义：谓词是一个**可以调用的表达式**，返回的结果可以被调用\n2. 分类：一元谓词和二元谓词\n   1. 一元谓词：只接受单一的参数\n   2. 二元谓词：接受两个参数\n3. 接受谓词的算法对输入序列中的**元素**调用谓词，因此**元素**必须能转换为谓词的参数类型\n\n`sort`函数接受一个**二元谓词**，假如我们要按字符串的长度升序排序，可以定义一个比较函数`isShorter`：\n\n```cpp\n// 比较函数，用来按长度排序单词\n// 必须是引用类型！！！\nbool isShorter(const string &s1, const string &s2){\n    return s1.size() < s2.size();\n}\n// 按长度由短至长排序words\nsort(words.begin(), words.end(), isShorter);\n\n# words = {\"foxs\", \"jumps\", \"end\", \"kid\"}\n# 输出结果为end kid foxs jumps\n```\n\n***注：针对同一长度的单词，`sort`是不稳定的，如果要保持对应的字典序，可以调用`stable_sort`***\n\n### lambda表达式\n\n对于一个对象或者表达式，如果对其可以使用调用运算符`()`，则称它为可调用的，可以将其传入算法。一个`lambda`表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。\n\n---\n\n**与任何函数相似，一个`lambda`具有一个返回类型，一个参数列表和一个函数体**\n\n**不同的是，`lambda`可以定义在函数内部**\n\n---\n\n一个`lambda`表达式具有如下形式：\n\n```cpp\n[capture list] (parameter list) -> return type { function body }\n```\n\n* `[capture list]`（捕获列表）是一个`lambda`**所在函数中**定义的局部变量的列表（通常为空）\n* `return type`、`parameter list`和`function body`与普通函数一样，分别为返回类型，参数列表和函数体，但是`lambda`必须使用尾置返回\n\n我们可以忽略参数列表和返回类型，但必须永远包括捕获列表和函数体：\n\n```cpp\n// 我们定义了一个可调用对象f，它不接受参数，返回42\nauto f = [] { return 42; };\n```\n\n`lambda`的调用方式与普通函数相同，使用调用运算符：\n\n```cpp\n// 输出42\ncout << f() << endl;\n```\n\n在此例中，当调用`f`时，参数列表为空并且忽略了返回类型，`lambda`根据函数体代码确定返回类型，如果函数体只有一个`return`语句，则返回类型从返回表达式的类型推断而来，否则返回`void`。\n\n***注：如果函数体中包含任何单一`return`语句之外的内容，且未指定返回类型，返回`void`***\n\n#### 向lambda传递参数\n\n与一个普通函数调用类似，调用一个`lambda`给定实参被用来初始化`lambda`形参，类型需要匹配。但是`lambda`不能有默认参数（比如：`int fun(int a = 1, int b = 1) { return a + b; }`）。因此，一个`lambda`调用的实参数目永远和形参数目相等，一旦形参初始化完毕，就可以执行函数体了。\n\n我们可以写出来一个与`isShorter`功能完全一样的`lambda`函数：\n\n```cpp\n[] (const string &s1, const string &s2)\n\t{ return s1.size() < s2.size(); }\n```\n\n空捕获列表表示不使用函数中的局部变量，如下所示，之前的`sort`函数可以改写如下：\n\n```cpp\nsort(words.begin(), words.end(), \n\t[] (const string &s1, const string &s2)\n\t{ return s1.size() < s2.size(); });\n```\n\n#### 使用捕获列表\n\n假如我们现在要找到`words`中第一个长度大于`sz`的单词的位置，可以编写一个可以传递给`find_if`的可调用表达式。一个`lambda`表达式**只能使用明确指明的变量**，在下面的例子中，`lambda`会捕获`sz`，，并只有单一的`string`参数（因为`find_if`只支持一元谓词），其函数体会将`string`的大小与捕获的`sz`进行比较：\n\n```cpp\n[sz] (const string &s)\n{ return s.size() >= sz; };\n```\n\n##### 调用`find_if`函数\n\n使用此`lambda`，查到第一个长度大于等于给定`sz`元素\n\n```cpp\nauto wc = find_if(words.begin(), words.end(),\n     [sz] (const string &s)\n     { return s.size() >= sz; });\n// 输出满足size >= sz第一个元素的值和位置\n// 如果没有找到，返回words.end()的一个拷贝\n// 取sz = 4\ncout << \"value:\" << *wc << \"position:\" << wc - words.begin();\n# value:foxs    position:2\n```\n\n##### `for_each`算法\n\n打印出长度大于等于`sz`的所有单词：\n\n```cpp\nfor_each(wc, words.end(), [] (const string &s) { cout << s << \" \";});\n# foxs jumps\n```\n\n### lambda捕获和返回\n\n我们可以认为，当向一个函数传递一个`lambda`时，同时定义了一个新类型和该类型的对象，传递的参数就是此编译器生成的**类的类型**的**未命名对象**。\n\n**默认情况下，由`lambda`生成的类，数据成员包含捕获列表中的变量，在`lambda`对象创建时被初始化。**\n\n#### 值捕获（后面更改不会影响值）\n\n与参数传递不同之处在于，被捕获的变量的值在`lambda`创建时拷贝，而不是调用时拷贝\n\n```cpp\nsize_t v1 = 42; // 局部变量\nauto f = [v1] { return v1; };\nv1 = 0;\nauto j = f();\n# j为42；f保存我们创建它时的拷贝，因此修改v1不会影响lambda内对应的值\n```\n\n#### 引用捕获（后面更改会影响变量值）\n\n```cpp\nsize_t v2 = 42; // 局部变量\nauto f2 = [&v2] { return v2; };\nv2 = 0;\nauto jj = f2();\n# jj为0；f2保存v1的引用\n# 需要注意的是必须确保被引用的对象在lambda执行的时候是存在的\n# 如果可能的话，避免捕获指针或引用（C++ Primer 351页）\n```\n\n#### 隐式捕获\n\n我们可以让编译器根据`lambda`函数体中的代码来推断我们要使用哪些变量，在捕获列表中写一个`&`表示捕获引用，`=`表示采用值捕获方式，我们可以重写`find_if`函数\n\n```cpp\n// sz为隐式值捕获\nauto wc = find_if(words.begin(), words.end(),\n     [=] (const string &s)\n     { return s.size() >= sz; });\n```\n\n如果想对一部分变量使用值捕获，一部分使用引用捕获，可以混合使用隐式捕获和显示捕获：\n\n```cpp\nostream &os = cout;\nchar c = ' ';\n// os隐式引用捕获，c显示值捕获\nfor_each(wc, words.end(), [&, c] (const string &s) { os << s << c;});\n// os显示引用捕获，c隐式值捕获\nfor_each(wc, words.end(), [=, &os] (const string &s) { os << s << c;});\n```\n\n1. **当我们使用混合捕获时，捕获列表第一个变量必须是一个&或者=，定义了默认捕获方式为引用或值。**\n2. **混合捕获时，显示捕获的变量必须使用与隐式捕获不同的方式，即：显示引用捕获，隐式值捕获或者显示值捕获，隐式引用捕获。**\n\n#### 指定lambda返回类型\n\n标准库函数`transform`：接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中的每个元素调用可调用对象，并将结果写到目的位置：\n\n```cpp\n// 取绝对值\nvector<int> vv1{-1, 1, 3, -20, 7};\ntransform(vv1.begin(), vv1.end(), vv1.begin(),\n          [] (int i) { return i < 0 ? -i : i; });\n# 1,1,3,20,7\n```\n\n如果写成以下形式就会产生编译错误：\n\n```cpp\ntransform(vv1.begin(), vv1.end(), vv1.begin(),\n          [] (int i) { if (i < 0) return -i; else return i; });\n```\n\n这是因为函数体中不止一个`return`语句，`lambda`无法判断返回类型。如果我们需要为其定义返回类型，必须用尾置的方式：\n\n```cpp\ntransform(vv1.begin(), vv1.end(), vv1.begin(),\n          [] (int i) -> int { if (i < 0) return -i; else return i; });\n```\n\n### 参数绑定\n\n---\n\n对于只在一两个地方使用的函数，使用`lambda`是很方便的，多次使用或者函数体比较长的话定义一个函数来实现更好。但是对于捕获局部变量的`lambda`表达式来说，用函数代替就不太容易了。\n\n---\n\n在之前的`find_if`函数中，我们可以容易写出来一个相同功能的函数：\n\n```cpp\nbool check_size(const string &s, string::size_type sz){\n\treturn s.size() >= sz;\n}\n```\n\n但是`find_if`函数只支持一元谓词，直接使用肯定是不可以的。\n\n#### 标准库bind函数\n\n使用`bind`函数可以解决上述问题，此函数定义在头文件`functional`中，可以将`bind`函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。\n\n调用形式为：\n\n```cpp\nauto newCallable = bind(callable, arg_list)\n```\n\n* `newCallable`本身是一个可调用对象\n* `arg_list`是一个逗号分隔的参数列表，对应给定`callable`的参数\n\n当我们调用`newCallable`时，`newCallable`会调用`callable`，并传递给它`arg_list`中的参数。\n\n`arg_list`中的参数可能包含形如`_n`的名字，其中`n`是一个整数，称为**占位符**，表示占据了传递给`newCallable`参数的位置。\n\n##### 绑定`check_size`的`sz`参数\n\n一个简单的例子，使用`bind`生成一个调用`check_size`的对象：\n\n```cpp\n// check4是一个可调用对象，接受一个string类型的参数\n// 使用此string和值4调用check_size\n// 注意要使用using std::placeholder::_1或using namespace std::placeholders\nauto check4 = bind(check_size, _1, 4);\n# 此bind调用只有一个占位符，表示check4只接受单一参数\n# 占位符在arg_list的第一个位置，表示check4的此参数对应check_size的第一个参数，是const string&\n# 因此调用check4必须传递给它一个string类型的参数，check4将其传给check_size\n```\n\n```cpp\nstring s = \"hello\";\nbool b1 = check4(s);\ncout << b1 << endl;\n# 1\n```\n\n此时我们可以改写`find_if`函数：\n\n```cpp\nauto wcc = find_if(words.begin(), words.end(),\n     \tbind(check_size, _1, sz));\nfor_each(wcc, words.end(), [] (const string &s) { cout << s << \" \";});\n# foxs jumps\n// 对比之前的find_if\nauto wc = find_if(words.begin(), words.end(),\n     [sz] (const string &s)\n     { return s.size() >= sz; });\n```\n\n### Reference\n\n《C++ Primer》370-383","tags":["lambda"],"categories":["C++"]},{"title":"LeetCode63-不同路径Ⅱ","url":"/blog/2020/07/26/LeetCode63-不同路径Ⅱ/","content":"\n本题与[**97交错字符串**](http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more)，[**174-地下城游戏**](https://leetcode-cn.com/problems/dungeon-game/)分析与解法相似\n\n### 题目描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n<!-- more-->\n\n<img src=\"LeetCode63-不同路径Ⅱ\\question\" style=\"zoom:80%;\" />\n\n<img src=\"LeetCode63-不同路径Ⅱ\\question1\" style=\"zoom:;\" />\n\n### 分析\n\n对于输入为二维数组的题目中出现了只能向下或者向右移动的字眼，一般来说考虑动态规划。这道题的不同之处是设置了障碍物，如果遇到了1则表示**不可达**，假如`m = 2, n = 2`，并且无障碍物，我们可以得到下图：\n\n<img src=\"LeetCode63-不同路径Ⅱ\\solution1\" style=\"zoom:80%;\" />\n\n那么对于`(0,1)`和`(1,0)`位置，都只有一条通路可达：\n\n<img src=\"LeetCode63-不同路径Ⅱ\\solution2\" style=\"zoom:80%;\" />\n\n最后对于末尾处`(1,1)`，它的上边和左边可以到达，所以到达它的路径为`1 + 1 = 2`条：\n\n<img src=\"LeetCode63-不同路径Ⅱ\\solution3\" style=\"zoom:80%;\" />\n\n通过观察我们发现，在不遮挡的情况下，可以到达当前位置的路径数就是当前位置的上边和左边路径数的总和。\n\n对于存在障碍物的情况，我们直接令到达它的路径数为0，这样也就满足的题目的要求。\n\n#### 定义dp数组\n\n根据上述分析，`dp[i][j]`表示有多少条路径可以到达`(i,j)`，如果网格中此处值为1，也就是有障碍的情况下，`dp[i][j] = 0`。表示无法到达，路径数为0。\n\n#### 初始化\n\n在**交错字符串**中使用的是从前往后遍历的思想，这里换一种思路，从后往前进行遍历。对于最后一个位置`dp[m-1][n-1]`，如果第`m - 1`行或者`n - 1`列其他位置可以到达最后位置，则为1，否则为0，只要在网格中往回走遇到了1，在那之后`dp`数组的值都为0。\n\n```cpp\nlong long dp[m][n];\nfor(int i = 0; i < m; ++i){\n\tfor(int j = 0; j < n; ++j)\n\t\tdp[i][j] = 0;\n}\n// 最后一行到end初始化为1\n// 注意有有一个为1，后面都被阻挡\nfor(int j = n - 1; j >= 0 && obstacleGrid[m - 1][j] == 0; --j){\n\tdp[m - 1][j] = 1; \n}\n// 最后一列到end初始化为1\nfor(int i = m - 1; i >= 0 && obstacleGrid[i][n - 1] == 0; --i){\n\tdp[i][n - 1] = 1;\n}\n```\n\n#### 状态转移方程\n\n```cpp\nif(obstacleGrid[i][j] == 0)\n    dp[i][j] = dp[i+1][j] + dp[i][j+1];\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        // 从后往前必须long long\n        long long dp[m][n];\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j)\n                dp[i][j] = 0;\n        }\n        // 最后一行到end初始化为1\n        // 注意有有一个为1，后面都被阻挡\n        for(int j = n - 1; j >= 0 && obstacleGrid[m - 1][j] == 0; --j){\n                dp[m - 1][j] = 1; \n        }\n        // 最后一列到end初始化为1\n        for(int i = m - 1; i >= 0 && obstacleGrid[i][n - 1] == 0; --i){\n                dp[i][n - 1] = 1;\n        }\n        for(int i = m - 2; i >= 0; --i){\n            for(int j = n - 2; j >= 0; --j){\n                if(obstacleGrid[i][j] == 0)\n                {\n                    dp[i][j] = dp[i + 1][j] + dp[i][j + 1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/unique-paths-ii/solution/jian-dan-dpbi-xu-miao-dong-by-sweetiee/","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode97-交错字符串","url":"/blog/2020/07/18/LeetCode97-交错字符串/","content":"\n在看了题解之后才慢慢意识到，这道题和[**63-不同路径Ⅱ**](https://leetcode-cn.com/problems/unique-paths-ii/)，[**174-地下城游戏**](https://leetcode-cn.com/problems/dungeon-game/)是非常相似的，题目虽然具有一定难度，但都是有迹可循。它们都可以抽象为在二维数组中，从起始到末尾找路径的问题。上面两个问题还未更新，跳转位置是题目链接。\n\n### 题目描述\n\n给定三个字符串 *s1*, *s2*, *s3*, 验证 *s3* 是否是由 *s1* 和 *s2* 交错组成的。\n\n<!-- more-->\n\n<img src=\"LeetCode97-交错字符串\\question1\"  />\n\n### 分析\n\n交错的意思是：如果第一次取了`s1`，那么第二次必须取`s2`，反之亦然。取多少和哪一个先取都是不一定的，只是要求交错即可。\n\n对于`s1 = \"bacc\", s2 = \"aabcce\", s3 = \"abaacbccec\"`，这个示例是可以匹配的，按照**可以匹配**的过程分析如下：\n\n1. 首先只能取`s2`中的`a`，再继续往下取`a`时，与`s3`已经无法匹配了；\n2. **再取`s1`中的`b`或者`ba`都是可以的**，这里取`b`\n3. 再取`s2`中的`a`，此时匹配到`aba`\n4. 再取`s1`中的`ac`，此时匹配到`abaac`\n5. 再取`s2`中的`bcce`，此时匹配到`abaacbbe`\n6. 再取`s1`中的`c`，此时完全匹配\n\n#### 定义dp数组\n\n`dp[i][j]`表示`s1`的前`i`个字符和`s2`的前`j`个字符是否匹配，我们可以将刚才的分析表示为下图：\n\n<img src=\"LeetCode97-交错字符串\\question1_dp\" style=\"zoom:80%;\" />\n\n上图是不是很像一个路径问题，而且只能向右或者向下移动，进一步说明是用动态规划来解决，如果还可以往上或者左，那就不能用动态规划来做了，得考虑`dfs`之类的算法。\n\n分析中的第二步，也就是图中`true`的其他可能。\n\n#### 初始化\n\n```cpp\n// 都为空时匹配\ndp[0][0] = 1\n// 对于第一行和第一列，当前值若无法匹配，则当前值和之后的都无法匹配\nif(i == 0) dp[0][j] = s2[0,j) == s3[0,j)\nif(j == 0) dp[i][0] = s2[0,i) == s3[0,i)\n```\n\n#### 状态转移方程\n\n```cpp\ndp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1])\n\t|| (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1])\n```\n\n### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        int m = s1.size(), n = s2.size();\n        if(m + n != s3.size()) return false;\n        // bool dp[m + 1][n + 1] = {false};\n        bool **dp = new bool*[m + 1];\n        for(int i = 0; i <= m; ++i){\n            dp[i] = new bool[n + 1];\n        }\n        for(int i = 0; i <= m; ++i){\n            for(int j = 0; j <= n; ++j){\n                dp[i][j] = 0;\n            }\n        }\n        // 初始化\n        dp[0][0] = true;\n        for(int j = 1; j <= n && (s2.substr(0, j) == s3.substr(0, j)); ++j) \n            dp[0][j] = true;\n        for(int i = 1; i <= m && (s1.substr(0, i) == s3.substr(0, i)); ++i) \n            dp[i][0] = true;\n        \n        for(int i = 1; i <= m; ++i){\n            for(int j = 1; j <= n; ++j){\n                dp[i][j] = (dp[i - 1][j] && (s1[i - 1] == s3[i + j - 1])) ||\n                            (dp[i][j - 1] && (s2[j - 1] == s3[i + j - 1]));\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/","tags":["动态规划"],"categories":["LeetCode"]},{"title":"Verilog基础2","url":"/blog/2020/07/14/Verilog基础2/","content":"\n## Verilog基础\n\n学习verilog基础语法2\n\n<!-- more-->\n\n### 第五章 FPGA基本实践\n\n#### 流水灯实践\n\n```verilog\nmodule v1(\n    input clk,\t\t\t// 时钟输入\n    input rst,\t\t\t// 复位信号\n    output [7:0] led\t// LED输出\n    );\nreg [7:0] ledtemp = 8'b0000_0001;\t// led初始值\nreg [23:0] divclk_cnt = 0;\t\t\t// 24位计数值\nreg divclk = 0;\t\t\t\t\t\t// 低频时钟\nassign led = ledtemp;\t// 实现将寄存器变量值赋给LED输出\n\tparameter halfduty_cntvalue = 12500000;\nalways @ ( posedge clk )\t\t\t// 把系统时钟分频50Mhz/25000000 = 2Hz\nbegin\n\tif( divclk_cnt == halfduty_cntvalue)\t// 计数满后翻转\n\t\tbegin\n\t\t\tdivclk = ~divclk;\n\t\t\tdivclk_cnt = 0;\n\t\tend\n\t\telse begin\n\t\t\tdivclk_cnt = divclk_cnt + 1'b1;\n\t\tend\n\tend\nalways @ ( posedge divclk )\nbegin\n\tif( !rst )\n\t\tbegin\n\t\t\tledtemp = 8'b0000_0001;\n\t\tend\n\telse if ( ledtemp[7] == 1 )\n\t\tledtemp = 8'b0000_0001;\t\t// 瀹炵幇寰幆绉讳綅\n\telse\n\t\tledtemp = ledtemp << 1;\nend\n\nendmodule\n```\n\n仿真代码：\n\n```verilog\nmodule sim3;\nreg clk;\nreg rst;\nwire led;\n\nv1 uut( clk, rst, led );\ninitial begin\n    clk = 0;\n    rst = 1;\nend\nalways #10 clk = ~clk; // 每隔10ns反转，周期是20ns，频率也就是50MHz\nendmodule\n```\n\n仿真图如下：\n\n<img src=\"Verilog基础2\\image1\"  />\n\n从**ledtemp**可以看出进行了左移的操作\n\n<img src=\"Verilog基础2\\image2\"  />\n\n完成一次循环之后回到**00000001**","categories":["FPGA"]},{"title":"Verilog基础1","url":"/blog/2020/07/14/Verilog基础1/","content":"\n## Verilog基础\n\n学习verilog基础语法1\n\n<!-- more-->\n\n## 第二章 基本语法\n\n#### 数据类型及变量\n\n查找表**LUT**\n\n1. 线网型变量wire\n   1. 信号间连接作用，只能将其连接到某处而不能进行赋值\n   2. 没有时序限定，与其它块语句并行执行\n   3. 不保存状态，值随时可以改变，不受时钟信号限制\n   4. input和output默认位wire\n   5. wire是组合逻辑的赋值，在时序控制always**块外**并使用**assign**进行赋值\n2. 寄存器类型reg\n   1. 值可以改变\n   2. 常用来表示时序控制always块内的指定信号\n3. 符号常量parameter\n\n#### 语句\n\n1. 连续赋值语句**assign**\n\n   assign语句用于对wire型变量赋值，例如`assign c = a & b`，a，b是wire型变量或寄存器变量，c必须是wire型变量或其他线网型变量。\n\n2. 过程赋值语句**`=`和`<=`**\n\n   1. 用于对reg型变量赋值，在过程块中使用过程赋值语句\n   2. 非阻塞(`<=`)：多条非阻塞赋值在过程块中同时完成赋值操作，多条语句相当于同时执行\n   3. 阻塞(`=`)：在一个块语句中，如果有多条阻塞赋值语句，在前面的赋值语句没有完成之前，后面的语句就不能执行`=`\n   4. 对于阻塞，在当前时钟就赋值了，而非阻塞是在下一个时钟进行赋值\n\n3. 过程说明语句**always**\n\n   1. always块包含一个或一个以上的语句（如：过程赋值语句、条件语句和循环语句等），在运行的过程中，在时钟控制下被反复执行，也就是说，时钟有效边沿来了就执行\n   2. 在always块中被赋值的只能是寄存器reg型变量\n   3. 书写方法：`always @ (敏感信号表达式)`\n\n   ```verilog\n   always @ (clk) // 只要clk发生变化就触发\n   always @ (posedge clk) // clk上升沿触发\n   always @ (negedge clk) // clk下降沿触发\n   always @ (negedge clk1 or posedge clk2) // clk1下降沿或者clk2上升沿触发\n   always @ (*) // 任何输入信号变化了都触发\n   ```\n\n\n4. 结构说明语句initial\n\ninitial语句用于对寄存器变量赋予初值\n\n5. 条件语句**if-else**\n\n6. 条件语句**case**\n\n   ```\n   case(表达式)\t<case分支项>\tendcase\n   case 分支项的一般格式：\n   分支表达式：语句；\n   默认项(default)  语句；\n   ```\n\n7. 循环语句\n\n   1. **forever**语句：连续执行的语句\n\n   ```\n   格式: forever begin 语句块 end\n   forever常用于仿真代码中\n   ```\n\n   2. **repeat**\n   3. **while**\n   4. **for** 尽量少用，循环次数固定\n\n## 第三章 组合逻辑电路\n\n#### 多数表决器的实现\n\n1. **逻辑表达式**：`f = a&b|a&c|b&C`\n2. **RTL分析**：在左侧的流程导航器`Flow Navigator`中的详细设计`Elaborated Design` 部分按右键，在弹出的菜单中选`New Elaborated Design`之后得到RTL电路图（RTL意思是寄存器传输级，生成寄存器传输级别的电路，并非综合后的电路），在开发过程中RTL分析不是必须的，但是能帮助我们检测错误。\n3. **综合**：将RTL级别的设计描述转换成逻辑门级的逻辑描述。单击流程导航窗口综合`Synthesis`项下的`Run Synthesis`进入综合，综合完毕后点击`Schematic`打开原理图。\n\n4. **仿真**：新建仿真文件，然后编辑内容，再点击`Run Simulation`\n5. **编程和调试**：首先生成比特流，然后再进行硬件调试\n\n#### **3-8译码器设计和IP核**\n\n1. 译码器设计步骤与多数表决器相同，也是组合逻辑电路\n2. **IP核**：点击顶部的**Tools**，然后点击**Create and Package IP**项，之后一直**Next**，进入以下页面：\n\n<img src=\"Verilog基础1\\image1\" style=\"zoom:80%;\" />\n\n没什么问题后点击**Review and Package**中的**Package IP**\n\n#### 调用IP核实现多数表决器\n\n## 第四章 时序逻辑电路\n\n时钟同步状态机：时序电路的状态变化发生的时间有一个统一的时钟信号的指定边沿来激励。\n\n#### 实现11001序列发生器\n\n1. 画出状态转移图\n\n<img src=\"Verilog基础1\\image2\"  />\n\n2. 画出状态转移表\n\n| Q0 Q1 Q2 | Q0* Q1* Q2* |  Z   |\n| :------: | :---------: | :--: |\n|   000    |     001     |  1   |\n|   001    |     010     |  1   |\n|   010    |     011     |  0   |\n|   011    |     100     |  0   |\n|   100    |     000     |  1   |\n\n3. 根据状态转移表画卡诺图求解。（未使用的状态用无关项表示）\n\n| Q2/Q0Q1 |  00   |  01   |  11   |  10   |\n| :-----: | :---: | :---: | :---: | :---: |\n|    0    | 001/1 | 011/0 | ddd/d | 000/1 |\n|    1    | 010/1 | 100/0 | ddd/d | ddd/d |\n\n4. 得到转移方程和输出方程\n\n   1. 转移方程：\n      $$\n      Q0* = Q1Q2\\\\\n      Q1* = Q1'Q2 + Q1Q2'\\\\\n      Q2* = Q0'Q2'\n      $$\n\n   2. 输出方程\n\n   $$\n   Z = Q1'\n   $$\n\n5. 判断自启动，FPGA设计可以给出初始态，所以可以忽略\n\n6. 使用D触发器，写出激励方程\n   $$\n   D0 = Q0* = Q1Q2\\\\\n   D1 = Q1* = Q1'Q2 + Q1Q2'\\\\\n   D2 = Q2* = Q0'Q2'\n   $$\n\n7. 建立工程编写程序\n\n```verilog\nmodule seq_11001_1(\n\tinput  clk,\n\toutput led\n    );\nreg [5:0] divclk_cnt = 0;\nreg divclk = 0;\nreg q0 = 0;\nreg q1 = 0;\nreg q2 = 0;\nalways @ ( posedge clk )\nbegin\n\tif(divclk_cnt == 25) // 50分频 25低25高 默认32位宽\n\tbegin\n\t\tdivclk = ~divclk;\n\t\tdivclk_cnt = 0;\t\t\n\tend\n\telse begin\n\t\tdivclk_cnt = divclk_cnt + 1'b1;\n\tend\nend\n\nassign led = ~q1;\nalways @ (posedge divclk)\nbegin\n\tq0 <= q1&q2;\n\tq1 <= ~q1&q2|q1&~q2;\n\tq2 <= ~q0&~q2;\nend\t\nendmodule\n```\n\n仿真文件：\n\n```verilog\nmodule sim1;\nreg clk;\nwire led;\nseq_11001_1 uut( clk, led );\ninitial begin\n    clk = 0;\nend\nalways #10 clk = ~clk;\nendmodule\n```\n\n8. 仿真\n\n<img src=\"Verilog基础1\\image3\"  />\n\n从图可知，和状态转移表一致\n\n#### 状态图直接描述法实现序列发生器\n\n根据上部分**1**中的状态转移图可以直接实现**11001**序列发生器，实现代码如下：\n\n```verilog\nmodule seq_11001_2(\n    input clk,\n    output led\n    );\nreg led;\nreg [31:0] divclk_cnt = 0;\nreg divclk = 0;\nreg [2:0] state = state_A;\nparameter // 符号常量\nstate_A = 3'b000,state_B = 3'b001,state_C = 3'b010,state_D = 3'b011,state_E = 3'b100;\nalways @ ( posedge clk )\nbegin\n\tif(divclk_cnt == 25)\n\tbegin\n\t\tdivclk = ~divclk;\n\t\tdivclk_cnt = 0;\n\tend\n\telse begin\n\t\tdivclk_cnt = divclk_cnt + 1;\n\tend\nend\nalways @ ( posedge divclk )\nbegin\n\tcase( state )\n\t\tstate_A:begin\n\t\t\tstate <= state_B;\n\t\t\tled <= 1;\n\t\tend\n\t\tstate_B:begin\n\t\t\tstate <= state_C;\n\t\t\tled <= 1;\n\t\tend\n\t\tstate_C:begin\n\t\t\tstate <= state_D;\n\t\t\tled <= 0;\n\t\tend\n\t\tstate_D:begin\n\t\t\tstate <= state_E;\n\t\t\tled <= 0;\n\t\tend\n\t\tstate_E:begin\n\t\t\tstate <= state_A;\n\t\t\tled <= 1;\n\t\tend\n        // 表示当前状态不属于以上状态，让状态回到state_A\n\t\tdefault:begin\n\t\t\tstate <= state_A;\n\t\t\tled <= 1;\n\t\tend\n\tendcase\nend\n\nendmodule\n```\n\n仿真图如下：\n\n<img src=\"Verilog基础1\\image4\"  />\n\n当`state = 000`时，在`divclk`的下一个上升沿时`led = 1`，以此类推\n\n","categories":["FPGA"]},{"title":"LeetCode718-最长重复子数组","url":"/blog/2020/07/03/LeetCode718-最长重复子数组/","content":"\n### 题目描述\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n<!-- more-->\n\n<img src=\"LeetCode718-最长重复子数组\\示例.png\" style=\"zoom: 80%;\" />\n\n### 分析\n\n题目的意思很好理解，如示例所示，公共的子数组除了单一的数值`[1],[2],[3]`，也有`[2,1],[3,2,1]`这些数组，其中最长的就是`[3,2,1]`这个数组，长度为3。像题目出现**最长，最短**之类的字都可以考虑用动态规划去解决。\n\n#### 一、定义dp数组的含义\n\n数组A长5，数组B长5，我们假设存在一个`6×6`的`dp`矩阵，使得矩阵坐标从1开始，同时保证边界位置上的计算，并初始化所有值为0。**矩阵表示固定A的值时，到B数组的当前值与到A固定值的公共数组长度**：\n\n<img src=\"LeetCode718-最长重复子数组\\index.png\"  />\n\n我们固定A数组，然后去遍历B数组。假如`A[i]=B[j]`时，公共数组的长度在上一次长度的基础上+1，否则不变，在后续分析中可以看到。\n\n比如说`A[0]=1`，此时遍历B数组，`B[0]=3`，两个值不等。因为我们建立数组时候起始坐标是从1开始的，所以`dp[1][1] = 0`。继续遍历B数组，可以得到以下结果：\n\n```\ndp[1][2] = 0\ndp[1][3] = 1\ndp[1][4] = 0\ndp[1][5] = 0\n```\n\n<img src=\"LeetCode718-最长重复子数组\\index1.png\"  />\n\n接下来改变A值，`A[1]=2`，可以得到：\n\n```\ndp[2][1] = 0\ndp[2][2] = 1\ndp[2][3] = 0\ndp[2][4] = 0\ndp[2][5] = 0\n```\n\n<img src=\"LeetCode718-最长重复子数组\\index2.png\"  />\n\n同理`A[2]=3`：\n\n<img src=\"LeetCode718-最长重复子数组\\index3.png\"  />\n\n当`A[3]=2,B[1]=2`时，此时满足`value(A)==value(B)`，所以`dp[4][2] = dp[3][1] + 1 = 2 `，如图：\n\n<img src=\"LeetCode718-最长重复子数组\\index4.png\"  />\n\n当`A[4]=1,B[2]=1`时，此时满足`value(A)==value(B)`，所以`dp[5][3] = dp[4][2] + 1 = 3`，如图：\n\n<img src=\"LeetCode718-最长重复子数组\\index5.png\"  />\n\n遍历完一次B数组后更新最大长度，所以最后最大的公共数组长度就是3。\n\n#### 二、状态转移方程\n\n根据上述分析，可以得到：\n\n```cpp\nif(A[i-1] == B[j-1])\n    dp[i][j] = dp[i-1][j-1] + 1;\n```\n\n#### 三、代码实现\n\n```cpp\nclass Solution {\npublic:\n    int findLength(vector<int>& A, vector<int>& B) {\n        int res = 0;\n        int **dp = new int*[A.size()+1];\n        for(int i = 0; i < A.size() + 1; i++){\n            dp[i] = new int[B.size()+1];\n        }\n        for(int i = 0; i < A.size() + 1; i++){\n            for(int j = 0; j < B.size() + 1; j++){\n                dp[i][j] = 0;\n            }\n        }\n        // 从前往后\n        for(int i = 1; i <= A.size(); i++){\n            for(int j = 1; j <= B.size(); j++){\n                if(A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\n                res = max(res, dp[i][j]);\n            }\n        }\n        return res;\n    }\n};\n```\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"堆排序(heap sort)","url":"/blog/2020/06/27/堆排序-heap-sort/","content":"\n堆排序是一种特殊的排序算法，涉及到了优先级的概念\n\n更新于2020/7/12\n\n### 本次学习要点\n\n1. 了解优先队列的一些概念\n2. 堆排序概念及实现\n\n<!-- more-->\n\n### 优先队列\n\n* 普通队列：FIFO\n* 优先队列：出队顺序与入队无关，与优先级有关\n\n为什么选择优先队列？\n\n比如：在10000000个元素中选择前100名？(在N个元素中选择前M个)\n\n* 排序算法复杂度 O(NlogN)\n* 优先队列 O(NlogM)\n\n优先队列的实现方法：\n\n<img src=\"D:堆排序-heap-sort\\实现方式.png\" style=\"zoom:80%;\" />\n\n使用普通数组在出队时需要遍历一次找到优先级最高的元素；顺序数组在每次插入的时候也要遍历一次找到相应的位置；使用堆这种结构可以让入队出队复杂度都为O(logN)。\n\n### 堆的基本实现\n\n#### 二叉堆(Binary Heap)\n\n二叉堆类似于二叉树，是一种树状结构，可以用数组来存储二叉堆，以最大堆为例。\n\n最大堆：\n\n* **堆中的某个节点值不大于其父亲节点(不意味着层数越高，数值越大)**\n* **堆总是一棵完全二叉树(这也是可以用数组表示的原因)**\n\n<img src=\"堆排序-heap-sort\\二叉堆1.png\" style=\"zoom:80%;\" />\n\n给每个节点按照从上到小，从左到右进行编号，可以有以下的性质：\n\n* **左节点的序号是父节点的二倍**\n* **右边序号为父节点的二倍加1**\n\n<img src=\"堆排序-heap-sort\\二叉堆2.png\" style=\"zoom:80%;\" />\n\n用1来做起始标号是经典实现办法，数组对应的标号就是节点的索引：\n\n<img src=\"堆排序-heap-sort\\数组1.png\"  />\n\n```cpp\n# 找到i的父节点序号\nparent[i] = i / 2\n# i节点的孩子节点序号\nleftChild[i] = 2 * i\nrightChild[i] = 2 * i + 1\n```\n\n构建堆的基本结构：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\npublic:\n    MaxHeap(int capacity){\n        data = new Item[capacity+1];\n        count = 0;\n    }\n    ~MaxHeap(){\n        delete[] data;\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count == 0;\n    }\n};\n```\n\n#### 添加元素(Shift Up)\n\n由于是用数组实现的堆，所以添加一个新的元素相当于在数组的末尾添加了一个元素：\n\n<img src=\"堆排序-heap-sort\\数组2.png\"  />\n\n相应的树形结构如下：\n\n<img src=\"堆排序-heap-sort\\shiftup1.png\" style=\"zoom:80%;\" />\n\n显然此时不符合最大堆的定义，新加入的52大于其父节点16，所以两个需要交换位置，以此类推，将52放在合适的位置，如下图所示：\n\n<img src=\"堆排序-heap-sort\\shiftup2.png\" style=\"zoom: 67%;\" />\n\n最终数组里的值为下图：\n\n<img src=\"堆排序-heap-sort\\数组3.png\"  />\n\n**Shift Up**代码实现(在基本结构基础上)：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\n    int capacity;\n    void shiftUp(int k){\n        // 孩子节点大于父节点需要交换，并更新节点位置\n        while( k > 1 && data[k/2] < data[k] ){\n            swap( data[k/2], data[k] );\n            k /= 2;\n        }\n    }\npublic:\n    MaxHeap(int capacity){\n        data = new Item[capacity+1];\n        count = 0;\n        this->capacity = capacity;\n    }\n    void insert(Item item){\n        assert( count + 1 <= capacity );\n        //添加新元素\n        data[count+1] = item;\n        count ++;\n        shiftUp(count);\n    }\n```\n\n#### 取出元素(Shift Down)\n\n对于堆来说，每次只能取根节点的那个元素，在这里就是取最大的元素。\n\n取出最大的元素后，根节点的位置就空出来了，这时候把最后一个元素补充到根节点处(保证仍然是一棵完全二叉树)，此时作为计数的变量`count--`，最后一个数组中的元素可以不动，使用`count`来卡住边界。\n\n<img src=\"堆排序-heap-sort\\shiftdown1.png\" style=\"zoom:80%;\" />\n\n此时数组中的元素为：\n\n<img src=\"堆排序-heap-sort\\数组4.png\"  />\n\n此时16也不满足最大堆的定义，接下来要调整这些元素的位置。将16一步一步的向下挪，直到合适的位置，所以叫**Shift Down**，不过每次下挪，有两个方向可以走，具体怎么选？**需要找到子节点中更大的那个值进行交换**，这样就可以保证子节点一定是不大于父节点的，过程如下：\n\n<img src=\"堆排序-heap-sort\\shiftdown2.png\" style=\"zoom:80%;\" />\n\n此时数组中的元素为：\n\n<img src=\"堆排序-heap-sort\\数组5\"  />\n\n**Shift Down**代码实现(在基本结构基础上)：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\n    int capacity;\n    void shiftDown(int k){\n        // 判断k是否有孩子\n        // 对于完全二叉树，有左孩子就代表一定有孩子\n        while( 2*k <= count ){\n            int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置\n            // j+1为右孩子，需要判断是否存在\n            // 再判断应该和哪个孩子交换\n            if( j+1 <= count && data[j+1] > data[j] ) // 右孩子大\n                j ++; // j代表右孩子，否则为左孩子\n            // data[j] 是 data[2*k]和data[2*k+1]中的最大值\n            if( data[k] >= data[j] ) break;\n            swap( data[k] , data[j] );\n            k = j; // 交换后的新节点，继续Shift Down\n        }\n    } \npublic:\n    Item extractMax(){\n        assert( count > 0 );\n        Item ret = data[1];\n\n        swap( data[1] , data[count] );\n        count --;\n        shiftDown(1);\n\n        return ret;\n    }\n    Item getMax(){\n        assert( count > 0 );\n        return data[1];\n    }\n};\n```\n\n#### Heapify(将普通数组变为堆)\n\n<img src=\"堆排序-heap-sort\\数组6.png\"  />\n\n对于以上数组，可以直接构建成堆，不用先进行插入元素，二叉树形式为下图：\n\n<img src=\"堆排序-heap-sort\\heapify1.png\" style=\"zoom:80%;\" />\n\n对于上图的树来说，所有的叶子节点都是一个最大堆：\n\n<img src=\"堆排序-heap-sort\\heapify2\" style=\"zoom:80%;\" />\n\n第一个非叶子节点的位置为`count/2`，即`10/2=5`，对于每个非叶子节点进行**Shift Down**操作。\n\n<img src=\"堆排序-heap-sort\\heapify3\" style=\"zoom: 67%;\" />\n\n**Heapify**代码实现：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\n    int capacity;\n    void shiftDown(int k){\n        // 判断k是否有孩子\n        // 对于完全二叉树，有左孩子就代表一定有孩子\n        while( 2*k <= count ){\n            int j = 2*k; \n            // 在此轮循环中,data[k]和data[j]交换位置\n            // j+1为右孩子，需要判断是否存在\n            // 再找到值更大的孩子\n            if( j+1 <= count && data[j+1] > data[j] ) \n                j ++;\n            // 如果孩子中最大值小于等于父节点的值，就不用交换了\n            if( data[k] >= data[j] ) break;\n            swap( data[k] , data[j] );\n            // 交换后的新节点，继续Shift Down\n            k = j; \n        }\n    } \npublic:\n    // 根据数组直接构造最大堆\n    MaxHeap(Item arr[], int n){\n        data = new Item[n+1];\n        capacity = n;\n\n        for( int i = 0 ; i < n ; i ++ )\n            data[i+1] = arr[i];\n        count = n;\n\n        for( int i = count/2 ; i >= 1 ; i -- )\n            shiftDown(i);\n    }\n    Item extractMax(){\n        assert( count > 0 );\n        Item ret = data[1];\n\n        swap( data[1] , data[count] );\n        count --;\n        shiftDown(1);\n\n        return ret;\n    }\n};\n```\n\n### 原地堆排序(从小到大)\n\n在之前构建一个堆需要额外的n个空间，实际上给定数组时候在原地也可以进行堆排序，过程如图所示：\n\n<img src=\"堆排序-heap-sort\\原地1.png\" style=\"zoom:80%;\" />\n\n* 先对数组进行`Heapify`操作，则V就是最大值，V和W进行交换，此时最大值在末尾\n* 此时V之前的数组不再是最大堆，对W进行`ShiftDown`操作使之前的数组再次成为最大堆\n* 再次把此时的V和W(倒数第二个元素)进行交换，以此类推。\n\n**此时的索引是从0开始的**，所以最后一个非叶子节点的索引为`(count-1)/2`，对于节点**i**，有：\n\n```cpp\nparent[i] = (i - 1) / 2;\nleft child[i] = 2 × i + 1;\nright child[i] = 2 × i + 2;\n```\n\n<img src=\"堆排序-heap-sort\\原地2.png\" style=\"zoom:80%;\" />\n\n对应的数组为：\n\n<img src=\"堆排序-heap-sort\\原地3.png\"  />\n\n代码实现：\n\n```cpp\npublic:\nvoid heapsort(T arr[], int n){\n    // heapify\n    // from 第一个非叶子节点\n    for(int i = (n - 1) / 2; i >= 0; --i)\n        __shiftDown(arr, n, i);\n    // i最后为1，当只有也给元素时无需进行操作\n    for(int i = n - 1; i > 0; --i){\n        swap(arr[0], arr[i]);\n        __shiftDown(arr, i, 0);\n    }\n}\nprivate:\nvoid __shiftDown(T arr[], int n, int k){\n    // 从0开始索引，k为父节点\n    while(2 * k + 1 < n){ // 如果左孩子存在\n        int j = 2 * k + 1;\n        // 以下操作是为了与左右孩子中更大的那个交换\n        if(j + 1 < n && arr[j+1] > arr[j])\n            j += 1;\n        if(arr[k] >= arr[j])\n            break;\n        swap(arr[k], arr[j]);\n        k = j;\n    } \n        \n}\n```\n\n### 索引堆(Index Heap)\n\n当进行堆排序之后，坐标和值的关系也就不复存在了，如果我们要继续使用坐标和值之间的关系，就需要对索引进行堆排序，以最大索引堆为例：\n\n<img src=\"堆排序-heap-sort\\index_heap1.png\" style=\"zoom:80%;\" />\n\n* `data`数组并未改变，只有`index`数组发生了改变(**根据data改变index**)\n* 堆顶的元素`index[1] = 10`，表示堆顶的元素是**10索引**所指向的`data[10]`，即62\n* 同理可得，`index[2] = 9`表示62的左孩子是**9索引**所指向的`data[9] = 41`，`index[3] = 7`表示62的右孩子是**7索引**所指向的`data[7] = 28`，以此类推\n\n**优点**：只有索引`index整型`数组发生了改变，`data`并未改变，`data`的类型并没有限制\n\n对于`shiftDown`和`shiftUp`变化不大，同时可以支持返回最大值的索引值，也可以根据索引值就直接返回`data`，最重要的操作是修改数据内容。\n\n```cpp\nvoid change( int i , Item newItem ){\n\n    i += 1;\n    data[i] = newItem;\n\n    // 找到indexes[j] = i, j表示data[i]在堆中的位置\n    // 之后shiftUp(j), 再shiftDown(j)，再次将index构建为最大堆\n\t// 这里用的是遍历，复杂度较高O(n + logn)\n    for( int j = 1 ; j <= count ; j ++ )\n        if( indexes[j] == i ){\n            shiftUp(j);\n            shiftDown(j);\n            return;\n        }\n}\n```\n\n#### 优化(change)\n\n<img src=\"堆排序-heap-sort\\index_heap2.png\"  />\n\n* `reverse[i]`表示索引`i`在`index`中的位置\n* 比如我们要查找`i = 4`这个索引在`index`中的位置，先找到`rev[4] = 9`，那么索引`i = 4`就在`index[9]`处，时间复杂度为O(1)\n\n```cpp\nindexes[i] = j;\nreverse[j] = i;\n\nindexes[reverse[i]] = i;\nreverse[indexes[i]] = i;\n```\n\n在`swap`操作中需要修改`reverse`\n\n代码如下：\n\n```cpp\npublic:\n    IndexMaxHeap(int capacity){\n\n        data = new Item[capacity+1];\n        indexes = new int[capacity+1];\n        reverse = new int[capacity+1];\n        // 初始化为0，代表不存在\n        for( int i = 0 ; i <= capacity ; i ++ )\n            reverse[i] = 0;\n\n        count = 0;\n        this->capacity = capacity;\n    }\n    ~IndexMaxHeap(){\n        delete[] data;\n        delete[] indexes;\n        delete[] reverse;\n    }\n    // 传入的i对用户而言,是从0索引的\n    void insert(int i, Item item){\n        assert( count + 1 <= capacity );\n        assert( i + 1 >= 1 && i + 1 <= capacity );\n\n        i += 1;\n        data[i] = item;\n        indexes[count+1] = i;\n        reverse[i] = count+1;\n        count++;\n\n        shiftUp(count);\n    }\n\t// 抽取最大的元素\n    Item extractMax(){\n        assert( count > 0 );\n\n        Item ret = data[indexes[1]];\n        swap( indexes[1] , indexes[count] );\n        // 此时最后一个元素没有意义了\n        // 此时的堆顶的第一个元素的reverse需要更新\n        reverse[indexes[count]] = 0;\n        reverse[indexes[1]] = 1;\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n\t// 抽取最大元素的坐标\n    int extractMaxIndex(){\n        assert( count > 0 );\n\n        int ret = indexes[1] - 1;\n        swap( indexes[1] , indexes[count] );\n        reverse[indexes[count]] = 0;\n        reverse[indexes[1]] = 1;\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n\t// 返回最大元素的值\n    Item getMax(){\n        assert( count > 0 );\n        return data[indexes[1]];\n    }\n\t// 返回最大元素的坐标\n    int getMaxIndex(){\n        assert( count > 0 );\n        return indexes[1]-1;\n    }\n\t// 保证不越界\n    bool contain( int i ){\n        assert( i + 1 >= 1 && i + 1 <= capacity );\n        return reverse[i+1] != 0;\n    }\n\t// 返回i处的元素值\n    Item getItem( int i ){\n        assert( contain(i) );\n        return data[i+1];\n    }\n\t// 改变i处的元素值\n    void change( int i , Item newItem ){\n\n        assert( contain(i) );\n        i += 1;\n        data[i] = newItem;\n\n        int j = reverse[i];\n        shiftUp( j );\n        shiftDown( j );\n    }\n```\n\n```cpp\nprivate:   \n    void shiftUp( int k ){\n\n        while( k > 1 && data[indexes[k/2]] < data[indexes[k]] ){\n            swap( indexes[k/2] , indexes[k] );\n            reverse[indexes[k/2]] = k/2;\n            reverse[indexes[k]] = k;\n            k /= 2;\n        }\n    }\n    void shiftDown( int k ){\n\n        while( 2*k <= count ){\n            int j = 2*k;\n            if( j + 1 <= count && data[indexes[j+1]] > data[indexes[j]] )\n                j += 1;\n\n            if( data[indexes[k]] >= data[indexes[j]] )\n                break;\n\n            swap( indexes[k] , indexes[j] );\n            reverse[indexes[k]] = k;\n            reverse[indexes[j]] = j;\n            k = j;\n        }\n    }\n```\n\n### 用堆解决第一节问题思路\n\n使用堆实现优先队列，动态选择优先级最高的任务执行。\n\n第一节中的问题，在10000000个元素中选出前100名(在N个元素中选前M个元素)，维护一个优先队列(长度为100)，每次把最小的移除，遍历完成后，最后剩下的100个元素就是前100个元素。\n\n### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git\n\n","categories":["算法与数据结构"]},{"title":"string操作总结(不定期更新)","url":"/blog/2020/06/25/string操作总结/","content":"\n总结一下C++中string的常见用法，包括但不局限于：\n\n1. 初始化\n2. string对象上的操作（包括取子串）\n3. 查找/删除/替换\n4. 与数值的相互转换\n\n<!-- more-->\n\n### 初始化\n\n```cpp\n//默认初始化，s1为空\nstring s1;\n//用s1初始化s2\nstring s2(s1);\n//s3为字面值\"value\"的副本，直接初始化\nstring s3(\"value\");\n//与上述等价，不同之处在于这里是拷贝初始化\nstring s3 = \"value\";\n//类似vector，n个'c'组成字符串s4\nstring s4(n, 'c');\n```\n\n### string对象上的操作\n\n```cpp\n//从is读取一行给s，返回is\ngetline(is, s)\n//判断是否为空\ns.empty()\n//s的长度\ns.size() / s.length()\n//完全一样则相等，大小写敏感\ns1 == s2\n//字典序比较，大小写敏感\n<, <=, >, >=\n```\n\n#### 两个string对象相加\n\n```cpp\nstring s1 = \"hello, \", s2 = \"world\";\n//s3 = \"hello, world\"\nstring s3 = s1 + s2;\n//s1 = \"hello, world\"\ns1 += s2; \t\t\t\n```\n\n#### 字面值和string对象相加\n\n当把string对象和字符字面值及字符串字面值混在一起相加时，必须确保`+`的两侧运算对象至少有一个string：\n\n```cpp\nstring s4 = s1 + \",\"; \t\t//√\nstring s5 = \"hello\" + \",\"\t//×\n```\n\n注意：字符串字面值与string是不同类型，以上操作是自动进行了类型转换。\n\n#### 处理string对象中的字符\n\n```cpp\n//定义在头文件cctype中\nisalnum(c)\t\t//当c是字母或数字为真\nisalpha(c)\t\t//当c是字母为真\niscntrl(c)\t\t//当c是控制字符为真，ASCII码前32\nisdigit(c)\t\t//当c是数字为真\nislower(c)\t\t//当c是小写字母为真\nisupper(c)\t\t//当c是大写字母为真\nispunct(c)\t\t//当c是标点符号为真\nisspace(c)\t\t//当c是空白为真(空格，回车，制表符等)\ntolower(c)\t\t//如果c为大写字母，转为小写，否则不变\ntoupper(c)\t\t//如果c为小写字母，转为大写，否则不变\n```\n\n**范围for语句**\n\n```cpp\n//打印s1的所有内容\n//仅访问时可加上const\n//简化类型名可用auto代替\nstring s1 = \"zhaoxingyu\"\nfor(string s : s1)\n    cout << s;\n//同时修改s1内容全为a\nfor(string &s : s1)\n    s = 'a';\n```\n\n#### 取子串\n\n```cpp\n//s.substr(pos, n)\n//取s中从pos开始长度为n的子串\n//如果pos超过s.size()则抛出out_of_range异常\n//如果pos+n超过s.size()则substr自动调整n值，只拷贝到s末尾\nstring s = \"hello world\";\nstring str = s.substr(0, 5);\t//str = \"hello\"\n```\n\n### 查找/删除/替换\n\n#### 查找函数find\n\nstring中的find函数返回子串/字符第一次出现在母串中的位置，类型为size_t，可以把它视为一个范围很大的int类型。如果没有找到，返回一个npos标记，是一个很大的整数。\n\n```cpp\n//size_t pos = s.find(str, startPos)\n//str为子串或字符，startPos为开始搜索位置，缺省时默认为0\nstring s = \"hello world\";\nstring str = \"world\";\nsize_t pos = s.find(str);\t//等价于pos = s.find(\"world\")，返回6\nsize_t pos1 = s.find(\"c\");\t//等价于pos1 = s.find('c')，返回npos\n```\n\n还可以从后往前反向查找，函数为rfind\n\n``` cpp\nstring s = \"hello world\";\nsize_t pos = s.rfind(\"l\"); \t//返回9\n```\n\n其他一些find函数\n\n```cpp\n//返回子串首次出现位置\npos = s.find_first_of(str);\n//返回字串最后出现位置\npos = s.find_last_of(str);\n```\n\n#### 删除函数erase\n\nstring中提供的成员函数可以用来删除字符串中的字符，这里主要介绍`erase`方法\n\n1. 从给定位置pos开始删除长度为n的字符串\n\n```cpp\n//basic_string & erase(size_type pos=0, size_type n=npos)\n//n缺省时默认为删除到末尾\nstring s = \"hello world\";\ns.erase(5);\t\t\t//从位置5开始全部删除，s = \"hello\";\ns.erase(0, 2); \t\t//从0开始删除长度为2的字符串，s = \"llo\"\n```\n\n2. 删除迭代器位置处的单个字符，并返回**下个元素**的迭代器\n\n```cpp\n//iterator erase(const_iterator position)\nstring s = \"hello world\";\ns.erase(s.begin());\t//s = \"ello world\";\n```\n\n3. 删除迭代器`[first, last)`区间的所有字符,返回一个指向被删除的最后一个元素的下一个字符的迭代器.\n\n```cpp\n//iterator erase(const_iterator first, const_iterator last)\nstring s = \"hello world\";\n//iter = s.erase(s.begin() + 1, s.end() - 1); \t //可以直接删除\nauto iter = s.erase(s.begin() + 1, s.end() - 1); //删除并返回迭代器\n//s = \"hd\"，*iter = d\n```\n\n**注：也可以用pop_back()删除最后一个元素**\n\n#### 替换函数replace\n\n1. 用str替换指定字符串从pos开始长度为len的字符串\n\n```cpp\n//string& replace(size_t pos, size_t len, const string& str)\n//注意这里的str必须是string对象，不能是char字符\nstring s = \"hello world\";\nstring str = \"#\";\ns = s.replace(0, 5, str);\t//s = \"# world\"\n```\n\n2. 用str替换迭代器起始位置到终止位置的字符串\n\n```cpp\n//string& replace(const_iterator it1, const_iterator it2, const string& str)\n//注意这里的str必须是string对象，不能是char字符\nstring s = \"hello world\";\nstring str = \"#\";\ns = s.replace(s.begin(), s.begin() + 5, str);\t//s = \"# world\"\n```\n\n3. 用重复n次的c字符替换从指定位置pos长度为len的字符串\n\n```cpp\n//string& replace(size_t pos, size_t len, size_t n, char c)\n//注意这里的c必须是char类型，不能是string对象\nstring s = \"hello world\";\nchar c = '#';\ns = s.replace(0, 5, 2, c);\t//s = \"## world\"\n```\n\n4. 用重复n次的c字符替换从指定迭代器位置到终止位置的字符串\n\n```cpp\n//string& replace (const_iterator i1, const_iterator i2, size_t n, char c)\n//注意这里的c必须是char类型，不能是string对象\nstring s = \"hello world\";\nchar c = '#';\ns = s.replace(s.begin(), s.end(), 2, c);\t//s = \"## world\"\n```\n\n### string与int相互转换\n\n#### string转int\n\n```cpp\n# string直接转int\n//stoi(s, pos, b) 把字符串s从pos开始转换成b进制的int\nstring s = \"123\";\n//a = 123，如果里面含有非数字，那么从pos开始连续的字符串型数字才会被转为数字\nint a = stoi(s, 0, 10);\t\n//stol(s,p,b)\t把字符串s从p开始转换成b进制的long\n//stoul(s,p,b)\t把字符串s从p开始转换成b进制的unsigned long\n//stoll(s,p,b)\t把字符串s从p开始转换成b进制的long long\n//stoull(s,p,b)\t把字符串s从p开始转换成b进制的unsigned long long\n//stof(s,p)\t\t把字符串s从p开始转换成float\n//stod(s,p)\t\t把字符串s从p开始转换成double\n//stold(s,p)\t把字符串s从p开始转换成long double\n# char型数组字符串转int\n//c_str()函数返回一个指向正规C字符串的指针, 内容与string串相同\n//string类对象的成员函数c_str()把string转换为c类型字符串\n//如果string不是数字形式的则转换结果为0\n//实际步骤为string->char*->int\nstring s = \"123\";\nint a = atoi(s.c_str());\t//a = 123\n```\n\n#### int转string\n\n```cpp\n//to_string(val) 将val转为string\nint val = 100;\nstring s = to_string(val);\t//s = \"100\"\n```\n\n### 参考\n\n查找/删除/替换：\n\n1. https://www.cnblogs.com/xzxl/p/7243490.html\n\n2. https://blog.csdn.net/cai_niaocainiao/article/details/81260902?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase\n\n3. https://blog.csdn.net/u010472607/article/details/80431604\n\n字符串转数值\n\nhttps://blog.csdn.net/sinat_40872274/article/details/81367815","tags":["string"],"categories":["C++"]},{"title":"git提交失败-ssh重置","url":"/blog/2020/06/25/git提交失败-ssh重置/","content":"\n一段时间不提交，就容易出现“Please make sure you have the correct access rights and the repository exists.”，原因是ssh key出现了问题，记录一下解决方法，省的每次都去百度细节。\n\n**用手机热点可以提交成功，尚不清楚原因(updated：2020/7/15)** \n\n<!-- more -->\n\n1. 重新配置身份信息\n   * `git config --global user.name \"yourname\"`\n   * `git config --global user.email \"your@email.com\"`\n\n2. 删除.ssh文件夹下的所有文件\n3. 输入命令`ssh-keygen -t rsa -C \"your@email.com\"`，出现提示直接回车\n4. 此时在.ssh文件夹下生成**id_rsa**和**id_rsa.pub**，用记事本打开**id_rsa.pub**并复制所有内容\n5. 打开github主页并进入到`SSH and GPG keys`中，新建shh，把刚才复制的内容粘贴进去\n6. 输入命令`ssh -T git@github.com`，出现提示输入`yes`，不是直接回车\n7. **重新打开**git进行提交\n\n以上所有git操作都在hexo根目录下\n\n","categories":["Hexo"]},{"title":"LeetCode139-单词拆分","url":"/blog/2020/06/25/LeetCode139-单词拆分/","content":"\n这道题我一开始没想到可以用动态规划来做，先试着用暴力做了，结果通过34/36，看似只剩下3个没通过，但是问题很大，不好修改，具体原因后面分析。\n\n### 题目描述\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n* 拆分时可以重复使用字典中的单词。\n* 你可以假设字典中没有重复的单词。\n\n<!--more -->\n\n<img src=\"LeetCode139-单词拆分\\示例.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这道题题意还是挺好理解的，给定字符串s，从字典wordDict中取出单个或多个字符串（可重复），最后如果可以拼接成s，返回true，反之返回false。\n\n一开始暴力的思路就是遍历字典中的每一个字符串看是否出现在s中，如果出现了，那么用#号来代替s中的出现的子串，并且继续搜索，搜索完成后，将s中的#号清空，如果此时s为空，那么代表s可以被拆分，返回true。但是对于以下的例子：\n\n```cpp\ns = \"abbbc\"\nwordDict = [\"ab\", \"b\", \"bbc\"]\n```\n\ns可以由ab+bbc组合而成。但是用暴力法，只会搜到ab+b+b，再往下就搜索不到了，返回了false。如果需要修改，要用到dfs的思想，进行深搜，但是不剪枝也容易超时。在看了答案之后才知道可以用动态规划来做，而且很好理解。\n\n按照第二个示例来说，`s = \"applepenapple\", wordDcit = [\"apple\", \"pen\"]`，从s的第一个字符`a`开始遍历：\n\n* 当等于`apple`时候，存在与字典中，就可以认为在第5个字符处是可以拆的；\n* 继续向后遍历，当得到`applepen`时，增加了字符串`pen`，且它存在于字典中，所以可以知道第8个字符处也是可拆的；\n* 直到`applepenapple`时，增加了`apple`，且它存在于字典中，最后一个字符即第13个字符处可拆。\n\n从上述分析可以知道，如果最后一个字符处可拆，就返回true，否则返回false。\n\n#### 定义dp数组\n\n首先，`dp`数组应该是`bool`类型，长度为`s.length()+1`，并且`dp[0]=true`，否则dp数组全是false。**dp数组含义为当前位置的字符是否可以被拆分**。\n\n如果`dp[j]`代表当前位置，`dp[i]`是某一起始位置，那么就需要检查从`i`到`j`的子串是否在字典中，如果在，并且`dp[i]`是可以拆分的，那么`dp[j]`也应该是可以拆分的，否则`dp[j]=false`。\n\n#### 状态转移方程\n\n根据上面的分析，可以容易写出以下的状态转移方程，同时将字典放入`unordered_map`中方便查找：\n\n```cpp\ndp[j] = dp[i] && dict.count(s.substr(i, j - i))\n```\n\n#### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        // 存入字典，方便查找\n        unordered_map<string, bool> dict; \n        for(const auto &word : wordDict) dict[word] = true;\n        // 初始化dp数组，如果s为空，返回true\n        // 实际上只初始化dp[0]即可\n        bool *dp = new bool[s.length() + 1];\n        dp[0] = true; \n        for(int i = 1; i <= s.length(); i++){\n            dp[i] = false;\n        }\n        for(int j = 1; j <= s.length(); j++){\n            for(int i = j - 1; i >= 0; i--){\n                dp[j] = dp[i] && dict.count(s.substr(i, j - i));\n                if(dp[j]) break;\n            }\n        }\n        return dp[s.length()];    \n    }\n};\n```\n\n### 参考资料\n\nhttps://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-ju-jue-zhuang-xcong-jian-dan-de-xi/\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode739-每日温度","url":"/blog/2020/06/13/LeetCode739-每日温度/","content":"\n这次主要学习一下单调栈这种数据结构，同时用此数据结构解决739题\n\n### 题目描述\n\n请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n\n<!--more -->\n\n### 单调栈\n\n先学习一下单调栈这种数据结构，单调栈就是栈的基础上使用一定的逻辑，使栈中的元素单调递增或者递减，一般只处理一种典型的问题，叫做**下一个更大的元素**，这个问题是说：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。举例如下：给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。\n\n可以这样思考，把数组元素想象成人，如何求2的下一个更大的元素呢？如果2的下一个人比2还低或者一样高，那么就会被2遮挡住，直到第一个比他高的人，他挡不住了，就是答案。\n\n<img src=\"LeetCode739-每日温度\\人.jpg\" style=\"zoom: 30%;\" />\n\n代码实现如下：\n\n```cpp\nvector<int> nextGreaterElement(vector<int>& nums) {\n    vector<int> ans(nums.size()); // 存放答案的数组\n    stack<int> s;\n    for (int i = nums.size() - 1; i >= 0; i--) { // 倒着往栈里放\n        while (!s.empty() && s.top() <= nums[i]) { // 判定个子高矮，nums在s之前\n            s.pop(); // 矮个起开，反正也被挡着了。。。\n        }\n        ans[i] = s.empty() ? -1 : s.top(); // 这个元素身后的第一个高个\n        s.push(nums[i]); // 入栈\n    }\n    return ans;\n}\n```\n\n<img src=\"LeetCode739-每日温度\\栈.png\" style=\"zoom: 80%;\" />\n\n以上图是栈中元素的变化情况，只有当新的高个子来临，才会有出栈的操作。\n\n### 分析及代码实现\n\n上面已经把单调栈阐述了一遍，本题唯一的区别是要返回还需要多少天，而不是那天的温度，所以要用栈来存储一下温度的坐标，根据当前温度的坐标与栈顶温度坐标的差作为返回值。\n\n代码如下：\n\n```cpp\nvector<int> dailyTemperatures(vector<int>& T) {\n    vector<int> ans(T.size());\n    stack<int> s; // 这里放元素索引，而不是元素\n    for (int i = T.size() - 1; i >= 0; i--) {\n        while (!s.empty() && T[s.top()] <= T[i]) {\n            s.pop();\n        }\n        ans[i] = s.empty() ? 0 : (s.top() - i); // 得到索引间距\n        s.push(i); // 加入索引，而不是元素\n    }\n    return ans;\n}\n```\n\n### 扩展：如何处理循环数组\n\n同样是**下一个更大的元素**，现在假设给你的数组是个环形的，如何处理？\n\n给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 。通过取模运算符%就可以模拟环形数组的效果。\n\n```cpp\nvector<int> arr{1,2,3,4,5};\nint n = arr.length(), index = 0;\nwhile (true) {\n    cout << arr[index % n] << endl;\n    index++;\n}\n```\n\n一种方法是将数组翻倍，然后进行取模运算，节省空间的做法是直接将循环的坐标变成之前的2倍，代码看起来更容易理解，如下：\n\n```cpp\nvector<int> nextGreaterElements(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> res(n); // 存放结果\n    stack<int> s;\n    // 假装这个数组长度翻倍了\n    for (int i = 2 * n - 1; i >= 0; i--) {\n        while (!s.empty() && s.top() <= nums[i % n])\n            s.pop();\n        res[i % n] = s.empty() ? -1 : s.top();\n        s.push(nums[i % n]);\n    }\n    return res;\n}\n```\n\n### 参考资料\n\n《labuladong的算法小抄》 单调栈","tags":["单调栈"],"categories":["LeetCode"]},{"title":"LeetCode126-单词接龙2","url":"/blog/2020/06/07/LeetCode126-单词接龙2/","content":"\n这是今天的每日一题，难度为hard，不过与之前软挑赛的题目有很多相似之处，但是我还是没做出来，还是要多总结。最后看了别人的答案，用BFS+DFS才解决这个问题。\n\n### 题目描述\n\n给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：\n\n1. 每次转换只能改变一个字母。\n2. 转换过程中的中间单词必须是字典中的单词。\n\n**说明**：\n\n* 如果不存在这样的转换序列，返回一个空列表。\n* 所有单词具有相同的长度。\n* 所有单词只由小写字母组成。\n* 字典中不存在重复的单词。\n* 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。\n\n<!--more -->\n\n<img src=\"LeetCode126-单词接龙2\\示例.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n对于beginWord，一次只能更改一个字母，同时更改后的字母必须出现在wordList中，所以考虑将wordList放入一个集合中，方便每次判断是否在集合内。一开始我考虑的是直接用DFS解决，虽然DFS可以找到所有路径，然后从中挑选最短，但是它无法直接找到最短路径。如果某条长度过长，很容易出现超时，事实上在刷题群里很多大佬已经出现了这个问题，所以只能找别的办法。直接用BFS是可以的，在找最短的同时记录路径，我没有尝试，之后可以再试试，我选择了使用BFS+DFS的方法，使用BFS建立逆邻接表，使用DFS在逆邻接表基础上搜索答案。\n\n#### BFS建立逆邻接表\n\n使用BFS可以找到最短的路径，可以建立一个逆邻接表，用来表示可以到达当前节点的所有节点(当然这些节点必须是出现在wordList之中的)，**我们用curr代表当前节点，temp代表更改一个字母后的节点**。\n\n使用`unordered_map<string, vector<string>> neighbor`来表示，就拿示例1来说，如下图所示：<img src=\"LeetCode126-单词接龙2\\邻接表.png\"  />\n\n上图表示可以到达cog的节点为dog和log，具体的实现还是需要一个记录当前节点深度的哈希表`unordered_map<string, int> depth`，用来判断curr是否可达temp，同时省去一些不必要的遍历。具体操作是：首先队列弹出curr节点，检查和它相差一个字母的temp是否在wordList中出现，如果出现了：\n\n* 没有记录过(`depth[temp] = 0`)，记录`curr->temp`，同时`depth[temp] = depth[curr] + 1`，将temp入队\n* 记录过并且相邻(`depth[temp] = depth[curr] + 1`)，同时避免不是直接相邻的遍历，也避免了往回遍历。如下表，遍历改变pot一个字母的节点时，可能再次出现hot，但是此时`depth[hot] = 1 != depth[pot] + 1 = 2`所以避免了再次遍历hot。\n\n```nginx\n   hot\n /       \\\npot     hit\n \\        /\n    pit\n```\n\n通过以上步骤就可以建立逆临界表，代码实现如下：\n\n```cpp\nunordered_map<string,int> depth;\nunordered_map<string,vector<string>> neighbor;\n//将wordList添加至集合中\nunordered_set<string> wordSet(wordList.begin(),wordList.end());\n//使用BFS建立逆邻接表\ndepth[beginWord]=1;\nqueue<string> Q;\nQ.push(beginWord);\n//从begin到end建图\nwhile(!Q.empty()){\n\tstring curr=Q.front();\n\tQ.pop();\n    for(int i=0;i<curr.size();++i){\n        string temp=curr;\n        for(char c='a';c<='z';++c){\n            temp[i]=c;\n            //如果修改后的这个temp是在集合里面\n            if(wordSet.count(temp)){\n           \t\t//这个temp还没被添加进neighbor\n                if(depth[temp] == 0){ \n                    Q.push(temp);\n                    depth[temp]=depth[curr]+1;\t//更新深度\n                    neighbor[temp].push_back(curr);\n                    }\n                //已经被添加并且相邻\n                else if(depth[temp]==depth[curr]+1){\n\n                    neighbor[temp].push_back(curr);\n                }\n            }\n        }\n    }\n}\n```\n\n#### DFS从逆邻接表中搜索答案\n\n在上一步的BFS中已经存储了每个点的逆邻接点，我们从endWord沿着neighbor往回进行搜索，直到到达beginWord，将已经记录的路径(path)进行反转，存入最终的res中；如果无法到达，则DFS执行至末尾，将path重置(省去了使用&path引用的pop_back()操作)。代码如下：\n\n```cpp\nvoid dfs(string &begin, string &curr, vector<string> path, unordered_map<string, vector<string>> &neighbor, vector<vector<string>> &res){\n\tif(curr == begin){\n        path.push_back(curr);\n        reverse(path.begin(), path.end());\n        res.push_back(path);\n        return;\n    }\n    path.push_back(curr);\n    for(auto &word : neighbor[curr]){\n        dfs(begin, word, path, neighbor, res);\n    }\n}\n```\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n\n        vector<vector<string>> res;\n        //如果wordList中没有endWord，则返回空\n        if(find(wordList.begin(), wordList.end(), endWord) == wordList.end())\n            return res; \n        vector<string> path;\t//记录路径\n        unordered_map<string, int> depth;\t//记录深度\n        //存储节点的逆邻接\n        unordered_map<string, vector<string>> neighbor;\t\n        //将wordList添加至集合中\n        unordered_set<string> wordset(wordList.begin(), wordList.end());\n        depth[beginWord] = 1;\n        queue<string> Q;\n        Q.push(beginWord);\n        while(!Q.empty()){\n            string curr = Q.front();\n            Q.pop();\n            for(int i = 0; i < curr.size(); i++){\n                string temp = curr;\n                for(char c = 'a'; c <= 'z'; c++){\n                    temp[i] = c;\n                    //如果修改后的这个temp是在集合里面\n                    if(wordset.count(temp)){\n                        //这个temp还没被添加进neighbor\n                        if(depth[temp] == 0){\n                            Q.push(temp);\n                            depth[temp] = depth[curr] + 1;\t//更新深度\n                            neighbor[temp].push_back(curr);\n                        }\n                        //已经被添加并且相邻\n                        else if(depth[temp] == depth[curr] + 1){\n                            neighbor[temp].push_back(curr);\n                        }\n                    }\n                }\n            }\n        }\n        dfs(beginWord, endWord, path, neighbor, res);\n        return res;\n    }\n\n    void dfs(string &begin, string &curr, vector<string> path, unordered_map<string, vector<string>> &neighbor, vector<vector<string>> &res){\n        //当前点已经等于beginWord\n        if(curr == begin){\n            path.push_back(curr);\n            reverse(path.begin(), path.end());\t//反转\n            res.push_back(path);\n            return;\n        }\n        path.push_back(curr);\n        for(auto &word : neighbor[curr]){\n            dfs(begin, word, path, neighbor, res);\n        }\n\t\t//如果没有逆邻接，则执行完毕此函数后，path还原为上一次的值，即省去了pop_back()\n    }\n};\n```\n\n### 参考\n\nhttps://leetcode-cn.com/problems/word-ladder-ii/solution/zhe-ti-you-xie-nan-bie-ren-de-dai-ma-zuo-xia-zhu-s/","tags":["BFS","DFS"],"categories":["LeetCode"]},{"title":"LeetCode837-新21点","url":"/blog/2020/06/06/LeetCode837-新21点/","content":"\n### 题目描述\n\n爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：\n\n爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。\n\n当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？\n\n<!--more -->\n\n<img src=\"LeetCode837-新21点\\示例.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这道题一看不太明白什么意思，看过港片的都知道，在牌面加起来不大于21点时候，谁的牌面最大，谁就能获胜。这道题其实是求爱丽丝获胜的概率，不过点数为N，可以把规则复述一下：\n\n1. 她可以从`[1,W]`的牌中任意取一张，可以无限重复取，也就是说取到范围中某张牌的概率一直是`1/W`；\n2. 如果她手上的牌总额小于K时，她就会继续抽牌，大于等于K时就停止抽牌；\n3. 停止抽牌后，和N进行比较，当小于等于N时，她就获胜了，求获胜的概率。\n\n#### 定义dp数组的含义\n\n定义`dp[x]`为她手上牌面为x时，能获胜的概率。因为每次从`[1,W]`中抽取的机会都是均等的，所以`dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W]) `。x最多可以到`K-1`，因为x等于K时会停止抽牌，所以当抽牌结束后，她可能达到的最大牌面是`K-1+W`，开始时她的牌面为0，所以用长度为K+W的dp数组就够了，最后`dp[0]`，也就是爱丽丝还没有抽牌时的胜率就是最终答案。\n\n#### 状态转移方程\n\n其实上一步已经提到了状态转移方程：`dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W]) `，但是dp数组具体应该怎么算呢，可以把它看成一个填格子的游戏，如下图：\n\n<img src=\"LeetCode837-新21点\\image1.png\" style=\"zoom:80%;\" />\n\n将格子分为两个部分，在橘黄色的格子中，爱丽丝是可以抽牌的，而在蓝色的格子中是不可以的。我们每次需要W个格子的结果进行状态转移。\n\n在蓝色的格子中，对于`[K,K+W-1]`中小于等于N的值，相应的`dp[i]`概率就是1，反之为0，在初始化时候进行。\n\n<img src=\"LeetCode837-新21点\\image2.png\" style=\"zoom:80%;\" />\n\n接下来，从K-1处根据状态转移方程进行dp数组的计算。在计算K-2处概率值时，在上一步用一个中间变量`sumw`保存`[K,K+W-1]`的概率之和，这样新的概率和`sumw = sumw - dp[K-1+W] + dp[K-1]`，提高效率。这样从最右边橘黄色格子一直填到最左边，就是最后的结果dp[0]。\n\n#### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    double new21Game(int N, int K, int W) {\n        vector<double> dp(K + W, 0);\n        double sumw = 0;\n        for(int i = K; i <= K + W - 1; i++){\n            if(i <= N) dp[i] = 1;\n            sumw += dp[i];\n        }\n        for(int i = K-1; i >=0; i--){\n            dp[i] = (double)1 / W * sumw; //概率可能是小数，需要强制类型转换\n            sumw = sumw - dp[i+W] + dp[i]; \n            //这里就是减去最右边概率dp[i+W]，加上最左边概率dp[i]\n        }\n        return dp[0];\n    }\n};\n```\n\n### 参考资料\n\nhttps://leetcode-cn.com/problems/new-21-game/solution/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/\n\n\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode877-石子游戏","url":"/blog/2020/05/28/LeetCode877-石子游戏/","content":"\n### 题目描述\n\n亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。\n\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。\n\n<!--more -->\n\n<img src=\"LeetCode877-石子游戏\\877.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这个题其实一定是先手获胜，为了更具有一般性，假设**石头的堆数可以是任意正整数**，那么就能打破先手必定获胜的局面了，比如`piles = [1, 100, 3]`，先手不管拿1还是3，能够决胜的100都会被后手拿走，后手获胜。\n\n**博弈问题的难点在于，两个人要轮流进行选择，而且都很精明，应该如何编程表示这个过程呢？**首先明确 dp 数组的含义，只要找到「状态」和「选择」，一切就水到渠成了。\n\n#### 一、定义 dp 数组的含义\n\n先看一下dp数组的最终样子，再介绍其含义\n\n<img src=\"LeetCode877-石子游戏\\dp.png\" style=\"zoom:50%;\" />\n\n定义dp数组是二维的，并且每个单元包含first和second两个属性，将这两个属性简写为fir和sec。如按上图的数据，我们说 `dp[1][3].fir = 10`，`dp[0][1].sec = 3`。\n\n**以下是对 dp 数组含义的解释：**\n\n```cpp\ndp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。\ndp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。\n\n举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始\ndp[0][1].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。\ndp[1][3].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。\n```\n\n我们想求的答案是先手和后手最终分数哪个更大，按照这个定义也就是 `dp[0][n-1].fir`和`dp[0][n-1].sec`哪个更大。\n\n#### 二、状态转移方程\n\n要写状态转移方程，需要找到所有**状态**和每个状态可以做出的**选择**，然后择优。\n\n根据前面对 dp 数组的定义，**状态**显然有三个：**开始的索引 i，结束的索引 j，当前轮到的人。**\n\n```cpp\ndp[i][j][fir or sec]\n其中：\n0 <= i < piles.length\ni <= j < piles.length\n```\n\n对于这个问题的每个状态，可以做的**选择**有两个：**选择最左边的那堆石头，或者选择最右边的那堆石头。**\n\n这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？根据我们对 dp 数组的定义，很容易解决这个难点，**写出状态转移方程：**\n\n```cpp\ndp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)\nleft = piles[i] + dp[i+1][j].sec //选择最左边的石头堆\nright = piles[j] + dp[i][j-1].sec //选择最右边的石头堆\n# 解释：我作为先手，面对 piles[i...j] 时，有两种选择：\n# 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]\n# 在上一轮中，我是作为后手的；\n# 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]\n# 在上一轮中，我是作为后手的。\n\nif 先手选择左边:\n    dp[i][j].sec = dp[i+1][j].fir\nif 先手选择右边:\n    dp[i][j].sec = dp[i][j-1].fir\n# 解释：我作为后手，要等先手先选择，有两种情况：\n# 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]\n# 此时轮到我，我变成了先手；\n# 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]\n# 此时轮到我，我变成了先手。\n根据 dp 数组的定义，我们也可以找出base case，也就是最简单的情况：\n\ndp[i][j].fir = piles[i]\ndp[i][j].sec = 0\n其中 0 <= i == j < n\n# 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]，i != j时可以不需要初始化\n# 那么显然先手的得分为 piles[i]\n# 后手没有石头拿了，得分为 0\n```\n\n<img src=\"LeetCode877-石子游戏\\dp1.png\" style=\"zoom:50%;\" />\n\n这里需要注意一点，我们发现 base case 是斜着的，而且我们推算`dp[i][j]`时需要用到`dp[i+1][j]`和`dp[i][j-1]`:\n\n<img src=\"LeetCode877-石子游戏\\dp2.png\" alt=\"dp2\" style=\"zoom:50%;\" />\n\n```c++\n# 举例：若i = 0, j = 1\n# dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)\ndp[0][1].fir = max(piles[0] + dp[1][1].sec, piles[1] + dp[0][0].sec)\n    \t\t = max(3 + 0, 9 + 0) = 9\n# 先手选择右边第一堆\n# if 先手选择右边: dp[i][j].sec = dp[i][j-1].fir\ndp[0][1].sec = dp[0][0].fir = 3\ndp[0][1] = {9, 3}\n```\n\n所以说算法不能简单的一行一行遍历 dp 数组，**而要斜着遍历数组：**\n\n<img src=\"LeetCode877-石子游戏\\dp3.png\" style=\"zoom:50%;\" />\n\n如何斜着遍历二维数组是个问题，这里我不是很会，只是有个框架，具体的细节还需要再消化消化\n\n```c++\n# 遍历的是橘黄色的部分\nfor (int l = 2; l <= n; l++) {\n        for (int i = 0; i <= n - l; i++) {\n            int j = l + i - 1;\n            /*操作段*/\n        }\n}\n```\n\n#### 三、代码实现\n\n实现fir和sec这个单元可以用pair容器，也可以用`dp[n][n][2]`这种三维数组，我在这里使用了结构体。\n\n```c++\nclass Solution {\npublic:\n    struct Pair{\n        int fir;\n        int sec;\n        Pair() {};\n        Pair(int a, int b){\n            this->fir = a;\n            this->sec = b;\n        } \n    };\n    bool stoneGame(vector<int>& piles) {\n        int n = piles.size();\n        Pair** dp = new Pair*[n];\n        for(int i = 0; i < n; i++){\n            dp[i] = new Pair[n];\n        }\n        for(int i = 0; i < n; i++){\n            dp[i][i].fir = piles[i];\n            dp[i][i].sec = 0;\n        }\n\n        for(int l = 2; l <= n; l++){\n            for(int i = 0; i <= n - l; i++){\n                int j = l + i - 1;\n\n                int left = dp[i+1][j].sec + piles[i];\n                int right = dp[i][j-1].sec + piles[j];\n                if(left > right){\n                    dp[i][j].fir = left;\n                    dp[i][j].sec = dp[i+1][j].fir;\n                }\n                else{\n                    dp[i][j].fir = right;\n                    dp[i][j].sec = dp[i][j-1].fir;\n                }\n            }\n        }\n        if(dp[0][n-1].fir > dp[0][n-1].sec) return true;\n        return false;\n    }\n};\n```\n\n### 参考资料\n\n《labuladong的算法小抄》 动态规划之博弈问题","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode300-最长上升子序列","url":"/blog/2020/05/26/LeetCode300-最长上升子序列/","content":"\n### 题目描述\n\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n<!--more -->\n\n<img src=\"LeetCode300-最长上升子序列\\sl.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这是一道动态规划的经典入门题，这里的子序列不一定是连续的。比如示例中`[2, 3, 7, 101]`，只要是递增的，就是上升子序列，我需要找到这里面最长的上升子序列的长度。\n\n动态规划一般是由历史信息推断当前信息的，并且历史信息是是独立的子问题，相互之间不会影响。现在考虑一个dp数组，如果说dp[0]到dp[i-1]都可以得到了，如果可以推出dp[i]，就可以得到dp数组的全部结果。\n\n#### 一、定义dp数组的含义\n\n我们可以定义dp[i]表示以nums[i]这个数结尾的最长上升子序列的长度。举两个例子：\n\n<img src=\"LeetCode300-最长上升子序列\\ex1.png\" style=\"zoom:80%;\" />\n\n根据这个定义，最终结果(子序列的最大长度)就是dp数组中的最大值。\n\n#### 二、状态转移方程\n\n这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：\n\n我们已经知道了 dp[0]到dp[4] 的所有结果，我们如何通过这些已知结果推出 dp[5] 呢？\n\n<img src=\"LeetCode300-最长上升子序列\\ex2.png\" style=\"zoom:80%;\" />\n\n根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。\n\nnums[5] = 7，既然是递增子序列，我们只要找到前面那些结尾比 7 小的子序列，然后把 7 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。\n\n当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。\n\n```cpp\nfor (int j = 0; j < i; j++) {\n    if (nums[i] > nums[j]) \n        dp[i] = max(dp[i], dp[j] + 1);\n} \n# dp数组需要初始化为1，因为自己本身也算一个序列\n# 当i = 5时\n# nums[5] > nums[2] dp[5] = max{dp[5], dp[2] + 1} = max{1, 2} = 2\n# nums[5] > nums[3] dp[5] = max{dp[5], dp[3] + 1} = max{2, 2 + 1} = 3\n# nums[5] > nums[4] dp[5] = max{dp[5], dp[4] + 1} = max{3, 2 + 1} = 3\n# 所以dp[5] = 3\n```\n\n根据上述的状态转移公式，就可以得到dp数组的所有值，我们再取其中的最大值，就是答案。\n\n#### 三、代码实现\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        vector<int> dp(nums.size(), 1);\n\n        for(int i = 0; i < nums.size(); i++){\n            for(int j = 0; j < i; j++){\n                if(nums[i] > nums[j])\n                    dp[i] = max(dp[i],dp[j] + 1); \n                //dp[i]是指历史中的最大长度，否则后面的长度+1小于历史最大长度时，会覆盖\n            }\n        }\n        return *max_element(dp.begin(), dp.end());\n    }\n};\n```\n\n### 参考资料\n\n《labuladong的算法小抄》 动态规划设计：最长递增子序列","tags":["动态规划"],"categories":["LeetCode"]},{"title":"2020学习/工作计划","url":"/blog/2020/04/30/2020学习计划/","content":"\n### 概要\n\n1. 写在前面\n2. 疫情期间的工作\n3. 反思自己的不足\n4. 2020学习/工作计划\n\n<!--more -->\n\n#### 写在前面\n\n2020年已经过去了四分之一，我才意识到需要做一个全年计划。这几个月来，小计划不断，但是都没有很好的完成，并且很容易受到外界因素的干扰，自己不知道自己到底**需要做什么**，于是看似做了不少东西，但是意义不大。我觉得全年的学习生活应该有一个基调，一年中总是要完成一些事情的。来到西电读研是进一步的学习机会，我要抓住这个机会。\n\n#### 疫情期间都做了什么？\n\n1. 首先是帮助师兄改了一个polar码的scl译码方法，其实到现在我对其原理也不是很明白，只是知道代码怎么用...\n2. 开始刷leetcode的题目，目前大概刷了100+，还是有一定的作用的。完成了\n   - 数据结构部分：队列和栈，数组和字符串，二分查找(83%)，链表(46%)\n   - 算法：BFS，DFS，双指针\n   - C++中vector，map，set等容器的使用，发现自己掌握的真是冰山一角\n\n3. 阅读了机器学习的几篇论文，主要是了解了随机梯度下降(SGD)方法，后面还需要进一步学习\n4. 很有限的学习了机器学习，矩阵论相关的内容\n5. 参加了华为的软件精英挑战赛，西北赛区第十名，进入复赛\n\n#### 自己的不足\n\n真正认识自己的不足也是在比赛期间，当你看到你辛辛苦苦半个月做出来的成果别人只需要几天，并且成绩还比你好的多的时候，你就越发的感觉到自己的渺小，我后悔的事情太多了，本科时候没有参加ACM是最大的错误，无论是数学建模或者是电赛，对于以后要进军互联网来说都没有ACM的奖牌作用大。不过我也意识到了这是教育之间的差异，有些人在中学的时候就开始接触比赛了，到了大学继续比赛那肯定更加熟练。我在高中的时候谈到计算机估计想的就是装个软件，换个内存条什么的，编程这个词都不知道啥意思，更不用说参加信息类的比赛了。。。为社么别人可以做到那些，我做不到，这并不全是自己的问题，种一棵树从现在开始也不迟，**虽然已经知道和别人的差距很大，但是只要是能缩小差距，那就是自己的进步**！还有一年的时间，一年是很快的，而且还有实验室的事情需要忙，所以时间很紧迫，千万不能再浪费了！\n\n#### 2020学习/工作计划\n\n1. 继续刷leetcode，学习了新算法，新思路或者新的函数之后在博客中进行总结，至少一周一篇，并且要做好题目的分类，算法和思路在tags中注明算法/思路，函数在tags中注明函数，在分类中注明C++。其中保证每周做7题以上，对于过于简单的题不计算在内，书籍**《算法》**。\n2. 继续学习C++，把**《C++ Prime》**过一遍，每周在博客总结一次，标签：C++ Prime，分类：C++；辅助阅读**《STL源码剖析》**和**《Effective C++》**标签：书名，分类：C++\n3. **《计算机网络 自顶向下方法》**前四章内容\n4. **《UNIX 网络编程》《UNIX 环境高级编程》** 辅助书籍**《Unix/Linux 编程实践教程》**\n5. **《深入理解计算机系统》**三四章可以先不看\n6. 机器学习的相关课程：吴恩达机器学习基础课程，CS231n计算机视觉课程，适应阅读英文论文，加强英语的学习\n7. 积极参加有水平的比赛\n8. 阅读一本非专业的书籍，陶冶陶冶情操？\n\n","categories":["生活随笔"]},{"title":"LeetCode17-电话号码的字母组合","url":"/blog/2020/02/16/LeetCode17-电话号码的字母组合/","content":"\n### 题目描述\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n已知数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n<!--more -->\n\n<img src=\"LeetCode17-电话号码的字母组合\\1.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n字符串的长度不确定，所以用循环直接解决不实际；\n\n可以由下至上进行递归来求解，以“23”为例，如图：\n\n```mermaid\ngraph TD\nA[2] -->|a| B[3]\nA[2] -->|b| C[3]\nA[2] -->|c| D[3]\nB[3] -->|d| E[ad]\nB[3] -->|f| F[af]\nB[3] -->|g| G[ag]\nC[3] -->|d| H[bd]\nC[3] -->|f| I[bf]\nC[3] -->|g| J[bg]\nD[3] -->|d| K[cd]\nD[3] -->|f| L[cf]\nD[3] -->|g| M[cg]\n```\n\n记数字2为第0层，那么数字3为第1层，需要一个变量level，记录当前遍历数字的位置。递归表现在：如果选择了’a'，那么就需要再进行三次选择‘d’ ‘f’ ‘g’后才可以输出，再选择'b'，以此类推。即递归到最后一层，输出一次递归结果，全部递归完成，得到最终结果。\n\n具体算法如下：\n\n* 建立一个**map**，用来存储数字与其对应的字符串，当然，这里的数字是char类型。\n* 递归函数中，首先判断**level**，如果等于**digits**中数字的个数，那么将当前的结果并入**res**，然后返回。\n* 否则通过**digits**中的数字找到对应的字符串，然后遍历取出整个字符串，将每个字符串都加到当前的组合后面，再调用递归函数。\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        if(digits.empty()) return {};\n        map<char,string> num_str{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},\n                                {'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        vector<string> res;\n        combin(digits,num_str,0,\"\",res);\n        return res;\n    }\n    void combin(string digits,map<char,string> num_str,int level,string out,vector<string> &res)\n    {\n        //递归\n        if(level == digits.length())\n        {\n            res.push_back(out);\n            return;\n        }\n        string buf = num_str[digits[level]];\n        for(int i=0;i<buf.length();i++)\n        {\n            combin(digits,num_str,level+1,out+buf[i],res);\n        }\n    }\n};\n```\n\n","tags":["递归"],"categories":["LeetCode"]},{"title":"转载：时间复杂度O(logn)意味着什么？（侵删）","url":"/blog/2020/01/01/转载：时间复杂度O-logn-意味着什么？（侵删）/","content":"\n<p>&nbsp;</p>\n<ul><li>原文地址：https://github.com/xitu/gold-miner/blob/master/TODO/what-does-the-time-complexity-o-log-n-actually-mean.md</li>\n\t<li>原文作者：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F%40maazrk\" rel=\"nofollow\">Maaz</a></li>\n\t<li>译文出自：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner\" rel=\"nofollow\">掘金翻译计划</a></li>\n\t<li>译者：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcdpath\" rel=\"nofollow\">cdpath</a></li>\n\t<li>校对者：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fzaraguo\" rel=\"nofollow\">zaraguo (zaraguo)</a>,&nbsp;<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwhatbeg\" rel=\"nofollow\">whatbeg (Qiu Hu)</a></li>\n</ul><p>&nbsp;</p>\n\n<!-- more -->\n\n<p><em>友情提示：如果图片挂了，请翻墙或者点击原文地址阅读。</em></p>\n<p>&nbsp;</p>\n<p>预先知道算法的复杂度是一回事，了解其后的原理是另一件事情。</p>\n<p>&nbsp;</p>\n<p>不管你是计算机科班出身还是想有效解决最优化问题，如果想要用自己的知识解决实际问题，你都必须理解时间复杂度。</p>\n<p>先从简单直观的 O(1) 和 O(n) 复杂度说起。O(1) 表示一次操作即可直接取得目标元素（比如字典或哈希表），O(n) 意味着先要检查 n 个元素来搜索目标，但是 O(log n) 是什么意思呢？</p>\n<p>你第一次听说 O(log n) 时间复杂度可能是在学二分搜索算法的时候。二分搜索一定有某种行为使其时间复杂度为 log n。我们来看看是二分搜索是如何实现的。</p>\n<p>因为在最好情况下二分搜索的时间复杂度是 O(1)，最坏情况（平均情况）下 O(log n)，我们直接来看最坏情况下的例子。已知有 16 个元素的有序数组。</p>\n<p>举个最坏情况的例子，比如我们要找的是数字 13。</p>\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20191121164646526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70\"></p>\n<p>十六个元素的有序数组</p>\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20191121164704291.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70\"></p>\n<p>选中间的元素作为中心点（长度的一半）</p>\n<p><img alt=\"\" class=\"has\" height=\"191\" src=\"https://img-blog.csdnimg.cn/20191121164715238.jpeg\" width=\"628\"></p>\n<p>13 小于中心点，所以不用考虑数组的后一半</p>\n<p><img alt=\"\" class=\"has\" height=\"134\" src=\"https://img-blog.csdnimg.cn/20191121164726473.jpeg\" width=\"411\"></p>\n<p>重复这个过程，每次都寻找子数组的中间元素</p>\n<p>&nbsp;</p>\n<p><img alt=\"\" class=\"has\" height=\"101\" src=\"https://img-blog.csdnimg.cn/20191121164751215.jpeg\" width=\"285\"></p>\n<p><img alt=\"\" class=\"has\" height=\"91\" src=\"https://img-blog.csdnimg.cn/20191121164811565.jpeg\" width=\"223\"></p>\n<p>每次和中间元素比较都会使搜索范围减半。</p>\n<p>所以为了从 16 个元素中找到目标元素，我们需要把数组平均分割 4 次，也就是说，</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164824637.png\" width=\"288\"></p>\n<p>简化后的公式</p>\n<p>类似的，如果有 n 个元素，</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164908192.png\" width=\"301\"></p>\n<p>&nbsp;</p>\n<p>归纳一下</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164916433.png\" width=\"275\"></p>\n<p>分子和分母代入指数</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164930660.png\" width=\"275\"></p>\n<p>等式两边同时乘以 2^k</p>\n<p><img alt=\"\" class=\"has\" height=\"100\" src=\"https://img-blog.csdnimg.cn/20191121164955503.png\" width=\"285\"></p>\n<p>最终结果</p>\n<p>现在来看看「对数」的定义：</p>\n<blockquote>\n<p>为使某数（底数）等于一给定数而必须取的乘幂的幂指数。</p>\n</blockquote>\n\n<p>也就是说可以写成这种形式</p>\n<p><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdnimg.cn/2019112116500667.png\" width=\"331\"></p>\n<p>对数形式</p>\n<p>所以 log n 的确是有意义的，不是吗？没有其他什么可以表示这种行为。</p>\n<p>就这样吧，我希望我讲得这些你都搞懂了。在从事计算机科学相关的工作时，了解这类知识总是有用的（而且很有趣）。说不定就因为你知道算法的原理，你成了小组里能找出问题的最优解的人呢，谁知道呢。祝好运！</p>","tags":["时间复杂度"],"categories":["转载"]},{"title":"链式栈","url":"/blog/2019/12/29/链式栈/","content":"\n### 本次学习要点\n\n1. 编写链式栈\n2. 括号匹配问题\n\n<!--more -->\n\n### 概述\n\n在程序中同时使用多个栈的情况下，使用链式栈不但可以提高存储效率，同时还可以达到共享存储空间的目的。\n\n链式栈的结构如图所示，一般都不使用头结点，而进行直接实现。\n\n<img src=\"链式栈\\结构图.png\" style=\"zoom: 50%;\" />\n\n#### 1. 结点类模板\n\n```c++\ntemplate<typename ElemType>\nstruct Node\n{\n\tElemType data;\n\tNode<ElemType> *next;\n\n\tNode();\n\tNode(ElemType item, Node<ElemType> *link);\n};\ntemplate<typename ElemType>\nNode<ElemType>::Node()\n{\n\tnext = NULL;\n}\ntemplate<typename ElemType>\nNode<ElemType>::Node(ElemType item, Node<ElemType> *link)\n{\n\tdata = item;\n\tnext = link;\n}\n```\n\n#### 2. 链式栈类模板\n\n```c++\ntemplate<typename ElemType>\nclass LinkStack\n{\nprotected:\n\tNode<ElemType> *top;//栈顶指针\n\tint count;//元素个数\n\npublic:\n\tLinkStack();//构造函数\n\tvirtual~LinkStack();//析构函数\n\tint Length() const;//栈的长度\n\tbool Empty() const;//栈是否为空\n\tvoid Clear();//清空栈\n\tvoid Traverse(void(*visit)(const ElemType&)) const;//对每个对象调用visit\n\tbool Push(const ElemType &e);//压栈\n\tbool Top(ElemType &e) const;//返回栈顶元素\n\tbool Pop(ElemType &e);//出栈\n\tLinkStack(const LinkStack<ElemType>&copy);//复制构造函数模板\n\tLinkStack<ElemType>&operator=(const LinkStack<ElemType>&copy);\n};\n```\n\n#### 3. 成员函数\n\n```c++\ntemplate<typename ElemType>\nLinkStack<ElemType>::LinkStack()\n{\n\ttop = NULL;\n\tcount = 0;\n}\ntemplate<typename ElemType>\nLinkStack<ElemType>::~LinkStack()\n{\n\tClear();\n}\ntemplate<typename ElemType>\nint LinkStack<ElemType>::Length() const\n{\n\treturn count;\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Empty() const\n{\n\treturn top == NULL;\n}\ntemplate<typename ElemType>\nvoid LinkStack<ElemType>::Clear()\n{\n\tElemType tmpElem;\n\twhile (!Empty())\n\t{\n\t\tPop(tmpElem);\n\t}\n}\ntemplate<typename ElemType>\nvoid LinkStack<ElemType>::Traverse(void(*visit)(const ElemType &)) const\n{\n\tNode<ElemType> *tmpPtr;\n\tLinkStack<ElemType> tmps;\n\tfor (tmpPtr = top; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\ttmps.Push(tmpPtr->data);\n\t}\n\tfor (tmpPtr = tmps.top; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\t(*visit)(tmpPtr->data);\n\t}\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Push(const ElemType &e)\n{\n\tNode<ElemType> *newTop = new Node<ElemType>(e, top);\n\tif (newTop == NULL)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\ttop = newTop;\n\t\tcount++;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Top(ElemType &e) const\n{\n\tif (Empty())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\te = top->data;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Pop(ElemType &e)\n{\n\tif (Empty())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *old_top = top;\n\t\te = old_top->data;\n\t\ttop = old_top->next;\n\t\tdelete old_top;\n\t\tcount--;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nLinkStack<ElemType>::LinkStack(const LinkStack<ElemType> &copy)\n{\n\t//由栈copy构造新栈——复制构造函数模板\n\tif (copy.Empty())\n\t{\n\t\ttop = NULL;\n\t\tcount = 0;\n\t}\n\telse\n\t{\n\t\ttop = new Node<ElemType>(copy.top->data,copy.top);//栈顶\n\t\tcount = copy.count;\n\n\t\tNode<ElemType> *buttomPtr = top;//栈底\n\t\tfor (Node<ElemType>*tmpPtr = copy.top->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)//从copy中第二个值开始取，第一个已经被复制给top(buttomPtr)\n\t\t{\n\t\t\tbuttomPtr->next = new Node<ElemType>(tmpPtr->data,tmpPtr->next);\n\t\t\tbuttomPtr = buttomPtr->next;\n\t\t}\n\t}\n}\ntemplate<typename ElemType>\nLinkStack<ElemType>&LinkStack<ElemType>::operator=(const LinkStack<ElemType> &copy)\n{\n\t//将栈copy赋值给当前栈——重载赋值运算符\n\tif (&copy != this)\n\t{\n\t\tif (copy.Empty())\n\t\t{\t//copy为空\n\t\t\ttop = NULL;\n\t\t\tcount = 0;\n\t\t}\n\t\telse\n\t\t{\t//copy非空，复制栈\n\t\t\tClear();\n\t\t\ttop = new Node<ElemType>(copy.top->data,copy.top);\n\t\t\tcount = copy.count;\n\n\t\t\tNode<ElemType>*buttomPtr = top;\n\t\t\tfor (Node<ElemType>*tmpPtr = copy.top->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t\t\t{\n\t\t\t\tbuttomPtr->next = new Node<ElemType>(tmpPtr->data,tmpPtr-next);\n\t\t\t\tbuttomPtr = buttomPtr->next;\n\t\t\t}\n\t\t}\n\t}\n\treturn *this;\n}\n```\n\n#### 4. main()\n\n```c++\n#include<iostream>\n#include\"alg.h\"\nusing namespace std;\n\ntemplate<typename ElemType>\nvoid display(ElemType &e)\n{\n\tcout << e << \" \";\n}\n\nint main()\n{\n\tLinkStack<int> l1;\n\tint e1,e2;\n\tcout << \"输入的三个数分别为5，1，2\" << endl;\n\tl1.Push(5);\n\tl1.Push(1);\n\tl1.Push(2);\n\tcout << \"当前栈长为：\" << endl;\n\tcout << l1.Length() << endl;\n\tcout << \"弹出栈顶，返回值为：\" << endl;\n\tl1.Pop(e1);\n\tcout << e1 << endl;\n\tcout << \"当前栈长为：\" << endl;\n\tcout << l1.Length() << endl;\n\tl1.Top(e2);\n\tcout << \"返回当前栈顶元素：\\n\";\n\tcout << e2 << endl;\n\tcout << \"输出l1当前栈内元素(dir:bottom->top)：\\n\";\n\tl1.Traverse(display); cout << endl;\n\n\tLinkStack<int> l2(l1);\n\t//l2 = l1;//将l1复制给l2\n\n\tcout << \"输出l2当前栈内元素(dir:bottom->top)：\\n\";\n\tl2.Traverse(display); cout << endl;\n\treturn 0;\n}\n```\n\n测试结果如图：\n\n<img src=\"链式栈\\结果图.png\" style=\"zoom: 80%;\" />\n\n#### 问题\n\n设计一个算法判别用字符串表示的表达式中括号()[]{}是否配对出现，括号之间无优先级。\n\n算法思路：\n\n如果读入的字符为(、[、{，则进栈；\n\n若读入的字符为)，如果栈空则说明不匹配；栈顶括号为(，则出栈匹配，否则不匹配，此时栈顶为[、{或空；\n\n若读入的字符为]，如果栈空则说明不匹配；栈顶括号为[，则出栈匹配，否则不匹配，此时栈顶为(、{或空；\n\n若读入的字符为}，如果栈空则说明不匹配；栈顶括号为{，则出栈匹配，否则不匹配，此时栈顶为[、(或空；\n\n若读入其他字符，则继续读入；\n\n扫描完各字符后，如栈为空则匹配，否则不匹配（括号数量为偶数，但括号不一定匹配）\n\n代码如下：\n\n```c++\nbool match(char *s)\n{\n\tLinkStack<char> tmps;//临时栈\n\tchar tmpch;//临时字符\n\n\tfor (unsigned int i = 0; i < strlen(s); i++)\n\t{\n\t\tif (s[i] == '(' || s[i] == '[' || s[i] == '{')\n\t\t{\n\t\t\ttmps.Push(s[i]);\n\t\t}\n\t\telse if (s[i] == ')')\n\t\t{\n\t\t\tif (tmps.Empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmps.Top(tmpch), tmpch == '(')\n\t\t\t{\n\t\t\t\ttmps.Pop(tmpch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == ']')\n\t\t{\n\t\t\tif (tmps.Empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmps.Top(tmpch), tmpch == '[')\n\t\t\t{\n\t\t\t\ttmps.Pop(tmpch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '}')\n\t\t{\n\t\t\tif (tmps.Empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmps.Top(tmpch), tmpch == '{')\n\t\t\t{\n\t\t\t\ttmps.Pop(tmpch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (tmps.Empty())\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n```\n\n测试代码：\n\n```c++\ncout << \"无括号优先级\" << endl;\nchar *s1 = \"{a*[c+d*(e+f)]}\";\nchar *s2 = \"{a*[c+d*[e+f)]}\";\nstring True = \"匹配\";\nstring False = \"不匹配\";\nstring s1_result = match(s1) ? True : False;\nstring s2_result = match(s2) ? True : False;\ncout << s1 << '\\t';\ncout << s1_result << endl;\ncout << s2 << '\\t';\ncout << s2_result << endl;\n```\n\n运行结果：\n\n<img src=\"链式栈\\匹配问题.png\"  />\n\n","categories":["算法与数据结构"]},{"title":"循环链表解决约瑟夫问题","url":"/blog/2019/11/18/循环链表解决约瑟夫问题/","content":"\n### 本次学习要点\n\n1. 编写循环链表，由单链表修改得到\n2. 使用循环链表解决约瑟夫问题\n\n<!--more -->\n\n### 循环链表与单链表的不同之处\n\n循环链表是另外一种线性表链式存储结构，它的节点结构与单链表相同，与单链表不同的是在循环链表中的表尾节点的`next`不为空（NULL），而是指向头节点，所以循环链表为空的条件为`head->next==head`,如图所示：\n\n<img src=\"循环链表解决约瑟夫问题\\非空循环链表.png\" style=\"zoom: 67%;\" />\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a)非空循环链表\n\n<img src=\"循环链表解决约瑟夫问题\\空循环链表.png\" style=\"zoom: 67%;\" />\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(b)空循环链表\n\n循环链表的操作与线性表的操作基本相同，只是将算法中的循环条件改为`temPtr`是否等于头指针，以下给出与单链表不同之处：\n\n```c++\ntemplate<typename ElemType>\nNode<ElemType> * SimpleCircLinkList<ElemType>::GetElemPtr(int position) const\n//返回指向第position个结点的指针,时间复杂度O(n)\n{\n\tif (position == 0)\n\t{\n\t\treturn head;\n\t}\n\t\n\tNode<ElemType> *tmpPtr = head->next; //用tmpPtr遍历线性表以查找第position个结点\n\tint pos = 1;\t\t\t\t\t//tmpPtr所指结点的位置\n\n\twhile (tmpPtr != head&&pos < position)\n\t{\t//顺指针向后查找，直到tmpPtr指向第position个结点\n\t\ttmpPtr = tmpPtr->next;\n\t\tpos++;\n\t}\n\tif (tmpPtr != head&&pos == position)\n\t{\t//查找成功\n\t\treturn tmpPtr;\n\t}\n\telse\n\t{\t//查找失败\n\t\treturn NULL;\n\t}\n}\n```\n\n```c++\ntemplate<typename ElemType>\nint SimpleCircLinkList<ElemType>::Length() const\n//返回线性表元素的个数\n{\n\tint count = 0;\n\tfor (Node<ElemType> *tmpPtr = head->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\tcount++;\n\t\tif (tmpPtr == head) break;\n\t}\n\treturn count;\n}\n```\n\n```c++\ntemplate<typename ElemType>\nbool SimpleCircLinkList<ElemType>::Empty() const\n//如果线性表为空，返回true，否则返回false\n{\n\treturn head->next == head;\n}\n```\n\n```C++\ntemplate<typename ElemType>\nvoid SimpleCircLinkList<ElemType>::Traverse(void(*visit)(const ElemType &)) const\n//依次对线性表每个元素调用函数(*visit)\n{\n\tfor (Node<ElemType> * tmpPtr = head->next; tmpPtr != head; tmpPtr = tmpPtr->next)\n\t{\n\t\t(*visit)(tmpPtr->data);\n\t}\n}\n```\n\n### 循环列表解决与瑟夫问题\n\n问题描述：一个旅行社要从n个旅客中选出一名旅客，为他提供免费旅行服务，选择方法是让n个旅客围成一个圆圈，然后从信封中取出一张纸条，用上面写着的正整数m(m<n)作为报数值，第一个人从1开始一个人一个人按顺时针报数，报到第m个旅客时，令其出列。然后从下一个人开始，从1顺时针报数，报到第m个游客时，再令其出列，如此下去，直到只剩下一个人为止。此人即为优胜者。如n=8，m=3，出列的顺序为3、6、1、5、2、8、4，最初编号为7的游客获得免费旅行服务。（待更新算法详细步骤）\n\n```\n//main.cpp\n#include<iostream>\n#include\"alg.h\"\n\nusing namespace std;\n\ntemplate<typename ElemType>\nvoid display(ElemType &e)\n{\n\tcout << e << \" \";\n}\n//循环链表解决约瑟夫问题\nint main()\n{\n\tSimpleCircLinkList<int> la;\n\tint n = 8, m = 3;\n\tint position = 1;\n\tint out, winer;\n\tfor (int k = 1; k <= n; k++)\n\t{\n\t\tla.Insert(k, k);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tif (position > la.Length())\n\t\t\t{\n\t\t\t\tposition = 1;\n\t\t\t}\n\t\t\tposition++;\n\t\t}\n\t\tposition--;\n\t\tla.Delete(position, out);\n\t\tcout << out << \" \";\n\t}\n\t\tla.GetElem(1, winer);\n\t\tcout << endl << \"优胜者：\" << winer << endl;\n\t\treturn 0;\n}\n```\n\n执行结果：\n\n<img src=\"循环链表解决约瑟夫问题\\结果.png\"  />\n\n","categories":["算法与数据结构"]},{"title":"单链表的基本操作","url":"/blog/2019/10/30/单链表的基本操作/","content":"\n### 本次学习要点（更新于2019.12.3）\n\n1. 掌握线性表的抽象数据类型\n2. 掌握链表的基本操作\n3. 学习链表的较复杂的操作\n\n<!--more -->\n\n### 线性表的抽象数据类型\n\n1. `int Length() const`\n\n* 初始条件：线性表已存在\n* 操作结果：返回线性表中元素的个数\n\n2. `bool Empty() const`\n\n* 初始条件：线性表已存在\n* 操作结果：判断线性表是否为空\n\n3. `void Clear()`\n\n* 初始条件：线性表已存在\n* 操作结果：清空线性表\n\n4. `void Traverse(void(*visit)(const ElemType &))`\n\n* 初始条件：线性表已存在\n* 操作结果：对每个元素调用函数(*visit)\n\n5. `bool GetElem(int position,ElemType &e) const`\n\n* 初始条件：线性表已存在，1<=position<=Length()\n* 操作结果：用e返回第position处的元素值\n\n6. `bool SetElem(int position,const ElemType &e) `\n\n* 初始条件：线性表已存在，1<=position<=Length()\n* 操作结果：设置第position处的元素值为e\n\n7. `bool Delete(int position,ElemType &e)`\n\n* 初始条件：线性表已存在，1<=position<=Length()\n* 操作结果：删除第position个元素，并用e返回其值，长度减少1\n\n8. `bool Insert(int position,const ElemType &e)`\n\n* 初始条件：线性表已存在，1<=position<=Length()+1\n* 操作结果：在第position前插入元素e，长度加1\n\n#### 思考\n\n函数声明中的`const`是什么作用？在不同位置的意思分别是什么？\n\n答：在成员函数后的`const`指常成员函数，不能更改类成员变量的值；在变量前的`const`指常变量，在函数体重不能更改变量值。\n\n### 单链表的实现\n\n```c++\n//文件名alg.h\n//结点结构体模板\ntemplate<typename ElemType>\nstruct Node\n{\n//数据成员\n\tElemType data;\n\tNode<ElemType> *next;\n//构造函数模板\n\tNode();//无参数的构造函数模板\n\tNode(ElemType item, Node<ElemType> *link);//已知数据元素和后继指针建立结构\n};\n//结点模板的实现部分\ntemplate<typename ElemType>\nNode<ElemType>::Node()\n//构造后继指针为空的结点\n{\n\tnext = NULL;\n}\ntemplate<typename ElemType>\nNode<ElemType>::Node(ElemType item, Node<ElemType> *link)\n//构造一个数据元素为item和后继指针为link的结点\n{\n\tdata = item;\n\tnext = link;\n}\n//线性链表简单实现为数据成员只有头指针，成员函数模板与顺序表相似\n\n\n//简单线性链表类模板\ntemplate<typename ElemType>\nclass SimpleLinkList\n{\nprotected:\n\tNode<ElemType> *head;\n\tNode<ElemType> *GetElemPtr(int position) const;//返回指向第position个结点的指针\npublic:\n\tSimpleLinkList();\n\tvirtual~SimpleLinkList();\n\tint Length() const;\n\tbool Empty() const;\n\tvoid Clear();\n\tvoid Traverse(void(*visit)(const ElemType &)) const;\n\tbool GetElem(int position, ElemType &e) const;\n\tbool SetElem(int position, const ElemType &e);\n\tbool Delete(int position, ElemType &e);\n\tbool Insert(int position, const ElemType &e);\n\tSimpleLinkList(const SimpleLinkList<ElemType> &copy);\n\tSimpleLinkList<ElemType>&operator=(const SimpleLinkList<ElemType>&copy);\n};\n\n//辅助函数模板的实现\t\ntemplate<typename ElemType>\nNode<ElemType> * SimpleLinkList<ElemType>::GetElemPtr(int position) const\n//返回指向第position个结点的指针,时间复杂度O(n)\n{\n\tNode<ElemType> *tmpPtr = head; //用tmpPtr遍历线性表以查找第position个结点\n\tint pos = 0;\t\t\t\t\t//tmpPtr所指结点的位置\n\n\twhile (tmpPtr != NULL&&pos < position)\n\t{\t//顺指针向后查找，知道tmpPtr指向第position个结点\n\t\ttmpPtr = tmpPtr->next;\n\t\tpos++;\n\t}\n\tif (tmpPtr != NULL&&pos == position)\n\t{\t//查找成功\n\t\treturn tmpPtr;\n\t}\n\telse\n\t{\t//查找失败\n\t\treturn NULL;\n\t}\n}\n\n//成员函数的实现\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>::SimpleLinkList()\n//构造一个空链表\n{\n\thead = new Node<ElemType>;\n}\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>::~SimpleLinkList()\n//销毁线性表\n{\n\tClear();\n\tdelete head;\n}\ntemplate<typename ElemType>\nint SimpleLinkList<ElemType>::Length() const\n//返回线性表元素的个数\n{\n\tint count = 0;\n\tNode<ElemType> *tmpPtr;\n\tfor (tmpPtr = head->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\tcount++;\n\t}\n\treturn count;\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::Empty() const\n//如果线性表为空，返回true，否则返回false\n{\n\treturn head->next == NULL;\n}\ntemplate<typename ElemType>\nvoid SimpleLinkList<ElemType>::Clear()\n//清空线性表\n{\n\tElemType tmpElem;\n\twhile (!Empty())\n\t{\t//线性表非空，删除第一个元素\n\t\tDelete(1, tmpElem);\n\t}\n}\ntemplate<typename ElemType>\nvoid SimpleLinkList<ElemType>::Traverse(void(*visit)(const ElemType &)) const\n//依次对线性表每个元素调用函数(*visit)\n{\n\tfor (Node<ElemType> * tmpPtr = head->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\t(*visit)(tmpPtr->data);\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::GetElem(int position, ElemType &e) const\n//当线性表存在第position给元素时，用e返回其指，返回true，否则\n//返回false\n{\n\tif (position<1 || position>Length())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> * tmpPtr;\n\t\ttmpPtr = GetElemPtr(position);\n\t\te = tmpPtr->data;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::SetElem(int position, const ElemType &e)\n//将线性表的第position个位置的元素设置成e，position合法时返回true，否则\n//返回false\n{\n\tif (position<1 || position>Length())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *tmpPtr;\n\t\ttmpPtr = GetElemPtr(position);\n\t\ttmpPtr->data = e;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::Delete(int position, ElemType &e)\n{\n\tif (position<1 || position>Length())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *tmpPtr;\n\t\ttmpPtr = GetElemPtr(position - 1);//取出指向第position-1个结点的指针\n\t\tNode<ElemType> *nextPtr;          //新建指针nextPtr\n\t\tnextPtr = tmpPtr->next;           //新指针为tmpPtr的后继\n\t\ttmpPtr->next = nextPtr->next;     //删除position处的结点\n\t\te = nextPtr->data;                //用e返回其值\n\t\tdelete nextPtr;                   //释放被删结点\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::Insert(int position, const ElemType &e)\n{\n\tif (position<1 || position>Length() + 1)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *tmpPtr;\n\t\ttmpPtr = GetElemPtr(position - 1);\n\t\tNode<ElemType> *nextPtr;\n\t\tnextPtr = new Node<ElemType>(e, tmpPtr->next);\n\t\ttmpPtr->next = nextPtr;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>::SimpleLinkList(const SimpleLinkList<ElemType> &copy)\n{\n\t//未写\n}\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>&SimpleLinkList<ElemType>::operator=(const SimpleLinkList<ElemType>&copy)\n{\n\t//未写\n}\n\n```\n\n```c++\n//文件名main.cpp\n//单链表的基本操作\n#include<iostream>\n#include\"alg.h\"\n\nusing namespace std;\n\ntemplate<typename ElemType>\nvoid display(ElemType &e)\n{\n\tcout << e << \" \";\n}\n\nint main()\n{\n\tSimpleLinkList<int> test;//定义空链表\n\tSimpleLinkList<int> test1;//定义空链表\n\tint e = 0;//返回值\n\tint e1 = 50;\n\tint n = 8;\n\tfor (int k = 1; k <= n; k++)//建立链表\n\t{\n\t\ttest.Insert(k, k);\n\t}\n\tcout << \"建立的链表:\";\n\ttest.Traverse(display);//显示数据\n\tcout << endl;\n\n\tcout << \"链表的长度为:\";\n\tcout << test.Length() << endl;\n\n\tcout << \"链表是否为空(0代表非空):\";\n\tcout << test.Empty() << endl;\n\n\tcout << \"返回第五个位置的值(5)(GetElem):\";\n\ttest.GetElem(5, e);//返回第五个值\n\tcout << e << endl;\n\n\tcout << \"设置第五个位置的值(50)(SetElem):\";\n\ttest.SetElem(5, e1);//设置第五个值为e1;\n\tcout << e1 << endl;\n\n\tcout << \"输出当前的链表:\";\n\ttest.Traverse(display);//显示数据\n\tcout << endl;\n\t\n\tcout << \"删除第5个元素:\";\n\ttest.Delete(5, e);\n\tcout << \"删除的元素值为:\" << e << endl;\n\n\tcout << \"链表的长度为:\";\n\tcout << test.Length() << endl;\n\n\tcout << \"输出当前的链表:\";\n\ttest.Traverse(display);//显示数据\n\tcout << endl;\n\n\tcout << \"清空线性表(Clear)\";\n\ttest.Clear();\n\tcout << endl;\n\n\tcout << \"链表是否为空(0代表非空):\";\n\tcout << test.Empty() << endl;\n\n\treturn 0;\n}\n```\n\n执行结果：\n\n<img src=\"单链表的基本操作\\基本操作.png\" style=\"zoom: 50%;\" />\n\n### 一个问题\n\n已知线性表la和lb中的数据元素按值递增，现在要将la和lb合并成新的线性表lc，使lc中的数据元素扔递增有序。","categories":["算法与数据结构"]},{"title":"Git的基本使用(三)-Stash、Checkout和Reset（未完待续）","url":"/blog/2019/10/08/Git的基本使用-Stash、Checkout和reset/","content":"\n### 本次学习要点\n\n`Stash、Checkout`和`Reset`指令\n\n经常有这样的事情发生，当你正在进行项目中某一部分的工作，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点，所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 `git stash`。\n\n<!--more -->\n\n### 基本指令-stash\n\n```\ngit stash \n#保存当前工作区所有内容到当前分支的储藏栈的栈顶(工作区会变为最后一次commit时的内容)。\ngit stash apply \n#应用当前分支的储藏栈栈顶的储藏到工作区。\ngit stash apply <stash id> \n#应用当前分支的储藏栈指定位置的储藏到工作区，例如git stash apply stash@{0}。\ngit stash list \n#列出当前分支的储藏栈详细信息。\ngit stash drop <stash id> \n#移除当前分支的储藏栈指定位置的储藏。\ngit stash pop\n#从git栈中获取到最近一次stash进去的内容，恢复工作区的内容，获取之后，会删除栈中对应的stash。\n```\n\n- 唯一需要注意的是，`git stash apply`并不会改变储藏栈的内容，所以如果你觉得之前的那个储藏没用了，请手动调用`git stash drop <stash id>`清理储藏栈。特别的，`git stash pop`会自动应用当前分支的储藏栈栈顶的储藏到工作区，并将其从栈顶移除。\n\n#### 练习一\n\n1. 新建一个仓库，建立文件`test.txt`，随意键入一段内容（123），提交。\n2. 创建分支`feature`，修改`test.txt`文件内容（321）然后运行`git status`可以看到以下中间过程的内容：\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n3. 现在你想切换分支，但是你还不想提交你正在进行中的工作；所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 `git stash`。\n\n```\n$ git stash\nSaved working directory and index state WIP on master: 7ac5b3d master注释\n#test.txt中的内容变成了“123”，工作区内容变为最后一次提交的内容\n```\n\n4. 这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 `git stash list`：\n\n```\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\n```\n\n5. 切换到分支`feature`并且使用指令`git stash pop`，观察`test.txt`中的内容变化。\n\n```\n$ git stash pop\nOn branch feature\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (81b72af21b8037e4b185820e3a86b78d95b9f8d8)\n#文档内容变成了“321”，也就是master修改后的工作区，但现在pop命令把储藏的栈顶弹出，是在feature分支进行工作的，此时feature的工作区是修改后的文档。\n```\n\n6. 再次使用指令`git stash`，然后`git checkout master`，再次使用`git stash pop`，那么修改后的文档就是在`master`工作区了，最后直接查看工作区状态。\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n#### 练习二\n\n在练习一基础上使用`apply`指令：\n\n1. 当前工作区为`master`，`test.txt`中的内容是修改后的321，使用`stash`指令存储当前的工作区。\n\n```\n$ git stash\nSaved working directory and index state WIP on master: 7ac5b3d master注释\n\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\n```\n\n2. 此时`test.txt`内容为（123），修改其内容（1234），然后进行`add`（不进行此操作也可以），再进行一次存储。\n\n```\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\nstash@{1}: WIP on master: 7ac5b3d master注释\n#现在堆栈里存储了两个工作区，工作区空\n$ git status\nOn branch master\nnothing to commit, working tree clean\n#test.txt中内容变为“123”\n```\n\n3. 使用`apply`指令将堆栈中的栈顶应用到当前工作区，当前的栈顶应该是`stash@{0}`，所以内容应该恢复为“1234”。\n\n```\n$ git stash apply\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n#打开test.txt发现内容已经变回“1234”\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\nstash@{1}: WIP on master: 7ac5b3d master注释\n#堆栈中的内容不会主动删除，继续保存下来\n```\n\n4. 修改`test.txt`中的“1234”为“123”（初始工作区），然后使用`git stash apply`指令将栈中的`stash@{1}`（修改后的工作区，内容是“321”）返回到工作区，此时文档内容是“321”。\n\n```\n$ git stash apply stash@{1}\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n#test.txt中的内容是“321”\n```\n\n#### 一些标注\n\n##### 练习一\n\n初始工作区的`test.txt`内容为：123\n\n第一次修改后的`test.txt`内容为：321\n\n最后`master`中的`stash@{0}`内容为：321\n\n##### 练习二\n\n初始`master`中的`stash@{0}`内容为：321\n\n修改初始的工作区中的`test.txt`内容为：1234\n\n进行存储，`stash@{0}->stash@{1}`，内容为：321\n\n此时`stash@{0}`中的内容为：1234\n\n本次练习最后结果改回了“1234”。","tags":["Git"],"categories":["Git"]},{"title":"Git的基本使用(二) --撤销提交","url":"/blog/2019/09/29/Git的基本使用-撤销提交/","content":"\n### 本次学习要点：\n\nGit的撤销提交操作\n\n与回滚不同，如果认为某次的提交是有问题的，需要撤回这次的提交，应该怎么做呢？\n\n<!-- more -->\n\n### 主要指令\n\n```\n$ git revert <SHA ID>\n```\n\n该指令可以直接把某一次的提交取消，所有在本次提交中发生变更的文件都会还原回上一次提交的内容。因为针对同一分支master操作，所以会产生冲突（解决方法见一），解决冲突后，再将文件放入缓存区，进行提交.\n\n```\n$ git reset <之前某个版本ID>\n$ git reset --hard <之前某个版本ID>\n```\n\n上述指令是不安全的撤销方式。当年使用`git reset`来重置记录时，所有**在此之后**的记录都将永久消失，**但是还会保留当前的提交**。如果带上参数`--hard`，还会直接清空工作区里的所有变更（**如果此时做了修改但是还没有提交，那么直接就会被撤销到未改动的时刻**），直接使工作区内容撤销到指定提交的时刻，是一种比较暴力的撤销方式。\n\n### 实现1\n\n1. 新建一个库，新建一个文件`text.txt` ，输入内容“1”，保存后提交。并以此类推，一共得到三次提交，内容分别是“1”，“2”，“3”，使用`git log`查看提交历史。\n\n```\n$ git log\ncommit 51df17687ea6bb6a53ed24d614ddcfe9e455e9f9\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:47:24 2019 +0800\n\n    3.第三次提交\n    sign off:<543040659@qq.com>\n\ncommit 9e71ea1c78ff7aa910959e02acb44e8e3373a805\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:46:38 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 3d4d2f3a3f44c0fcb5d4357d85abf5cb33304e97\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:45:09 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n2. 使用`git revert`进行撤销操作，撤销到第二次提交，那么结果应该是显示第一次提交的内容，即“1”。\n\n```\n$ git revert 9e71ea\n```\n\n3. 此时产生了冲突，打开`test.txt`，将第三次的提交内容删除，留下内容“1”，不解决冲突无法提交。然后再加入缓存区，进行提交（当时没有记录，这里只有进行操作的指令，没有结果，失策失策）。\n\n```\n$ git add test.txt\n$ git status\t#可以看到test.txt加入了缓存，可以不写\n$ git commit\n```\n\n4. 最后使用`git log`查看提交记录，会产生一个新的提交记录，并且之前记录都会存在，所以是一种安全的撤销操作。\n\n```\n$ git log\ncommit 57124efed6dd52b7224c3e3b5ee0be7042cee27b (HEAD -> master)\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:50:18 2019 +0800\n\n    Revert \"2.第二次提交\"\n\n    This reverts commit 9e71ea1c78ff7aa910959e02acb44e8e3373a805.\n\ncommit 51df17687ea6bb6a53ed24d614ddcfe9e455e9f9\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:47:24 2019 +0800\n\n    3.第三次提交\n    sign off:<543040659@qq.com>\n\ncommit 9e71ea1c78ff7aa910959e02acb44e8e3373a805\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:46:38 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 3d4d2f3a3f44c0fcb5d4357d85abf5cb33304e97\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:45:09 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n总结：revert指令可以使版本撤销到之前的某一次提交，并且在那次提交中改变的部分都会还原为上一次提交的内容（比如撤销到第二次，那么内容就会还原为第一次提交的内容），并且在这个过程中会产生冲突，按照我的理解，产生冲突之后修改的txt文档，决定了还原的最终结果。如果我在解决冲突的过程中，留下了“3”，而不是“1”，那么还原的内容应该是“3”。\n\n### 实现2\n\n1. 新建一个库，新建一个文件`text.txt` ，输入内容“1”，保存后提交。并以此类推，一共得到三次提交，内容分别是“1”，“2”，“3”，使用`git log`查看提交历史。\n\n```\n$ git log\ncommit 9e541291495cfe4c57b62f699ff17deed99bd853 (HEAD -> master)\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:56:32 2019 +0800\n\n    3.第三次提交\n    sign off:<543040659@qq.com>\n\ncommit 1d0feb4e586995b4d1bd6e3d78af5350b2726b68\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:55:37 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 47bbd152043e6f2de771413739b2fccadad6893d\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:54:36 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n2. 使用`git reset`进行撤销操作1。先改变`test.txt`中的内容，开始应为“3”，现在可以任意改变，假如改为“5”，然后执行指令（撤销到第三次），并得到以下结果：\n\n```\n$ git reset 9e5412\nUnstaged changes after reset:\nM       test.txt\n```\n\n执行的结果就是`test.txt`文档中的”5”又变成了“3”，成功！\n\n3. 使用`git reset`进行撤销操作2。直接执行指令撤销到第二次，得到以下结果：\n\n```\n$ git reset 1d0fe\nUnstaged changes after reset:\nM       test.txt\n#再执行git log指令\n$ git log\ncommit 1d0feb4e586995b4d1bd6e3d78af5350b2726b68 (HEAD -> master)\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:55:37 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 47bbd152043e6f2de771413739b2fccadad6893d\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:54:36 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n可以发现第三次的提交已经没有了，所以是一种不安全的撤销，此时`test.txt`中应为“2”，如果你此时修改了文档中的内容，再执行以上步骤，文档中的内容修改会被继续保留下来，与下面的有所不同。\n\n4. 使用`git reset --hard`进行撤销操作。如前所述，此指令会直接撤销到**当前提交时刻的原始版本**（以撤销到第二次为例）。\n\n```\n$ git reset --hard 1d0feb\nHEAD is now at 1d0feb4 2.第二次提交\n```\n\n我们一开始在第二次提交时，里面的内容就是“2”，现在执行上述指令后，`test.txt`中就是“2”。如果把`test.txt`中的内容修改为“5”，甚至你已经进行add指令加入到了缓存，但是没有提交，那么再次执行上述hard指令后，文档中的内容又变成了“2”，你之前的所有修改都白费了，所以要特别小心，慎用！\n\n## 最后\n\n这次的练习收获很多，不过只是很浅显的一些理解，不免有些理解不到位或者容易产生歧义的地方。如果有哪里有疑问，可以和我联系进行讨论。\n\n","tags":["Git"],"categories":["Git"]},{"title":"Git的基本使用(一)","url":"/blog/2019/09/26/Git的基本使用（一）/","content":"\n### 本次学习要点：\n\n1. 如何建立一个本地仓库\n2. 设置你的个性化信息\n3. 工作区与缓存区\n\n4. 提交与历史\n\n<!--more -->\n\n### 如何建立一个本地仓库\n\n有两种方法，一种是Git GUI，一种是Git Bush，第一步都是先建立一个空文件夹。\n\n1. 在文件夹空白处右键，选择Git GUI Here，点击Create New Repository，OK。\n2. 在文件夹空白处右键，选择Git Bush Here，输入`git init`，OK。\n\n### 设置你的个性化信息\n\nGit是一个团队开发工作，你对团队的每次贡献都会有相应的记录。所以此时你应该告诉这个仓库你的个人信息，主要包括两个：\n\n- **邮箱** 邮箱是别人联系你的途径，当然你应当留意你的个人隐私问题，这个内容我们会放到之后的几章中讲，此处你可以随便填写一个邮箱。\n- **姓名** 你可以填真名或是化名，取决于你的实际开发和协作环境。\n\n1. 打开Git Bash界面，我们输入指令`git config --help`来查看`git config`的帮助文档。【–help】是一个很有用的指令参数，当你忘了某个指令的使用方法，你都可以如此进行搜寻。\n2. 我们可以看到如此一行：\n\n```\nuser.email\n\tYour email address to be recorded in any newly created commits. \n\tCan be overridden by the GIT_AUTHOR_EMAIL, GIT_COMMITTER_EMAIL, \n\tand EMAIL environment variables. See git-commit-tree(1).\n```\n\n* 使用`git config user.email <你的Email>`进行邮箱的设置。同样的，`git config user.name <你的名字或化名>`可以设置该本地仓库的所有者姓名。\n\n* 当你设置完这些值之后，可以打开`.gti/config`，查看到你刚刚所设置邮箱和姓名。\n\n### 工作区与缓存区\n\n<img src=\"Git的基本使用（一）\\GitFlow.jpg\" style=\"zoom:50%;\" />\n\n​                                                            上图来源于西电腾讯TIC-Git的培训资料\n\nGit的基本工作流程，目前阶段我们需要知道三个区域：**工作区域**、**缓存区**和**仓库记录**。其中，仓库记录是由**历史记录**构成的，因为历史纪录是一棵树状结构，也被叫做(History Tree)。\n\n- 用户在工作区域(或工作目录)中进行的修改会被Git检测到，通过`add`指令被提交到缓存区。\n- 缓存区中的文件是工作区域中的文件的一次快照备份，你之后在工作区域中做任何修改都不会影响到缓存区中同一个文件的内容，除非再次使用`add`指令更新缓存区。\n- 当你觉得工作做得差不多了，你可以使用`commit`指令，把缓存区中的文件提交到仓库记录，仓库记录会自动生成一次历史记录。你可以简单认为仓库记录就是个数据库，一次`commit`指令就是一次数据库写入请求。从此之后该记录将一直留在仓库中，你也可以把工作区中的数据文件随时回滚到当时提交的这个版本。\n- 缓存区中的文件在并未被`commit`之前，并不会被写入记录，也就意味着有些操作会导致你丢失缓存区的文件快照备份(如`checkout`等)。\n\n```\ngit add <filename>\n#添加文件至缓存区\ngit status\n#查看当前缓存区的状态\ngit commit\n#将缓存区的文件提交到仓库\n```\n\n### 提交与历史\n\n* 打开Git Bash，键入`git log`，即可查看提交的历史纪录。如果对当前提交不满意，找到上一次提交的版本ID值(SHA ID)，键入命令`git checkout <SHA ID>`，此时版本便已回滚到了之前那个版本，当前的提交会直接删除掉。\n\n* 在Vim界面中，按字母a来进入编辑模式，编辑完毕后按ESC键退出编辑，再按大写锁定，按ZZ来退出Vim。\n\n编辑模板\n\n提交了xxxx\n\n来自：Zxy<<543040659@qq.com>>","tags":["Git"],"categories":["Git"]},{"title":"Sublime Text3安装Emmet插件遇到的问题及解决","url":"/blog/2019/09/16/Sublime-text3安装Emmet插件遇到的问题及解决/","content":"\n# 写在前面\n\n最近对前端的知识准备进行一个入门，首先学习一下html文档的写法，第一步就是选择一个合适的开发工具。<!-- more -->当然，html文件也可以用记事本的方式进行编写，不过在尝试了记事本编写之后还是放弃了，缩进或者格式都得自己来，无疑是给自己徒增烦恼。\n\n在进行一番查看之后，选择了Sublime Text3这款工具来编写html文件，这款工具目前也比较流行，具体的好处就是可以带很多插件，提高你写代码的效率。这里附上ST3的下载网址：\n\nhttp://www.sublimetext.com/3\n\n# 为什么使用Emmet这个插件？\n\n在没有安装Emmet之前，Sublime Text的使用貌似和记事本没有什么不同，也是得自己写结构，区别就是颜色好看了些，而安装了Emmet之后就不同了，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度，可以直接使用 !+tab 快速得到一个标准的html5文档，如下图所示：\n\n<img src=\"Sublime-text3安装Emmet插件遇到的问题及解决\\ST界面.png\" style=\"zoom:50%;\" />\n\n# 安装Emmet插件\n\n这里已经默认你安装了Package Control，这个组件是用来安装/删除插件和其他一些功能要用到的（目前我就用到了安装和删除两个功能）。\n\n## 自动安装法\n\n这个方法就是看你运气，不过过程一定是正确的，但由于各种原因（墙、网络之类的）安装不成功的大有人在，所以先写一下自动安装法。\n\n1. 在Sublime Text3的主页面按**CTRL+SHIFT+P**打开Package Control\n2. 输入**install**，选择第一个回车\n3. 这时候会让你选择需要安装的插件，你输入**Emmet**，选择第一个回车即可\n4. 左下角会显示下载PyV8，在提示**PyV8 binary successfully loaded**即安装完成\n5. 重启Sublime Text3，安装完成！\n\n当然，一般人像我运气一样的，这样是成功不了的（坏笑）。\n\n## 手动安装法\n\n### 1.安装PyV8\n\n在你安装Emmet时，你可能出现下面这种错误提示：\n\n***Sublime Text Error while loading PyV8 binary: exit code 1 Try to manually install Pyv8 form https://github.com/emetio/pyv8-binaries***\n\n出现这种情况的原因就是下载PyV8这个包不成功，那么你就得手动去下载，这个里也把网址给你了，如下：https://github.com/emmetio/pyv8-binaries 选择合适你电脑的版本去下载，这个必须记住，不然可能会用不了，我第一次就犯了这个错误。因为我电脑装了python3.7，所以我选择了 **pyv8-win64-p3**，我把下载地址也贴出来，不过因为gtihub是国外的网站，所以下载会很慢，链接如下：\n\nhttps://github.com/emmetio/pyv8-binaries/raw/master/pyv8-win64-p3.zip\n\n下载好了之后，对它进行解压，得到下面这个文件：\n\n<img src=\"Sublime-text3安装Emmet插件遇到的问题及解决\\pyv8.png\" style=\"zoom:80%;\" />\n\n接下来按照以下的步骤做就ok了：\n\n1. 打开Sublime Text\n2. 依次选择首选项 -> 浏览插件目录（我的汉化了，不然是Preferences ->Browse Packages）\n3. 新建PyV8文件夹\n4. 在PyV8文件夹把上图中的文件复制过来\n5. 重启Sublime Text\n\n现在你就可以在ST3中使用Emmet的功能了，不过还有运气不好的人，还是不能用，比如说我，那么继续往下看。\n\n### 2.手动安装Emmet\n\n如果你还是无法使用Emmet，但是你在首选项菜单中的Package Settings还能看到Emmet的身影，然而那只是个空壳，继续进入插件目录，你会发现没有与Emmet相关的文件夹的存在，那么你就需要自己手动安装Emmet。下载地址如下（下载也比较慢，但是只有200k左右）：\n\nhttps://codeload.github.com/sergeche/emmet-sublime/zip/master\n\n下载好了之后，继续进入插件目录（首选项 -> 浏览插件目录），把解压后的文件放进去，如图：\n\n<img src=\"Sublime-text3安装Emmet插件遇到的问题及解决\\emmet.png\" style=\"zoom:50%;\" />\n\n接下来你再重启ST就行了，需要注意的是，如果你没有装PyV8，那么你打开ST之后它会自动再一次下载这个包，同样可能出现1中的问题，那么你可以先把PyV8装好，再手动安装Emmet，重启之后就大功告成，终于装好啦！我属于运气最差的那种，不好的都让我遇到了，刚接触花了几个小时才弄明白，虽然最后成功了，我还是流下了没有技术的眼泪。。。","categories":["前端"]},{"title":"一个测试文档","url":"/blog/2019/09/06/一个测试文档/","content":"\n目前没有特别需要写的东西，就收藏几个网站，便于之后写文章时查阅语法\n\n<!-- more -->\n\n参考网站：\n\n[1]https://www.jianshu.com/p/56d99a3049a5\n\n[2]https://blog.csdn.net/u014061630/article/details/81359144\n\n记录一下: [我的博客](https://www.xingyuzhao.ltd)\n\n**使用该`<!-- more -->`标志来控制文章的摘要预览，因为这种方式可以让摘要也按照css文件中的样式来渲染。如果使用了自动摘要的功能，你会发现文章摘要是一大团没有样式的文本，很是难看。**\n\n","tags":["Markdown语法"],"categories":["Hexo"]},{"title":"使用hexo遇到的问题及解决方案","url":"/blog/2019/09/05/使用hexo遇到的问题及解决方案/","content":"使用hexo遇到的问题及解决\n\n<!-- more -->\n\n#### 上传步骤\n\n1. hexo generate\n2. hexo server (http://localhost:4000/)\n3. hexo deploy\n\n#### 公式的显示问题\n\n公式内换行使用`//`时，会被识别成转义字符，需要再加上`//`，故需要使用`////`。\n\n如果使用**kramed**对公式进行渲染，会导致序号的显示出现问题，所以又改了回来，继续使用**marked**。","categories":["Hexo"]}]