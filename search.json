[{"title":"LeetCode839-相似字符串组","url":"/blog/2021/01/31/LeetCode839-相似字符串组/","content":"\n#### 题目描述\n\n如果交换字符串 `X` 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 `X` 和 `Y` 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。\n\n例如，`\"tars\"` 和 `\"rats\"` 是相似的 (交换 `0` 与 `2` 的位置)； `\"rats\"` 和 `\"arts\"` 也是相似的，但是 `\"star\"` 不与 `\"tars\"`，`\"rats\"`，或 `\"arts\"` 相似。\n\n总之，它们通过相似性形成了两个关联组：`{\"tars\", \"rats\", \"arts\"}` 和 `{\"star\"}`。注意，`\"tars\"` 和 `\"arts\"` 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。\n\n给你一个字符串列表 `strs`。列表中的每个字符串都是 `strs` 中其它所有字符串的一个字母异位词。请问 `strs` 中有多少个相似字符串组？\n\n<!-- more-->\n\n<img src=\"LeetCode839-相似字符串组\\839.png\"  />\n\n**备注：**\n\n​\t字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。\n\n#### 思路\n\n本题如果理解了题目的意思，就不难。\n\n**给你一个字符串列表 `strs`。列表中的每个字符串都是 `strs` 中其它所有字符串的一个字母异位词**。再结合备注可知：所有的字符串都是由**相同的字母**组成，无非就是字母顺序不一样罢了。\n\n题目要求**相似**的字符串为一组，何为相似？有两种情况：\n\n1. 两个字符串相同。\n2. 其中一个字符串交换一对字母后与另一字符串相同。\n\n**如何操作**？\n\n使用一个变量统计两个字符串对应位置字母不相同的个数。如果计数等于 0 或者 2，说明这两个字符串是相似的，使用并查集进行合并即可。\n\n返回合并后的连通集数就是最终答案。\n\n#### 代码\n\n暴力遍历即可。35% 99%\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        parent[pRoot] = qRoot;\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int numSimilarGroups(vector<string>& strs) {\n        int n = strs.size();\n        int len = strs[0].size();\n        unionFind uf(n);\n        for(int i = 0; i < n; ++i){\n            for(int j = i + 1; j < n; ++j){\n                int cnt = 0;\n                for(int k = 0; k < len; ++k){\n                    if(strs[i][k] != strs[j][k])\n                        cnt++;\n                }\n                // 对比完一个后，如果只有两个字母不同，说明在同一个分组里面\n                if(cnt == 2 || cnt == 0) uf.unionElem(i, j);\n            }\n        }\n        return uf.getCount();\n    }\n};\n```\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode778-水位上升的游泳池中游泳","url":"/blog/2021/01/30/LeetCode778-水位上升的游泳池中游泳/","content":"\n#### 本题描述\n\n在一个 N x N 的坐标方格 `grid` 中，每一个方格的值 `grid[i][j]` 表示在位置 `(i,j)` 的平台高度。\n\n现在开始下雨了。当时间为 `t` 时，此时雨水导致水池中任意位置的水位为 `t` 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。\n\n你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 `(N-1, N-1)`？\n\n本题与[LeetCode1631-最小体力消耗路径]()基本一致。\n\n<!-- more-->\n\n<img src=\"LeetCode778-水位上升的游泳池中游泳\\778.png\"  />\n\n#### 思路\n\n将本题抽象为一个图论模型：\n\n* 将每个位置抽象为一个节点，共有 `n * n` 个节点。\n* 每个节点与其上下左右构成带权无向图（存在此节点的话）。\n* 当存在一条从左上角到右下角的路径时，所需要的最小时间 T。\n\n设置一个时间阈值 t，如果存在一条路径可以由左上角到右下角，那么可以继续缩短时间 t。直到找到最短的时间。本题高度范围是 `[0, N*N - 1]`，从 0 到 N*N - 1 设置阈值，进行二分搜索。\n\n* 如果当前高度大于 t，说明此路不通，需要跳过。\n* 当前高度小于等于 t，并且其四个方向也存在小于等于 t 的高度，才可以继续搜索。\n\n**对于图论的最短路径问题，考虑使用广度优先搜索（BFS）**。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int dx[4] = {-1,1,0,0};\n    int dy[4] = {0,0,-1,1};\n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int left = 0, right = n * n - 1;\n        int ans = 0;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            queue<pair<int, int>> q;\n            q.emplace(0, 0);\n            vector<bool> vis(n * n, 0);\n            vis[0] = true;\n            while(!q.empty()){\n                auto [x, y] = q.front();\n                q.pop();\n                if(grid[x][y] > mid) continue;\n                for(int i = 0; i < 4; ++i){\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if(nx >= 0 && nx < n && ny >= 0 && ny < n && !vis[nx * n + ny] && grid[nx][ny] <= mid){\n                        vis[nx * n + ny] = true;\n                        q.emplace(nx, ny);\n                    }\n                }\n            }\n            if(vis[n * n - 1]){\n                ans = mid;\n                right = mid - 1;\n            }\n            else{\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["BFS","图论","二分法"],"categories":["LeetCode"]},{"title":"LeetCode1631-最小体力消耗路径","url":"/blog/2021/01/29/LeetCode1631-最小体力消耗路径/","content":"\n#### 题目描述\n\n你准备参加一场远足活动。给你一个二维 `rows x columns` 的地图 `heights` ，其中 `heights[row][col]` 表示格子 `(row, col)` 的高度。一开始你在最左上角的格子 `(0, 0)` ，且你希望去最右下角的格子 `(rows-1, columns-1)` （注意下标从 **0** 开始编号）。你每次可以往 **上**，**下**，**左**，**右** 四个方向之一移动，你想要找到耗费 **体力** 最小的一条路径。\n\n一条路径耗费的 **体力值** 是路径上相邻格子之间 **高度差绝对值** 的 **最大值** 决定的。\n\n请你返回从左上角走到右下角的最小 **体力消耗值** 。\n\n<!-- more-->\n\n<img src=\"LeetCode1631-最小体力消耗路径\\1631.png\"  />\n\n<img src=\"LeetCode1631-最小体力消耗路径\\1631-提示.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n将本题抽象为一个图论模型：\n\n* 将每个位置抽象为一个节点，共有 `m * n` 个节点。\n* 每个节点与其上下左右构成带权无向图（存在此节点的话），其权值为节点间高度差的绝对值。\n* 寻找一条从左上角到右下角的最短路径，一条路径的长度定义为所有边权的最大值。\n\n我们可以设置一个阈值 x，看是否存在一条路径，从左上角到右下角所累加的权值小于等于 x；如果小于等于 x，说明可能存在更小的阈值，使路径存在，并进一步缩小阈值范围。\n\n本题高度差范围是 `[1,1000000]`，从 0 到 999999 设置阈值，进行二分搜索。\n\n**对于图论的最短路径问题，考虑使用广度优先搜索（BFS）**。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int dx[4] = {-1,1,0,0};\n    int dy[4] = {0,0,-1,1};\n    int minimumEffortPath(vector<vector<int>>& heights) {\n        int m = heights.size(); \n        int n = heights[0].size();\n        int ans = 0;\n        int left = 0, right = 1000000 - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            queue<pair<int, int>> q;\n            q.push({0, 0});\n            vector<bool> vis(m * n, 0);\n            vis[0] = true;\n            while(!q.empty()){\n                auto [x, y] = q.front();\n                q.pop();\n                for(int i = 0; i < 4; ++i){\n                    int nx = x + dx[i];\n                    int ny = y + dy[i];\n                    if(nx >= 0 && nx < heights.size() && ny >= 0 && ny < heights[0].size() && !vis[nx * n + ny] && abs(heights[nx][ny] - heights[x][y]) <= mid){\n                        vis[nx * n + ny] = true;\n                        q.emplace(nx, ny);\n                    }\n                }\n            }\n            if(vis[m * n - 1]){\n                ans = mid;\n                right = mid - 1;\n            }\n            else{\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/","tags":["BFS","图论","二分法"],"categories":["LeetCode"]},{"title":"文件管理（四）","url":"/blog/2021/01/28/文件管理（四）/","content":"\n#### 本次学习要点\n\n1. 磁盘的结构\n2. 磁盘调度算法\n3. 减少磁盘延迟时间的方法\n4. 磁盘的管理\n\n<!-- more-->\n\n#### 磁盘的结构\n\n##### 磁盘、磁道、扇区\n\n磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。\n\n磁道与扇区：\n\n<img src=\"文件管理（四）\\磁道与扇区.png\" style=\"zoom:80%;\" />\n\n##### 如何在磁盘中读/写数据\n\n将**磁头**移动到想要读/写扇区所在的磁道，磁盘转动，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。\n\n##### 盘面、柱面\n\n<img src=\"文件管理（四）\\盘面、柱面.png\" style=\"zoom:80%;\" />\n\n##### 磁盘的物理地址\n\n地址形式：（柱面号，盘面号，扇区号）。\n\n**如何读写？**\n\n1. 根据柱面号移动磁臂，让磁头指向指定柱面。\n2. 激活指定盘面对应的磁头。\n3. 磁盘旋转的过程中，指定的扇区会从磁头下面划过，完成读写。\n\n##### 小结\n\n<img src=\"文件管理（四）\\磁盘的结构小结.png\"  />\n\n#### 磁盘调度算法\n\n##### 一次磁盘读写操作需要的时间\n\n**寻道时间** $T_s$：在读写数据前，将磁头移动到指定磁道所花的时间。\n$$\nT_s = s + m\\times n\n$$\n其中，$s$ 为启动磁头臂时间；$m$ 为跨越一个磁道耗时；$n$ 为跨越磁道总数。\n\n**延迟时间** $T_R$：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。\n$$\nT_R = \\frac{1}{2} \\times \\frac{1}{r} = \\frac{1}{2r}\n$$\n其中，$\\frac{1}{2}$ 为平均找到目标扇区所走的圈数；$r$ 为磁盘转速。\n\n**传输时间** $T_t$：从磁盘读写数据所需时间。\n$$\nT_t = \\frac{1}{r} \\times \\frac{b}{N} = \\frac{b}{rN}\n$$\n其中，$r$ 为磁盘转速；$b$ 为此次读写的字节数；$N$ 为每个磁道上的字节数。\n\n**后两个是磁盘固有时间消耗，无法优化**。总消耗时间 $T_a$ 如下：\n$$\nT_a = T_s + \\frac{1}{2r} + \\frac{b}{rN}\n$$\n**消耗时间的优化主要从寻道时间入手**。\n\n##### 先来先服务算法（FCFS）\n\n根据进程请求访问磁盘的先后顺序进行调度。\n\n* 优点：公平；如果请求访问的磁道比较集中，性能还行。\n* 缺点：如果大量进程竞争使用磁盘且较分散，性能差，寻到时间长，\n\n##### 最短寻找时间优先（SSTF）\n\n此算法优先处理与当前磁头最近的磁道。可保证每次的寻道时间最短，但不保证总寻道时间最短。\n\n* 优点：性能较好，平均寻道时间短。\n* 缺点：可能产生**饥饿**现象。\n\n##### 扫描算法（SCAN）\n\n在 SSTF 算法的基础上规定：只有磁头移动到嘴最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动，也叫电梯算法。\n\n* 优点：性能较好，平均寻道时间短，不会产生饥饿现象。\n* 缺点：①只有到最边上才会改变磁头方向；②各个位置磁道的响应频率不平均，靠边的响应频率更高一些。\n\n##### LOOK 调度算法\n\n**为解决 SCAN 缺点①。**\n\n在 SCAN 算法的基础上规定：如果在磁头移动的方向上已经没有别的请求，就可以立即改变磁头移动方向。\n\n* 优点：较 SCAN 算法寻道时间进一步缩短。\n\n##### 循环扫描算法（C-SCAN）\n\n**为解决 SCAN 缺点②。**\n\n在 SCAN 算法的基础上规定：只有朝某个方向移动磁头时才处理磁道访问请求，返回时直接移动至起始端。\n\n* 优点：磁道响应平均。\n* 缺点：到最边上才改变磁头方向。\n\n##### C-LOOK 调度算法\n\n在 C-SCAN 算法的基础上规定：如果磁头移动的方向上已经没有磁道访问请求了，可以让磁头立即返回有磁道访问请求的位置。\n\n##### 小结\n\n<img src=\"文件管理（四）\\磁盘调度算法小结.png\"  />\n\n#### 减少延迟时间的方法\n\n磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，需要较长延迟时间。\n\n##### 交替编号\n\n让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。\n\n<img src=\"文件管理（四）\\交替编号.png\"  style=\"zoom:80%;\" />\n\n##### 错位命名\n\n相邻盘面的扇区编号错位。\n\n<img src=\"文件管理（四）\\错位命名.png\" style=\"zoom:80%;\" />\n\n##### 磁盘地址结构的设计\n\n为什么磁盘的物理地址是 （柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？\n\n答：读取地址连续的磁盘块时，采用前者可以减少磁头移动消耗的时间。\n\n#### 小结\n\n<img src=\"文件管理（四）\\减少延迟时间的方法.png\"  />\n\n#### 磁盘的管理\n\n##### 磁盘初始化\n\n1. 低级初始化（物理格式化）：将磁盘的各个磁道划分为扇区。一个扇区分为 头、数据区域（如512B大小）、尾 三个部分。\n2. 将磁盘分区，每个分区由若干**柱面**组成（C、D、E盘等）。\n3. 逻辑格式化，创建文件系统。创建文件根目录，初始化存储空间管理所用的数据结构，如位示图、空闲分区表等。\n\n##### 引导块\n\n计算机开机时需要初始化，通过执行**初始化程序（自举程序）**完成。\n\n<img src=\"文件管理（四）\\自举程序.png\" style=\"zoom:80%;\" />\n\n完整的自举程序放在磁盘的启动块（引导块/启动分区）上，启动块位于磁盘的固定位置，拥有启动分区的磁盘称为启动磁盘或系统磁盘（C盘）。\n\n##### 坏块的管理\n\n简单磁盘可以在**逻辑格式化**时，对磁盘进行坏块检查，标明坏扇区，如：在 FAT 表上标明，坏块对操作系统不透明。\n\n复杂磁盘会有一个**磁盘控制器**（磁盘中的一个硬件）来维护坏块链表。同时会保留一些“备用扇区”，用于替换坏块。此种方式坏块对操作系统透明。\n\n##### 小结\n\n<img src=\"文件管理（四）\\磁盘的管理.png\"  />","tags":["磁盘"],"categories":["操作系统"]},{"title":"文件管理（三）","url":"/blog/2021/01/28/文件管理（三）/","content":"\n#### 本次学习要点\n\n1. 文件的基本操作\n2. 文件共享\n3. 文件保护\n4. 文件系统的层次结构\n\n<!-- more-->\n\n#### 文件的基本操作\n\n##### 创建文件\n\n使用 **create** 系统调用，需要提供几个主要参数：\n\n1. 所需的外存空间大小。\n2. 文件存放路径。\n3. 文件名。\n\n操作系统在处理 **create** 系统调用时，主要做了两件事：\n\n1. 在外存中找到文件所需的空间（空闲链表法等）。\n2. 根据文件存放路径信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。\n\n##### 删除文件\n\n使用 **delete** 系统调用，需要提供几个主要参数：\n\n1. 文件存放路径。\n2. 文件名。\n\n操作系统在处理 **delete** 系统调用时，主要做了三件事：\n\n1. 从目录中找到文件名对应的目录项。\n2. 根据目录项记录的文件信息，回收文件占用的磁盘块。\n3. 从目录表中删除文件对应的目录项。\n\n##### 打开文件\n\n使用 **open** 系统调用，需要提供几个主要参数：\n\n1. 文件存放路径。\n2. 文件名。\n3. 要对文件的操作类型（如：r 只读；rw 读写等）。\n\n操作系统在处理 **open** 系统调用时，主要做了两件事：\n\n1. 从目录中找到文件名对应的目录项，并检查该用户是否有指定的操作权限。\n2. 将目录项复制到内存中的**打开文件表**中。并返回对应的编号返回。之后用户使用打开文件表的编号来知名要操作的文件。这样做可以加快文件的访问速度。\n\n##### 关闭文件\n\n进程使用完文件后，要关闭文件，操作系统在处理 **close** 系统调用时，需要做以下三件事：\n\n1. 将**用户进程的打开文件表**相应表项删除。\n2. 回收分配给该文件的内存空间等资源。\n3. **系统打开文件表（整个系统只有一张）**的打开计数器 count 减一，若 count = 0，则删除对应表项。\n\n##### 读文件\n\n使用 **read** 系统调用，需要提供几个主要参数：\n\n1. 指明是哪个文件。\n2. 指明要读入多少数据。\n3. 指明读入的数据放在内存何处。\n\n操作系统从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。\n\n##### 写文件\n\n使用 **write** 系统调用，需要提供几个主要参数：\n\n1. 指明是哪个文件。\n2. 指明要写出多少数据。\n3. 写回外存的数据放在内存中的什么位置。\n\n操作系统从用户指定的内存区域中，将指定大小的数据写回指针指向的外存。\n\n##### 小结\n\n<img src=\"文件管理（三）\\文件基本操作小结.png\"  />\n\n#### 文件共享\n\n操作系统提供给用户文件共享功能，可以让多个用户共享的使用同一个文件。\n\n##### 基于索引结点的共享方式（硬链接）\n\n由于检索时只需用到文件名，所以将除了文件名之外的其他信息放到索引结点中，目录项仅包含文件名和索引结点指针。\n\n<img src=\"文件管理（三）\\索引结点.png\" style=\"zoom:80%;\" />\n\ncount 记录链接到本索引结点上的用户目录项数，当 count = 0 时，系统删除该文件。\n\n##### 基于符合链的共享方式（软链接）\n\n使用 **link** 类型文件，记录**文件的路径**。\n\n<img src=\"文件管理（三）\\符号链.png\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"文件管理（三）\\文件共享小结.png\" style=\"zoom:80%;\" />\n\n#### 文件保护\n\n保护文件数据的安全。\n\n##### 口令保护\n\n为文件设置一个口令，用户请求访问该文件时必须提供口令。\n\n* 优点：保存口令的空间开销不多，验证口令的时间开销小。\n* 缺点：正确的口令存放在系统内部，不够安全。\n\n##### 加密保护\n\n使用某个密码对文件进行加密，访问文件时需提供正确密码。例如：异或加密。\n\n* 优点：保密性强，不需要在系统中存储密码。\n* 缺点：编/解码，加/解密需要花费一定时间。\n\n##### 访问控制\n\n在每个文件的 FCB 中增加一个**访问控制列表（Access-Control List, ACL）**，该表记录各个用户可以对该文件进行的操作。\n\n<img src=\"文件管理（三）\\访问控制.png\" style=\"zoom:80%;\" />\n\n精简访问列表：可将用户以**组**为单位，来管理用户可以进行哪些操作。\n\n<img src=\"文件管理（三）\\精简访问列表.png\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"文件管理（三）\\文件保护小结.png\" style=\"zoom:80%;\" />\n\n#### 文件系统的层次结构\n\n<img src=\"文件管理（三）\\文件系统的层次结构.png\"  />\n\n##### 一个例子\n\n某用户请求删除文件 `test.txt` ：\n\n1. 用户通过操作系统提供的接口发出删除请求——**用户接口**。\n2. 用户提供的是文件存放路径，操作系统需查找目录，找到目录项——**文件目录系统**。\n3. 不同用户的操作权限不同，需要检查用户的权限——**存取控制模块（存取控制验证层）**。\n4. 验证权限后，操作系统将用户提供的**记录号**转变为对应的逻辑地址——**逻辑文件系统与文件信息缓冲区**。\n5. 将逻辑地址转换为物理地址——**物理文件系统**。\n6. 要删除这条记录，需要对磁盘设备发出请求——**设备管理程序模块**。\n7. 删除后，会有一些磁盘空闲，因此需要将其回收——**辅助分配模块**。","tags":["文件共享","文件保护"],"categories":["操作系统"]},{"title":"LeetCode1579-保证图可完全遍历","url":"/blog/2021/01/27/LeetCode1579-保证图可完全遍历/","content":"\n#### 题目描述\n\nAlice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边：\n\n* 类型 1：只能由 Alice 遍历。\n* 类型 2：只能由 Bob 遍历。\n* 类型 3：Alice 和 Bob 都可以遍历。\n\n给你一个数组 $edges$ ，其中 $edges[i] = [type_i, u_i, v_i]$ 表示节点 $u_i$ 和 $v_i$ 之间存在类型为 $type_i$ 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。\n\n返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1。\n\n<!-- more-->\n\n<img src=\"LeetCode1579-保证图可完全遍历\\1567.png\" style=\"zoom:120%;\" />\n\n#### 思路\n\n本题和[LeetCode1319-连通网络的操作次数](http://www.xingyuzhao.ltd/blog/2021/01/23/LeetCode1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/#more)很相似，可以说是1319的加强版。这道题需要给两位主角分别建立一个并查集，并且要解决下面三个问题：\n\n**1. 如何判断边重复？**\n\n在进行 `union` 操作前后，如果 `count` 变化（减一），代表进行了合并；否则，说明此边重复，可以删掉。\n\n**2. 什么是公共边？**\n\n对于此题来说，$type$ 为 3 的边既可以被 Alice 遍历，也可以被 Bob 遍历。所以此种类型的边就是公共边。\n\n**3. 如何处理公共边？**\n\n这是本题的重点，对 Alice 和 Bob 分别根据公共边进行合并。\n\n* 如果先对 Alice 根据公共边合并，当发现边重复时，就需要删掉此边，不会对节点之间的连通性造成任何影响。\n* 再对 Bob 根据公共边合并时，就不需要删边了，因为上一步已经删去了重复公共边，不需要再一次删除了。两者的联通集是一致的。\n\n总而言之，**公共边只能删除一次。**\n\n经历上述操作后，再分别对两个人按照自己可以遍历的类型进行合并，同样遇到了重复边可以删掉。将重复公共边总数和非公共边重复总数求和，就是最终结果了。\n\n当然，如果合并结束后，两个并查集中有一个或多个不止一个联通集，说明无法全部遍历，返回 -1。\n\n#### 代码\n\n顺序可能不太一致，但不影响最终结果。\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\n        unionFind Alice(n);\n        unionFind Bob(n);\n        int cnt = 0;\n        // Alice\n        for(auto &edge : edges){\n            int type = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            if(type != 3) continue;\n            int count = Alice.getCount();\n            Alice.unionElem(u - 1, v - 1);\n            if(Alice.getCount() == count)\n                cnt++;\n        }\n        for(auto &edge : edges){\n            int type = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            if(type != 1) continue;\n            int count = Alice.getCount();\n            Alice.unionElem(u - 1, v - 1);\n            if(Alice.getCount() == count)\n                cnt++;\n        }\n        // Bob\n        for(auto &edge : edges){\n            int type = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            if(type != 3) continue;\n            Bob.unionElem(u - 1, v - 1);\n        }\n        for(auto &edge : edges){\n            int type = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            if(type != 2) continue;\n            int count = Bob.getCount();\n            Bob.unionElem(u - 1, v - 1);\n            if(Bob.getCount() == count)\n                cnt++;\n        }\n        return Alice.getCount() == 1 && Bob.getCount() == 1 ? cnt : -1;\n    }\n};\n```\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode959-由斜杠划分区域","url":"/blog/2021/01/25/LeetCode959-由斜杠划分区域/","content":"\n#### 题目描述\n\n在由 1 x 1 方格组成的 N x N 网格 `grid` 中，每个 1 x 1 方块由 `/`、`\\` 或空格构成。这些字符会将方块划分为一些共边的区域。\n\n（请注意，反斜杠字符是转义的，因此 `\\` 用 `\"\\\\\"` 表示。）。\n\n返回区域的数目。\n\n<!-- more-->\n\n<img src=\"LeetCode959-由斜杠划分区域\\959.png\"  />\n\n#### 思路\n\n输入 `grid` 的长度 `n` 就是网格的**边长**。比如示例中 `grid` 的长度为2，那么就是对 $2\\times2$ 的网格中的每一小格，通过字符确定如何划分这一小格。\n\n将一个小格分为**4**个部分，分别为 `0,1,2,3`，如下：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_1.png\"  />\n\n* 如果输入字符为 `\"/\"` ，则将 `0-1` 与 `3-2` 分别连接。\n* 如果输入字符为 `\"\\\\\"` ，则将 `0-3` 与 `1-2` 分别连接。\n\n* 如果输入字符为 ` \" \"`，则将 `0-1-2-3` 全部连接。\n\n左右相邻的两个小格需要将左边的 `1` 与右边的 `3` 相连：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_2.png\" style=\"zoom:80%;\" />\n\n上下相邻的两个小格需要将上面的 `2`  与下边的 `0` 相连：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_3.png\"  />\n\n除了第一行和第一列，其他的行和列都需要考虑上述两种相邻的情况。\n\n合并结束后，连通集的个数就是区域的数目。\n\n以示例4为例：\n\n* 仅对于每个字符合并：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_4.png\"  />\n\n* 对行和列相邻的小格进行合并：\n\n<img src=\"LeetCode959-由斜杠划分区域\\959_5.png\"  />\n\n如上图所示，区域一共有5个。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(0);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int genCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic: \n    int regionsBySlashes(vector<string>& grid) {\n        int n = grid.size();\n        unionFind uf(4 * n * n);\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                int start = 4 * (i * n + j); // 0号位置\n                switch(grid[i][j]){\n                    case ' ':\n                        uf.unionElem(start, start + 1);\n                        uf.unionElem(start + 1, start + 2);\n                        uf.unionElem(start + 2, start + 3);\n                        break;\n                    case '/':\n                        uf.unionElem(start, start + 3);\n                        uf.unionElem(start + 1, start + 2);\n                        break;\n                    case '\\\\':\n                        uf.unionElem(start, start + 1);\n                        uf.unionElem(start + 2, start + 3);\n                        break;\n                }\n                // 连接同一列2-0\n                if(i > 0) uf.unionElem(start, start - 4 * n + 2);\n                // 连接同一行1-3\n                if(j > 0) uf.unionElem(start + 3, start - 3);\n            }\n        }\n        return uf.genCount();\n    }\n};\n```\n\n#### Reference\n\n评论区：https://leetcode-cn.com/problems/regions-cut-by-slashes/comments/","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode1319-连通网络的操作次数","url":"/blog/2021/01/23/LeetCode1319-连通网络的操作次数/","content":"\n#### 题目描述\n\n用以太网线缆将 `n` 台计算机连接成一个网络，计算机的编号从 `0` 到 `n-1`。线缆用 `connections` 表示，其中 `connections[i] = [a, b]` 连接了计算机 `a` 和 `b`。\n\n网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。\n\n给你这个计算机网络的初始布线 `connections`，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。\n\n<!-- more-->\n\n<img src=\"LeetCode1319-连通网络的操作次数\\1319.png\"  />\n\n#### 思路\n\n首先我们需要得到**多余**的边的总数：先判断两个节点是否处于同一个连通集，如果处于同一个连通集并且当前还有一条边连接它们，那么就将**可用边**计数加1。\n\n其次，我们需要得到连通集的个数，连通集的总数减去1就是要将它们连接起来**所需要边**的个数。\n\n如果**可用边**小于**所需要边**的个数，就返回-1，代表无法使所有计算机连通。否则，取两者中的较小值，就是最小需要移动边的个数。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(0);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[qRoot] < rank[pRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        unionFind uf(n);\n        int lines = 0;\n        for(int i = 0; i < connections.size(); ++i){\n            int count = uf.getCount();\n            uf.unionElem(connections[i][0], connections[i][1]);\n            if(count == uf.getCount()) lines++;\n        }  \n        int need = uf.getCount() - 1;\n        // cout << lines << \" \" << need;\n        if(lines >= need){\n            return min(lines, need);\n        }\n        return -1;\n    }\n};\n```\n\n\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"C++动态数组","url":"/blog/2021/01/20/C-动态数组/","content":"\n#### 本次学习要点\n\n1. `new` 和数组\n2. `allocator` 类\n3. 使用标准库：文本查询程序\n\n<!-- more-->\n\n#### new和数组\n\n使用 `new` 分配一个对象数组，在类型名后跟一对方括号，在其中指明要分配的对象的数目：\n\n```cpp\nint *pia = new int[get_size()]; // pia指向第一个int\n// 类型别名\ntypedef int arrT[42]; // arrT表示42个int的数组类型\nint *p = new arrT; // 分配一个42个int的数组；p指向第一个int\n```\n\n##### 分配一个数组会得到一个元素类型的指针\n\n分配的内存不是一个数组类型，因此不能对动态数组调用 `begin` 和 `end` ，也不能用范围 `for`。\n\n##### 初始化动态分配对象的数组\n\n动态数组中的元素可以进行值初始化：\n\n```cpp\nint *pi = new int[10]; // 未初始化\nint *pia = new int[10](); // 值初始化（0）\nstring *ps = new string[10]; // 10个空string\nstring *psa = new string[10](); // 同上\n```\n\n新标准下还可以用花括号列表进行初始化：\n\n```cpp\nint *pia = new int[10]{0,1,2,3,4,5,6,7,8,9};\n// 前四个用给定的初始化器初始化，剩余的进行值初始化\nstring *pia = new string[10]{\"a\",\"an\",\"the\",string(3, 'x')};\n```\n\n同时，动态分配一个空数组是合法的。\n\n##### 释放动态数组\n\n在指针前加上一个空方括号对：\n\n```cpp\ndelete []pa; // pa必须指向一个动态分配的数组或为空\n```\n\n##### 智能指针和动态数组\n\n```cpp\n// up指向一个包含10个未初始化int的数组\nunique_ptr<int[]> uo(new int[10]);\nup.release(); // 自动用delete[]销毁其指针\n```\n\n当一个 `unique_ptr` 指向一个数组时，可以使用下标运算符来访问数组中的元素：\n\n```cpp\nfor(size_t i = 0; i != 10; ++i)\n\tup[i] = i; // 为每个元素赋予一个新值\n```\n\n<img src=\"C-动态数组\\指向数组的unique_ptr.png\"  />\n\n*如果希望使用 `shared_ptr` 管理一个动态数组，必须提供自己定义的删除器。*\n\n#### allocator类\n\n标准库 `allocator` 类定义在 `memory` 中，它将内存分配和对象构造分离开来。当一个 `allocator` 对象分配内存时，它会根据给定的**对象类型**来确定恰当的内存大小和对齐位置：\n\n```cpp\nallocator<string> alloc; // 可以分配string的allocator对象\nauto const p = alloc.allocate(n); // 分配n个未初始化的string\n```\n\n<img src=\"C-动态数组\\标准库allocator类及其算法.png\"  />\n\n##### allocator 分配未构造的内存\n\n`allocator` 分配的内存是未构造的，我们按需要在此内存中使用 `construct` 构造对象：\n\n```cpp\nauto q = p; // q指向最后构造的元素之后的位置\nalloc.construct(q++); // *q为空字符串\nalloc.construct(q++, 10, 'c'); // *q为cccccccccc\nalloc.construct(q++, \"hi\"); // *q为hi\n```\n\n<img src=\"C-动态数组\\alloc_warning.png\"  />\n\n使用完对象后，必须对**每个构造**的元素调用 `destory` 来销毁它们。其接受一个指针，对指向的对象执行析构函数：\n\n```cpp\nwhile(q != p)\n\talloc.destory(--q); // 第一次调用时，q指向最后一个构造的元素\n```\n\n元素被销毁后，可以将这部分内存来保存其他 `string`，也可将其归还给系统，使用 `deallocate` 完成：\n\n```cpp\nalloc.deallocate(p, n);\n```\n\n##### 拷贝和填充未初始化内存的算法\n\n标准库还定义了两个伴随算法，可以在未初始化内存中创建对象：\n\n<img src=\"C-动态数组\\allocator算法.png\"  />\n\n#### 使用标准库：文本查询程序\n\n在一个给定的文件中查询单词，结果是单词在文件中出现的次数及其所在行。如果一个单词一行中出现多次，只列出一次。行会按照升序输出。\n\n读入一个英文文本，在其中查询单词 `element` ，输出结果的前几行如下图：\n\n<img src=\"C-动态数组\\example.png\"  />\n\n##### 查询类TextQuery\n\n```cpp\nclass TextQuery {\npublic:\n    using line_no = vector<string>::size_type;\n    TextQuery(ifstream&);\n    QueryResult query(const string&) const;\nprivate:\n    shared_ptr<vector<string>> file; // 输入文件，需要两个类共享\n    // 每个单词到它所在的行号的集合的映射\n    map<string, shared_ptr<set<line_no>>> wm;\n};\nTextQuery::TextQuery(ifstream &is): file(new vector<string>) {\n    string text;\n    while(getline(is, text)){ // 对文件中每一行\n        file->push_back(text); // 保存此行文本\n        int n = file->size() - 1; // 当前行号\n        istringstream line(text); // 将文本分解为单词\n        string word;\n        while(line >> word){ // 对行中的每个单词\n            // 如果单词不在wm中，以之为下标在wm中添加一项\n            // lines是一个引用，改变lines也会改变wm中的元素\n            auto &lines = wm[word];\n            if(!lines) // 在我们第一次遇到这个单词时，此指针为空\n                lines.reset(new set<line_no>); // 分配一个新的set\n            lines->insert(n); // 将此行号插入set中\n        }\n    }\n}\nQueryResult TextQuery::query(const string &sought) const {\n    // 如果未找到sought，返回一个指向此set的指针\n    static shared_ptr<set<line_no>> nodata(new set<line_no>);\n    // 使用find而不是下标运算符来查找单词，避免将单词添加到wm中\n    auto loc = wm.find(sought);\n    if(loc == wm.end())\n        return QueryResult(sought, nodata, file); // 未找到\n    else\n        return QueryResult(sought, loc->second, file);\n}\n```\n\n##### 查询结果类QueryResult\n\n```cpp\nstring make_plural(size_t ctr,const string &word, const string &ending);\n\nclass QueryResult {\n    friend ostream& print(ostream&, const QueryResult&); // 友元函数\npublic:\n    using line_no = vector<string>::size_type;\n    QueryResult(string s, shared_ptr<set<line_no>> p, shared_ptr<vector<string>> f):\n                sought(s), lines(p), file(f){ }\nprivate:\n    string sought; // 查询单词\n    shared_ptr<set<line_no>> lines; // 出现的行号\n    shared_ptr<vector<string>> file; // 输入文件\n};\nostream &print(ostream &os, const QueryResult &qr){\n    // 如果找到了单词，打印出现次数和所有出现的位置\n    os << qr.sought << \" occurs \" << qr.lines->size() << \" \"\n       << make_plural(qr.lines->size(), \"time\", \"s\") << endl;\n    // 打印单词出现的每一行\n    for(auto num : *qr.lines)\n        // 行号从1开始\n        os << \"\\t(lines \" << num + 1 << \") \"\n           << *(qr.file->begin() + num) << endl;\n    return os;\n}\nstring make_plural(size_t ctr, const string &word, const string &ending)\n{\n    return (ctr == 1) ? word : word + ending;//make_plural(wc, \"word \", \"s \")当输入中文本中\n    //word数大于一是在word后加s，为words为word的复数！\n}\n```\n\n##### 主函数\n\n```cpp\nvoid runQueries(ifstream &infile);\nint main() {\n    ifstream infile(\"test.txt\");\n    runQueries(infile);\n    return 0;\n}\nvoid runQueries(ifstream &infile){\n    TextQuery tq(infile);\n    while(true){\n        cout << \"输入要查询的单词，或按q退出：\";\n        string s;\n        if(!(cin >> s) || s == \"q\") break;\n        print(cout, tq.query(s)) << endl;\n    }\n}\n```\n\n##### 完整工程\n\nhttps://gitee.com/settlezxy/learning-cpp.git","tags":["动态数组"],"categories":["C++"]},{"title":"C++动态内存与智能指针","url":"/blog/2021/01/20/C-动态内存与智能指针/","content":"\n#### 本次学习要点\n\n1. `shared_ptr` 类\n2. 直接管理内存\n3. `shared_ptr` 和 `new` 结合使用\n4. 智能指针和异常\n5. `unique_ptr`\n6. `weak_ptr`\n\n<!-- more-->\n\n静态内存：保存局部 `static` 对象、类 `static` 数据成员及定义在任何函数之外的变量。\n\n栈内存：保存和定义在函数内的非 `static` 对象。\n\n除了静态内存和栈内存，程序还拥有一个内存池，被称为**自由空间**或**堆**。程序用堆来存储**动态分配**的对象，当动态对象不再使用时，必须用代码显式的销毁它们。\n\n**动态内存与智能指针**\n\n* `new` ：在动态内存中为对象分配空间并返回一个指向该对象的指针。\n* `delete` ：接受一个动态对象的指针，销毁该对象，并释放相关内存。\n\n不合理时释放内存会出现内存泄漏（忘记释放）或产生引用非法内存的指针（有指针还在引用内存时就释放了它）。\n\n标准库提供两种**智能指针**管理动态对象，它们可以自动释放所指向的对象。\n\n1. `shared_ptr` 允许多个指针指向同一个对象。\n2. `unique_ptr` 则**独占**所指向的对象。\n\n标准库还定义了一个名为 `weak_ptr` 的伴随类，它是一种弱引用（**?**），指向 `shared_ptr` 所管理的对象。这三种类型都定义在 `memory` 头文件中。\n\n#### shared_ptr类\n\n智能指针也是模板，必须提供指针可以指向的类型：\n\n```cpp\nshared_ptr<string> p1; // 指向string\nshared_ptr<list<int>>  p2; // 指向int的list\n```\n\n如果在一个条件判断中使用智能指针，效果就是检测它是否为空：\n\n```cpp\n// 如果p1不为空，并且指向一个空的string\nif(p1 && p1->empty())\n\t*p1 = \"hi\";\n```\n\n`shared_ptr `和 `unique_ptr` 都支持的操作：\n\n<img src=\"C-动态内存与智能指针\\shared_ptr与unique_ptr都支持的操作.png\"  />\n\n`shared_ptr` 独有的操作：\n\n<img src=\"C-动态内存与智能指针\\shared_ptr独有的操作.png\"  />\n\n##### make_shared函数\n\n此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 `shared_ptr`：\n\n```cpp\n// 指向一个值为42的int的shared_ptr\nshared_ptr<int> p3 = make_shared<int>(42);\n// 指向一个值初始化的int，即，值为0\nshared_ptr<int> p4 = make_shared<int>();\n// 也可以用auto\n```\n\n**调用make_shared<T>时必须与T的某个构造函数相匹配**。\n\n##### shared_ptr的拷贝和赋值\n\n当进行拷贝或赋值操作时，每个 `shared_ptr` 都会记录又多少个其他 `shared_ptr` 指向相同的对象：\n\n```cpp\nauto p = make_shared<int>(42);\nauto q(p); // p和q指向相同对象，此对象有两个引用者\n```\n\n每个 `shared_ptr` 都有要给**引用计数**，只要我们拷贝一个 `shared_ptr` ，计数器就会增加，当我们给 `shared_ptr` 赋予一个新值或是 `shared_ptr` 被销毁，计数器递减。\n\n一旦计数器变为0，它就会自动释放自己所管理的对象：\n\n```cpp\nauto r = make_shared<int>(42);\nr = q; // 给r赋值，令它指向另一个地址\n\t   // 递增q指向的对象的引用计数\n\t   // 递减r原来指向的对象的引用计数\n\t   // r原来指向的对象已经没有引用者，会自动释放\n```\n\n##### shared_ptr自动销毁所管理的对象\n\n当指向一个对象的最后一个 `shared_ptr` 被销毁时，`shared_ptr` 类会通过**析构函数**销毁此对象。`shared_ptr` 的析构函数会递减它所指向的对象的引用计数，如果引用计数变为0， `shared_ptr` 的析构函数就会销毁对象，并释放它占用的内存。\n\n##### shared_ptr还会自动释放相关联的内存\n\n<img src=\"C-动态内存与智能指针\\note_shared_ptr释放内存.png\"  />\n\n##### 使用了动态生存期的资源的类\n\n程序使用动态内存出于一下三种原因之一 ：\n\n1. 程序不知道自己需要使用多少对象。\n2. 程序不知道所需对象的准确类型。\n3. 程序需要在多个对象间共享数据。\n\n一般而言，如果两个对象共享底层的数据，当某个对象被销毁时，我们不能单方面的销毁底层数据：\n\n```cpp\nBlob<string> b1; // 空Blob\n{\t新作用域\n    Blob<string> b2 = {\"z\",\"zx\",\"zxy\"};\n \tb1 = b2; // b1和b2共享相同的元素\n} // b2被销毁了，但b2中的元素不能销毁\n  // b1指向最初由b2创建的元素\n```\n\n此例中，`b1` 和 `b2` 共享相同的元素。当 `b2` 离开作用域时，这些元素必须保留，`b1` 仍然在使用它们。\n\n#### 直接管理内存\n\n##### 使用new动态分配和初始化对象\n\n使用传统构造方式（使用圆括号），或列表初始化（使用花括号）初始化一个动态分配的对象：\n\n```cpp\nint *pi = new int(1024); // pi指向的对象的值为1024\nstring *ps = new string(10, '9'); // *ps为\"9999999999\"\n// vector有10个元素，值以此从0到9\nvector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};\n```\n\n对动态分配的对象进行值初始化：\n\n```cpp\nstring *ps = new string(); // 值初始化为空string\nint *pi = new int(); // 值初始化为0；*pi为0\n```\n\n##### 动态分配的const对象\n\n用 `new` 分配 `const` 是合法的，但必须进行初始化，返回一个指向 `cosnt` 的指针：\n\n```cpp\nconst int *pci = new const int(1024);\nconst string *pcs = new const string;\n// const对象是可以销毁的\ndelete pci;\n```\n\n##### 内存耗尽\n\n如果 `new` 不能分配所要求的内存空间，它会抛出一个类型为 `bad_alloc` 的异常，但是可以使用 `new`  的方式阻止其抛出异常，称这种形式的 `new` 为**定位new**：\n\n```cpp\n// 如果分配失败，new返回一个空指针\nint *p1 = new int; // 如果分配失败，new抛出std:bad_alloc;\nint *p2 = new (nothrow) int; // 如果分配失败，new返回要给空指针\n```\n\n##### 释放动态内存\n\n```cpp\ndelete p; // p必须指向一个动态分配的对象或是一个空指针\n```\n\n释放一块非 `new` 分配的内存，或者将相同的指针值释放多次，其行为是未定义的：\n\n```cpp\nint i;\nint *pi1 = &i;\ndelete pi1; // 未定义：pi1指向一个局部变量\nint *pi2 = nullptr;\ndelete pi2; // 正确：释放一个空指针总是没有错误的\n```\n\n##### 动态对象的生存期直到被释放时为止\n\n<img src=\"C-动态内存与智能指针\\warning_释放动态对象.png\"  />\n\n##### 使用new和delete管理动态内存存在的三个常见问题\n\n1. 忘记 `delete` 内存，会导致**内存泄漏**，因为这种内存永远不可能被归还给自由空间了，只有真正耗尽内存时，才能检测到这种错误。\n2. 使用已释放掉的内存。\n3. 同一块内存释放两次。\n\n##### delete之后重置指针值\n\n在 `delete` 之后，指针就变成了**空悬指针**，即，指向一块曾经保存数据对象但现在已经无效的内存的指针。\n\n#### shared_ptr和new结合使用\n\n我们可以使用 `new` 返回的指针来初始化智能指针：\n\n```cpp\nshared_ptr<int> p2(new int(42)); // p2指向一个值为42的int\n```\n\n接受指针参数的智能指针的构造函数是 `explicit` 的，因此必须使用直接初始化形式来初始化一个智能指针：\n\n```cpp\nshared_ptr<int> p1 = new int(1024); // 错误\nshared_ptr<int> p2(new int(1024)); // 正确\n```\n\n<img src=\"C-动态内存与智能指针\\定义和改变shared_ptr的其他方法1.png\"  />\n\n<img src=\"C-动态内存与智能指针\\定义和改变shared_ptr的其他方法2.png\"  />\n\n##### get使用注意\n\n<img src=\"C-动态内存与智能指针\\warning_get_use.png\"  />\n\n##### 其他shared_ptr操作\n\n我们可以同 `reset` 来将一个新的指针赋予一个 `shared_ptr` ：\n\n```cpp\np = new int(1024); // 错误，不能将一个指针赋予shared_ptr\np.reset(new int(1024)); // 正确，p指向一个新对象\n```\n\n`reset` 成员常与 `unique` 一起使用：\n\n```cpp\nif(!p.unique()){\n\tp.reset(new string(*p)); // 不是唯一用户，分配新的拷贝\n}\n*p += newVal; // 现在唯一，可以改变对象的值\n```\n\n#### 智能指针和异常\n\n如果使用智能指针，即使程序块过早结束，智能指针也能确保在内存不再需要时将其释放；而 `new` 和 `delete` 之间发生异常，且异常未被捕获，则内存就永远不会被释放了。\n\n##### 使用自己的释放操作\n\n有些类未定义析构函数，需要用户显示地释放所使用的任何资源。假定我们正在使用一个C和C++都使用的网络库，使用这个库的代码可能如下：\n\n```cpp\nstruct destination; // 表示我们正在连接什么\nstruct connection; // 使用连接所需的信息\nconnection connect(destination *); // 打开连接\nvoid disconnect(connect); // 关闭给定的连接\nvoid f(destination &d /* 其他参数 */){\n    // 获得一个连接，记住使用完之后要关闭！\n    connection c = connect(&d);\n    // 使用连接\n    // 如果我们在f推出前忘记调用disconnect，就无法关闭c了\n}\n```\n\n使用 `shared_ptr` 来保证 `connection` 被正确关闭：\n\n```cpp\n// 定义一个函数来代替delete\n// 这个「删除器」函数必须能够完成对shared_ptr中保存的指针进行释放的操作\nvoid end_connection(connection *p) { disconnect (*p); };\n// 创建shared_ptr时，可以传递一个（可选的）指向删除器函数的参数\nvoid f(destination &d /* 其他参数 */){\n    connection c = connect(&d);\n    shared_ptr<connection> p(&c, end_connection);\n    // 使用连接\n    // 当f退出时（即使时因为异常而退出），connection会被正确关闭\n}\n```\n\n#### unique_ptr\n\n当我们定义一个 `unique_ptr` 时，需要将其绑定到一个 `new` 返回的指针上。如果进行初始化，必须是直接初始化：\n\n```cpp\nunique_ptr<double> p1; // 可以指向一个double的unique_ptr\nunique_ptr<int> p2(new int(42)); // p2指向一个值为42的int\n```\n\n`unique` 不支持普通的拷贝或赋值操作：\n\n```cpp\nunique_ptr<string> p1(new string(\"zxy\"));\nunique_ptr<string> p2(p1); // 错误，不能拷贝\nunique_ptr<string> p3;\np3 = p2; // 错误，不能赋值\n```\n\n<img src=\"C-动态内存与智能指针\\unique_str操作.png\"  />\n\n可以通过 `release` 或 `reset` 将指针的所有权（非const）从一个 `unique_ptr` 转移给另一个 `unique_ptr`：\n\n```cpp\n// 将所有权从p1转移给p2，并将p1置空\nunique_ptr<string> p2(p1.release());\n// 将所有权从p3转移给p2，并将p3置空\nunique_ptr<string> p3(new string(\"Zxy\"));\np2.reset(p3.release()); // reset释放了p2原来指向的内存\n```\n\n需要注意：\n\n```cpp\np2.release(); // 错误，p2不会释放内存，而且我们丢失了指针\nauto p = p2.release(); // 正确，但必须记得delete(p);\n```\n\n##### 传递unique_ptr参数和返回unique_ptr\n\n不能拷贝 `unique_ptr` 规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 `unique_ptr` 。如下：\n\n```cpp\nunique_ptr<int> clone(int p){\n\treturn unique_ptr<int>(new int(p));\n}\n// 返回局部对象的拷贝\nunique_ptr<int> clone(int p){\n\tunique_ptr<int> ret(new int(p));\n    // ...\n    return ret;\n}\n```\n\n##### 向unique_ptr传递删除器\n\n用 `unique_ptr` 来代替 `shared_ptr` ，如下所示：\n\n```cpp\nvoid end_connection(connection *p) { disconnect (*p); };\n// 创建shared_ptr时，可以传递一个（可选的）指向删除器函数的参数\nvoid f(destination &d /* 其他参数 */){\n    connection c = connect(&d);\n    unique_ptr<connection, decltype(end_connection)*> \n        p(&c, end_connection);\n    // 使用连接\n    // 当f退出时（即使时因为异常而退出），connection会被正确关闭\n}\n```\n\n由于 `decltype(end_connection)` 返回一个函数类型，所以我们必须添加一个 `*` 来指出我们正在使用该类型的一个指针。\n\n#### weak_ptr\n\n`weak_ptr` 是一种不控制所指向对象生存期的智能指针，它指向一个由 `shared_ptr` 管理的对象。将一个 `weak_ptr` 绑定到一个 `shared_ptr` 不会改变 `shared_ptr` 的引用计数。一旦最后一个指向对象的 `shared_ptr` 被销毁，对象就会被释放。\n\n<img src=\"C-动态内存与智能指针\\weak_ptr.png\"  />\n\n创建一个 `weak_ptr` 时，要用一个 `shared_ptr` 来初始化它：\n\n```cpp\nauto p = make_shared<int>(42);\nweak_ptr<int> wp(p); // wp弱共享p，p的引用计数未改变\n```\n\n由于对象可能不存在，不能使用 `weak_ptr` 直接访问对象，必须调用 `lock`。如果对象存在， `lock` 返回一个指向共享对象的 `shared_ptr`。例如：\n\n```cpp\nif(shared_ptr<int> np = wp.lock()){ // 如果np不为空则条件成立\n\t// 在if中，np与p共享对象\n}\n```\n\n","tags":["智能指针"],"categories":["C++"]},{"title":"文件管理（二）","url":"/blog/2021/01/20/文件管理（二）/","content":"\n#### 本次学习要点\n\n1. 文件的物理结构\n3. 文件存储空间管理\n\n<!-- more-->\n\n#### 文件的物理结构\n\n对非空闲磁盘块的管理。磁盘中的存储单元被划分为一个个的“块、磁盘块、物理块”。**磁盘块的大小与内存块、页面的大小相同**。\n\n##### 连续分配\n\n连续分配方式要求每个文件在磁盘上占有一组连续的块。\n\n<img src=\"文件管理（二）\\连续分配目录.png\"  />\n\n优点：\n\n* 支持**顺序访问和直接访问（即随机访问）**。\n* 连续分配的文件在顺序访问时速度最快。\n\n缺点：\n\n* 不方便文件拓展。\n* 存储空间利用率低，会产生磁盘碎片。\n\n##### 链接分配\n\n链接分配采取**离散**分配的方式，可以为文件分配离散的磁盘块。分为**隐式链接**和显示链接。\n\n###### 隐式链接\n\n除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。\n\n<img src=\"文件管理（二）\\隐式链接.png\" style=\"zoom:80%;\" />\n\n优点：\n\n* 方便文件拓展，不会有碎片问题，外存利用率高。\n\n缺点：\n\n* 只能顺序访问，查找效率低，指向下一个盘块的指针也需要消耗少量的存储空间。\n\n###### 显式链接\n\n把用于链接文件各物理块的指针显式地存放在一张表中，即**文件分配表（FAT，File Allocation Table）**。\n\n<img src=\"文件管理（二）\\显式链接.png\" style=\"zoom:80%;\" />\n\n*一个磁盘仅设置一张FAT，开机时，将FAT读入内存，并常驻内存*。\n\n优点：\n\n* 方便文件拓展，不会有碎片问题，外存利用率高，并且支持**随机访问**。\n* 相比于隐式链接，地址转换不需要访问磁盘，因此文件的访问效率更高。\n\n缺点：\n\n* 文件分配表需要占用一定的存储空间。\n\n##### 索引分配\n\n索引分配允许文件离散地分配在各个磁盘块中，系统会为**每个文件**建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为**索引块**。文件数据存放的磁盘块称为**数据块**。\n\n<img src=\"文件管理（二）\\索引分配.png\" style=\"zoom:80%;\" />\n\n###### 链接方案\n\n如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。\n\n<img src=\"文件管理（二）\\索引分配-链接方案.png\" style=\"zoom:80%;\" />\n\n缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，导致磁盘 I/O 过多，查找效率低下。\n\n###### 多层索引\n\n建立多层索引（类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。\n\n<img src=\"文件管理（二）\\索引分配-多层索引.png\" style=\"zoom:80%;\" />\n\n*采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操作*。\n\n缺点：即使是小文件，访问一个数据块依然需要 K + 1 次读磁盘。\n\n###### 混合索引\n\n多种索引分配方式的结合。例如，一个文件的顶级索引中，既包含**直接地址索引（直接指向数据块）**，又包含**一级、二级间接索引**。\n\n<img src=\"文件管理（二）\\索引分配-混合索引.png\" style=\"zoom:80%;\" />\n\n优点：对于小文件来说，访问要给数据块所需的读磁盘次数更少。\n\n##### 文件的物理结构小结\n\n<img src=\"文件管理（二）\\文件的物理结构小结.png\"  />\n\n#### 文件存储空间管理\n\n对空闲磁盘块的管理。\n\n存储空间的初始化：将各个文件卷划分为目录区、文件区。\n\n* 目录区存放文件目录信息（FCB）、用于词牌存储空间管理的信息。\n* 文件区用于存放文件数据。\n\n##### 存储空间管理——空闲表法\n\n适用于连续分配方式。\n\n**如何分配连续的存储空间**：与内存管理中的动态分区分配类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。\n\n**如何回收磁盘块**：\n\n1. 回收区前后都没有相邻空闲区。\n2. 回收区的前后都是空闲区。\n3. 回收区前面是空闲区。\n4. 回收区后面是空闲区。\n\n*回收时注意表项的合并问题*。\n\n##### 存储空间管理——空闲链表法\n\n###### 空闲盘块链\n\n<img src=\"文件管理（二）\\空闲盘块链.png\" style=\"zoom:80%;\" />\n\n操作系统保存着**链头、链尾指针**。\n\n**如何分配**：若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针。\n\n**如何回收**：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。\n\n###### 空闲盘区链\n\n<img src=\"文件管理（二）\\空闲盘区链.png\" style=\"zoom:80%;\" />\n\n**如何分配**：若某文件申请 K 个盘块，可采用首次适应、最佳适应等算法从链头开始检索，找到符合的一个空闲盘区；若没有合适的连续空闲块，可将不同盘区的盘块分配给文件。\n\n**如何回收**：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为一个单独的空闲盘区挂到链尾。\n\n##### 存储空间管理——位示图法\n\n<img src=\"文件管理（二）\\位示图法.png\"  />\n\n**位示图**：每个二进制位对应一个盘号，空闲为 0，已分配为 1。位示图用**字**来表示，上图字长为16。可以用**（字号，位号）**对应一个盘块号。\n\n* $（字号，位号）=(i,j)$ 的**二进制位**对应的**盘块号** $b=n\\times i + j$。\n\n* $b$ 号**盘块**对应的**字号** $i=b/n$，位号 $j=b\\%n$。\n\n**如何分配**：若文件需要 K 个块：\n\n1. 顺序扫描位示图，找到 K 个相邻或不相邻的 0。\n2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件。\n3. 将相应位设置为 1。\n\n**如何回收**：\n\n1. 根据回收的盘块号计算出对应的字号、位号。\n2. 将相应的二进制位设为 0。\n\n##### 存储空间管理——成组链接法\n\n文件卷目录区用一个磁盘块作为**超级块**，系统启动时将其调入内存，并保证内外存超级块数据一致。\n\n<img src=\"文件管理（二）\\超级块.png\"  />\n\n**超级块（空闲盘块号栈）**\n\n① 存放下一组空闲盘块的**盘块号**（不超过100）。\n\n② 此组空闲盘的**空闲块总数** N。\n\n**我的理解**：超级块大小等于其他块中的第一个空闲块。都是用来存储下一组空闲块信息的，主要针对**分配时只剩下一个空闲块**（此空闲块存储了下一组空闲块信息）或**回收时已经回收够100个空闲块**的特殊情况。**类似于链表中的哑节点**。\n\n<img src=\"文件管理（二）\\超级块1.png\" style=\"zoom:120%;\" />\n\n最后一组的 `s.free[0] = -1`，表示空闲盘块链的结尾标志。\n\n**N 兼做栈顶指针**\n\n例如，当 `N = 100` 时，它指向`s.free(99)`，即 N 指向 `s.free(N - 1)`。\n\n###### 空间分配\n\n将盘块 `4` 分配给文件，先将 `4` 出栈，再将 N 减1。同理再将 `3` 分配给文件，可得：\n\n<img src=\"文件管理（二）\\超级块2.png\" style=\"zoom:120%;\" />\n\n如果此时还要将 `2` 分配给文件（`2` 保存了下一个盘块的信息），需要进行以下操作：\n\n1. 将 `2` 的信息保存到超级块中，将 `2` 分配给文件。\n2. 更新指针。\n\n<img src=\"文件管理（二）\\超级块3.png\" style=\"zoom:120%;\" />\n\n###### 空间回收\n\n假如回收盘块 `4`，先将 `4` 压入栈中，再更新 N：\n\n<img src=\"文件管理（二）\\超级块4.png\" style=\"zoom:120%;\" />\n\n当栈满时，**会将超级块的内容复制到新回收的块中**，再更新指针，假如新回收的盘块为 `3`，可以得到下图:\n\n<img src=\"文件管理（二）\\超级块5.png\" style=\"zoom:120%;\" />\n\n再根据磁盘块 `3` 更新超级块中的栈和 N，显然 N 为1，超级块指向的下一个盘块只有 `3`，将 `3` 压入栈中，此时新回收盘块 `2`，将其压入栈中，N 再加1即可：\n\n<img src=\"文件管理（二）\\超级块6.png\" style=\"zoom:120%;\" />\n\n##### 文件的存储空间管理小结\n\n<img src=\"文件管理（二）\\文件的存储空间管理小结.png\"  />\n\n#### Reference\n\n成组链接法bilibili：https://www.bilibili.com/video/av71840093/\n\n实例讲解成组链接法：https://blog.csdn.net/smartab/article/details/81285353\n\n","categories":["操作系统"]},{"title":"LeetCode1584-连接所有点的最小费用","url":"/blog/2021/01/19/LeetCode1584-连接所有点的最小费用/","content":"\n#### 题目描述\n\n给你一个 `points` 数组，表示 2D 平面上的一些点，其中 `points[i] = [xi, yi]` 。\n\n连接点 `[xi, yi]` 和点 `[xj, yj]` 的费用为它们之间的 **曼哈顿距离** ：`|xi - xj| + |yi - yj|` ，其中 `|val|` 表示 `val` 的绝对值。\n\n请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。\n\n<!-- more-->\n\n<img src=\"LeetCode1584-连接所有点的最小费用\\1584.png\"  />\n\n#### 思路\n\n`points` 数组中两两节点相连构成一个完全图，根据 `Kruskal` 算法（并查集）找到完全图中的最小生成树，这棵树上的权值之和就是题目要求的最小费用。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\npublic:\n    unionFind(int n){\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n   bool unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return false;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[qRoot] < rank[pRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        return true;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n};\nstruct Edge{\n    int v, w;\n    int weight;\n    Edge(int v, int w, int weight) : v(v), w(w), weight(weight){}\n};\nclass Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        auto f = [](vector<int> &v1, vector<int> &v2) -> int{\n            return abs(v1[0] - v2[0]) + abs(v1[1] - v2[1]);\n        };\n        unionFind uf(points.size());\n        vector<Edge> edges;\n        for(int i = 0; i < points.size(); ++i){\n            for(int j = i + 1; j < points.size(); ++j){\n                edges.emplace_back(i, j, f(points[i], points[j]));\n            }\n        }\n        int res = 0;\n        int num = 0; // 记录最小生成树边的个数\n        // 每条边按照权值排序\n        sort(edges.begin(), edges.end(), [](Edge &a, Edge &b){\n            return a.weight < b.weight;\n        });\n        for(auto &[v, w, weight] : edges){\n            if(uf.isConnected(v, w)) continue;\n            res += weight;\n            num++;\n            uf.unionElem(v, w);\n            if(num == points.size() - 1) break;\n        }\n        return res;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/lian-jie-suo-you-dian-de-zui-xiao-fei-yo-kcx7/\n\n#### Appendix\n\n$\\text{Kruskal}$ 算法是一种常见并且好写的最小生成树算法，由 $\\text{Kruskal}$ 发明。该算法的基本思想是根据边的权值从小到大加入边，是一个贪心算法。\n\n其算法流程为：\n\n1. 将图 $G=\\{V,E\\}$ 中的所有边按照长度由小到大进行排序，等长的边可以按任意顺序。\n\n2. 初始化图 $G'$ 初始化为 $\\{V,\\varnothing\\}$，从前向后扫描排序后的边，如果扫描到的边 $e$ 在 $G'$ 中连接了两个不同的连通块,则将它插入 $G'$ 中。\n\n3. 最后得到的图 $G'$ 就是图 $G$ 的最小生成树。\n\n","tags":["并查集","图论","最小生成树"],"categories":["LeetCode"]},{"title":"LeetCode721-合并账户","url":"/blog/2021/01/18/LeetCode721-合并账户/","content":"\n#### 题目描述\n\n给定一个列表 `accounts`，每个元素 `accounts[i]` 是一个字符串列表，其中第一个元素 `accounts[i][0]` 是 名称 *(name)*，其余元素是 *emails* 表示该账户的邮箱地址。\n\n现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。\n\n合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。\n\n<!-- more-->\n\n<img src=\"LeetCode721-合并账户\\721.png\"  />\n\n#### 思路\n\n根据邮箱之间的连通性可以找到同一名字下的所有邮箱地址。可以将字符串映射到数字域方便建立并查集，同时需要建立反向哈希表，可以从数字得到字符串（数字必须唯一）。\n\n**算法如下**：\n\n* 使用并查集将同一名字下的邮箱地址进行合并。\n\n* 再次遍历 `accounts`，找到每个邮箱地址对应的根节点，根据根节点建立节点间的连通关系。\n\n* 从根节点邮箱找到对应的名字，然后再根据上一步的连通关系找到所有邮箱。\n\n细节详见代码。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\npublic:\n    unionFind(int n){\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(qRoot == pRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n    }\n};\nclass Solution {\npublic:\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\n        unordered_map<string, string> map; // 建立邮箱对名字的映射\n        unordered_map<string, int> stoi; // 将邮箱映射为数字，方便并查集处理\n        unordered_map<int, string> itos; // 将上面的数字映射为邮箱，反向映射\n        // 邮箱与数字之间的相互映射\n        int cnt = 0;\n        for(auto &account : accounts){\n            for(int i = 1; i < account.size(); ++i){\n                if(!stoi.count(account[i])){\n                    stoi[account[i]] = cnt;\n                    itos[cnt++] = account[i];\n                }\n            }\n        }\n        // 邮箱对名字的映射\n        for(auto &account : accounts){\n            for(int i = 1; i < account.size(); ++i){\n                if(!map.count(account[i])){\n                    map[account[i]] = account[0];\n                }\n            }\n        }\n        // 建立并查集，对同一名字下的所有邮箱进行合并\n        // 使不同的accounts之间，有相同的名字时必定在一个集合中\n        unionFind uf(stoi.size());\n        for(auto &account : accounts){\n            for(int i = 2; i < account.size(); ++i){\n                uf.unionElem(stoi[account[i]], stoi[account[i - 1]]);\n            }\n        }\n        // 找到邮箱对应的根节点，建立根节点与所有相连节点的映射\n        // 此处根节点是数字，下一步需要转换为相应的邮箱（itos），再根据邮箱得到名字（map）\n        unordered_map<int, set<string>> fin;\n        for(auto &account : accounts){\n            for(int i = 1; i < account.size(); ++i){\n                // 找到当前邮箱的根节点\n                int root = uf.find(stoi[account[i]]);\n                // 根据根节点建立连通关系\n                fin[root].insert(account[i]);\n            }\n        }\n        vector<vector<string>> res;\n        for(auto m = fin.begin(); m != fin.end(); ++m){\n            vector<string> buf;\n            // 根节点数字->根节点字符串->根节点对应的名字\n            buf.push_back(map[itos[m->first]]);\n            // 将根节点相连通的所有邮箱加入答案中，set已经进行排序\n            auto vec = vector<string>(m->second.begin(), m->second.end());\n            buf.insert(buf.end(), vec.begin(), vec.end());\n            res.push_back(buf);\n        }\n        return res;\n    }\n};\n```\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"文件管理（一）","url":"/blog/2021/01/16/文件管理（一）/","content":"\n#### 本次学习要点\n\n1. 初识文件管理\n2. 文件的逻辑结构\n3. 文件目录\n\n<!-- more-->\n\n#### 初识文件管理\n\n文件：一组有意义的信息/数据集合。\n\n##### 文件的属性\n\n文件名：由创建文件的用户决定，同一目录下不允许有重名文件。\n\n标识符：操作系统用于区分各个文件（文件名相同更应如此）的一种内部名称。\n\n类型：指明文件的类型。\n\n位置：文件存放的路径、在外存中的地址。\n\n大小：指明文件的大小。\n\n创建时间、上次修改时间、文件所有者信息。\n\n保护信息：对文件进行保护的访问控制信息。\n\n##### 文件内部数据的组织\n\n<img src=\"文件管理（一）\\文件内部数据的组织.png\"  />\n\n##### 操作系统应该向上提供的功能\n\n<img src=\"文件管理（一）\\操作系统应该向上提供的功能.png\"  />\n\n* 创建文件：新建后，图形化交互进程调用了**create系统调用**。\n* 读文件：使用**read系统调用**，将文件数据从外存读入内存。\n* 写文件：使用**write系统调用**，将文件数据从内存写回外存。\n* 删除文件：删除后，图形化交互进程调用了**delete系统调用**。\n\n* 打开文件：读/写文件之前，需要打开文件，使用**open系统调用**。\n* 关闭文件：读/写文件结束之后，需要关闭文件，使用**close系统调用**。\n\n##### 从上往下看，文件应如何存放在外存？\n\n类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址。每个存储单元对应一个物理地址。\n\n##### 其他需要由操作系统实现的功能\n\n* 文件共享：使多个用户可以共享使用要给文件。\n* 文件保护：不同的用户对文件有不同的操作权限。\n\n##### 小结\n\n<img src=\"文件管理（一）\\初识文件管理小结.png\"  />\n\n#### 文件的逻辑结构\n\n<img src=\"文件管理（一）\\文件的逻辑结构.png\" style=\"zoom:80%;\" />\n\n##### 无结构文件\n\n文件内部的数据就是一系列的二进制流或字符流组成。又称**流式文件**。如 `txt` 文件。\n\n##### 有结构文件\n\n由一组相似的记录组成，又称**记录式文件**。每条记录由若干个数据项组成，如数据库表文件。一般每条记录有一个数据项可作为**关键字**。根据各条记录的长度是否相等，可分为**定长记录**和**可变长记录**。\n\n##### 有结构文件的逻辑结构\n\n<img src=\"文件管理（一）\\有结构文件的逻辑结构.png\" style=\"zoom:80%;\" />\n\n###### 顺序文件\n\n文件中记录连续排列（逻辑上），记录可以是**定长**或**可变长**的。各个记录再物理上可以是**顺序存储**或**链式存储**。\n\n<img src=\"文件管理（一）\\顺序文件存储方式.png\"  />\n\n* 串结构：记录之间的顺序与关键字无关。\n* 顺序结构：记录之间的顺序按关键字顺序排列。\n\n<img src=\"文件管理（一）\\顺序文件存储方式+结构.png\" style=\"zoom:80%;\" />\n\n结论：定长记录的顺序文件，若物理上采用顺序存储，可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索。\n\n###### 索引文件\n\n**可变长记录**文件时查找第 `i` 个记录必须先查找前 `i-1` 个记录，如何解决这个问题？\n\n---\n\n索引表：**定长记录**的**顺序文件**，可以快速找到第 `i` 个记录对应的索引项。应用于对信息处理的及时性要求比较好的场合。\n\n<img src=\"文件管理（一）\\索引表.png\" style=\"zoom:80%;\" />\n\n###### 索引顺序文件\n\n与索引文件不同的是，不对每个记录都建立索引表项，而是**一组记录对应一个索引表项**。下图中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不许眼按关键字排序。**索引顺序文件指索引表中的项是按关键字排列的**。\n\n<img src=\"文件管理（一）\\索引顺序文件.png\" style=\"zoom:80%;\" />\n\n**多级索引顺序文件**\n\n为了进一步提高检索效率，可以为顺序文件建立多级索引表。\n\n<img src=\"文件管理（一）\\多级索引顺序文件.png\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"文件管理（一）\\文件的逻辑结构小结.png\"  />\n\n#### 文件目录\n\n<img src=\"文件管理（一）\\文件目录.png\" style=\"zoom:80%;\" />\n\n##### 文件控制块\n\n<img src=\"文件管理（一）\\文件控制块FCB.png\" style=\"zoom:80%;\" />\n\n**FCB**的有序集合称为“文件目录”，一个**FCB**就是一个文件**目录项**。\n\n**FCB**包含了文件的基本信息（文件名、物理地址、逻辑地址、物理结构等），存储控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（文件的建立时间、修改时间等）。\n\n**最基本的是**：文件名、文件存放的物理地址。\n\n对目录进行的操作：\n\n* 搜索：系统根据文件名搜索目录，找到该文件对应的目录项。\n* 创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项。\n* 删除文件：当删除一个文件时，需要在目录中删除对应的目录项。\n* 显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性。\n* 修改目录：目录中保存了某些文件属性，这些属性变化时需要修改相应的目录项（如文件重命名）。\n\n##### 目录结构\n\n###### 单级目录结构\n\n实现了**按名存取**，但是**不允许文件重名**。不适合多用户操作系统\n\n<img src=\"文件管理（一）\\单级目录结构.png\" style=\"zoom:80%;\" />\n\n###### 两级目录结构\n\n分为**主文件目录**和**用户文件目录**。\n\n<img src=\"文件管理（一）\\两级目录结构.png\" style=\"zoom:80%;\" />\n\n###### 多级目录结构（树形目录结构）\n\n文件路径名是个字符串，各级目录之间用”/“隔开， 从根目录出发的路径称为**绝对路径**。系统根据绝对路径一层一层的找到下一级目录。树形结构**不利于实现文件共享**。\n\n<img src=\"文件管理（一）\\多级目录结构.png\" style=\"zoom:80%;\" />\n\n`自拍.jpg`的绝对路径为`/照片/2015-0/自拍.jpg`。找到此文件需要3次读磁盘I/O操作。\n\n每次从根目录查找很低效，可以设置**当前目录**，当用户访问某个文件时，可以使用**从当前目录出发**的**相对路径**。\n\n###### 无环图目录结构\n\n<img src=\"文件管理（一）\\无环图目录结构.png\" style=\"zoom:80%;\" />\n\n用户提出删除节点时，只删除该用户的PCB，并使共享计数器减1，不会直接删去共享节点。只要共有计数器减为0时才删除节点。\n\n##### 索引节点（FCB的改进）\n\n一般查找只需要用到**文件名**这个信息，文件名匹配时才需要读出文件的其他信息，所以可以使目录表包含最有用的信息来提高效率，如下图：\n\n<img src=\"文件管理（一）\\索引节点.png\" style=\"zoom:80%;\" />\n\n存放在**外存**的索引节点称为**磁盘索引节点**，当索引节点**放入内存**后称为**内存索引节点**。内存索引节点需要增加一些信息，如：文件是否被修改，此时有几个进程在访问该文件等。\n\n##### 小结\n\n<img src=\"文件管理（一）\\文件目录小结.png\"  />\n\n","categories":["操作系统"]},{"title":"LeetCode947-移除最多的同行或同列石头","url":"/blog/2021/01/15/LeetCode947-移除最多的同行或同列石头/","content":"\n#### 题目描述\n\n`n` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。\n\n如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。\n\n给你一个长度为 `n` 的数组 `stones` ，其中 `stones[i] = [xi, yi]` 表示第 `i` 块石头的位置，返回 **可以移除的石子** 的最大数量。\n\n<!-- more-->\n\n<img src=\"LeetCode947-移除最多的同行或同列石头\\947.png\"  />\n\n#### 思路\n\n这个题的意思是：某行或者某列上最多只能存在一个石头，求移除的石头总数。\n\n对于 `stones` 中任意两个位置，如果相对应的位置有一个相等，说明两个位置存在**相同的**行或者列，可以合并为一个集合。根据上述条件，使用双重循环将 `stones` 两两结合，最终合并的次数就是移除的石头个数，可以由 `stones` 的长度减去并查集中连通分量个数得到。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(0);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int removeStones(vector<vector<int>>& stones) {\n        int n = stones.size();\n        unionFind uf(n);\n        for(int i = 0; i < n; ++i){\n            for(int j = i + 1; j < n; ++j){\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\n                    uf.unionElem(i, j);\n            }\n        }\n        return stones.size() - uf.getCount();\n    }\n};\n```\n\n时间复杂度为 `O(n^2)`。\n\n#### 更进一步\n\n如果将 `stones` 中的位置与其相应的行或者列绑定，那么可以将二维降为一维，将行和列当作一个数字，降低了时间复杂度。\n\n* 当遍历到点 `[x,y]` 时，直接将 `x` 和 `y` 进行合并，表示该行和该列的点属于同一个并查集（根节点相同）。\n* `x` 和 `y` 的值可能相等，相等时不能进行合并（一维情况下，行与列需要区分开），根据题目范围，将 `y` 加上10001，两者不会重合。\n\n##### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    unordered_map<int, int> parent, rank;\n    int count;\npublic:\n    unionFind():count(0){};\n    int find(int p){\n        // 当不存在p时，创建p并且指向自身，根节点数加1\n        if(!parent.count(p)){\n            parent[p] = p;\n            count++;\n        }\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int removeStones(vector<vector<int>>& stones) {\n        int n = stones.size();\n        unionFind uf;\n        for(auto &stone : stones){\n            uf.unionElem(stone[0], stone[1] + 10001); \n        }\n        return stones.size() - uf.getCount();\n    }\n};\n```\n\n#### Reference\n\n题解：https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode684-冗余连接","url":"/blog/2021/01/13/LeetCode684-冗余连接/","content":"\n#### 题目描述\n\n在本问题中, 树指的是一个连通且无环的无向图。\n\n输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以边组成的二维数组。每一个边的元素是一对 `[u, v]`，满足 `u < v`，表示连接顶点 `u` 和 `v` 的无向图的边。\n\n返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。\n\n<!-- more-->\n\n<img src=\"LeetCode684-冗余连接\\684.png\"  />\n\n#### 思路\n\n并查集中使用 `count` 记录当前还有多少个根节点，如果**上一次的根节点数等于本次的根节点数**，说明本次的合并无效，记录当前坐标即可。一次遍历结束后，找到了不需要进行合并的最后一个边。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(int n){\n        this->count = n;\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--; // 合并一次，根节点数减1\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        unionFind uf(edges.size());\n        int pre; // 上一次根节点数\n        int index; // 不需要合并的最后一个边的位置\n        for(int i = 0; i < edges.size(); ++i){\n            pre = uf.getCount();\n            uf.unionElem(edges[i][0] - 1, edges[i][1] - 1);\n            // 上次根节点数等于本次合并后根节点数，更新index\n            if(pre == uf.getCount()) index = i;\n        }\n        return edges[index];\n    }\n};\n```\n\n","tags":["并查集","图论"],"categories":["LeetCode"]},{"title":"LeetCode1203-项目管理","url":"/blog/2021/01/12/LeetCode1203-项目管理/","content":"\n#### 题目描述\n\n公司共有 `n` 个项目和  `m` 个小组，每个项目要不无人接手，要不就由 `m` 个小组之一负责。\n\n`group[i]` 表示第 `i` 个项目所属的小组，如果这个项目目前无人接手，那么 `group[i]` 就等于 `-1`。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。\n\n请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：\n\n同一小组的项目，排序后在列表中彼此相邻。\n项目之间存在一定的依赖关系，我们用一个列表 `beforeItems` 来表示，其中 `beforeItems[i]` 表示在进行第 `i` 个项目前（位于第 `i` 个项目左侧）应该完成的所有项目。\n如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 **空列表** 。\n\n<!-- more-->\n\n<img src=\"LeetCode1203-项目管理\\1203.png\"  />\n\n#### 思路\n\n这道题是真的难，看了别人的题解才勉强写出来。\n\n##### 拓扑排序\n\n在有向无环图（DAG）问题中，如果节点之间含有**依赖关系**，比如要完成 `B` 工作，必须先完成 `A` 工作，考虑进行**拓扑排序**，有关知识点参考[这里](https://www.cnblogs.com/bigsai/p/11489260.html)。\n\n**C++模板**：\n\n```cpp\n// 图，节点入度，节点编号\nvector<int> topSort(vector<vector<int>> &G, vector<int> &inDegree, vector<int> &id){\n    queue<int> q;\n    for(auto &i : id){\n        if(inDegree[i] == 0) q.push(i);\n    }\n    int times = 0; // 记录已经出队多少个点，小于节点数说明有环\n    vector<int> afterSort;\n    while(!q.empty()){\n        // 取出第一个入度为0的点\n        int cur = q.front();\n        afterSort.push_back(cur);\n        q.pop();\n        times++;\n        // 遍历图\n        for(int i = 0; i < G[cur].size(); ++i){\n            inDegree[G[cur][i]]--;\n            if(inDegree[G[cur][i]] == 0)\n                q.push(G[cur][i]);\n        }\n    }\n    if(times < id.size()) return {};\n    return afterSort;\n}\n```\n\n##### 关于本题\n\n从宏观来看，本题要求同一小组所处理的项目是相邻的，**小组与小组之间**是有依赖关系的，根据 `Before` 得到。同时，**项目与项目之间**也是有依赖关系的，也是由 `Before` 得到。以示例1为例：\n\n* 项目与项目之间：对于小组0，3必须在6之后，4必须在3和6之后。\n* 小组与小组之间：小组-1中的1必须在小组0中的6之后。\n\n根据以上两条信息，可以先对所有小组进行拓扑排序，再对排好序的小组集合中的每个小组进行一个拓扑排序，就可以得到结果了。**所有小组号为-1的表示当前未进行处理，可以给其分配一个新的组号，从m开始递增**，只要拓扑排序时无环，所有的项目都会被处理掉。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems){      \n        // 将同一组的放一起\n        // 比如3, 4, 6分组为0，则sameGroup[0] = {3,4,6}\n        vector<vector<int>> sameGroup(n + m);\n        int samegroup = m;\n        for(int i = 0; i < group.size(); ++i){\n            if(group[i] == -1) group[i] = samegroup++;\n            sameGroup[group[i]].push_back(i);\n        }\n        // 最多会有n + m个小组（比如m=2, 所有分组都为-1）\n        // n + m个小组的序号\n        vector<int> groupid;\n        for(int i = 0; i < n + m; ++i) groupid.push_back(i);\n        // 建立group图和item图及其入度\n        vector<vector<int>> itemGraph(n);\n        vector<vector<int>> groupGraph(n + m);\n        vector<int> itemIndegree(n, 0);\n        vector<int> groupIndegree(n + m, 0);\n        for(int i = 0; i < beforeItems.size(); ++i){\n            int curId = group[i];\n            for(auto &item : beforeItems[i]){\n                // 如果是同一个组，那么有item->i\n                // i入度+1，同时节点item可达i\n                if(group[item] == curId){ \n                    itemIndegree[i]++;\n                    itemGraph[item].push_back(i);\n                }\n                // 不同组，有小组group[item]->curId\n                // 小组curId入度+1，同时小组group[item]可达curId\n                else{ \n                    groupIndegree[curId]++;\n                    groupGraph[group[item]].push_back(curId);\n                }\n            }\n        }\n        // 对group图进行topSort，得到小组之间的拓扑关系\n        auto outGroup = topSort(groupGraph, groupIndegree, groupid);\n        // 对每个小组进行topSort，得到组内的拓扑关系\n        vector<int> ret;\n        for(auto &g : outGroup){\n            auto id = sameGroup[g];\n            if(id.empty()) continue;\n            auto res = topSort(itemGraph, itemIndegree, id);\n            if(res.empty()) return {};\n            for(auto &r : res)\n                ret.push_back(r);\n        }\n        return ret;\n    }\n    // 参数：图，入度，当前的节点集合\n    vector<int> topSort(vector<vector<int>> &G, vector<int> &inDegree, vector<int> &id){\n        queue<int> q;\n        for(auto &i : id){\n            if(inDegree[i] == 0) q.push(i);\n        }\n        int times = 0; // 记录已经出队多少个点，小于id数说明有环\n        vector<int> afterSort;\n        while(!q.empty()){\n            // 取出第一个入度为0的点\n            int cur = q.front();\n            afterSort.push_back(cur);\n            q.pop();\n            times++;\n            // 遍历图\n            for(int i = 0; i < G[cur].size(); ++i){\n                inDegree[G[cur][i]]--;\n                if(inDegree[G[cur][i]] == 0)\n                    q.push(G[cur][i]);\n            }\n        }\n        if(times < id.size()) return {}; // 有环，返回空\n        return afterSort;\n    }\n};\n```\n\n#### Reference\n\n题解：https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/chao-xiang-xi-shuang-ceng-tuo-bu-pai-xu-5cyuc/\n\n拓扑排序：https://www.cnblogs.com/bigsai/p/11489260.html","tags":["拓扑排序","图论"],"categories":["LeetCode"]},{"title":"LeetCode1202-交换字符串中的元素","url":"/blog/2021/01/11/LeetCode1202-交换字符串中的元素/","content":"\n#### 题目描述\n\n给你一个字符串 `s`，以及该字符串中的一些「索引对」数组 `pairs`，其中 `pairs[i] = [a, b]` 表示字符串中的两个索引（编号从 0 开始）。\n\n你可以 **任意多次交换** 在 `pairs` 中任意一对索引处的字符。\n\n返回在经过若干次交换后，`s` 可以变成的按字典序最小的字符串。\n\n<!-- more-->\n\n<img src=\"LeetCode1202-交换字符串中的元素\\1202.png\"  />\n\n#### 思路\n\n~~不看提示我都没想到用并查集去解决这个问题~~。\n\n以示例三为例：`s = \"cba\", pairs = [[0,1],[1,2]]`，输出为 `\"abc\"`。可以看出 `pairs` 中 `0,1,2` 三个点是相连的。相连的点在 `s` 中对应的元素 `\"cba\"` 可以任意排序，我们需要让这些元素的组合字典序最小，可以得到 `\"abc\"`。\n\n将上述例子扩充，`s = \"cbafd\", pairs = [[0,1],[1,2],[4,3]]`，输出为 `\"abcdf\"`。其中 `0,1,2` 相连，`4,3` 相连，分别将两个集合中对应的位置**升序排序**得到 `0,1,2` 和 `3,4`，再将 `s` 中对应位置元素取出来按照**字典序排序**，再根据对应位置修改 `s` 中的元素。所以**一共需要进行两次排序**。\n\n---\n\n我们将 `pairs` 中的**每一个**元素想象成一个孤立的点，对于 `pairs` 中的**每一对**元素，表示两个点相连，所有相连的点构成不同的集合（只需要知道是否相连，不需要知道如何相连），所以使用并查集即可。\n\n**算法如下**：\n\n* 将 `pairs` 中的**每一对**元素进行 `union` 操作，再将它们根据共同祖先分为**若干集合**。\n* 将每个集合中的序列**升序排列**，再找到 `s` 中对应的元素，将这些元素按**字典序**排序。\n* 将按字典序排列的元素按照集合中序列的顺序依次修改 `s`。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count; // 未用到\npublic:\n    unionFind(string &s){\n        this->count = 0; // 未用到\n        int n = s.size();\n        for(int i = 0; i < n; ++i){\n            parent.push_back(i);\n            rank.push_back(1);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[qRoot] < rank[pRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[qRoot] = pRoot;\n            rank[pRoot]++;\n        }\n    }\n};\nclass Solution {\npublic:\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\n        if(pairs.size() == 0) return s;\n        unionFind uf(s);\n        for(int i = 0; i < pairs.size(); ++i){\n            uf.unionElem(pairs[i][0], pairs[i][1]);\n        }\n        auto rootIdx = vector<vector<int>>(s.size());\n        // 如果祖先相同，代表在同一个集合中\n        for(int i = 0; i < s.size(); ++i){\n            int root = uf.find(i);\n            rootIdx[root].push_back(i);\n        }\n        for(int i = 0; i < rootIdx.size(); ++i){\n            if(rootIdx[i].empty()) continue;\n            // 将同一个祖先的序列升序排列\n            sort(rootIdx[i].begin(), rootIdx[i].end());\n            string buf;\n            // 根据排好序的序列取出s中的元素\n            for(auto &v : rootIdx[i]){\n                buf += s[v];\n            }\n            // 再将取出的元素按照字典序排列\n            sort(buf.begin(), buf.end());\n            int j = 0;\n            // 将排好序的字符串根据排好序的序列修改s中相应的位置\n            for(auto &v : rootIdx[i]){\n                s[v] = buf[j++];\n            }\n        }\n        return s;\n    }\n};\n```\n\n","tags":["并查集"],"categories":["LeetCode"]},{"title":"LeetCode228-汇总区间","url":"/blog/2021/01/10/LeetCode228-汇总区间/","content":"\n#### 题目描述\n\n给定一个无重复元素的有序整数数组 `nums` 。\n\n返回 **恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。\n\n列表中的每个区间范围 `[a,b]` 应该按如下格式输出：\n\n* `\"a->b\"` ，如果 `a != b`\n* `\"a\"` ，如果 `a == b`\n\n<!-- more-->\n\n<img src=\"LeetCode228-汇总区间\\228.png\"  />\n\n#### 思路\n\n如果序列满足 `nums[i] == nums[i - 1]` 代表它们是同一个区间。\n\n需要记录区间的起始位置的终止位置，使用双指针，`i` 代表当前区间的起始位置， `j` 代表当前区间的终止位置。\n\n遍历结束时，还需要**把最后一个区间加入答案中**，如果最后一个区间的 `j - i == 1`，说明最后一个区间只有一个数，否则，需要再加入一个新的区间。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        if(nums.empty()) return {};\n        vector<string> ret;\n        int i = 0, j = 1;\n        while(j < nums.size()){\n            if(nums[j] == nums[j - 1] + 1){\n                j++;\n            }\n            else{\n                if(j == i + 1){\n                    ret.push_back(to_string(nums[i]));\n                    j++;\n                    i++;\n                }\n                else{\n                    ret.push_back(to_string(nums[i]) + \"->\" + to_string(nums[j - 1]));\n                    i = j;\n                    j++;\n                }\n            }\n        }\n        if(i == j - 1) ret.push_back(to_string(nums[i]));\n        if(i != j - 1) ret.push_back(to_string(nums[i]) + \"->\" + to_string(nums[j - 1]));\n        return ret;\n    }\n};\n\n```\n\n","tags":["双指针"],"categories":["LeetCode"]},{"title":"LeetCode189-旋转数组","url":"/blog/2021/01/08/LeetCode189-旋转数组/","content":"\n#### 题目描述\n\n给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。\n\n**进阶**：\n\n* 尽可能想出更多的解决方案，~~至少有三种不同的方法可以解决这个问题~~。\n* 你可以使用空间复杂度为 O(1) 的 **原地** 算法解决这个问题吗？\n\n<!-- more-->\n\n<img src=\"LeetCode189-旋转数组\\189.png\"  />\n\n#### 思路\n\n根据 `k` 值，将 `nums` 数组分为前后两个部分。将后 `k` 个值截取出来得到的数组，拼接到剩余数组之前即可。空间复杂度为 `O(n)`。\n\n#### 代码\n\n```cpp\n// 99% 9%\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size(); // 如果k大于nums的长度，取余之后再进行处理\n        vector<int> buf1(nums.begin() + nums.size() - k, nums.end());\n        vector<int> buf2(nums.begin(), nums.begin() + nums.size() - k);\n        buf1.insert(buf1.end(), buf2.begin(), buf2.end());\n        nums = buf1;\n    }\n};\n```\n\n#### 更进一步\n\n上述的空间复杂度为 `O(n)`，可以进一步压缩空间，使空间复杂度降为 `O(1)`。\n\n##### 思路\n\n具体思路如下：\n\n```\nk = 3;\n---->--> 移动后得到 -->---->\n可以对原始序列进行如下操作：\n---->--> 反转后 <--<----\n其中<-- 反转后 --><----\n其中<---- 反转后 -->---->\n```\n\n##### 代码\n\n````cpp\n// 库函数 50.50% 84.77%\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    }\n};\n// 非库函数 50.50% 74.88%\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        reverse(nums, 0, nums.size() - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.size() - 1);\n    }\n    void reverse(vector<int> &nums, int start, int end){\n        while(start < end){\n            swap(nums[start], nums[end]);\n            start++;\n            end--;\n        }\n    }\n};\n````\n\n虽然速度慢了点（实际上为 `O(2n) = O(n)` ），不过空间使用较之前还是低了很多。\n\n#### Reference\n\n官方题解及其评论区：https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/","tags":["数组"],"categories":["LeetCode"]},{"title":"内存管理（五）","url":"/blog/2021/01/08/内存管理（五）/","content":"\n#### 本次学习要点\n\n1. 虚拟内存基本概念\n2. 请求分页管理方式\n3. 页面置换算法\n4. 页面分配策略\n\n<!-- more-->\n\n#### 虚拟内存基本概念\n\n##### 传统存储管理方式的特征、缺点\n\n传统存储管理特点：\n\n1. 一次性：作业必须**一次性全部装入内存**才能开始运行。\n2. 驻留性：一旦作业被装入内存，就**会一直驻留在内存中**。\n\n很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。\n\n##### 局部性原理\n\n* 时间局部性\n* 空间局部性\n\n##### 虚拟内存的定义和特征\n\n虚拟内存：若内存空间不够，由**操作系统**负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**。虚拟性体现在：实际的物理内存大小没有变，只是在逻辑上进行了扩充。\n\n* 虚拟内存最大容量：计算机的地址结构（CPU寻址范围）确定。\n* 虚拟内存实际容量：*min*(内存和外存容量之和，CPU寻址范围)。\n\n虚拟内存有以下三个特征：\n\n1. 多次性（对应一次性）：允许作业被分成多次调入内存。\n2. 对换性（对应驻留性）：允许作业运行中，将作业换出、换入内存。\n3. 虚拟性：从逻辑上扩充了内存的容量。\n\n##### 如何实现虚拟内存技术\n\n<img src=\"内存管理（五）\\虚拟内存的实现.png\"  />\n\n虚拟内存技术基于**离散分配**的内存管理方式。**请求分页存储管理**与**基本分页存储管理**的**主要区别**是：操作系统需要提供**请求调页**和**页面置换**功能。\n\n* 请求调页：程序执行过程中，当所访问信息**不在内存中**时，由操作系统负责**将所需信息从外存调入内存**。\n* 页面置换：若内存空间不够，由操作系统将**内存中暂时用不到的信息换出到外存**。\n\n##### 小结\n\n<img src=\"内存管理（五）\\虚拟内存基本概念小结.png\" style=\"zoom:120%;\" />\n\n#### 请求分页管理方式\n\n<img src=\"内存管理（五）\\请求分页管理方式.png\"  />\n\n##### 页表机制\n\n* 为了实现**请求调页**，操作系统需要知道每个页面是否已经调入内存；如果没调入，那么也需要知道该页面在外存中存放的位置。\n* 为了实现**内存置换**，操作系统需要通过某些指标来决定到底换出哪个页面。需要记录各个页面是否被修改过，修改过才需要换出，将外存中的旧数据覆盖。\n\n<img src=\"内存管理（五）\\页表机制.png\"  />\n\n##### 缺页中断机构\n\n请求分页系统中，若访问页面**不在内存中**时，便产生一个**缺页中断**。然后由操作系统的**缺页中断处理程序**处理中断。此时**缺页的进程阻塞**，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。\n\n* 如果内存中**有空闲块**，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中对应页表项。\n\n* 如果内存中**无空闲块**，则由**页面置换算法**选择**淘汰**一个页面，若该页面在内存期间被**修改过**，则要将其**写回外存**。未修改过的页面不用写回外存。\n\n缺页中断是由于当前指令想要访问的目标页面未调入内存而产生的，因此属于**内中断**。一条指令在执行期间，可能产生**多次**缺页中断。\n\n<img src=\"内存管理（五）\\缺页中断机构.png\"  />\n\n##### 地址变换机构\n\n<img src=\"内存管理（五）\\地址变化机构.png\"  />\n\n* 新增步骤1：请求调页（查到页表项时进行判断）。\n* 新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）。\n* 新增步骤3：需要修改请求页表中新增的表项。\n\n<img src=\"内存管理（五）\\地址变化机构步骤.png\" style=\"zoom:120%;\" />\n\n补充：\n\n1. 换入/换出页面需要启动慢速I/O操作，如果过于频繁，会有很大开销。\n2. 页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。\n\n在具有快表的请求分页系统中，访问一个逻辑地址时，若发生缺页，地址变换步骤为：\n\n```\n查快表（未命中）->查慢表（发现未调入内存）->调页（调入的页面对应的表项会直接加入快表）\n->查快表（命中）->访问目标内存单元\n```\n\n##### 小结\n\n<img src=\"内存管理（五）\\地址变化机构小结.png\" style=\"zoom:120%;\" />\n\n#### 页面置换算法\n\n<img src=\"内存管理（五）\\页面置换算法.png\" style=\"zoom:80%;\" />\n\n##### 最佳置换算法（OPT）\n\n每次选择淘汰的页面**以后永不使用**或**最长时间内不再被访问**，保证最低缺页率。\n\n缺点：只有进程执行的过程中才能知道接下来会访问到哪个页面，操作系统无法提前预判访问序列。因此，最佳置换算法**无法实现**。\n\n##### 先进先出置换算法（FIFO）\n\n每次选择淘汰的页面是**最早进入内存的页面**。\n\nBelady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。\n\n缺点：只有FIFO算法会产生**Belady异常**，虽然其实现简单，但是与进程实际运行时规律不适应，因为先进入的页面也有可能最经常被访问。因此算法**性能差**。\n\n#####  最近最久未使用置换算法（LRU）\n\n每次选择淘汰的页面是**最近最久未使用的页面**。用每个页面页表项中的**访问字段**记录该页面自上次被访问以来所经历的时间 t 。淘汰时选择 t 最大的页面。\n\n缺点：实现需要专门的硬件支持，虽然算法性能好，但**实现困难，开销大**。\n\n##### 时钟置换算法（CLOCK）\n\n此算法是一种性能和开销较均衡的算法，也称**最近未用算法（NRU，Not Recently Used）**。\n\n简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个**循环队列**。当某页被访问时，其**访问位置为1**。**当需要淘汰一个页面时，只需检查页的访问位**。\n\n<img src=\"内存管理（五）\\简单clock.png\"  />\n\n* 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面。\n* 若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）。\n\n###### 改进型的时钟置换算法\n\n简单的CLOCK算法**仅考虑一个页面最近是否被访问过**，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。**只有被淘汰的页面被修改过，才需要写回外存**。\n\n因此，在其他条件都相同时，应**优先淘汰没有修改过的页面**，避免I/O操作。修改位为0时表示没有修改过，修改位为1，表示页面被修改过。\n\n改进型CLOCK置换算法选择一个淘汰页面最多会进行**四轮扫描**。\n\n##### 小结\n\n<img src=\"内存管理（五）\\页面置换算法小结.png\"  />\n\n#### 页面分配策略\n\n##### 页面分配、置换策略\n\n驻留集：请求分页存储管理中给进程分配的物理块的集合。驻留集大小一般小于进程的总大小。\n\n* 若驻留集太小，会导致缺页频繁。\n* 若驻留集太大，会导致多道程序并发度下降。\n\n固定分配：操作系统为每个进程分配一组固定数目的物理块。进程运行期间驻留集**大小不变**。\n\n可变分配：驻留集**大小可变**。\n\n局部置换：缺页时只能选进程自己的物理块进行置换。\n\n全局置换：操作系统保留的空闲物理块和别的进程持有的物理块（先置换到外存）都可以分配给缺页进程。\n\n<img src=\"内存管理（五）\\页面置换策略.png\"  />\n\n可变分配**全局**置换：只要缺页就给分配新物理块。\n\n可变分配**局部**置换：根据**缺页的频率**来动态地增加或减少进程的物理块。\n\n##### 何时调入页面\n\n1. 预调页策略：根据空间局部性，一次调入若干相邻的页面可能比一次调入一个页面更高效。主要用于**进程的首次调入**，由程序员指出（**运行前调入**）。\n2. 请求调页策略：进程在**运行期间**发现缺页时才将所缺页面调入内存。I/O开销较大（每次只能调入一页，每次调页都要进行磁盘I/O）。\n\n##### 何处调入页面\n\n###### 系统拥有足够的对换区空间\n\n<img src=\"内存管理（五）\\何处调入1.png\"  />\n\n###### 系统缺少足够的对换区空间\n\n<img src=\"内存管理（五）\\何处调入2.png\"  />\n\n###### UNIX方式\n\n<img src=\"内存管理（五）\\何处调入3.png\"  />\n\n##### 抖动（颠簸）现象\n\n刚换出的页面马上要换入内存，或刚换入的需要换出，这种频繁的页面调度行为称为**抖动（颠簸）**。主要原因是进程频繁访问的页面数目高于可用的物理块数（**分配给进程的物理块不够**）。\n\n##### 工作集\n\n驻留集：指请求分页存储管理中给进程分配的内存块的集合。\n\n工作集：指在某段时间间隔里，进程实际访问页面的集合。\n\n<img src=\"内存管理（五）\\工作集.png\"  />\n\n**窗口尺寸为4**。\n\n**工作集大小**可能小于窗口尺寸，一般来说，驻留集大小不能**小于**工作集大小，否则进程运行过程中将频繁缺页。\n\n##### 小结\n\n<img src=\"内存管理（五）\\页面分配策略小结.png\" style=\"zoom:120%;\" />","categories":["操作系统"]},{"title":"LeetCode547-省份数量","url":"/blog/2021/01/07/LeetCode547-省份数量/","content":"\n#### 题目描述\n\n有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。\n\n**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\n\n给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。\n\n返回矩阵中 **省份** 的数量。\n\n<!-- more-->\n\n<img src=\"LeetCode547-省份数量\\547.png\"  />\n\n#### 思路\n\n此题的核心问题是**节点之间是否相连**。如果找到了这个核心点，就可以想到两种解决方案。一种是图论中，计算**连通分量**的个数；另一种是并查集，找到大家的**公共祖先**的个数。\n\n考虑到我们并不需要知道节点与节点之间**如何连接**，只需要知道节点与节点之间**是否连接**，所以使用**并查集**来解决这个问题就足够了。\n\n并查集的相关知识可参考[这里]([http://www.xingyuzhao.ltd/blog/2020/09/06/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find/)，建议先看！\n\n输入矩阵的长或者宽（其实就是一个邻接矩阵）的大小就是城市的个数，所以对于并查集的初始化，我们只需要设置长度与城市个数相等的`parent`数组即可，并且指向自身，同时可以初始化当前祖先的总数，即城市的个数。\n\n在遍历`isconnected`矩阵时，遇到`isconnected[i][j]`为 1 时，代表`i, j`两节点相连，进行`union(i, j)`操作。同时祖先数减去 1 。否则不相连，不进行任何操作。\n\n#### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(vector<vector<int>> &grid){\n        this->count = 0;\n        int m = grid.size();\n        for(int i = 0; i < m; ++i){\n            parent.push_back(i);\n            count++;\n            rank.push_back(0);\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot){\n            return;\n        }\n        // 根不同，将其相连，计数减1\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            parent[pRoot] = qRoot; // 随便指一个\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        if(isConnected.empty()) return 0;\n        unionFind uf(isConnected);\n        int m = isConnected.size();\n        int n = isConnected[0].size();\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(isConnected[i][j] == 1){\n                    uf.unionElem(i, j);\n                }         \n            }\n        }\n        return uf.getCount();\n    }\n};\n```\n\n","tags":["并查集"],"categories":["LeetCode"]},{"title":"LeetCode399-除法求值","url":"/blog/2021/01/06/LeetCode399-除法求值/","content":"\n#### 题目描述\n\n给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。\n\n另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。\n\n返回 所有问题的答案 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。\n\n**注意**：输入总是有效的。你可以假设除法运算中不会出现除数为 `0` 的情况，且不存在任何矛盾的结果。\n\n<!-- more-->\n\n<img src=\"LeetCode399-除法求值\\399.png\"  />\n\n#### 思路\n\n首先得理解题目意思：\n\n* `equations`和`values`：`equations`中每个一维序列表示一对数进行相除（前 / 后），得到的结果就是`values`中相应位置的值，以上作为已知条件。\n* `queries`：包含两个元素，目的是要我们求：第一个元素 / 第二个元素 = ？\n\n我们可以将其抽象为一个**带权图**问题，对于`queries`中的两个元素 `x`, `y` ，是否有一条路径可以从 `x` 到 `y` ，并求出经过这条路径的消耗是多少。由于两个元素的比值是一个常量，所以**如果有多条路径，消耗是一样的**，选其中一条就可以。\n\n以示例1为例，对于`a/c`，可以由`a/b * b/c`得到，也就是`a->b`与`b->c`两条路径的权值相乘得到，所以路径上的消耗，就是**所走过的每条路径的权值之积**。\n\n由于每个基本元素类型都是`string`，所以先对所有的元素映射到数字域，方便查找：\n\n```cpp\n// 将equations中的string映射到0，1，2，3...\nunordered_map<string, int> map;\nint cnt = 0;\nfor(auto &s : equations){\n    for(auto &ch : s){\n    \tif(!map.count(ch)) map[ch] = cnt++;\n    }\n}\n```\n\n下一步就是建图，使用邻接表，并且路径之间是**双向**的，权值**互为倒数**：\n\n```cpp\nvector<vector<int>> G;\nvector<vector<double>> W;\nG = vector<vector<int>>(map.size());\nW = vector<vector<double>>(map.size());\nfor(int i = 0; i < equations.size(); ++i){\n    G[map[equations[i][0]]].push_back(map[equations[i][1]]);\n    W[map[equations[i][0]]].push_back(values[i]);\n    G[map[equations[i][1]]].push_back(map[equations[i][0]]);\n    W[map[equations[i][1]]].push_back(1 / values[i]);\n}\n```\n\n建好图之后，就可以用**深度优先搜索（DFS）**和**回溯算法**来找路了，需要用一个数组记录走过的节点，防止重复走过，还需要一个变量`flag`表示起点与终点之间是否存在路径：\n\n```cpp\nint flag = 0; // 初始为0，表示起点与终点之间没有路径。设置为全局变量，在函数中不用调用。\nvector<bool> vis;\nvis = vector<bool>(map.size());\nfor (auto& querie : queries) {\n    string s1 = querie[0];\n    string s2 = querie[1];\n    // 如果两个元素相同并且存在于map中，结果就是1\n    if (s1 == s2 && map.count(s1)) {\n        res.push_back(1.0);\n        continue;\n    }\n    // 如果有一个元素不存在于map中，结果就是-1，因为没有这条路径\n    if (!map.count(s1) || !map.count(s2)) {\n        res.push_back(-1.0);\n        continue;\n    }\n    // 将起点标记为已使用\n    vis[map[s1]] = true;\n    // 参数：图，权值，标记数组，起点，终点，当前计算结果（初始为1）\n    dfs(G, W, vis, map[s1], map[s2], 1);\n    // 使用过后，再次标记为未使用\n    vis[map[s1]] = false;\n    // 没有路径，结果为-1\n    if (flag == 0) res.push_back(-1.0);\n    // 已经有路径，将flag置为0，结果已经在DFS中记录过，所以不用再次记录了\n    else {\n        flag = 0;\n    }\n}\n```\n\nDFS+回溯：\n\n```cpp\nvoid dfs(vector<vector<int>> &G, vector<vector<double>> &W, vector<bool> &vis, int start, int end, double val){\n    if(start == end){\n        res.push_back(val);\n        // 有路径，flag为1\n        flag = 1;\n        return;\n    }\n    for(int i = 0; i < G[start].size(); ++i){\n        // 如果flag已经为1了，说明找到一条路径了，就不需要再找了\n        // 剩下的就是一般的回溯算法\n        if(vis[G[start][i]] || flag == 1) continue;\n        vis[G[start][i]] = true;\n        val *= W[start][i];\n        dfs(G, W, vis, G[start][i], end, val);\n        val /= W[start][i];\n        vis[G[start][i]] = false;\n    }\n}\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<double> res;\n    int flag = 0;\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        vector<vector<int>> G;\n        vector<vector<double>> W;\n        vector<bool> vis;\n        unordered_map<string, int> map;\n        // set<pair<int, int>> set;\n        int cnt = 0;\n        for(auto &s : equations){\n            for(auto &ch : s){\n                if(!map.count(ch)) map[ch] = cnt++;\n            }\n        }\n        // cout << map.size();\n        // 建图\n        G = vector<vector<int>>(map.size());\n        W = vector<vector<double>>(map.size());\n        vis = vector<bool>(map.size());\n        for(int i = 0; i < equations.size(); ++i){\n            G[map[equations[i][0]]].push_back(map[equations[i][1]]);\n            // cout << map[equations[i][0]] << \" \" << map[equations[i][1]];\n            W[map[equations[i][0]]].push_back(values[i]);\n            G[map[equations[i][1]]].push_back(map[equations[i][0]]);\n            W[map[equations[i][1]]].push_back(1 / values[i]);\n        }\n        // for(auto &g : G){\n        //     for(auto &gg : g){\n        //         cout << gg << \" \";\n        //     }\n        //     cout << \"    \";\n        // }\n        // for(auto &w : W){\n        //     for(auto &ww : w){\n        //         cout << ww << \" \";\n        //     }\n        //     cout << \"    \";\n        // }\n        for(auto &querie : queries){\n            string s1 = querie[0];\n            string s2 = querie[1];\n            if(s1 == s2 && map.count(s1)){\n                res.push_back(1.0);\n                continue;\n            }   \n            if(!map.count(s1) || !map.count(s2)){\n                res.push_back(-1.0);\n                continue;\n            }\n            vis[map[s1]] = true;\n            dfs(G, W, vis, map[s1], map[s2], 1);\n            vis[map[s1]] = false;\n            if(flag == 0) res.push_back(-1.0);\n            else {\n                flag = 0;\n            }\n        }\n        // int count = queries.size() - res.size();\n        // while(count--){\n        //     res.insert(res.begin(), -1.0);\n        // }\n        return res;\n    }\n    void dfs(vector<vector<int>> &G, vector<vector<double>> &W, vector<bool> &vis, int start, int end, double val){\n        if(start == end){\n            res.push_back(val);\n            // cout << val << \" \";\n            flag = 1;\n            return;\n        }\n        for(int i = 0; i < G[start].size(); ++i){\n            if(vis[G[start][i]] || flag == 1) continue;\n            vis[G[start][i]] = true;\n            val *= W[start][i];\n            dfs(G, W, vis, G[start][i], end, val);\n            val /= W[start][i];\n            vis[G[start][i]] = false;\n        }\n    }\n};\n```\n\n#### 后续补充\n\n可以使用并查集解决。\n\n\n\n","tags":["DFS","图论","回溯算法"],"categories":["LeetCode"]},{"title":"LeetCode830-较大分组的位置","url":"/blog/2021/01/05/LeetCode830-较大分组的位置/","content":"\n#### 题目描述\n\n在一个由小写字母构成的字符串 `s` 中，包含由一些连续的相同字符所构成的分组。\n\n例如，在字符串 `s = \"abbxxxxzyy\"` 中，就含有 `\"a\"`, `\"bb\"`, `\"xxxx\"`, `\"z\"` 和 `\"yy\"` 这样的一些分组。\n\n分组可以用区间 `[start, end]` 表示，其中 `start` 和 `end` 分别表示该分组的起始和终止位置的下标。上例中的 `\"xxxx\"` 分组用区间表示为 `[3,6]` 。\n\n我们称所有包含大于或等于三个连续字符的分组为 **较大分组** 。\n\n找到每一个 **较大分组** 的区间，**按起始位置下标递增顺序排序后**，返回结果。\n\n<!-- more-->\n\n<img src=\"LeetCode830-较大分组的位置\\830.png\"  />\n\n#### 思路\n\n寻找每个重复字符出现的起始位置和终止位置，如果长度大于等于3，记录一下结果就可以了。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> largeGroupPositions(string s) {\n        vector<vector<int>> res;\n        int i = 0;\n        char ch = s[i];\n        i++;\n        int start = 0;\n        while(i < s.size()){\n            // 此位置的前一个位置就是上一个重复字符的终止位置\n            if(s[i] != ch){\n                ch = s[i];\n                if(i - 1 - start + 1 >= 3) res.push_back({start, i - 1});\n                // 更新起始位置\n                start = i;\n            }\n            // 字符重复\n            else{\n                i++;\n            }\n        }\n        if(i - 1 - start + 1 >= 3) res.push_back({start, i - 1});\n        return res;\n    }\n};\n```\n\n","tags":["数组"],"categories":["LeetCode"]},{"title":"LeetCode509-斐波那契数","url":"/blog/2021/01/04/LeetCode509-斐波那契数/","content":"\n#### 题目描述\n\n斐波那契数，通常用 `F(n)` 表示，形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n```\nF(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n > 1\n```\n\n\n给你 `n` ，请计算 `F(n)` 。\n\n<!-- more-->\n\n<img src=\"LeetCode509-斐波那契数\\509.png\"  />\n\n#### 思路\n\n这个算是动态规划的入门题目。给定 $F(0)$ 和 $F(1)$ 之后，后面的数都是前面两个数之和。比如 $F(2)=F(0)+F(1)$，$F(3)=F(1)+F(2)$...\n\n基于此，其实已经告诉了我们状态转移方程：\n$$\ndp[i]=dp[i-1]+dp[i-2]\\quad i\\geq2\n$$\n当 $i=0,1$ 时，函数值已经给定：\n\n```cpp\ndp[0] = 0;\ndp[1] = 1;\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        vector<int> dp(n + 1);\n        dp[0] = 0;\n        dp[1] = 1;\n        for(int i = 2; i <= n; ++i){\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n};\n```\n\n实际上只用三个变量就可以表示每种状态：\n\n```cpp\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        // 最终结果\n        int fin = 0;\n        // dp[i - 2]\n        int fir = 0;\n        // dp[i - 1]\n        int sec = 1;\n        for(int i = 2; i <= n; ++i){\n            fin = fir + sec;\n            fir = sec;\n            sec = fin;\n        }\n        return fin;\n    }\n};\n\n```\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"内存管理（四）","url":"/blog/2021/01/04/内存管理（四）/","content":"\n#### 本次学习要点\n\n1. 基本分段存储管理方式\n2. 段页式管理方式\n\n<!-- more-->\n\n#### 基本分段存储管理方式\n\n与分页存储管理方式区别为：离散分配时所分配地址空间的基本单位不同。\n\n##### 分段\n\n进程的地址空间：按照程序**自身的逻辑**关系划分为若干个段，每个段都有一个段名，每段从0开始编址。\n\n内存分配规则：以段位单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。\n\n<img src=\"内存管理（四）\\分段-逻辑编程.png\"  />\n\n分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）组成：\n\n<img src=\"内存管理（四）\\分段逻辑地址.png\"  />\n\n* 段号的位数决定每个进程最多可分几个段。\n* 段内地址位数决定了每个段的最大长度是多少。\n\n##### 段表\n\n<img src=\"内存管理（四）\\段表.png\"  />\n\n##### 地址变换\n\n<img src=\"内存管理（四）\\地址变换.png\"  />\n\n④处与**分页存储**不同。\n\n##### 分段、分页管理对比\n\n###### 基本单位\n\n* **页是信息的物理单位**。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要,完全是系统行为，**对用户是不可见的**。\n* **段是信息的逻辑单位**。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。\n\n###### 大小\n\n* 页的大小**固定**且由**系统**决定。\n* 段的长度却**不固定**，决定于**用户编写的程序**。\n\n###### 地址空间\n\n* 分页的用户进程地址空间是**一维**的，程序员只需给出一个记忆符即可表示一个地址。\n* 分段的用户进程地址空间是**二维**的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。\n\n分段比分页**更容易实现信息的共享和保护**。不能被修改的代码称为**纯代码**或**可重入代码**（不属于临界资源），这样的代码可以共享，可修改的代码不可共享。\n\n##### 小结\n\n<img src=\"内存管理（四）\\分段存储管理小结.png\" style=\"zoom:120%;\" />\n\n#### 段页式管理方式\n\n<img src=\"内存管理（四）\\段页式管理方式.png\" style=\"zoom:80%;\" />\n\n##### 分页、分段优缺点分析\n\n<img src=\"内存管理（四）\\分页、分段优缺点分析.png\"  />\n\n##### 段页式管理\n\n<img src=\"内存管理（四）\\段页式管理.png\"  />\n\n将进程按逻辑模块分段，再将各段分页，再装入大小相同的内存块（页框/页帧/物理块）中。\n\n##### 段页式管理的逻辑地址结构\n\n<img src=\"内存管理（四）\\段页式管理的逻辑地址结构.png\"  />\n\n* 段号的位数决定每个进程最多可分几个段。\n* 页号位数决定了每个段最大有多少页。\n* 页内偏移量决定了页面大小、内存块大小是多少。\n\n**分段**对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将**各段**进行**分页**对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此段页式管理的地址结构是二维的。\n\n##### 段表、页表\n\n<img src=\"内存管理（四）\\段表、页表.png\"  />\n\n每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，**段号是隐含的**。\n\n每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，**页号是隐含的**。\n\n<img src=\"内存管理（四）\\段表、页表寻址.png\"  />\n\n##### 小结\n\n<img src=\"内存管理（四）\\段页式管理方式小结.png\"  style=\"zoom:120%;\" />","categories":["操作系统"]},{"title":"LeetCode86-分隔链表","url":"/blog/2021/01/03/LeetCode86-分隔链表/","content":"\n#### 题目描述\n\n给你一个链表和一个特定值 `x` ，请你对链表进行分隔，使得所有小于 `x` 的节点都出现在大于或等于 `x` 的节点之前。\n\n你应当保留两个分区中每个节点的初始相对位置。\n\n<!-- more-->\n\n<img src=\"LeetCode86-分隔链表\\86.png\"  />\n\n#### 思路\n\n将链表一分为二，为小于 `x` 的部分和大于等于 `x` 的部分分别建立一个新链表，然后再将小链表的表尾连接至大链表的表头即可。\n\n#### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        if(!head) return nullptr;\n        ListNode *dummyNodeSmall = new ListNode(0);\n        ListNode *dummyNodeLarge = new ListNode(0);\n        ListNode *small = dummyNodeSmall;\n        ListNode *large = dummyNodeLarge;\n        for(auto iter = head; iter != nullptr; iter = iter->next){\n            if(iter->val < x){\n                small->next = iter;\n                small = small->next;\n            }\n            else{\n                large->next = iter;\n                large = large->next;\n            }\n        }\n        large->next = nullptr;\n        small->next = dummyNodeLarge->next;\n        return dummyNodeSmall->next;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/partition-list/solution/fen-ge-lian-biao-by-leetcode-solution-7ade/","tags":["链表"],"categories":["LeetCode"]},{"title":"LeetCode239-滑动窗口的最大值","url":"/blog/2021/01/02/LeetCode239-滑动窗口的最大值/","content":"\n#### 题目描述\n\n给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n<!-- more-->\n\n<img src=\"LeetCode239-滑动窗口的最大值\\239.png\"  />\n\n#### 思路\n\n首先使用优先队列存储 `nums` 的前 `k` 个值，队首就是第一个窗口最大的值。\n\n接着从第 `k` 个位置开始，将序列入队，每次最大的值都出现在队首。但是**当前的队首不一定是当前窗口中的元素**，此时队列的长度可能大于 `k`。如下：\n\n```\nnums = {3,1,1}, k = 2;\n1. {3,1} max = 3; // 队列中元素为3,1\n2. {1,1} max = 1; // 队列中元素为3,1,1，此时需要将3出队\n```\n\n如果不是当前窗口中的元素，只有可能是上一个窗口中的最大值，它一定是在当前窗口左端点的左侧，就需要将队首出队，直到队首元素在当前窗口内。\n\n所以优先队列需要同时存储当前序列的值和坐标。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        priority_queue<pair<int, int>> q;\n        for(int i = 0; i < k; ++i){\n            q.push({nums[i], i});\n        }\n        vector<int> ans{q.top().first};\n        for(int i = k; i < nums.size(); ++i){\n            q.push({nums[i], i});\n            // 队首元素不在当前窗口内\n            while(q.top().second <= i - k){\n                q.pop();\n            }\n            ans.push_back(q.top().first);\n        }\n        return ans;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/","tags":["优先队列"],"categories":["LeetCode"]},{"title":"LeetCode605-种花问题","url":"/blog/2021/01/01/LeetCode605-种花问题/","content":"\n#### 题目描述\n\n假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。\n\n给你一个整数数组  `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false`。\n\n<!-- more-->\n\n<img src=\"LeetCode605-种花问题\\605.png\"  />\n\n#### 思路\n\n除了首尾位置，只要当前位置的前一个位置和下一个位置没有种花，那么当前位置就可以种花。\n\n对于首尾位置，只有其相邻位置没有种花，在它的位置就可以种花。\n\n**当前位置如果没有种花，才需要考虑上述问题**。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        if(n == 0) return true;\n        if(flowerbed.size() == 1) return flowerbed[0] == 0;\n        for(int i = 0; i < flowerbed.size(); ++i){\n            if(i == 0 && flowerbed[i] == 0 && flowerbed[i + 1] == 0){\n                flowerbed[i] = 1;\n                n--;\n            }\n            else if(i == flowerbed.size() - 1 && flowerbed[i] == 0 && flowerbed[i - 1] == 0){\n                flowerbed[i] = 1;\n                n--;\n            }\n            else if(i != 0 && i != flowerbed.size() - 1 && flowerbed[i] == 0 && flowerbed[i - 1] != 1 && flowerbed[i + 1] != 1){\n                flowerbed[i] = 1;\n                n--;\n            }\n            if(n == 0) return true;\n        }\n        return false;\n    }\n};\n```\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode435-无重叠区间","url":"/blog/2020/12/31/LeetCode435-无重叠区间/","content":"\n#### 题目描述\n\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n\n**注意**:\n\n可以认为区间的终点总是大于它的起点。\n区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n\n<!-- more-->\n\n<img src=\"LeetCode435-无重叠区间\\435.png\"  />\n\n#### 思路\n\n首先对二维数组排序，对其中的每个一维数组，先按照元素的第一个升序排列，如果第一个元素相同，再按照第二个升序排列。\n\n如此一来，为了使移除的区间数最小，那么就需要**从重叠的区间中选出右端点最小的一个**，那样就可以尽可能留下更多不重叠的空间（所以说只按照第二个元素升序排列也是可以的）。\n\n排序后，如果前一个数组的第二个元素在第二个数组范围之内，就留下前一个数组，用它把第二个数组覆盖；如果前一个数组第二个元素大于第二个数组的后一个元素，那么留下第二个数组，不用进行覆盖，但是前一个数组是需要移除的。这两种情况下，都需要移除操作。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), [](vector<int> &v1, vector<int> &v2) -> bool{\n            if(v1[0] < v2[0])\n                return true;\n            else if(v1[0] == v2[0])\n                return v1[1] < v2[1];\n            else\n                return false;\n        });\n        // sort(intervals.begin(), intervals.end());\n        // for(auto &v1 : intervals){\n        //     for(auto &v2 : v1)\n        //         cout << v2 << \" \";\n        // }\n        int cnt = 0;\n        for(int i = 1; i < intervals.size(); ++i){\n            if(intervals[i - 1][1] > intervals[i][0] && intervals[i - 1][1] <= intervals[i][1]){\n                intervals[i][0] = intervals[i - 1][0];\n                intervals[i][1] = intervals[i - 1][1];\n                cnt++;\n            }\n            else if(intervals[i - 1][1] > intervals[i][0] && intervals[i - 1][1] > intervals[i][1]){\n                cnt++;\n            }\n            else continue;\n        }\n        return cnt;\n    }\n};\n```\n\n#### Reference\n\nC++ STL sort作用于二维vector 效果和应用：\n\nhttps://blog.csdn.net/y625658683/article/details/104154089\n\n#### Appendix\n\n对于二维数组，`sort`是把`vector<int>`作为一个一维数组对象，整体进行比较和排序。\n\n默认比较两个`int`向量的规则是：\n\n从第一个元素开始比，第一个元素小的，整个向量就小，如果第一个元素一样，再比较第二个，第二个元素小的，整个向量小，依此类推。`sort`默认按从小到大排序。\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode1046-最后一块石头的重量","url":"/blog/2020/12/30/LeetCode1046-最后一块石头的重量/","content":"\n#### 题目描述\n\n有一堆石头，每块石头的重量都是正整数。\n\n每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n\n如果 `x == y`，那么两块石头都会被完全粉碎；\n如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。\n\n<!-- more-->\n\n#### 思路及代码\n\n##### 链表\n\n###### 思路\n\n每次寻找最大的两个石头重量进行碰撞，直到链表为空或只剩下一个元素：\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        if(stones.size() <= 1) return stones.empty() ? 0 : stones[0];\n        list<int> li(stones.begin(), stones.end());\n        while(!li.empty()){\n            auto it1 = max_element(li.begin(), li.end());\n            int val1 = *it1;\n            li.erase(it1);\n            auto it2 = max_element(li.begin(), li.end());\n            int val2 = *it2;\n            if(val2 != val1)\n                *it2 = abs(val1 - val2);\n            else li.erase(it2);\n            if(li.size() == 1) break;\n        }\n        return li.empty() ? 0 : *li.begin();\n    }\n};\n```\n\n##### 优先队列\n\n###### 思路\n\n大顶堆，每次前两个出队元素就是石头中重量最大的两个。\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        priority_queue<int, vector<int>, less<int>> p_q(stones.begin(), stones.end());\n        while(!p_q.empty()){\n            if(p_q.size() == 1) break;\n            int v1 = p_q.top();\n            p_q.pop();\n            int v2 = p_q.top();\n            p_q.pop();\n            int v = abs(v1 - v2);\n            if(v != 0) p_q.push(v);\n        }\n        return p_q.empty() ? 0 : p_q.top();\n    }\n};\n```\n\n","tags":["链表","优先队列"],"categories":["LeetCode"]},{"title":"LeetCode330-按要求补齐数组","url":"/blog/2020/12/29/LeetCode330-按要求补齐数组/","content":"\n#### 题目描述\n\n给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 `[1, n]` 区间内选取任意个数字补充到 $nums$ 中，使得 `[1, n]` 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。\n\n<!-- more-->\n\n<img src=\"LeetCode330-按要求补齐数组\\330.png\"  />\n\n#### 思路\n\n如果区间 $[1,x)$ 的所有数都被覆盖了：\n\n*  如果$nums[i]\\in[1,x)$，那么区间 $[1+nums[i],x+nums[i])$ 中所有数也会被覆盖。由于 $nums[i]\\geq1$ ，则此时 $x\\in[1+nums[i],x+nums[i])$，覆盖区间可以更新为 $[1,x+nums[i])$。\n*  如果 $nums[i]$ 恰好等于 $x$ ，那么覆盖区间变为 $[1,x+nums[i])$。不需要补充 $x$ 。\n* 否则，补充 $x$ ，则区间 $[1,x]$ 全部覆盖；并且可以得到覆盖区间 $[1+x,x+x)=[x+1,2x)$。两者取交集得到此时覆盖数字区间 $[1,2x)$，此时覆盖的数字最多（如果取小于 $x$ 的数，覆盖区间会变小，这是不希望看到的， $x$ 不能取两次，每个数字只能取一次）。\n* 当 $x>n$ 时，就可以结束了。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minPatches(vector<int>& nums, int n) {\n        // 初始区间为空，表示已经覆盖\n        long long x = 1;\n        int index = 0;\n        int times = 0;\n        while(x <= n){\n            if(index < nums.size() && nums[index] < x){\n                x += nums[index++];\n            }\n            else if(index < nums.size() && nums[index] == x){\n                x += nums[index++];\n            }\n            else{\n                x <<= 1;\n                times++;\n            }\n        }\n        return times;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/","tags":["贪心算法","数学"],"categories":["LeetCode"]},{"title":"LeetCode309-最佳买卖股票时机含冷冻期","url":"/blog/2020/12/28/LeetCode309-最佳买卖股票时机含冷冻期/","content":"\n#### 题目描述\n\n给定一个整数数组，其中第 $i$ 个元素代表了第 $i$ 天的股票价格 。\n\n* 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n* 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n  卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n<!-- more-->\n\n<img src=\"LeetCode309-最佳买卖股票时机含冷冻期\\309.png\"  />\n\n#### 思路\n\n本题与其他股票问题不同之处在于**卖出之后至少间隔一天才能够买入**，可以多次买入卖出。\n\n##### 定义dp数组\n\n$dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益。\n\n$dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。\n\n##### 状态转移方程\n\n* 如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：\n  $$\n  dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])\n  $$\n\n* 如果当天持有股票，那么前一天可以持有股票或者前两天未持有股票，当天买入（如果前一天持有且卖出股票，当天就不能买入了；前一天如果未持有且没有卖出股票，就与前两天未持有，当天买入等价了）：\n  $$\n  dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i])\n  $$\n\n##### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。假设有第零天，那么收益应也为 $0$。\n\n```cpp\ndp[0][0] = 0;\ndp[0][1] = -prices[0];\ndp[-1][0] = 0; // 用dp_0 = 0代替\n```\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        int dp_0 = 0;\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(dp[i - 1][1], (i - 2 < 0 ? dp_0 : dp[i - 2][0]) - prices[i]);\n        }\n        return dp[prices.size() - 1][0];\n    }\n};\n```\n\n##### 空间优化\n\n由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        int profit = 0;\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, profit - prices[i]);\n            profit = profit0;\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode121-买卖股票的最佳时机","url":"/blog/2020/12/28/LeetCode121-买卖股票的最佳时机/","content":"\n#### 题目描述\n\n给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n**注意**：你不能在买入股票前卖出股票。\n\n<!-- more-->\n\n<img src=\"LeetCode121-买卖股票的最佳时机\\121.png\"  />\n\n#### 思路\n\n##### 贪心算法\n\n###### 策略\n\n从前往后遍历找到最小的价格买入，再往后找到最大的价格卖出即可。\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        stack<int> st;\n        int res = 0;\n        st.push(prices[0]);\n        for(int i = 1; i < prices.size(); i++)\n        {\n            if(prices[i] <= st.top())\n            {\n                st.pop();\n                st.push(prices[i]);\n            }\n            else\n            {\n                int m = prices[i] - st.top();\n                res = res > m ? res : m;\n            }\n        }\n        return res;\n    }\n};\n```\n\n##### 动态规划\n\n本题是[LeetCode122-买卖股票的最佳时机II]()的简化版，这道题与其最大的区别在于限制交易次数为 **一次**，找到最小的起点之后，再去找最大的终点即可。\n\n###### 定义dp数组\n\n$dp[i][0]$ 表示第 $i$ 天不持有股票可获得的最大收益。\n\n$dp[i][1]$ 表示第 $i$ 天持有股票可获得的最大收益。\n\n###### 状态转移方程\n\n* 如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：\n  $$\n  dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])\n  $$\n\n* 如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入（只能持有一次，所以第一次持有时的利润为$-prices[i]$）：\n  $$\n  dp[i][1]=max(dp[i-1][1],-prices[i])\n  $$\n\n###### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。\n\n```cpp\ndp[0][0] = 0;\ndp[0][1] = -prices[0];\n```\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(dp[i - 1][1], -prices[i]);\n        }\n        return dp[prices.size() - 1][0];\n    }\n};\n```\n\n###### 空间优化\n\n由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, -prices[i]);\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)\n\n","tags":["动态规划","贪心算法","栈","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode123-买卖股票的最佳时机III","url":"/blog/2020/12/28/LeetCode123-买卖股票的最佳时机III/","content":"\n#### 题目描述\n\n给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。\n\n**注意**: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n<!-- more-->\n\n<img src=\"LeetCode123-买卖股票的最佳时机III\\123.png\"  />\n\n#### 思路\n\n本题是[LeetCode122-买卖股票的最佳时机II]()的升级版，这道题与其最大的区别在于限制交易次数为 **两次**，所以选择哪两次交易至关重要。\n\n##### 定义dp数组\n\n需要记录当前还剩下多少次交易次数，还有当天是否持有股票（ $k=0,1,2$ ）。\n\n$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。\n\n$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。\n\n##### 状态转移方程\n\n* 第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：\n  $$\n  dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);\n  $$\n\n* 第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：\n  $$\n  dp[i][j][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);\n  $$\n\n##### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：\n\n```cpp\n// 剩余交易i次，获得收益初始化\nfor(int i = 0; i <= k; ++i){\n    dp[0][i][0] = 0;\n    dp[0][i][1] = -prices[0];\n}\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2 + 1, vector<int>(2)));\n        for(int i = 0; i <= 2; ++i){\n            dp[0][i][0] = 0;\n            dp[0][i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = 2; j > 0; --j){\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n        return dp[prices.size() - 1][2][0];\n    }\n};\n```\n\n#### 空间优化\n\n由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(2 + 1, vector<int>(2));\n        for(int i = 0; i <= 2; ++i){\n            dp[i][0] = 0;\n            dp[i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = 2; j > 0; --j){\n                dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]);\n                dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]);\n            }\n        }\n        return dp[2][0];\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)\n\n","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode122-买卖股票的最佳时机II","url":"/blog/2020/12/28/LeetCode122-买卖股票的最佳时机II/","content":"\n#### 题目描述\n\n给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n<!-- more-->\n\n<img src=\"LeetCode122-买卖股票的最佳时机II\\122.png\"  />\n\n#### 思路\n\n##### 贪心算法\n\n###### 策略\n\n本题要求尽可能地完成更多地交易，所以可以使用贪心策略，在局部价格最低时买入，在局部价格最高时卖出，重复此操作直到最后一天，最后一天不持有股票时收益最大。\n\n* 局部最低：如果后一天价格低于前一天价格，更新局部最低，否则已经是局部最低\n* 局部最高：在持有股票后，当前价格的下一天价格降低，说明已经达到局部最高\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0;\n        int val = prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            if(prices[i] <= val) {\n                val = prices[i];\n            }\n            else{\n                if(i + 1 < prices.size() && prices[i + 1] < prices[i]){\n                    res += prices[i] - val;\n                    val = prices[i + 1];\n                    i++;\n                }\n                // 最后一天如果还持有股票应该卖出\n                if(i + 1 == prices.size()){\n                    res += prices[i] - val;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n###### 另一种策略\n\n把股票的交易价格看成曲线图，找出图中上升的部分，即为交易获利。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int> prices)\n    {\n        int sum = 0;\n        for(int i=0; i<prices.size()-1; i++)\n        {\n            if(prices[i] < prices[i + 1])\n            sum += prices[i + 1] - prices[i];\n        }\n        return sum;\n    }\n};\n```\n\n##### 动态规划\n\n###### 定义dp数组\n\n每天的状态可以为持有股票或不持有股票，所以使用 $dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益； $dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。本题交易次数 **+∞** 。\n\n######  状态转移方程\n\n* 如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：\n  $$\n  dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])\n  $$\n\n* 如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入：\n  $$\n  dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])\n  $$\n\n###### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。\n\n```cpp\ndp[0][0] = 0;\ndp[0][1] = -prices[0];\n```\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n        }\n        return dp[prices.size() - 1][0];\n    }\n};\n```\n\n###### 空间优化\n\n由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, profit0 - prices[i]);\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)\n\n","tags":["动态规划","贪心算法","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode188-买卖股票的最佳时机IV","url":"/blog/2020/12/28/LeetCode188-买卖股票的最佳时机IV/","content":"\n#### 题目描述\n\n给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。\n\n**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n<!-- more-->\n\n<img src=\"LeetCode188-买卖股票的最佳时机IV\\188.png\"  />\n\n#### 思路\n\n本题是[LeetCode122-买卖股票的最佳时机II]()的升级版，这道题与其最大的区别在于限制交易次数为 **k** 次，所以选择在何时交易至关重要。\n\n因为买入卖出至少得两天，所以最大的交易次数不会超过 $prices.size()/2$ 。如果 $k\\geq{prices.size()/2}$ ，那么本题就退化为122题。\n\n##### 定义dp数组\n\n需要记录当前还剩下多少次交易次数，还有当天是否持有股票。\n\n$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。\n\n$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。\n\n##### 状态转移方程\n\n* 第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：\n  $$\n  dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);\n  $$\n\n* 第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：\n  $$\n  dp[i][j][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);\n  $$\n\n##### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：\n\n```cpp\n// 剩余交易i次，获得收益初始化\nfor(int i = 0; i <= k; ++i){\n    dp[0][i][0] = 0;\n    dp[0][i][1] = -prices[0];\n}\n// 在没有进行股票交易时不允许持有股票\n// 这个系列中没有用到，记录学习一下\ndp[-1][k][1] = -INF;\ndp[i][0][1] = -INF;\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if(k == 0 || prices.empty()) return 0;\n        if(k >= prices.size() / 2){\n            return maxprofit(prices);\n        }\n        vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(k + 1, vector<int>(2, 0)));\n        // 最多交易i次，获得的收益\n        for(int i = 0; i <= k; ++i){\n            dp[0][i][0] = 0;\n            dp[0][i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = k; j > 0; --j){\n                // 第i天不持有，前一天不持有或前一天持有今天卖出\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                // 第i天持有，前一天持有或前一天不持有今天买入\n                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n        return dp[prices.size() - 1][k][0];\n    }\n    int maxprofit(vector<int> &prices){\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, profit0 - prices[i]);\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### 空间优化\n\n由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if(k == 0 || prices.empty()) return 0;\n        if(k >= prices.size() / 2){\n            return maxprofit(prices);\n        }\n        vector<vector<int>> dp(k + 1, vector<int>(2));\n        // 最多交易i次，获得的收益\n        for(int i = 0; i <= k; ++i){\n            dp[i][0] = 0;\n            dp[i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = k; j > 0; --j){\n                // 第i天不持有，前一天不持有或前一天持有今天卖出\n                dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]);\n                // 第i天持有，前一天持有或前一天不持有今天买入\n                dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]);\n            }\n        }\n        return dp[k][0];\n    }\n    int maxprofit(vector<int> &prices){\n        if(prices.empty()) return 0;\n        int fit0 = 0;\n        int fit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(fit0, fit1 + prices[i]);\n            int new1 = max(fit1, fit0 - prices[i]);\n            fit0 = new0;\n            fit1 = new1;\n        }\n        return fit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode205-同构字符串","url":"/blog/2020/12/27/LeetCode205-同构字符串/","content":"\n#### 题目描述\n\n给定两个字符串 ***s*** 和 ***t***，判断它们是否是同构的。\n\n如果 ***s*** 中的字符可以被替换得到 ***t*** ，那么这两个字符串是同构的。\n\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\n\n本题是[LeetCode290-单词规律](http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more)的简化版。\n\n<!--more-->\n\n<img src=\"LeetCode205-同构字符串\\205.png\"  />\n\n#### 思路\n\n##### 方法一\n\n与[LeetCode290-单词规律](http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more)基本一致。\n\n##### 方法二\n\n此题字母大小写均可，数组初始化时为0，每对字符都应唯一映射为同一个数。如果两个数不同，返回`false`，否则返回`true`。\n\n#### 代码\n\n##### 方法一\n\n```cpp\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        unordered_map<char, unordered_set<char>> map1;\n        unordered_map<char, unordered_set<char>> map2;\n        for(int i = 0; i < s.size(); ++i){\n            map1[s[i]].insert(t[i]);\n            map2[t[i]].insert(s[i]);\n            if(map1[s[i]].size() > 1 || map2[t[i]].size() > 1) return false;\n        }\n        return true;\n    }\n};\n```\n\n##### 方法二\n\n```cpp\nclass Solution {\npublic:\n    int map1[256];\n    int map2[256];\n    bool isIsomorphic(string s, string t) {\n        for(int i = 0; i < s.size(); ++i){\n            if(map1[s[i]] != map2[t[i]]) return false;\n            map1[s[i]] = i + 1;\n            map2[t[i]] = i + 1;\n        }\n        return true;\n    }\n};\n```\n\n#### Reference\n\n官方题解评论区：\n\nhttps://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/","tags":["字符串","哈希表"],"categories":["LeetCode"]},{"title":"LeetCode85-最大矩形","url":"/blog/2020/12/26/LeetCode85-最大矩形/","content":"\n#### 题目描述\n\n给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。\n\n本题与[LeetCode84-柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)基本一致。\n\n <!-- more-->\n\n<img src=\"LeetCode85-最大矩形\\85.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n如图，使坐标值竖向移动，求出每个坐标轴下的矩形最大面积，再从中取最大值就是最大的矩形：\n\n<img src=\"LeetCode85-最大矩形\\坐标轴.png\" style=\"zoom:80%;\" />\n\n很明显在图三中得到最大矩形，面积为6。求当前坐标轴下的最大矩形面积与[LeetCode84-柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/c-dan-diao-zhan-si-lu-qing-xi-you-tu-you-ip3c/)方法一致。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        if(matrix.empty()) return 0;\n        int res = 0;\n        vector<int> preHeights;\n        for(int i = 0; i < matrix.size(); ++i){\n            vector<int> heights;\n            for(int j = 0; j < matrix[0].size(); ++j){\n                if(i == 0){\n                    heights.push_back(matrix[i][j] - '0');    \n                }\n                else{\n                    if(matrix[i][j] == '1') \n                        heights.push_back(preHeights[j] + matrix[i][j] - '0');\n                    else\n                        heights.push_back(0);\n                }\n            }\n            preHeights = heights;\n            res = max(res, maxArea(heights));\n        }\n        return res;\n    }\n    int maxArea(vector<int> &heights){\n        heights.push_back(0);\n        stack<int> st;\n        int mArea = 0;\n        for(int i = 0; i < heights.size(); ++i){\n            int area = 0;\n            while(!st.empty() && heights[i] < heights[st.top()]){\n                int v = st.top();\n                st.pop();\n                int right = i;\n                int left = st.empty() ? 0 : st.top() + 1;\n                area = heights[v] * (right - left);\n                mArea = max(mArea, area);\n            }\n            st.push(i);\n        }\n        return mArea;\n    }\n};\n```\n\n#### Reference\n\n评论区：https://leetcode-cn.com/problems/maximal-rectangle/comments/","tags":["贪心算法","单调栈"],"categories":["LeetCode"]},{"title":"LeetCode84-柱状图中最大的矩形","url":"/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/","content":"\n#### 题目描述\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n<!-- more-->\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\84.png\"  />\n\n#### 思路\n\n找到当前高度下的最大矩形面积，然后从所有得到的面积中挑出最大的那一个就是能够勾勒出来矩形的最大面积，如下：\n\n1. 第1个高度，当前面积为2。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-1.png\"  />\n\n2. 第2个高度，当前面积为6。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-2.png\"  />\n\n3. 第3个高度，当前面积为10。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-3.png\"  />\n\n4. 第4个高度，当前面积为6。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-4.png\"  />\n\n5. 第5个高度，当前面积为8。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-5.png\"  />\n\n6. 第6个高度，当前面积为3。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-6.png\"  />\n\n综上，面积最大出现在第三个高度，此时面积为5。\n\n我们需要找到当前高度下可以构成矩形的左边界和右边界，再去计算矩形的面积，使用单调栈来实现：\n\n* 计算高度：如果当前高度小于栈顶元素，此时的栈顶就是上一次高度的最大值（准确一点，是上一次高度最大值的坐标），将其记录并出栈，这时候就可以计算上一个高度面积的最大值了，直到遇到栈顶元素小于等于当前元素或者栈为空，在此之前会一直计算高度\n\n* 寻找边界：当前遍历到的坐标 $i$ 就是右边界，左边界就是 $st.top()+1$（对于示例，当遍历到第二个2时，坐标为4，作为**右边界**；经过一系列的出栈操作，栈中**最后剩下**的元素坐标为1，而**左边界**就应该是**1+1​**而不是1），**如果栈为空，那么左边界就是0**。如下图：\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-边界.png\"  />\n\n所以为了提供坐标6，还需要给高度矩阵后面续上一个0。\n\n由于找到了下一个小于栈顶高度的值时才会计算面积，所以对于示例，最后得到的结果及顺序如下：\n\n|       坐标       |  0   |  1   |  2   |  3   |  4   |  5   |\n| :--------------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|       高度       |  2   |  1   |  5   |  6   |  2   |  3   |\n| 当前坐标最大面积 |  2   |  6   |  10  |  6   |  8   |  3   |\n|  面积出现的顺序  |  1   |  6   |  3   |  2   |  5   |  4   |\n\n即，真正得到的面积结果为`2, 6, 10, 3, 8, 6`。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        heights.push_back(0);\n        stack<int> st;\n        int mArea = 0;\n        for(int i = 0; i < heights.size(); ++i){\n            int area = 0;\n            while(!st.empty() && heights[i] < heights[st.top()]){\n                int v = st.top();\n                st.pop();\n                int right = i;\n                int left = st.empty() ? 0 : st.top() + 1;\n                area = heights[v] * (right - left);\n                mArea = max(mArea, area);\n            }\n            st.push(i);\n        }\n        return mArea;\n    }\n};\n```\n\n#### Reference\n\nCSDN：https://blog.csdn.net/Zolewit/article/details/88863970","tags":["贪心算法","单调栈"],"categories":["LeetCode"]},{"title":"LeetCode365-水壶问题","url":"/blog/2020/12/25/LeetCode365-水壶问题/","content":"\n#### 题目描述\n\n有两个容量分别为 `x` 升和 `y` 升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 `z` 升的水？\n\n如果可以，最后请用以上水壶中的一或两个来盛放取得的 `z` 升水。\n\n你允许：\n\n* 装满任意一个水壶\n* 清空任意一个水壶\n* 从一个水壶向另外一个水壶倒水，直到装满或者倒空\n\n<!-- more-->\n\n<img src=\"LeetCode365-水壶问题\\365.png\"  />\n\n#### 思路\n\n这道题实际上是一个数学问题，需要有先验知识——[贝祖定理](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&fromid=5185441)：若 $a, b$ 是整数，且$gcd(a,b)=d$，那么对于任意的整数 $x$$，y$，$ax+by$ 都一定是 $d$ 的倍数，特别地，一定存在整数 $x$,  $y$，使 $ax+by=d$ 成立。$gcd(a,b)$ 用来求 $a, b$ 的最大公约数，称为辗转相除法。\n\n实际上，每次操作只会让桶里的水增加`x`或增加`y`，减少`x`或减少`y`，两个桶不可能同时有水且不满，观察所有的操作都至少有一个桶是空的或满的。如果往一个不满的桶里加水或将其倒空是没有意义的，这是因为：\n\n* 向有水且不满的桶加水是没有意义的：\n  * 另一个桶满，加水等价于从初始状态给两个桶加满水\n  * 另一个桶空，加水等价于将不满的桶加满\n* 将有水且不满的桶倒掉是没有意义的：\n  * 另一个桶满，倒水等价于从初始状态给另一个桶加满水\n  * 另一个桶空，倒水等价于两个桶都没水，回到初始状态\n\n所以每次操作只会给水的总量带来`x`或`y`的变化量，所以目标为找到一组 $a, b$ ，满足：\n$$\nax+by=z\n$$\n根据贝祖定理，当且仅当`z`是  $a, b$ 最大公约数倍数时，有解。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int gcd(int a, int b){\n        if(a < b) swap(a, b);\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    bool canMeasureWater(int x, int y, int z) {\n        if(x + y < z) return false;\n        if(x == 0 || y == 0){\n            return z == 0 || x + y == z;\n        }\n        if(z % gcd(x, y) == 0) return true;\n        return false;\n    }\n};\n```\n\n#### Reference\n\n官方题解：\n\nhttps://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/\n\n#### 附录\n\n要满足$z\\le{x+y}$，且这样的 $a, b$ 存在，目标就可以达成，是因为：\n\n* 若 $a\\ge0, b\\ge0$时，可以达成\n\n* 若 $a<0$ ，那么执行以下操作：\n\n  * 将`y`壶倒满\n  * 将`y`壶中水倒入`x`壶\n  * 如果`y`不为空，那么`x`肯定是满的，把`x`**倒空**，再把`y`剩下的倒入`x`壶\n\n  重复以上操作直到某一步`x`壶进行了 $a$ 次倒空，`y`壶进行了 $b$ 次倒水操作。\n\n* 若 $b<0$，方法同上，`x`与`y`互换。\n\n","tags":["数学"],"categories":["LeetCode"]},{"title":"LeetCode12-整数转罗马数字","url":"/blog/2020/12/25/LeetCode12-整数转罗马数字/","content":"\n#### 题目描述\n\n罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n<img src=\"LeetCode12-整数转罗马数字\\12.png\"  />\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n* `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n* `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n* `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n<!-- more-->\n\n#### 思路\n\n主要是处理那些特殊的样例，结合代码，对于示例中的1994，去掉1000后还剩下994，这个900的表示是特殊的，所以如果当前 $num$ 范围是900-999，就需要加上\"CM\"；$num$ 还剩下94，这个90也是特殊的，所以如果当前 $num$ 范围是90-99，就需要加上\"XC\"；最后剩下4，所以加上\"IV\"，得到结果\"MCMXCIV\"。\n\n**需要注意`if`语句的顺序不能改变，就像状态机一样，执行完一个状态后才能执行下一个状态**。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        // 前面几行针对特定案例，注释了也不影响\n        if(num == 4) return \"IV\";\n        if(num == 9) return \"IX\";\n        if(num == 40) return \"XL\";\n        if(num == 90) return \"XC\";\n        if(num == 400) return \"CD\";\n        if(num == 900) return \"CM\";\n        string res;\n        while(num){\n            if(num / 1000 != 0){\n                res += string(num / 1000, 'M');\n                num -= num / 1000 * 1000;\n            }\n            else if(num >= 900 && num < 1000){\n                res += \"CM\";\n                num -= 900;\n            }\n            else if(num / 500 != 0){\n                res += string(num / 500, 'D');\n                num -= num / 500 * 500;\n            }\n            else if(num >= 400 && num < 500){\n                res += \"CD\";\n                num -= 400;\n            }\n            else if(num / 100 != 0){\n                res += string(num / 100, 'C');\n                num -= num / 100 * 100;\n            }\n            else if(num >= 90 && num < 100){\n                res += \"XC\";\n                num -= 90;\n            }\n            else if(num / 50 != 0){\n                res += string(num / 50, 'L');\n                num -= num / 50 * 50;\n            }\n            else if(num >= 40 && num < 50){\n                res += \"XL\";\n                num -= 40;\n            }\n            else if(num / 10 != 0){\n                res += string(num / 10, 'X');\n                num -= num / 10 * 10;\n            }\n            else if(num == 9){\n                res += \"IX\";\n                break;\n            }\n            else if(num / 5 != 0){\n                res += string(num / 5, 'V');\n                num -= num / 5 * 5;\n            }\n            else if(num == 4){\n                res += \"IV\";\n                break;\n            }\n            else if(num / 1 != 0){\n                res += string(num / 1, 'I');\n                num = 0;\n            }\n        }\n        return res;\n    }\n};\n```\n\n","tags":["贪心算法","状态机"],"categories":["LeetCode"]},{"title":"内存管理（三）","url":"/blog/2020/12/25/内存管理（三）/","content":"\n#### 本次学习要点\n\n1. 基本分页存储管理的基本概念\n2. 基本地址变换机构\n3. 具有快表的地址变换机构\n4. 基本分段存储管理方式\n5. 段页式管理方式\n\n<!-- more-->\n\n#### 基本分页存储管理的基本概念\n\n##### 连续分配方式的缺点\n\n1. 固定分区分配：内存利用率低，会产生大量的内部碎片。\n2. 动态分区分配：会产生很多外部碎片，可以通过“紧凑”处理，但代价很高。\n\n如果允许将一个程序分散的装入到许多不相邻的分区中，便可充分利用内存——非连续分配方式（离散分配方式）。\n\n##### 基本分页存储管理思想\n\n把内存分为一个个相等的小分区，再按照分区大小把进程拆分为一个个小部分。\n\n*如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高*。\n\n##### 分页存储的基本概念\n\n**页框**：将内存空间分为一个个**大小相等的分区**，每个分区就是一个页框，也称为”页帧“、”内存块“、”物理块“。\n\n**页框号**：每个页框的编号，其他名称同上。从0开始。\n\n**页**：将用户进程的地址空间分为**与页框大小相等**的一个个区域，称为”页“或者”页面“。\n\n**页号**：每个页面的编号，也是从0开始。\n\n操作系统**以页框为单位为各个进程分配**内存空间。进程的**页面**与内存的**页框**有**一一对应**的关系。\n\n##### 地址转换\n\n###### 进程在内存中连续存放\n\n重定位寄存器：存放装入模块的起始位置。\n\n思想：模块在内存中的“起始地址” + 目标内存单元相对于起始位置的“偏移量”。\n\n###### 进程在内存中非连续存放\n\n<img src=\"内存管理（三）\\进程在内存中非连续存放.png\" style=\"zoom:80%;\" />\n\n如何计算进程在内存中的存放位置？\n\n1. 计算出逻辑地址对应的页号：\n   $$\n   页号=逻辑地址/页面长度（取整）\n   $$\n\n2. 该页号对应页面在内存中的起始位置： 操作系统的某种数据结构记录\n\n3. 逻辑地址在页面内的偏移量：\n   $$\n   页内偏移量=逻辑地址\\%页面长度\n   $$\n\n4. 物理地址 = 页面地址+ 页内偏移量\n\n对于逻辑地址为80的内存单元：\n\n1. 在1号页 : $80 / 50 = 1$\n2. 该页在内存中的起始地址为450\n3. 内存单元相对于该页起始地址偏移量为 $80\\%50=30$\n4. 实际物理地址为 $450+30=480$\n\n为了方便计算页号、页内偏移量，**页面大小**一般取**2的整数幂**。\n\n假设用32个二进制位表示逻辑地址，页面大小为 $2^{12}B=4096B=4KB$。\n\n* 0号页逻辑地址空间为0~4095，用二进制表示为：\n\n  `0000_0000_0000_0000_0000_0000_0000_0000~0000_0000_0000_0000_0000_1111_1111_1111`\n\n* 1号页逻辑地址空间为4096~8191，用二进制表示为：\n\n  `0000_0000_0000_0000_0001_0000_0000_0000~0000_0000_0000_0000_0001_1111_1111_1111`\n\n* 2号页逻辑地址空间为4096~8191，用二进制表示为：\n\n  `0000_0000_0000_0000_0010_0000_0000_0000~0000_0000_0000_0000_0010_1111_1111_1111`\n\neg：逻辑地址4097，用二进制表示为：`0000_0000_0000_0000_0001_0000_0000_0001`。\n\n若1号页在内存中的起始地址为X，则逻辑地址4097对应的物理地址为：`X+0000_0000_0001`。\n\n结论：\n\n如果每个页面大小为 $2^KB$，用二进制数表示逻辑地址，则末尾的 $K$ 位为**页内偏移量**，其余部分就是**页号**。所以让**每个页面的大小为2的整数幂**。\n\n###### 分页存储管理的逻辑地址结构\n\n<img src=\"内存管理（三）\\分页存储管理的逻辑地址结构.png\"  />\n\n**如果有 $K$ 位表示“页内偏移量”，则说明系统中一个页面的大小是 $2^K$ 个内存单元**。\n\n**如果有 $M$ 位表示“页号”，则说明在该系统中，一个进程最多允许有 $2^M$ 个页面**。\n\n##### 页表\n\n为了能知道进程的每个页面在内存中存放的位置，操作系统要为**每个进程建立一张页表**。\n\n<img src=\"内存管理（三）\\页表.png\"  />\n\n上述的第五条，是因为：\n\n假设内存大小位4GB，页面大小位4KB，则每个页表项至少为多少个字节？\n\n$4GB=2^{32}B$\n\n$4KB=2^{12}B$\n\n $4GB$ 内存会被划分为 $2^{32}/2^{12}=2^{20}$ 个内存块，所以内存块号的范围是 $0\\sim2^{20}-1$ ，所以至少需要20个二进制位才能表示内存块号，即至少需要3个字节。\n\n各页表项会**按顺序且连续的**存在在内存中，如果该页表在内存中存放的起始位置为X，则M号页对应的页表项一定是存放在内存地址为 $X+3*M$ 处。\n\n因此，只需要知道**页表存放的起始位置**和**页表项长度**。即可找到各个页号对应的页表项存放的位置。\n\n##### 小结\n\n<img src=\"内存管理（三）\\分页存储管理小结.png\"  />\n\n#### 基本地址变换机构\n\n用于实现逻辑地址到物理地址转换的一组硬件机构。\n\n在**系统中**设置一个**页表寄存器（PTR）**，存放：\n\n* 页表在内存中的起始地址F\n* 页表长度M\n\n进程还未执行时，上述两个参数存放在**进程控制块（PCB）**中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。**页面大小是2的整数幂**。\n\n##### 地址变换过程\n\n设页面大小为L，逻辑地址A到物理地址E的变换过程如下：\n\n<img src=\"内存管理（三）\\逻辑地址2物理地址.png\"  />\n\n1. 计算页号P和页内偏移量W\n2. 比较页号P和页表长度M，若 $P\\geq{M}$ ，则产生越界\n3. 页表中页号P对应的 $页表项地址=页表起始地址F+页号P\\times页表项长度M$ ，取出该页表项内容b即为内存块号\n4. 计算 $E=b\\times L+W$，用得到的物理地址E去访问内存\n\n**注意**：\n\n* 页表长度：当前页表中总共有几个页表项，即总共有几个页（用户进程）\n* 页表项长度：每个页表项占多大的存储空间\n* 页面大小：一个页面占多大的存储空间（与页框大小一致，用户进程）\n\n##### 一个例题\n\n若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。\n\n等价描述：某系统**按字节寻址**，逻辑地址结构中，**页内偏移量占10位**（说明一个页面的大小位2^10B=1KB），页号2对应的内存块号b=8，将逻辑地址A=2500转换位物理地址E。\n\n1. 计算页号P、页内偏移量W\n\n$$\nP=A/L=2500/1024=2\\\\\\\\\nW=A\\%L=2500\\%1024=452\n$$\n\n2. 页号2没有越界，存放内存块号为b=8\n3. 计算物理地址E\n\n$$\nE=b\\times L+W=8\\times 1024+425=8644\n$$\n\n分页式存储管理系统中，只要确定每个页面的大小，逻辑地址结构就确定了。因此，**页式管理中地址是一维的**。即，只要给出逻辑地址，系统会自动算出页号、页内偏移量，**不需要**显示的告诉系统页内偏移量占多少位。\n\n##### 对页表项大小的进一步探讨\n\n之前说过一个页表项占据3B的内存，如果一个页面为4KB，则每个页框可以存放4096/3=1365个页表项，则会剩下4096%3=1B的页内碎片，如果**每个页表项占4个字节**，则每个页框刚好可存放1024个页表项。\n\n除此之外，如果**每个页表项占据3个字节**，则1365号页表项地址为 $X+3\\times1365+1$。如果**每个页表项占4个字节**，则1024号页表项地址为 $X+4\\times1024$，更方便计算。\n\n理论上，页表项长度为3B即可表示内存块号的范围，但是**为了方便页表查询，常常会让一个页表项占据更多的字节，使得每个页面恰好可以装得下整数个页表项**。\n\n##### 小结\n\n<img src=\"内存管理（三）\\基本地址变换机构.png\"  />\n\n#### 具有快表的地址变换机构\n\n基本地址变换机构的改进版本。\n\n##### 局部性原理\n\n* 时间局部性：如果程序执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很有可能再次被访问（程序中一般存在大量循环）。\n* 空间局部性：如果程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（数据在内存中连续存放）。\n\n之前提到的**基本地址变换机构**中，每访问一个逻辑地址，都**需要查询内存中的页表**。由于局部性原理，可能**连续很多次查到的都是同一个页表项**。可以利用这个特性减少访问页表的次数。\n\n##### 快表（TLB）\n\n也称联想寄存器（TLB），是一种**访问速度比内存快很多**的**高速缓冲存储器**，存储当前访问的若页表项，加速地址变换过程。相对应的**内存**中的页表称为**慢表**。\n\n##### 引入快表后，地址的变换过程\n\n<img src=\"内存管理（三）\\引入快表后的地址变换过程.png\"  />\n\n1. CPU给出逻辑地址，由**硬件**得到页号、页内偏移量，将页号与快表中的所有页号进行比较。\n2. 找到匹配的页号，直接从**快表**中取出该页对应的内存块号，将内存块号和页内偏移量拼接成物理地址，再访问该物理地址对应的内存单元。因此**快表命中**，访问某个逻辑地址仅需**一次访存**。\n3. 未找到匹配的页号，访问**内存中的页表**，找到对应页表项，根据页表项得到页面存放的内存块号，再将内存块号和页内偏移量拼接得到物理地址，再根据物理地址访问对应的内存单元。因此**快表未命中**，访问某个逻辑地址需要**两次访存**（找到页表项后，同时将其**存入快表**，若快表已满，则按照一定算法对旧的页表进行替换）。\n\n由于局部性原理，快表命中率可达**90%**以上。\n\n##### 小结\n\n<img src=\"内存管理（三）\\快表小结.png\"  />","categories":["操作系统"]},{"title":"LeetCode455-分发饼干","url":"/blog/2020/12/25/LeetCode455-分发饼干/","content":"\n#### 题目描述\n\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n\n对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j]` >= `g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n<!-- more-->\n\n<img src=\"LeetCode455-分发饼干\\455.png\"  />\n\n#### 思路\n\n先将两个数组分别排序，使用两个指针分别指向两个数组的首元素，当饼干值满足胃口值时，两个指针后移；否则只需要将饼干数组的指针进行后移，直到满足胃口值或到达数组末尾。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int i = 0, j = 0;\n        int cnt = 0;\n        while(i < g.size() && j < s.size()){\n            if(s[j] >= g[i]){\n                cnt++;\n                i++;\n                j++;\n            }\n            else j++;\n        }\n        return cnt;\n    }\n};\n```\n\n","tags":["贪心算法","双指针"],"categories":["LeetCode"]},{"title":"LeetCode135-分发糖果","url":"/blog/2020/12/24/LeetCode135-分发糖果/","content":"\n#### 题目描述\n\n老师想给孩子们分发糖果，有 *N* 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。\n\n你需要按照以下要求，帮助老师给这些孩子分发糖果：\n\n* 每个孩子至少分配到 1 个糖果。\n* 相邻的孩子中，评分高的孩子必须获得更多的糖果。\n\n那么这样下来，老师至少需要准备多少颗糖果呢？\n\n<!-- more-->\n\n<img src=\"LeetCode135-分发糖果\\135.png\"  />\n\n#### 思路\n\n用数组 $store$ 记录每个孩子得到的糖果数，$store[i]$ 表示第 $i$ 个孩子获得的糖果数。\n\n首先找到最低的评分，这个位置记为 $pos$，最低分孩子的糖果数必为1，所以可以得到 $store[pos]=1$ ，以 $pos$为界，将评分数组分为两个部分分别操作，两个部分是**互不影响**的。\n\n<img src=\"LeetCode135-分发糖果\\评分数组.png\" style=\"zoom:80%;\" />\n\n1. 对于 $pos$ 之前（包括 $pos$），往回遍历评分数组，在不越界的条件下可以得到：\n\n   <img src=\"LeetCode135-分发糖果\\从后往前1.png\" style=\"zoom:80%;\" />\n\n   1. 如果前一个评分小于当前评分：\n\n      1. 当前糖果数不为1，那么前一个孩子获得的糖果置为1，结束；\n\n      2. 当前糖果数为1，那么前一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于前一个孩子获得的糖果数（前一个评分小于当前评分）。所以需要从前一个位置开始往后遍历：\n\n         1. 如果遇到**后一个评分大于当前评分，并且后一个的糖果等于当前糖果数（上图红线）**，需要给后一个糖果数加1，保证后一个的糖果大于当前糖果数。\n\n            <img src=\"LeetCode135-分发糖果\\从后往前2.png\" style=\"zoom:80%;\" />\n\n         2. 如果后一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。\n\n            <img src=\"LeetCode135-分发糖果\\从后往前3.png\" style=\"zoom:80%;\" />\n\n   2. 如果前一个评分等于当前评分，前一个糖果数为1\n\n   3. 如果前一个评分大于当前评分，前一个糖果数为当前糖果数加1\n\n2. 对于 $pos$ 之后（包括 $pos$），往后遍历评分数组，在不越界的条件下：\n\n   <img src=\"LeetCode135-分发糖果\\从前往后1.png\" style=\"zoom:80%;\" />\n\n   1. 如果后一个评分小于当前评分：\n\n      1. 当前糖果数不为1，那么后一个孩子获得的糖果置为1，结束；\n\n      2. 当前糖果数为1，那么后一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于后一个孩子获得的糖果数（后一个评分小于当前评分）。所以需要从后一个位置开始往前遍历：\n\n         1. 如果遇到**前一个评分大于当前评分，并且前一个的糖果等于当前糖果数（上图红线）**，需要给前一个糖果数加1，保证前一个的糖果大于当前糖果数。\n\n            <img src=\"LeetCode135-分发糖果\\从前往后2.png\" style=\"zoom: 80%;\" />\n\n         2. 如果前一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。\n\n            <img src=\"LeetCode135-分发糖果\\从前往后3.png\" style=\"zoom:80%;\" />\n\n   2. 如果后一个评分等于当前评分，后一个糖果数为1\n\n   3. 如果后一个评分大于当前评分，后一个糖果数为当前糖果数加1\n\n最终结果：\n\n| ratings | 2    | 3    | 3    | 1    | 3    | 2    | 2    | 1    |\n| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| store   | 1    | 2    | 2    | 1    | 2    | 1    | 2    | 1    |\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        if(ratings.empty()) return 0;\n        auto iter = min_element(ratings.begin(), ratings.end());\n        int val = *iter;\n        int pos = iter - ratings.begin();\n        vector<int> store(ratings.size(), 0);\n        store[pos] = 1;\n        // 从pos往前\n        for(int i = pos; i >= 0; --i){\n            if(i - 1 >= 0 && ratings[i - 1] < ratings[i]){\n                if(store[i] != 1) store[i - 1] = 1;\n                else{\n                    store[i - 1] = 1;\n                    for(int j = i - 1; j < pos; ++j){\n                        // 往后走\n                        // 下一个评分比当前评分高，并且下一个的糖果又没当前糖果多\n                        if(ratings[j + 1] > ratings[j] && store[j + 1] <= store[j]){\n                            store[j + 1] += 1;\n                        }\n                        if(ratings[j + 1] == ratings[j]) break;                        \n                    }\n                }\n            }\n            else if(i - 1 >= 0 && ratings[i - 1] == ratings[i]){\n                store[i - 1] = 1;\n            }\n            else if(i - 1 >= 0 && ratings[i - 1] > ratings[i]){\n                store[i - 1] = store[i] + 1;\n            }\n        }\n        // 从pos往后\n        for(int i = pos; i < ratings.size(); ++i){\n            if(i + 1 < ratings.size() && ratings[i + 1] < ratings[i]){\n                if(store[i] != 1) store[i + 1] = 1;\n                else{\n                    store[i + 1] = 1;\n                    for(int j = i + 1; j > pos; --j){\n                        // 往前走\n                        // 上一个评分比当前评分高，并且上一个的糖果又没当前糖果多\n                        if(ratings[j - 1] > ratings[j] && store[j - 1] <= store[j]){\n                            store[j - 1] += 1;\n                        }\n                        if(ratings[j - 1] == ratings[j]) break;\n                    }\n                }\n            }\n            else if(i + 1 < ratings.size() && ratings[i + 1] == ratings[i]){\n                store[i + 1] = 1;\n            }\n            else if(i + 1 < ratings.size() && ratings[i + 1] > ratings[i]){\n                store[i + 1] = store[i] + 1;\n            }\n        }\n        // for(auto &v : store) cout << v << \" \";\n        int sum = accumulate(store.begin(), store.end(), 0);\n        return sum;\n    }\n};\n```\n\n#### 更进一步\n\n##### 思路\n\n**相邻的孩子中，评分高的孩子必须获得更多的糖果**。这句话可以拆为两个规则分别处理：\n\n* 左规则：当 $ratings[i-1]<ratings[i]$ 时，$i$ 获得的糖果要多于 $i-1$ 。\n* 右规则：当 $ratings[i]>ratings[i+1]$ 时，$i$ 获得的糖果要多于 $i+1$ 。\n\n遍历数组两次，分别得到每一个孩子满足左规则和右规则的糖果数，取两者之间的最大值就是这个孩子最少分配的糖果数。\n\n在实际代码中，我们先计算出左规则 $left$ 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        if(ratings.empty()) return 0;\n        vector<int> left(ratings.size());\n        for(int i = 0; i < ratings.size(); ++i){\n            if(i - 1 >= 0 && ratings[i] > ratings[i - 1]){\n                left[i] = left[i - 1] + 1;\n            }\n            else\n                left[i] = 1;\n        }\n        int right = 0, ret = 0;\n        for(int i = ratings.size() - 1; i >= 0; --i){\n            if(i + 1 < ratings.size() && ratings[i] > ratings[i + 1]){\n                right++;\n            }\n            else{\n                right = 1;\n            }\n            ret += max(left[i], right);\n        }\n        return ret;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode387-字符串中的第一个唯一字符","url":"/blog/2020/12/23/LeetCode387-字符串中的第一个唯一字符/","content":"\n#### 题目描述\n\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n<!-- more-->\n\n<img src=\"LeetCode387-字符串中的第一个唯一字符\\387.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n用一个哈希表记录一下每个字母出现的次数，返回第一个出现次数为1的字母位置即可。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        int cnt[26] = {0};\n        for(auto &ch : s)\n            cnt[ch - 'a']++;\n        int pos = -1;\n        for(int i = 0; i < s.size(); ++i){\n            if(cnt[s[i] - 'a'] == 1){\n                pos = i;\n                break;\n            }      \n        }\n        return pos;\n    }\n};\n```\n\n","tags":["字符串","哈希表"],"categories":["LeetCode"]},{"title":"LeetCode103-二叉树的锯齿形层序遍历","url":"/blog/2020/12/22/LeetCode103-二叉树的锯齿形层序遍历/","content":"\n#### 题目描述\n\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n<!-- more-->\n\n例如：\n给定二叉树 `[3,9,20,null,null,15,7]`,\n\n<img src=\"LeetCode103-二叉树的锯齿形层序遍历\\103.png\"  />\n\n#### 思路\n\n这道题和二叉树的层序遍历很相似，无非就是遍历完每一层需要改变一次方向，使用一个标志位标记从前往后或者从后往前遍历。可以使用双端队列，根据标志位决定从队列的那一头开始遍历。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if(!root) return {};\n        vector<vector<int>> res;\n        deque<TreeNode*> deq;\n        deq.push_back(root);\n        int dir = 0;\n        while(!deq.empty()){\n            vector<int> buf;\n            // 前往后\n            if(dir == 0){\n                dir = 1;\n                int n = deq.size();\n                for(int i = 0; i < n; ++i){\n                    TreeNode* tmp = deq.front();\n                    buf.push_back(tmp->val);\n                    // 前向时需要先将左边的点入队，保证下次遍历的顺序正确\n                    if(tmp->left) deq.push_back(tmp->left);\n                    if(tmp->right) deq.push_back(tmp->right);\n                    deq.pop_front();\n                }\n                res.push_back(buf);\n            }\n            // 后往前\n            else{\n                dir = 0;\n                int n = deq.size();\n                for(int i = 0; i < n; ++i){\n                    TreeNode* tmp = deq.back();\n                    buf.push_back(tmp->val);\n                    // 后向时需要先将右边的点入队，保证下次遍历的顺序正确\n                    if(tmp->right) deq.push_front(tmp->right);\n                    if(tmp->left) deq.push_front(tmp->left);\n                    deq.pop_back();\n                }\n                res.push_back(buf);\n            }        \n        }\n        return res;\n    }\n};\n```\n\n#### 附录\n\n[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)：\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(!root) return {};\n        vector<vector<int>> res;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int n = q.size();\n            vector<int> buf;\n            for(int i = 0; i < n; ++i){\n                TreeNode *node = q.front();\n                q.pop();\n                buf.push_back(node->val);\n                if(node->left) q.push(node->left);\n                if(node->right) q.push(node->right);\n            }\n            res.push_back(buf);\n        }\n        return res;\n    }\n};\n```\n\n","tags":["二叉树"],"categories":["LeetCode"]},{"title":"C++关联容器","url":"/blog/2020/12/21/C-关联容器/","content":"\n#### 本次学习要点\n\n1. 使用关联容器\n2. 关联容器概述\n3. 关联容器操作\n4. 无序容器\n\n<!-- more-->\n\n关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是**map**和**set**。\n\n* `map`中元素是一些关键字-值（key-value）对，关键字起到索引的作用，值则表示于索引相关联的数据。\n* `set`中每个元素只包含一个关键字，支持高效的关键字查询操作-检查一个给定的关键字是否在set中。\n\n<img src=\"C-关联容器\\关联容器类型.png\"  />\n\n类型`map`和`multimap`定义在头文件`map`中；`set`和`multiset`定义在头文件`set`中；无序容器定义在头文件`unordered_map`和`unordered_set`中。\n\n#### 使用关联容器\n\n##### 使用map\n\n单词计数程序：\n\n```cpp\nmap<string, size_t> word_count;\nstring count;\nwhile(cin >> word)\n\t++word_count[word];\nfor(const auto &w : word_count)\n    cout << w.first << \" occurs \" << w.second\n    << ((w.second > 1) ? \" times\" : \" time\") << endl;\n```\n\n此程序读取输入，报告每个单词出现多少次。`map`保存的每个元素中，关键字是`string`，值是`size_t`类型。如果`word`还未在`map`中。下标运算符会创建一个新元素。从`map`中提取一个元素时，会得到一个`pair`类型的对象，`pair`用`first`成员保存关键字，用`second`成员保存对应的值。\n\n##### 使用set\n\n对上一个程序扩展，忽略常见单词，如“the”、“and”、“or”等。可以用`set`保存想忽略的单词，只对不在集合中的单词统计出现次数：\n\n```cpp\nmap<string, size_t> word_count;\nset<string> exclude = {\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\",\n                       \"the\", \"but\", \"and\", \"or\", \"an\", \"a\"};\nstring count;\nwhile(cin >> word)\n    if(exclude.find(word) == exclude.end())\n\t\t++word_count[word];\n```\n\n在`if`中，`find`返回一个迭代器。如果给定关键字在`set`中，迭代器指向该关键字。否则，`find`返回尾后迭代器。\n\n#### 关联容器概述\n\n##### 定义关联容器\n\n当定义一个`map`时，必须指明**关键字类型**和**值类型**；而定义一个`set`时，只需要指明**关键字类型**。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。\n\n```cpp\nmap<string, size_t> word_count; // 空容器\n// 列表初始化\nset<string> exclude = {\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\",\n                       \"the\", \"but\", \"and\", \"or\", \"an\", \"a\"};\n// 三个元素；authors将姓映射为名\nmap<string, string> authors = { {\"zhao\", \"xingyu\"},\n                                {\"zhou\", \"yanxuan\"}};\n```\n\n初始化`map`时，每对映射用花括号包含：{*key*, *value*}。\n\n##### 初始化multimap或multiset\n\n`map`和`set`的关键字都是唯一的。容器`multiset`和`multimap`没有此限制，它们都允许多个元素具有相同的关键字。\n\n```cpp\n// 定义一个有20哥元素的vector，保存0到9每个整数的两个拷贝\nvector<int> ivec;\nfor(vector<int>::size_type i = 0; i != 10; ++i){\n    ivec.push_back(i);\n    ivec.push_back(i);\n}\n// iset包含来自ivec的不重复的元素；miset包含所有20个元素\nset<int> iset(ivec.begin(), ivec.end());\nmultiset<int> miset(ivec.begin(), ivec.end());\ncout << ivec.size() << endl;\ncout << iset.size() << endl;\ncout << miset.size() << endl;\n```\n\n##### 关键字类型的要求\n\n###### 有序容器的关键字类型\n\n所提供的操作必须在关键字类型上定义一个**严格弱序**。可以将严格弱序看作“小于”（**书上是\"小于等于\"，网上查到为小于**），它必须具备以下性质：\n\n* 两个关键字不能同时“小于”对方\n* 如果k1\"小于\"k2，k2“小于”k3，那么k1必须”小于“k3\n* 如果存在两个关键字，任何一个都不”小于“另一个，那么我们称这两个关键字是”等价“的。并且等价具有传递性。\n\n如果两个关键字等价，那么容器将它们视作相等来处理。\n\n###### 使用关键字类型的比较函数\n\n在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数的形式提供真正的比较操作（其类型必须与尖括号中指定的类型相吻合）。\n\n例如：我们不能直接定义一个`Sales_data`的`multiset`，因为`Sales_data`没有`<`运算符。以下函数在`ISBN`成员上定义一个严格弱序：\n\n```cpp\nbool compareIsbn(const Sales_data &lhs, const Sales_data &rhs){\n    return lhs.isbn() < rhs.isbn();\n}\n```\n\n**要使用自己定义的操作**，在定义`multiset`时必须提供两个类型：**关键字类型**Sales_data以及**比较操作类型**——应该是一种函数指针类型，可以指向`compareIsbn`：\n\n```cpp\n// bookstore中多条记录可以有相同的ISBN\n// bookstore中的元素以ISBN的顺序进行排列\nmultiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);\n```\n\n**当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数的指针**。`bookstore`中的元素将按它们的`ISBN`成员的值升序排列。\n\n##### pair类型\n\n`pair`标注库类型定义在头文件`utility`中。`pair`保存两个数据成员，它是一个用来生成特定类型的模板。\n\n```cpp\npair<string, string > anon;\npair<string, size_t> word_count;\npair<string, vector<int>> line;\n```\n\n`pair`的默认构造函数对数据成员进行值初始化。以下三种初始化都是可以的：\n\n```cpp\npair<int, int> p = {1,1};\npair<int, int> q{1,1};\npair<int, int> m(1,1);\n```\n\n<img src=\"C-关联容器\\pair上的操作.png\"  />\n\n###### 创建pair对象的函数\n\n新标准下，可以对返回值进行列表初始化：\n\n```cpp\npair<string, int> process(vector<string> &v){\n\t// 处理v\n    if(!v.empty())\n        return {v.back(), v.back().size()}; // 列表初始化\n    else\n        return pair<string, int>(); // 隐式构造返回值\n}\n```\n\n早期版本必须显式的构造返回值：\n\n```cpp\nif(!v.empty())\n    return pair<string, int>(v.back(), v.back().size());\n```\n\n还可以使用`make_pair`来生成`pair`对象，`pair`的两个类型来自于`make_pair`的参数：\n\n```cpp\nif(!v.empty())\n\treturn make_pair(v.back(), v.back().size());\n```\n\n#### 关联容器操作\n\n<img src=\"C-关联容器\\关联容器额外的类型别名.png\"  />\n\n```cpp\nset<string>::value_type v1; // v1是一个string\nset<string>::key_value v2; // v2是一个string\nmap<string, int>::value_type v3; // v3是一个pair<const string, int>\nmap<string, int>::key_type v4; // v4是一个string\nmap<string, int>::mapped_type v5; // v5是一个int\n```\n\n只有`map`类型（`unordered_map、unordered_multimap、multimap、map`）才定义了`mapped_type`;\n\n##### 关联容器迭代器\n\n解引用一个关联容器的迭代器时，得到一个类型为容器的`value_type`的值的**引用**。对`map`而言，`value_type`是一个`pair`类型，其`first`成员保存`cosnt`的关键字，`second`成员保存值。\n\n```cpp\n// 获得指向word_count中一个元素的迭代器\nauto map_it = word_count.begin();\n// *map_it是指向一个pair<const string, size_t>对象的引用\n// 或者使用(*map_it).first，(*map_it).second\ncout << map_it->first; // 打印此元素的关键字\ncout << \" \" << map_it->second; // 打印此元素的值\nmap_it->first = \"new key\"; // 错误：关键字是const的\n++map_it->second; // 正确：可以通过迭代器改变元素 \n```\n\n###### set的迭代器是const的\n\n虽然`set`类型同时定义了`iterator`和`const_iterator`类型， 但两种类型都只允许读`set`中的元素。\n\n```cpp\nset<int> iset = {0,1,2,3,4,5,6};\nset<int>::iterator set_it = iset.begin();\nif(set_it != iset.end()){\n    *set_it = 42; // 错误：set中的关键字是只读的\n    cout << *set_it << endl; // 正确：可以读关键字\n}\n```\n\n###### 遍历关联容器\n\n`map`和`set`都支持之前所说的`begin`和`end`操作。\n\n```cpp\nauto map_it = word_count.cbegin();\nwhile(map_it != word_count.cbegin()){\n    cout << map_it->first << \" occurs\"\n         << map_it->second << \" times\" << endl;\n    ++map_it;\n}\n```\n\n###### 关联容器和算法\n\n通常不对关联容器使用泛型算法，有其专用算法。如果真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的位置。\n\n##### 添加元素\n\n使用关联容器的`insert`成员向容器中添加一个元素或一个元素范围：\n\n```cpp\nvector<int> ivec = {2,4,6,8,2,4,6,8}; // ivec有8个元素\nset<int> set2;\nset2.insert(ivec.cbegin(), ivec.cend()); // set2有4个元素\nset2.insert({1,3,5,7,1,3,5,7}); // set2现在有8个元素\n```\n\n###### 向map添加元素\n\n对一个`map`进行`insert`操作时，必须记住元素类型是`pair`。\n\n```cpp\n// 向word_count插入word的4种方法\nword_count.insert({word, 1});\nword_count.insert(make_pair(word, 1));\nword_count.insert(pair<string, size_t>(word, 1));\nword_count.insert(map<string, size_t>::value_type(word, 1));\n```\n\n<img src=\"C-关联容器\\关联容器insert操作.png\"  />\n\n###### 检测insert返回值\n\n`insert`(或`emplace`)返回的值依赖于容器类型和参数。对于**不包含重复关键字**的容器，添加单一元素的`insert`和`emplace`版本返回一个`pair`，告诉我们插入操作是否成功。`pair`的`first`成员是一个**迭代器**，指向**具有给定关键字的元素**；`second`成员是一个`bool`值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则`insert`什么事情也不做，且返回值中的`bool`部分为`false`。如果关键字不存在，元素被插入容器中，且`bool`值为`true`。\n\n例子，重写单词计数程序：\n\n```cpp\nmap<string, size_t> word_count;\nstring word;\nwhile(cin >> word){\n    auto ret = word_count.insert({word, 1});\n    if(!ret.second)\n        ++ret.first->second;\n}\n```\n\n###### 展开递增语句\n\n* **ret**：保存`insert`返回的值，是一个**pair**\n* **ret.first**：是一个`map`迭代器，指向具有给定关键字的元素\n* **ret.first->**：解引用此迭代器，提取`map`种元素，元素也是一个`pair`\n* **ret.first->second**：`map`中元素的值部分\n* **++ret.first->second**：递增此值\n\n###### 向multiset或multimap添加元素\n\n```cpp\nmultimap<string, string> authors;\n// 插入第一个元素，关键字为zxy\nauthors.insert({\"zxy\", \"c++泛型算法\"});\n// 正确：添加第二个元素，关键字也是zxy\"\nauthors.insert({\"zxy\", \"c++关联容器\"});\n```\n\n这里`insert`操作返回一个指向新元素的迭代器。无需返回一个`bool`值，因为`insert`总是向这类容器中加入一个新元素。\n\n##### 删除元素\n\n关联容器定义了三个版本的`erase`，如下：\n\n<img src=\"C-关联容器\\关联容器erase操作.png\"  />\n\n后两个与顺序容器一样，第一个是关联容器额外提供的，它接受一个`key_type`类型。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除元素的数量。\n\n* 对于保存不重复关键字的容器，`erase`的返回值总是0或1。0表示要删除的元素不在容器中\n* 对于允许重复关键字的容器，删除元素的数量可能大于1\n\n##### map的下标操作\n\n`map`和`unordered_map`容器提供了下标运算符和一个对应的`at`函数：\n\n<img src=\"C-关联容器\\map和unordered_map的下标操作.png\"  />\n\n**`set`类型不支持下标，因为`set`中元素本身就是关键字，同时也不能对`multimap`或者`unordered_multimap`进行下标操作，因为这些容器中可能有多个值与一个关键字相关联**。\n\n<img src=\"C-关联容器\\map_note.png\"  />\n\n###### 使用下标操作的返回值\n\n当对一个`map`进行下标操作时，会获得一个`mapped_type`对象；但当解引用一个`map`迭代器时，会得到一个`value_type`对象。与其他下标运算符相同的是，`map`的下标运算符返回一个左值，所以既可以读也可以写元素。\n\n<img src=\"C-关联容器\\map下标_note.png\"  />\n\n##### 访问元素\n\n关联容器提供多种查找一个指定元素的方法，应该使用哪个取决我们要解决什么问题。\n\n<img src=\"C-关联容器\\在一个关联容器种查找元素的操作.png\"  />\n\n```cpp\nset<int> iset{0,1,2,3,4,5,6};\niset.find(1); // 返回一个迭代器，指向key = 1的元素\niset.find(11); // 返回一个迭代器，其值等于iset.end()\niset.count(1); // 返回1\niset.count(11); // 返回0\n```\n\n###### 对map和find代替下标操作\n\n如果我们只是想知道一个给定的关键字是否在`map`中，而不想改变`map`（下标操作会插入一个未在`map`的元素）。这种情况下应该使用`find`：\n\n```cpp\nif(word_count.find(\"foobar\") == word_count.end())\n\tcout << \"foobar is not in the map\" << endl;\n```\n\n###### 在multimap或multiset中查找元素\n\n如果一个`multimap`或`multiset`中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。\n\n例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。可以用三种不同方法来解决这个问题。最直观的方法是使用`find`和`count`。\n\n```cpp\nstring search_item(\"zxy\"); // 作者\nauto entries = authors.count(search_item); // 元素的数量\nauto iter = authors.find(search_item); // 作者的第一本书\n// 查找此作者所有著作\nwhile(entries){\n    cout << iter->second << endl; // 打印书名\n    ++iter; // 下一本\n    --entries; // 打印一次，计数减一\n}\n```\n\n<img src=\"C-关联容器\\multimap或multiset中查找元素_note.png\"  />\n\n###### 一种不同的，面向迭代器的解决办法\n\n可以使用`lower_bound`和`upper_bound`来解决。\n\n* 关键字在容器中，`lower_bound`返回迭代器将指向第一个具有给定关键字的元素，`upper_bound`返回迭代器指向最后一个匹配关键字元素之后的位置\n* 关键字不在容器中，两者返回一个不影响排序的关键字插入位置\n\n因此，使用相同关键字调用`lower_bound`和`upper_bound`会得到关键字元素的范围。我们可以重写程序：\n\n```cpp\nfor(auto beg = authors.lower_bound(search_item),\n    end = authors.upper_bound(search_item);\n    beg != end; ++ beg)\n    cout << beg->second << endl;\n```\n\n<img src=\"C-关联容器\\lower_bound和upper_bound_note.png\"  />\n\n###### equal_range函数\n\n此函数接受一个关键字，返回一个**迭代器`pair`**（不是`pair`对象）。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。再次修改程序\n\n```cpp\nfor(auto pos = authors.equal_range(search_item);\n\tpos.first != pos.second; ++pos.first)\n    cout << pos.first->second << endl;\n```\n\n##### 一个单词转换的map\n\n程序功能：给定一个`string`，将它转换为另一个`string`。我们需要根据单词转换文件将待转换的文本转换为我们想要的样子：\n\n单词转换文件：\n\n```\nk okay?\ny why\nr are\nu you\npic picture\nthk thank!\nl8r later\n```\n\n待转换文本：\n\n```\nwhere r u\ny dont u send me a pic\nk thk l8r\n```\n\n转换结果：\n\n```\nwhere are you\nwhy dont you send me a picture\nokay? thanks! later\n```\n\n###### 单词转换程序\n\n```cpp\n// map_file 转换规则\n// input 待转换文本\nvoid word_transform(ifstream &map_file, ifstream &input, ofstream &output){\n    auto trans_map = buildMap(map_file);\n    string text; // 保存输入中的每一行\n    while(getline(input, text)){ // 读取每一行输入\n        istringstream stream(text); // 读取每个单词\n        string word;\n        bool firstword = true; // 控制是否打印空格\n        while(stream >> word){\n            if(firstword)\n                firstword = false;\n            else\n                output << \" \"; // 单词间打印一个空格\n            output << transform(word, trans_map); // 打印输出\n        }\n        output << endl; // 完成一行的转换\n    }\n}\n```\n\n###### 建立转换映射\n\n```cpp\nmap<string, string> buildMap(ifstream & map_file){\n\tmap<string, string> trans_map; // 保存转换规则\n    string key; // 要转换的单词\n    string value; // 替换后的内容\n    // 读取第一个单词存入key，剩余存入value（包括标点）\n    // map_file>>key流只读取第一个空格前string，剩下的流由getline读取到value中\n    while(map_file >> key && getline(map_file, value))\n        if(value.size() > 1) // 检查是否有转换规则\n            trans_map[key] = value.substr(1); // 跳过前导空格，getline不会跳过前导空格\n        else\n            throw runtime_error(\"no rule for \" + key);\n    return trans_map;\n}\n```\n\n###### 生成转换文本\n\n```cpp\nconst string& transform(const string &s, const map<string, string> &m){\n    auto map_it = m.find(s);\n    if(map_it != m.cend())\n        return map_it->second; // 使用替换短语\n    else return s; // 否则返回原string\n}\n```\n\n#### 无序容器\n\n新标准定义了**4**个**无序关联容器**，这些容器使用一个哈希函数和关键字类型的`==`运算符。\n\n###### 使用无序容器\n\n用于`map`和`set`的操作也能用于`unordered_map`和`unordered_set`，如`find、insert`等。无序容器也有允许重复关键字的版本。\n\n###### 管理桶\n\n无序容器在存储上组织为**一组桶**，每个桶保存零个或多个元素。**无序容器使用一个哈希函数将元素映射到桶**。\n\n* 为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。\n\n* 容器将具有一个特定哈希值的所有元素都保存在相同的桶中。\n* 如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。\n\n因此，无序容器的性能依赖于**哈希函数的质量**和**桶的数量和大小**。\n\n对于相同的参数，哈希函数必须总是产生相同的结果。**理想情况下，哈希函数将每个特定的值映射到唯一的桶**。但是，**将不同关键字的元素映射到相同的桶也是允许的**。\n\n* 当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。\n* 计算一个元素的哈希值和在桶中搜索通常都是很快的操作。\n* 如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。\n\n以下这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。\n\n<img src=\"C-关联容器\\无序容器管理操作.png\"  />\n\n###### 无序容器对关键字类型的要求\n\n默认情况下，无序容器使用关键字类型`==`运算符来比较元素，它们还使用一个`hash<key_type>`类型的对象来**生成每个元素的哈希值**。\n\n* 无序容器支持关键字是**内置类型(包括指针类型)**、**`string`**或者**智能指针**类型的无序容器。\n* 无序容器**不能**直接定义**关键字类型为自定义类类型的无序容器**。与容器不同，不能直接使用哈希模板，而必须提供我们自己的`hash`模板版本。\n* 不使用默认的`hash`，而是使用一种类似于**为有序容器重载关键字类型**的默认比较操作。\n\n为了能将`Sale_data`用作关键字，我们需要提供函数来替代`==`运算符和哈希值计算函数。我们从定义这些重载函数开始：\n\n```cpp\nsize_t hasher(const Sales_data &sd){\n    return hash<string>()(sd.isbn());\n}\nbool eqOp(const Sales_data &lhs, const Sales_data &rhs){\n    return lhs.isbn() == rhs.isbn();\n}\n```\n\n`hasher`函数使用标准库`hash`类型对象计算`ISBN`成员的哈希值，该哈希值建立在`string`之上。\n\n`eqOp`函数通过比较`ISBN`号来比较两个`Salas_data`。\n\n使用以上函数来定义一个`unordered_multiset`：\n\n```cpp\nusing SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;\n// 参数是桶大小、哈希函数指针和相等性判断运算符指针\nSD_miltiset bookstore(42, hasher, eqOp);\n```\n\n此集合的哈希和相等性判断操作与`hasher`和`eqOp`函数有着相同的类型。在定义`bookstore`时可以将我们希望它使用的函数的指针传递给它。\n\n如果类定义了`==`运算符，则可以只重载哈希函数：\n\n```cpp\n// 使用FooHash生成哈希值；Foo必须有==运算符\nunordered_set<Foo, decltype(FooHash)*> fooSet(10, FoolHash);\n```\n\n","categories":["C++"]},{"title":"LeetCode746-使用最小花费爬楼梯","url":"/blog/2020/12/21/LeetCode746-使用最小花费爬楼梯/","content":"\n#### 题目描述\n\n数组的每个索引作为一个阶梯，第`i`个阶梯对应着一个非负数的体力花费值 `cost[i]`(索引从0开始)。\n\n每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。\n\n您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。\n\n<!-- more-->\n\n<img src=\"LeetCode746-使用最小花费爬楼梯\\746.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n像这种爬楼梯问题考虑动态规划，当前状态花费 $dp[i]$ 可以由上一次 $dp[i-1]$ 或者上上次 $dp[i-2]$ 中的最小花费得到（对应爬一层台阶和爬两层台阶），其次当前状态还有体力消耗 $cost[i]$，所以可以定义状态转移方程：\n$$\ndp[i]=min(dp[i-1],dp[i-2])+cost[i]\n$$\n当楼梯只有两阶时，假定有第三阶，那么到达第三阶的花费就为0，初始化如下：\n\n``` cpp\ndp[0] = cost[0];\ndp[1] = cost[1];\ncost.push_back(0);\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        vector<int> dp(cost.size() + 1, 0);\n        cost.push_back(0);\n        dp[0] = cost[0];\n        dp[1] = cost[1];\n        for(int i = 2; i < dp.size(); ++i){\n            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];\n        }\n        return dp[dp.size() - 1];\n    }\n};\n```\n\n\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode316-去除重复字母","url":"/blog/2020/12/20/LeetCode316-去除重复字母/","content":"\n#### 题目描述\n\n给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。\n\n<!-- more-->\n\n<img src=\"LeetCode316-去除重复字母\\316.png\"  />\n\n#### 思路\n\n对于一个字符串来说，如果 $s[i]>s[i+1]$ ，去除此时的 $s[i]$ 可以使剩下的字符串字典序最小。我们将 $s[i]$ 称为**关键字符**。\n\n从前往后遍历字符串。假定在 $s[i-1]$ 之前所有的**关键字符**都已经去除，那么在扫描 $s[i]$ 时，新出现的**关键字符**只能出现在 $s[i]$ 或者其后的位置。\n\n所以用栈来维护去除**关键字符**后得到的字符串。如果栈顶字符大于 $s[i]$ ，说明栈顶字符应当被去除，此时新的栈顶字符就与 $s[i]$ 相邻（保持相对位置）。重复此操作，直到栈为空或者栈顶字符不大于 $s[i]$ 。\n\n还需要满足 $s$ 中的每个字符都出现在新字符串中且只出现一次，所以还需要考虑：\n\n* 如果字符 $s[i]$ 已经存在于栈中，则不再将此字符加入栈，所以需要记录字符是否被使用过\n* 弹出栈顶字符时，如果后面再没有此字符（此字符剩余数量为0），则不能弹出，所以需要记录每个字符出现的次数；如果可以弹出，需要将此字符再次置为未使用的状态\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n\tstring removeDuplicateLetters(string s) {\n        int cnt[26] = {0}; // 记录字符使用次数\n        bitset<26> vis; // 记录字符是否被使用\n        for(auto &ch : s) cnt[ch - 'a']++;\n        stack<char> st;\n        for(auto &ch : s){\n            // 如果字符没被使用\n            if(!vis[ch - 'a']){\n                // 如果栈不为空且栈顶字符大于当前字符，需要看是否弹出\n                while(!st.empty() && st.top() > ch){\n                    // 如果此字符串剩余次数不为0，可以弹出，并且此字符置为「未使用」\n                    if(cnt[st.top() - 'a'] > 0){\n                        vis[st.top() - 'a'] = 0;\n                        st.pop();\n                    }\n                    else break;\n                }\n                // 当前字符入栈，并且置为「已使用」\n                vis[ch - 'a'] = 1;\n                st.push(ch);\n            }\n            // 当前字符被使用了一次\n            cnt[ch - 'a']--;\n        }\n        // 取出栈中字符并输出\n        string res;\n        while(!st.empty()){\n            res += st.top();\n            st.pop();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n\t}\n};\n```\n\n\n\n#### Reference\n\n官方题解：\n\nhttps://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/","tags":["贪心算法","单调栈"],"categories":["LeetCode"]},{"title":"C++泛型算法（二）","url":"/blog/2020/12/19/C-泛型算法（二）/","content":"\n#### 本次学习要点\n\n1. 再探迭代器\n2. 泛型算法结构\n3. 特定容器算法\n\n<!-- more-->\n\n#### 再探迭代器\n\n标准库在头文件`iterator`中还定义了额外集中迭代器。包括：\n\n* **插入迭代器（insert iterator）**：这些迭代器被绑定在一个容器上，可用来向容器插入元素。\n* **流迭代器（stream iterator）**：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。\n* **反向迭代器（reverse iterator）**：这些迭代器向前而不是向后移动（**书上写的是向后而不是向前，疑问？**），除了`forward_list`之外的标准库容器都有反向迭代器。\n* **移动迭代器（move iterator）**：这些专用的迭代器不是拷贝其中的元素，而是移动它们。后面会提到。\n\n##### 插入迭代器\n\n插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。\n\n插入器有三种类型，差异在于元素插入的位置：\n\n* **back_inserter**：创建一个使用`push_back`的迭代器。\n* **front_inserter**：创建一个使用`push_front`的迭代器。\n* **inserter**创建一个使用`insert`的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。**元素将被插入到给定得到所表示的元素之前**。\n\n<img src=\"C-泛型算法（二）\\插入迭代器_note.png\"  />\n\n当调用`inserter(c, iter)`时，会得到一个迭代器，接下来使用它时，会将元素插入到`iter`原来所指向的元素之前的位置。即，如果`it`是由`iterator`生成的迭代器，则下面两段代码效果一样：\n\n```cpp\n*it = val;\n// 等价于\nit = c.insert(it, val); // it指向新加入的元素\n++it; // 递增it使它指向原来的元素\n```\n\n`front_inserter`生成的迭代器的行为于`inserter`生成的迭代器完全不一样。当我们使用`front_inserter`时，元素总是插入到容器第一个元素之前。即使我们传递给`inserter`的位置原来是指向第一个元素的，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：\n\n```cpp\nlist<int> lst{1,2,3,4};\nlist<int> lst2, lst3; // 空list\n// 拷贝完成后，lst2包含4 3 2 1\ncopy(lst.begin(), lst.end(), front_inserter(lst2));\n// 拷贝完成后，lst3包含1 2 3 4\ncopy(lst.begin(), lst.end(), inserter(lst3, lsr3.begin());\n```\n\n##### iostream迭代器\n\n虽然`iostream`不是迭代器，但标准库定义了一个可以用于这些IO类型对象的迭代器。**iostream_iterator**读入输入流，**ostream_iterator**向一个输出流写数据。这些迭代器将它们对应的流当作一个特定的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。\n\n###### istream_iterator操作\n\n当创建一个流迭代器时，必须指定将要读写的对象类型。一个`istream_iterator`使用`>>`来读取流。因此，`istream_iterator`要读取的类型必须定义了输入运算符。当创建一个`istream_iterator`时，我们可以将它绑定到一个流。\n\n```cpp\nistream_iterator<int> int_it(cin); // 从cin读取int\nistream_iterator<int> int_eof; // 尾后迭代器\nifstream in(\"afile\");\nistream_iterator<string> str_it; // 从\"afile\"读取字符串\n```\n\n下面是一个用`istream_iterator`从标准输入读取数据，存入一个`vector`的例子：\n\n``` cpp\nistream_iterator<int> in_iter(cin); // 从cin读取int\nistream_iterator<int> eof; // istream尾后迭代器\nwhile(in_iter != eof){\n    // 后置递增运算读取流，返回迭代器的旧值\n    // 解引用迭代器，获得从流读取的前一个值\n    vec.push_back(*in_iter++);\n}\n```\n\n`eof`被定义为空的`istream_iterator`，从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等。\n\n上述程序可以改写如下：\n\n```cpp\nistream_iterator<int> in_iter(cin), eof; // 从cin读取int\nvector<int> vec(in_iter, eof); // 从迭代器范围构造vec\n```\n\n<img src=\"C-泛型算法（二）\\istream_iterator操作.png\" style=\"zoom: 80%;\" />\n\n###### 使用算法操作流迭代器\n\n```cpp\nistream_iterator<int> in(cin), eof;\ncout << accumulate(in, eof, 0) << endl;\n```\n\n此调用会计算出从标准输入读取的值的和。\n\n###### istream_iterator允许使用懒惰求值\n\n当我们将一个`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流读取数据。可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。\n\n###### ostream_iterator操作\n\n我们可以对具有输出运算符`<<`的类型定义`ostream_iterator`。创建一个`ostream_iterator`时，可选第二个参数，它是一个**C**风格字符串（**即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）**。在输出的每个元素之后都会打印此字符串。并且必须将`ostream_iterator`绑定到一个指定的流，不允许空的或表示尾后位置的`ostream_iterator`。\n\n<img src=\"C-泛型算法（二）\\ostream_iterator操作.png\" style=\"zoom:80%;\" />\n\n我们可以用`ostream_iterator`来输出值的序列：\n\n```cpp\nostream_iterator<int> out_iter(cout, \" \");\nfor(auto e : vec)\n\t*out_iter++ = e; // 赋值语句实际上将元素写到cout\ncout << endl;\n// 下面的也行，但不推荐\nostream_iterator<int> out_iter(cout, \" \");\nfor(auto e : vec)\n\tout_iter = e; // 赋值语句将元素写到cout\ncout << endl;\n```\n\n运算符`*`和`++`不对`ostream_iterator`对象做任何操作。第一种写法流迭代器的使用与其他迭代器的使用保持一致。\n\n可以通过`copy`来打印`vec`中的元素，更简单：\n\n```cpp\ncopy(vec.begin(), vec.end(), out_iter);\ncout << endl;\n```\n\n###### 使用流迭代器处理类类型\n\n对于之前的`Sales_item`既有输入运算符也有输出运算符，可以使用IO迭代器重写书店程序：\n\n```cpp\n// 原始程序\nSales_item total; // 保存下一条交易记录的变量\n// 读入第一条交易记录，并确保有数据可以处理\nif(cin >> total){\n    Sales_item trans; // 保存和的变量\n    // 读入并处理剩余交易记录\n    while(cin >> trans){\n        // 如果我们仍在处理相同的书\n        if(total.isbn() == trans.isbn())\n            totao += trans; // 更新销售总额\n        else{\n            // 打印前一本书的结果\n            cout << total << endl;\n            total = trans; // total现在表示下一本书的销售额\n        }\n    }\n    cout << total << endl;\n}\n// 使用IO迭代器重写\nistream_iterator<Sales_item> item_iter(cin), eof;\nostream_iterator<Sales_item> out_iter(cout, \"\\n\");\n// 将第一笔交易记录存在sum中，并读取下一条记录\nSales_item sum = *item_iter++;\nwhile(item_iter != eof){\n    // 如果当前交易记录（存在item_iter中）有相同的ISBN号\n    if(item_iter->isbn() == sum.isbn())\n        sum += *item_iter++;\n    else{\n        out_iter = sum;\n        sum = *item_iter++;\n    }\n}\nout_iter = sum;\n```\n\n##### 反向迭代器\n\n顾名思义，反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增和递减含义会颠倒过来。递增一个反向迭代器（`++it`）会移动到前一个元素；递减一个反向迭代器（`--it`）会移动到后一个元素。反向迭代器也有`const`和非`const`版本。\n\n<img src=\"C-泛型算法（二）\\反向迭代器.png\" style=\"zoom:80%;\" />\n\n下面是一个例子：\n\n```cpp\nvector<int> vec = {1,2,3,4,5,6};\nfor(auto r_iter = vec.crbegin(); r_iter != vec.crend(); ++r_iter)\n    cout << *r_iter << endl;\n// 打印6，5，4，3，2，1\n```\n\n可以通过向`sort`传递一对反向迭代器来将`vector`整理为递减：\n\n```cpp\nsort(vec.begin(), vec.end()); // 递增\nsort(vec.rbegin(), vec.rend()); // 递减\n```\n\n###### 反向迭代器和其他迭代器间的关系\n\n假定有一个名为`line`的`string`，保存着以逗号分隔的单词列表，我们希望打印`line`中的第一个单词，可以使用`find`完成：\n\n```cpp\nauto comma = find(line.cbegin(), line.cend(), ',');\ncout << string(line.cbegin(), comma) << endl;\n```\n\n如果`line`中有逗号，那么`comma`将指向这个逗号，否则它指向`line.cend()`。如果希望打印最后一个单词：\n\n```cpp\nauto rcomma = find(line.crbegin(), line.crend(), ',');\n```\n\n当我们试图打印找到的单词时，不能用以下代码：\n\n```cpp\n// 错误，对于FIRST,MIDDLE,LAST会打印出TSAL\ncout << string(line.crbegin(), rcomma) << endl;\n```\n\n需要做的是，将`rcomma`转换为一个普通迭代器，能在`line`中正向移动。可以调用`reverse_iterator`中的`base`成员来完成这一转换，此成员函数会返回其对应的普通迭代器：\n\n```cpp\ncout << string(rcomma.base(), line.cend()) << endl;\n```\n\n<img src=\"C-泛型算法（二）\\反向迭代器_使用base.png\" style=\"zoom:80%;\" />\n\n需要注意的是：\n\n<img src=\"C-泛型算法（二）\\反向迭代器_note.png\" style=\"zoom: 80%;\" />\n\n#### 泛型算法结构\n\n算法所要求的迭代器操作可以分为5个迭代器类别：\n\n<img src=\"C-泛型算法（二）\\迭代器类别.png\" style=\"zoom:80%;\" />\n\n##### 5类迭代器\n\n对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。**而这种错误很多编译器不会给出任何警告和提示**。\n\n###### 输入迭代器（input iterator）\n\n可以读取序列中的元素。一个输入迭代器必须支持：\n\n* 用于比较两个迭代器的相等和不相等运算符（`==、!=`）\n* 用于推进迭代器的前置和后置递增运算（`++`）\n* 用于读取元素的解引用运算符（`*`）；解引用只会出现在赋值运算符的右侧\n* 箭头运算符（`->`），等价于`(*it).member`，即，解引用迭代器，并提取对象的成员\n\n输入迭代器只用于顺序访问，只能用于单边扫描算法。算法`find`和`accumulate`要求输入迭代器；而`istream_iterator`是一种输入迭代器。\n\n###### 输出迭代器（output iterator）\n\n可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：\n\n* 用于推进迭代器的前置和后置递增运算（`++`）\n* 解引用运算符（`*`），只出现在赋值运算符的左侧\n\n例如，`copy`函数的第三个参数就是输出迭代器；`ostream_iterator`是一种输出迭代器。\n\n###### 前向迭代器（forward iterator）\n\n可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法`replace`要求前向迭代器， `forward_list`上的迭代器是前向迭代器。\n\n###### 双向迭代器（bidirectional iterator）\n\n可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（`--`）。算法`reverse`要求双向迭代器，除了`forward_list`之外，其他标准库都提供符合双向迭代器要求的迭代器.\n\n###### 随机访问迭代器（random-access iterator）\n\n提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，还支持以下操作：\n\n* 用于比较两个迭代器相对位置的关系运算符（`<、<=、>`和`>=`) \n* 迭代器和一个整数值的加减运算（`+、+=、-`和`-=`），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置\n* 用于两个迭代器上的减法运算符（`-`），得到两个迭代器的距离\n* 下标运算符`iter[n]`，与`*(iter[n])`等价\n\n算法`sort`要求随机访问迭代器。`array、deque、string、vector`的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。\n\n##### 算法形参模式\n\n大多数算法具有如下4种形式之一：\n\n* ***alg*** ( beg, end, ***other args***)\n* ***alg*** ( beg, end, dest, ***other args***)\n* ***alg*** ( beg, end, beg2, ***other args***)\n* ***alg*** ( beg, end, be2, end2, ***other args***)\n\n##### 算法命名规范\n\n如何提供一个操作代替默认的`<`或`==`运算符，以及算法是将输出数据写入输入序列，还是写入分离的目的位置等问题。\n\n###### 一些算法使用重载形式传递一个谓词\n\n```cpp\nunique(beg, end); // 使用 == 运算符比较元素\nunique(beg, end, comp); // 使用comp比较元素\n```\n\n###### _if版本的算法\n\n接受一个元素值得算法通常有另一个不同名的版本（非重载），该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的`_if`前缀：\n\n```cpp\nfind(beg, end, val); // 查找输入范围种val第一次出现的位置\nfind_if(beg, end, pred);// 查找第一个令pred为真的元素\n```\n\n###### 区分拷贝元素的版本和不拷贝的版本\n\n默认情况下，重排元素的算法将重排后的元素写回给定的输入序列。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个`_copy`：\n\n```cpp\nreverse(beg, end); // 反转输入范围中元素的顺序\nreverse_copy(beg, end ,dest); // 将元素按逆序拷贝到dest\n```\n\n一些算法同时提供`_if`和`_copy`版本。\n\n```cpp\n// 从v1中删除奇数元素\nremove_if(v1.begin(), v1.end(), \n          [](int i) { return i % 2; });\n// 将偶数元素从v1拷贝到v2，v1不变\nremove_copy_if(v1.begin(), v1.end(), back_inserter(v2),\n              [](int i){ return i % 2});\n```\n\n#### 特定容器算法\n\n与其他容器不同，链表类型`list`和`forward_list`定义了几个成员函数形式的算法，它们定义了独有的`sort、merge、remove、reverse、unique`，这些独有的版本比通用版本好得多。\n\n<img src=\"C-泛型算法（二）\\特定容器算法.png\" style=\"zoom:80%;\" />\n\n算法如下：\n\n<img src=\"C-泛型算法（二）\\list.png\" style=\"zoom:80%;\" />\n\n##### splice成员\n\n<img src=\"C-泛型算法（二）\\splice.png\" style=\"zoom:80%;\" />\n\n##### 链表特有的操作会改变容器\n\n链表特有版本会改变底层的容器，例如`remove`会删除指定的元素。`unique`会删除第二个和后继的重复元素。\n\n类似的，通用版本`merge`将合并的序列写到一个给定的目的迭代器，两个输入序列是不变的。而链表版本的`merge`会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用`merge`的链表对象中。在`merge`之后，来自两个链表中的元素依然存在，但它们都已在同一个链表中。","categories":["C++"]},{"title":"C++泛型算法（一）","url":"/blog/2020/12/19/C-泛型算法（一）/","content":"\n#### 本次学习要点\n\n1. 概述\n2. 初识泛型算法\n3. 定制操作\n\n<!-- more-->\n\n#### 概述\n\n大多数算法都定义在头文件`algorithm`中。标准库还在头文件`numeric`中定义了一组数值泛型算法。\n\n##### 算法永远不会执行容器的操作\n\n泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。算法永远**不会改变**底层容器的大小。算法可能**改变**容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。\n\n标准库定义了一类特殊的迭代器，称为插入器（inserter）。它们会在底层的容器上执行插入操作。当一个算法操作这样的一个迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身**不会**做这样的操作。\n\n#### 初识泛型算法\n\n标准库算法都对一个范围内的元素进行操作。此范围称为“输入范围”。输入范围使用两个参数：要处理的第一个元素和尾元素之后的位置的迭代器。\n\n##### 只读算法\n\n此类算法只会读取其输入范围内的元素，而从不改变元素。如`find`，`count`。定义在`numeric`中有只读算法`accumulate`，前两个指出需要求和的元素的范围，第三个参数是和的初值。最好用`cbegin()`和`cend()`，除非打算用返回的迭代器来改变元素的值。\n\n```cpp\n// 对vec中的元素求和，和的初值为0\nint sum = accumulate(v.cbegin(), v.cend(), 0);\n```\n\n###### 算法和元素类型\n\n`accumulate`第三个参数为求和起点，包含了一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须和第三个参数匹配。由于`string`定义了`+`操作，所以可以将`vector`中的所有`string`连接起来：\n\n```cpp\nstring sum = accumulate(v.cbegin(), v.cend(), string(\"\"));\n```\n\n将空串当作一个字符串字面值传递给第三个参数是不可以的，会导致编译错误：\n\n```cpp\n// 错误：const char*上没有定义+运算符\nstring sum = accumulate(v.cbegin(), v.cend(), \"\");\n```\n\n###### 操作两个序列的算法\n\n只读算法`equal`用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素和第二个序列中的对应元素逐个比较，如果都相等返回`true`，否则返回`false`。此算法接受三个迭代器：前两个表示第一个序列范围，第三个表示第二个序列的首元素：\n\n```cpp\n// roster2中的元素数目应该至少于roster1一样多\nequal(roster1.cbegin(), roster1.cend(), roster2.cbegin());\n```\n\n`equal`基于假设：第二个序列至少与第一个序列一样长。\n\n***注意！！！****那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。*\n\n##### 写容器元素的算法\n\n一些算法将新值赋予序列中的元素，需要确保序列原大小至少不小于要求算法写入的元素数目。例如`fill`接受一对迭代器表示一个范围，还接受一个值作为第三个参数，将范围内的值置为第三个参数的值：\n\n```cpp\nfill(vec.begin(), vec.end(), 0); // 将每个元素重置为0\n// 将容器的一个子序列设置为10\nfill(vec.begin(), vec.begin() + vec.size() / 2, 0);\n```\n\n###### 算法不检查写操作\n\n一些算法接受一个迭代器来指出一个单独的目的位置，从目的位置开始，将新值赋予一个序列中的元素。例如`fill_n`接受一个单迭代器、一个计数值和一个值：\n\n```cpp\nfill_n(dest, n, val);\n```\n\n`fill_n`假定`dest`指向一个元素，从`dest`开始的序列至少包含n个元素。\n\n```cpp\nvector<int> vec; // 空vector\n// 正确\nfill_n(vec.begin(), vec.size(); 0);\n// 错误,vec并没有10个元素\nfill_n(vec.begin(), 10, 0);\n```\n\n###### 介绍back_inserter\n\n`back_inserter`定义在头文件`iterator`中，其接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中：\n\n```cpp\nvector<int> vec;\nauto it = back_inserter(vec);\n*it = 42;\n```\n\n常常使用`back_inserter`创建一个迭代器，作为算法的目的位置来使用。例如：\n\n```cpp\nvector<int> vec;\nfill_n(back_inserter(vec), 10, 0);\n```\n\n###### 拷贝算法\n\n此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。算法将输入范围中的元素拷贝到目的序列中。**传递给`copy`的目的序列至少要包含与输入序列一样多的元素**。\n\n```cpp\nint a1[] = {0,1,2,3,4,5,6,7,8,9};\nint a2[sizeof(a1) / sizeof(*a1)];\nauto ret = copy(begin(a1), end(a1), a2);\n```\n\n`copy`返回其目的位置迭代器（递增后）的值，即`ret`恰好指向拷贝到`a2`的尾元素之后的位置。\n\n多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放在输入序列的末尾，而是创建一个新序列保存这些结果。\n\n如`replace`，其读入一个序列，并将其中所有等于给定值元素都改为另一个值，此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值：\n\n```cpp\n// 将所有值为0的元素改为42\nreplace(ilist.begin(), ilist.end(), 0, 42);\n```\n\n对于它的“拷贝”版本`replace_copy`，此算法接受额外第三个迭代器参数，指出点整后序列的保存位置：\n\n```cpp\n// 使用back_inserter按需要增长目标序列\nreplace_copy(ilist.cbegin(), ilist.cend(),\n             back_inserter(ivec), 0, 42);\n```\n\n经过此调用，`ilist`并未改变，`ivec`包含`ilist`的一份拷贝，不过原来在`ilist`中值为0的元素在`ivec`中都变为42。\n\n##### 重排容器元素的算法\n\n假定已经有一个`vector`，保存了多个故事的文本，简化这个`vector`，使得每个单词只出现一次。输入如下：\n\n<img src=\"C-泛型算法（一）\\重排_输入.png\" style=\"zoom:80%;\" />\n\n要求得到的结果如下：\n\n<img src=\"C-泛型算法（一）\\重排_输出.png\"  />\n\n为了消除重复单词，先对`vector`排序，使得重复的单词相邻出现，之后可以使用另一个称为`unique`的标准库算法来重排`vector`，使得不重复的元素出现在`vector`的开始部分。由于算法不能执行容器的操作，可以使用`vector`的成员`erase`来完成真正的删除操作：\n\n```cpp\nvoid elimDups(vector<string> &words){\n\tsort(words.begin(), words.end());\n    auto end_unique(words.begin(), words.end());\n    words.erase(end_unique, words.end());\n}\n```\n\n`words`排序完毕后，使用`unique`算法重排输入序列，将相邻的重复项”消除“，并**返回一个指向最后一个不重复元素之后的位置的迭代器**。调用`unique`后，`vector`将变为：\n\n<img src=\"C-泛型算法（一）\\after_unique.png\"  />\n\n如上图所示，`unique`并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列的开始部分。`unique`返回的迭代器位置之后的元素依旧存在，但不知道是什么。\n\n**标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元。素**\n\n最后，使用`erase`删除从`end_unique`开始至`words`末尾的范围内的所有元素。即使`words`中没有重复单词，调用`erase`也是安全的，删除空的范围没什么不良后果。\n\n#### 定制操作\n\n详见[C++11之lambda表达式](http://www.xingyuzhao.ltd/blog/2020/08/02/C-11%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/)。","categories":["C++"]},{"title":"LeetCode48-旋转图像","url":"/blog/2020/12/19/LeetCode48-旋转图像/","content":"\n#### 题目描述\n\n给定一个 $n × n$ 的二维矩阵表示一个图像。\n\n将图像顺时针旋转 90 度。\n\n说明：\n\n你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。\n\n<!-- more-->\n\n<img src=\"LeetCode48-旋转图像\\48.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n不好意思，一开始我还是用了新的数组。\n\n从最后一列往前，从第一行往后，每一列都是由相应的行复制过来，如下图（示例二）：\n\n<img src=\"LeetCode48-旋转图像\\48_思路.png\" style=\"zoom:80%;\" />\n\n新建数组保存原始数组的拷贝，然后再根据原始数组拷贝来修改原始数组。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int scale = matrix.size();\n        auto matrixHelper = matrix;\n        int pos = 0; // 表示当前遍历到拷贝数组的第pos行\n        for(int j = scale - 1; j >= 0; --j){\n            for(int i = 0; i < scale; ++i){\n                // 前面的i表示原始数组的行，后面的i表示拷贝数组的列\n                matrix[i][j] = matrixHelper[pos][i];\n            }\n            pos++;\n        }\n    }\n};\n```\n\n时间复杂度和空间复杂度都是$O(N^2)$。\n\n#### 更进一步\n\n##### 思路\n\n仔细观察旋转后的图：\n\n<img src=\"LeetCode48-旋转图像\\48_思路.png\" style=\"zoom:80%;\" />\n\n对于矩阵中第 $i$ 行的第 $j$ 个元素，在旋转后，它出现在倒数第 $i $ 列的第 $j$ 个位置。即：\n$$\nmatrix_{new}[col][n-row-1]=matrix[row][col]\n$$\n这样可以得到以下代码：\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        auto matrixHelper = matrix;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                matrix[j][n - i - 1] = matrixHelper[i][j];\n            }\n        }\n    }\n};\n```\n\n这样也不是原地修改，但是可以得到上面那个重要等式。\n\n如果对矩阵先进行水平轴翻转，再进行主对角线翻转，也可以得到旋转后的矩阵，以示例二为例：\n\n1. 水平翻转：\n\n$$\n\\left[\n\\begin{matrix}\n\t5 & 1 & 9 & 11 \\\\\\\\\n\t2 & 4 & 8 & 10 \\\\\\\\\n    13 & 3 & 6 & 7 \\\\\\\\\n    15 & 14 & 12 & 16\n\t\\end{matrix}\n\t\\right]\\stackrel{\\Large水平翻转}{\\huge\\longrightarrow}\n\\left[\n\\begin{matrix}\n\t15 & 14 & 12 & 16\\\\\\\\\n    13 & 3 & 6 & 7 \\\\\\\\\n    2 & 4 & 8 & 10 \\\\\\\\\n    5 & 1 & 9 & 11\n\t\\end{matrix}\n\t\\right]\n$$\n\n$$\nmatrix[row][col]=matrix[n-row-1][col]\n$$\n\n2. 主对角线翻转：\n\n$$\n\\left[\n\\begin{matrix}\n\t15 & 14 & 12 & 16 \\\\\\\\\n    13 & 3 & 6 & 7 \\\\\\\\\n    2 & 4 & 8 & 10 \\\\\\\\\n    5 & 1 & 9 & 11\n\t\\end{matrix}\n\t\\right]\\stackrel{\\Large主对角线翻转}{\\huge\\longrightarrow}\n\\left[\n\\begin{matrix}\n\t15 & 13 & 2 & 5 \\\\\\\\\n    14 & 3 & 4 & 1 \\\\\\\\\n    12 & 6 & 8 & 9 \\\\\\\\\n    16 & 7 & 10 & 11\n\t\\end{matrix}\n\t\\right]\n$$\n\n$$\nmatrix[row][col]=matrix[col][row]\n$$\n\n综合以上两式，可以得到：\n$$\nmatrix[row][col]\\stackrel{\\large水平翻转}{\\large\\longrightarrow}matrix[n-row-1][col]\n$$\n\n$$\nmatrix[n-row-1][col]\\stackrel{\\large主对角线翻转}{\\large\\longrightarrow}matrix[col][n-row-1]\n$$\n\n即：\n$$\nmatrix[row][col]=matrix_{new}[col][n-row-1]\n$$\n这就与之前得到的重要等式相同了。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        // 水平翻转\n        for (int i = 0; i < n / 2; ++i) {\n            for (int j = 0; j < n; ++j) {\n                swap(matrix[i][j], matrix[n - i - 1][j]);\n            }\n        }\n        // 主对角线翻转\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n    }\n};\n\n```\n\n#### Reference\n\n官方题解：\n\nhttps://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/","tags":["数组"],"categories":["LeetCode"]},{"title":"LeetCode389-找不同","url":"/blog/2020/12/18/LeetCode389-找不同/","content":"\n#### 题目描述\n\n给定两个字符串 ***s*** 和 ***t***，它们只包含小写字母。\n\n字符串 ***t*** 由字符串 ***s*** 随机重排，然后在随机位置添加一个字母。\n\n请找出在 ***t*** 中被添加的字母。\n\n<!-- more-->\n\n<img src=\"LeetCode389-找不同\\389.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n用一个长为26的数组记录在 ***t*** 中所有字母的出现次数，然后再去遍历 ***s*** ，对每次遇到的字母对应的次数减一，最后再遍历这个数组，如果有出现次数为1的字母，那么这就是 ***t*** 中被添加的字母。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    char findTheDifference(string s, string t) {\n        int map[26] = {0};\n        for(auto &ch : t){\n            map[ch - 'a']++;\n        }\n        for(auto &ch : s){\n            map[ch - 'a']--;\n        }\n        for(int i = 0; i < 26; ++i){\n            if(map[i] == 1) return char(i + 'a');\n        }\n        return char(' ');\n    }\n};\n```\n\n","tags":["哈希表"],"categories":["LeetCode"]},{"title":"LeetCode714-买卖股票的最佳时机含手续费","url":"/blog/2020/12/17/LeetCode714-买卖股票的最佳时机含手续费/","content":"\n#### 题目描述\n\n给定一个整数数组 $prices$，其中第$i$个元素代表了第$i$天的股票价格 ；非负整数 $fee$ 代表了交易股票的手续费用。\n\n你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n\n返回获得利润的最大值。\n\n注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n\n<!-- more-->\n\n<img src=\"LeetCode714-买卖股票的最佳时机含手续费\\714.png\"  />\n\n#### 思路\n\n##### 定义$dp$数组\n\n使用两个数组$dp1[i]$和$dp2[i]$分别表示当天持有股票or当天不持有股票时的最大收益。\n\n##### 状态转移方程\n\n* $dp1[i]$表示第$i$天未持有的最大收益，由上一天未持有或者上一天持有当天卖出得到：\n\n$$\ndp1[i] = max(dp1[i - 1], dp2[i - 1] + prices[i] - fee)\n$$\n\n* $dp2[i]$表示第$i$天持有的最大收益，由上一天持有或者上一天不持有今天买入得到：\n\n$$\ndp2[i] = max(dp2[i - 1], dp1[i - 1] - prices[i])\n$$\n\n##### 初始化\n\n* 第一天未持有股票时，收益为0，$dp1[0] = 0$。\n* 第一天持有股票时，收益为当天买入所需要的钱，$dp2[0] = -prices[0]$。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        vector<int> dp1(prices.size());\n        vector<int> dp2(prices.size());\n        dp1[0] = 0;\n        dp2[0] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp1[i] = max(dp1[i - 1], dp2[i - 1] + prices[i] - fee);\n            dp2[i] = max(dp2[i - 1], dp1[i - 1] - prices[i]);\n        }\n        return dp1[prices.size() - 1];\n    }\n};\n```\n\n##### 更进一步\n\n注意到$dp1[i]$和$dp2[i]$只会从$dp1[i-1]$和$dp2[i-1]$转移而来，所以用两个变量$sell$以及$buy$分别表示$dp1[i]$和$dp2[i]$，空间复杂度降为$O(1)$。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int sell = 0;\n        int buy = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int tmp = sell;\n            sell = max(sell, buy + prices[i] - fee);\n            buy = max(buy, sell - prices[i]);\n        }\n        return sell;\n    }\n};\n```\n\n#### Reference\n\n评论区：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/comments/\n\n官方题解：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/)\n\n[LeetCode122-买卖股票的最佳时机II](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/)\n\n[LeetCode122-买卖股票的最佳时机III](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/)\n\n[LeetCode122-买卖股票的最佳时机IV](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/)\n\n[LeetCode309-最佳买卖股票时机含冷冻期](http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/)\n\n[LeetCode714-买卖股票的最佳时机含手续费](http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/)","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode290-单词规律","url":"/blog/2020/12/16/LeetCode290-单词规律/","content":"\n#### 题目描述\n\n给定一种规律 `pattern` 和一个字符串 `str` ，判断 `str` 是否遵循相同的规律。\n\n这里的 `遵循` 指完全匹配，例如， `pattern` 里的每个字母和字符串 `str` 中的每个非空单词之间存在着双向连接的对应规律。\n\n<!-- more-->\n\n<img src=\"LeetCode290-单词规律\\290.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n字母和单词一一对应时返回true，否则返回false。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        istringstream istr(s);\n        vector<string> str;\n        string word;\n        while(istr >> word){\n            str.push_back(word);\n        }\n        if(pattern.size() != str.size()) return false;\n        unordered_map<char, unordered_set<string>> map1;\n        unordered_map<string, unordered_set<char>> map2;\n        for(int i = 0; i < pattern.size(); ++i){\n            map1[pattern[i]].insert(str[i]);\n            map2[str[i]].insert(pattern[i]);\n            // 如果不是一一对应，返回false\n            if(map1[pattern[i]].size() > 1 || map2[str[i]].size() > 1) return false;\n        }\n        return true;\n    }\n};\n```\n\n","tags":["哈希表"],"categories":["LeetCode"]},{"title":"LeetCode738-单调递增的数字","url":"/blog/2020/12/15/LeetCode738-单调递增的数字/","content":"\n#### 题目描述\n\n给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。（当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）\n\n<!-- more-->\n\n<img src=\"LeetCode738-单调递增的数字\\738.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n这种思路太繁琐，不想看的话直接转至**更进一步**。\n\n---\n\n输入是一个非负整数，所以第一步要将其转换成可以遍历的形式，可以先将整数转换为字符串序列。\n\n从**输入序列**的第一个数开始，一个一个数的建立起**答案序列**。\n\n1. **输入序列单调不减**，答案序列的当前值最大可以取到输入序列的当前值。如输入为1234，那么答案序列的第一个位置最大可以取到1，继续遍历，取到当前位置最大值时，一直会大于等于上一个取到的值，所以最终可以得到答案1234：\n\n```cpp\nstring nums; // 输入序列\nstring res; // 答案序列\nint pre = -1; // 初始化为-1，保证第一个值可以取到\nint cur;\nfor(int i = 0; i < nums.size(); ++i){\n    cur = nums[i] - '0';\n    if(cur >= pre){\n        res += to_string(cur);\n        pre = nums[i] - '0';\n    }\n}\n```\n\n2. **输入序列非单调不减**，如果当前值小于上一个可以取到的最大值，就需要回退，直到当前值不小于上一个可以取到的最大值。如输入332。\n   1. 当取到2时小于上一个取到的值3，上一个值减去1作为当前值（得到2），`res`出栈一次，如果出栈后`res`为空，那么存下当前值并退出。否则，上一个值取`res`末尾的值（第一个3）。\n   2. 当前值为2，上一个值为第一个3，由于2小于3，那么再将上一个值减1作为当前值得到2），出栈一次，遍历回退一次，那么当前值变为2，此时`res`为空，记录2并且退出遍历。\n\n* 使用一个`flag`标记是否回退。\n* 如果`res == \"0\"`，说明第一个数为0，此时答案长度为输入序列的长度减去1，全部为9；否则，就在`res`后补充9直到和输入序列长度相同。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int monotoneIncreasingDigits(int N) {\n        string nums = to_string(N);\n        int pre = -1;\n        int cur;\n        int flag = 0;\n        string res;\n        int i;\n        for(i = 0; i < nums.size(); ++i){\n            if(flag == 0){\n                cur = nums[i] - '0';\n                if(cur >= pre){\n                    res += to_string(cur);\n                    pre = nums[i] - '0';\n                }\n                else{\n                    flag = 1;\n                    pre--;\n                    res.pop_back();\n                    if(res.empty()){\n                        res += to_string(pre);\n                        break;\n                    }\n                    cur = pre;\n                    pre = res.back() - '0';\n                    i--;\n                }\n            }\n            else{\n                if(cur >= pre){\n                    res += to_string(cur);\n                    break;\n                }\n                pre--;\n                res.pop_back();\n                if(res.empty()){\n                    res += to_string(pre);\n                    break;\n                }\n                cur = pre;\n                pre = res.back() - '0';\n                i--;\n            }\n        }\n        int resVal;\n        if(res == \"0\"){\n            int n = nums.size() - 1;\n            string buf(n, '9');\n            resVal = stoi(buf, 0, 10);\n        }\n        else{\n            for(int j = res.size(); j < nums.size(); ++j){\n                res += '9';\n            }\n            resVal = stoi(res, 0, 10);\n        }\n        return resVal;\n    }\n};\n```\n\n这种思路实现起来太繁琐了（我是sb）。\n\n#### 更进一步\n\n##### 思路\n\n局部最优：遇到`nums[i - 1] > nums[i]`的情况，让`nums[i - 1]--`，然后`nums[i]`值为9，可以保证这两位变成最大单调不减整数。\n\n全局最优：尽量使`nums[i - 1]--`靠后，这样做可以使整数尽可能的大，因为越后面减去1，对整数的损失越小，所以从后往前遍历。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int monotoneIncreasingDigits(int N) {\n        string nums = to_string(N);\n        int flag = nums.size();\n        for(int i = nums.size() - 1; i >= 1; --i){\n            if(nums[i - 1] > nums[i]){\n                nums[i - 1]--;\n                flag = i;\n            }\n        }\n        for(flag; flag < nums.size(); ++flag){\n            nums[flag] = '9';\n        }\n        return stoi(nums, 0, 10);\n    }\n};\n```\n\n#### Reference\n\n题解：\n\nhttps://leetcode-cn.com/problems/monotone-increasing-digits/solution/738-dan-diao-di-zeng-de-shu-zi-tan-xin-s-vq4r/","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode49-字母异位词分组","url":"/blog/2020/12/14/LeetCode49-字母异位词分组/","content":"\n#### 题目描述\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n<!-- more-->\n\n<img src=\"LeetCode49-字母异位词分组\\49.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n主要是理解哈希表的 $key$ 和 $value$ 表示什么数或者集合。对于字母构造相同的几个`string`，它们进行排序后的结果是一致的，所以可以将排序后的结果作为哈希表的 $key$，而对应的 $value$ 来存储排序后等于此 $key$ 的所有`string`。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> map;\n        vector<vector<string>> res;\n        for(int i = 0; i < strs.size(); ++i){\n            string str = strs[i];\n            sort(str.begin(), str.end());\n            map[str].push_back(strs[i]);\n        }\n        for(auto &m : map)\n            res.push_back(m.second);\n        return res;   \n    }\n};\n```\n\n#### 更进一步\n\n##### 思路\n\n**唯一分解定理**：任何一个大于1的**自然数**N,如果N不为**质数**，那么N可以唯一分解成**有限个质数**的乘积。\n\n用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。并且每个乘积只能是由这几个质数相乘得到。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<double, vector<string>> map;\n        vector<vector<string>> res;\n        double value[26]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};\n        for(int i = 0; i < strs.size(); ++i){\n            double v = 1;\n            for(auto &ch : strs[i]){\n                v *= value[ch - 'a'];\n            }\n            map[v].push_back(strs[i]);\n        }\n        for(auto &m : map)\n            res.push_back(m.second);\n        return res;   \n    }\n};\n```\n\n#### Reference\n\n评论区https://leetcode-cn.com/problems/group-anagrams/comments/","tags":["哈希表"],"categories":["LeetCode"]},{"title":"内存管理（二）","url":"/blog/2020/12/12/内存管理（二）/","content":"\n#### 本次学习要点\n\n1. 连续分配管理方式\n2. 动态分区分配算法\n\n <!-- more-->\n\n#### 连续分配管理方式\n\n连续分配：指为用户进程分配的必须是一个**连续的空间**。\n\n<img src=\"内存管理（二）\\连续分配.png\"  />\n\n##### 单一连续分配\n\n单一连续分配方式中，内存被分为**系统区**和**用户区**。\n\n<img src=\"内存管理（二）\\单一连续分配.png\" style=\"zoom:80%;\" />\n\n特点：内存中**只能有一道用户程序**，用户程序独占整个用户区空间。\n\n优点：实现简单，**无外部碎片**；可采用覆盖技术扩充内存；不一定需要采取内存保护\n\n缺点：只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低。\n\n*分配给某进程的内存区域中，如果有些部分没有用上，就是**内部碎片***。\n\n##### 固定分区分配\n\n将**用户空间**划分为**若干个固定大小的分区**，每个分区中**只装入一道作业**。\n\n有两种形式：分区大小相等和分区大小不等\n\n<img src=\"内存管理（二）\\固定分区分配.png\" style=\"zoom:80%;\" />\n\n* 分区大小相等：缺乏灵活性，适用于一台计算机控制多个相同模块的场合。\n* 分区大小不等：增加灵活性，可以满足不同大小进程需求。\n\n###### 分区说明表\n\n操作系统需要建立一个数据结构—分区说明表，每个表包括对应分区的**大小、起始地址、状态**：\n\n<img src=\"内存管理（二）\\固定分区分配-分区说明表.png\"  />\n\n当某用户程序要装入内存时，操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将其分配给该程序，然后修改状态为“已分配”。\n\n优点：实现简单，无外部碎片。\n\n缺点：用户程序太大时，所有分区都不能满足需求，此时得采用覆盖技术，会降低性能；会产生内部碎片，内存利用率低。\n\n##### 动态分区分配\n\n动态分区分配也称可变分区分配，这种方法不会预先划分内存分区，而是**在进程装入内存时，根据进程的大小动态的建立分区**，使分区的大小正好适合进程的需要。\n\n<img src=\"内存管理（二）\\动态分配数据结构.png\" style=\"zoom:80%;\" />\n\n###### 使用什么数据结构？\n\n1. 空闲分区表：每个空闲分区对应一个表项，表项中包含分区号、分区大小、分区起始地址等信息。\n\n<img src=\"内存管理（二）\\动态分配数据结构-空闲分区表.png\"  />\n\n2. 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可以记录分区大小等信息。\n\n<img src=\"内存管理（二）\\动态分配数据结构-空闲分区链.png\"  />\n\n###### 选择哪个分区？\n\n动态分区分配算法，之后会提到。\n\n###### 如何进行分区的分配与回收？\n\n1. 分配\n\n<img src=\"内存管理（二）\\动态分配数据结构-分配1.png\" style=\"zoom:80%;\" />\n\n如果此时一个大小为5MB的进程到来，按照一定的分配算法，将分区1的一部分分配给它运行，分区表更新如下：\n\n![image-20201218113548211](D:\\zxy543040659.github.io\\source\\_posts\\内存管理（二）\\动态分配数据结构-分配2.png)\n\n还有一种情况，如果到来的进程大小为4MB，且将分区3分配给它，那么分区表更新如下：\n\n<img src=\"内存管理（二）\\动态分配数据结构-分配3.png\"  />\n\n2. 回收\n\n   1. 情况一，回收区的后面有一个相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收1.png\" style=\"zoom: 80%;\" />\n\n   此时进程4执行完毕，释放其占用的4MB内存，更新分区表如下（二合一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收2.png\"  />\n\n   \n\n   2. 情况二，回收区的前面有一个相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收3.png\" style=\"zoom:80%;\" />\n\n   此时进程3执行完毕，释放其占用的18MB内存，更新分区表如下（二合一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收4.png\"  />\n\n   3. 情况三，回收区的前、后各有一个相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收5.png\" style=\"zoom:80%;\" />\n\n   此时进程4执行完毕，释放其占用的4MB内存，更新分区表如下（三合一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收6.png\"  />\n\n   4. 情况四，回收区的前、后都没有相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收7.png\" style=\"zoom:85%;\" />\n\n   此时进程2执行完毕，释放其占用的14MB内存，更新分区表如下（新增一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收8.png\"  />\n\n*各表项的顺序不一定按照地址递增顺序，具体由动态分区分配算法确定。*\n\n###### 小结\n\n动态分区分配**没有内部碎片**，但是有**外部碎片**。\n\n* 内部碎片：分配给某进程的内存区域中，有些部分没有用上。\n* 外部碎片：指内存中某些空闲分区由于太小而难以利用。\n\n如果内存中空闲空间的总和本来可以满足某进程的要求，但是进程需要一整块连续的内存空间，而碎片不连续，可以通过**紧凑（拼凑，Compaction）**技术解决外部碎片。\n\n##### 小结\n\n<img src=\"内存管理（二）\\连续分配小结.png\" style=\"zoom:120%;\" />\n\n#### 动态分区分配算法\n\n在动态分区分配方式中，当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？\n\n<img src=\"内存管理（二）\\动态分配算法.png\" style=\"zoom:80%;\" />\n\n##### 首次适应算法\n\n算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。\n\n如何实现：**空闲分区以地址递增的次序排列**。每次分配内存时顺序查找**空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区。\n\n##### 最佳适应算法\n\n算法思想：尽可能多的留下大片的空闲区，优先使用更小的空闲区。\n\n如何实现：**空闲分区以容量递增次序链接**。每次分配内存时顺序查找**空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区（能够满足但大小最小）。\n\n缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多外部碎片。\n\n##### 最坏适应算法\n\n又称最大适应算法。\n\n算法思想：每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小。\n\n如何实现：**空闲分区以容量递减次序链接**。每次分配内存时顺序查找**空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区。\n\n缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。之后如果有“大进程”到达，就没有内存分区可用了。\n\n##### 邻近适应算法\n\n算法思想：在首次适应算法基础上，每次都从上次查找结束的位置开始检索，减小查找的开销。\n\n如何实现：**空闲分区以地址递增的顺序排列（可排成一个循环链表）**。每次分配内存时**从上次查找结束的位置开始查找空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区。\n\n**首次适应算法**每次都会从头查找，每次都需要检索低地址的小分区。这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来。\n\n**邻近适应算法**的规则可能导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，被划分为小分区，最后导致无大分区可用。\n\n**综合来看，首次适应算法的效果反而最好**。\n\n##### 小结\n\n<img src=\"内存管理（二）\\动态分配算法小结.png\" style=\"zoom:120%;\" />\n\n\n\n","categories":["操作系统"]},{"title":"内存管理（一）","url":"/blog/2020/12/12/内存管理（一）/","content":"\n#### 本次学习要点\n\n1. 内存的基础知识\n2. 内存管理的概念\n3. 覆盖与交换\n\n<!-- more-->\n\n#### 内存的基本知识\n\n##### 什么是内存？有何作用？\n\n**内存**是用于存放数据的硬件。程序执行前**需要先放到内存中才能被CPU处理。**\n\n在多道程序环境下，系统中会有多个程序并发执行，会有多个程序的数据需要同时放到内存中。如何区分各个程序的数据在什么地方？——给内存的存储单元编地址。\n\n**内存地址**从0开始，每个地址对应一个存储单元。如果计算机按**字节**编址，则每个存储单元大小为1字节；如果**字长为16位**的计算机按**字**编址，则每个存储单元大小位1个字，也就是16个二进制位。\n\n常用的几个数量单位：\n\n```\n2^10 = 1K\n2^20 = 1M\n2^30 = 1G\n```\n\n##### 逻辑地址与物理地址\n\n编译时产生的指令只关心**相对地址**，实际放入内存中再想办法根据起始位置得到**绝对地址**。\n\neg：编译时只需确定变量x的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程*起始地址+100*即可。\n\n**相对地址**又称**逻辑地址**，**绝对地址**又称**物理地址**。\n\n##### 程序的装入和链接\n\n<img src=\"内存管理（一）\\程序的执行.png\" style=\"zoom:120%;\" />\n\n编译：由编译程序将用户源代码编译成若干个目标模块（高级语言->机器语言）。\n\n链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。\n\n装入（装载）：由装入程序将装入模块装入内存运行。\n\n##### 装入的三种方式\n\n<img src=\"内存管理（一）\\三种装入方式.png\" style=\"zoom:120%;\" />\n\n###### 绝对装入\n\n在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。\n\n绝对装入**只适用于单道程序环境**。\n\n程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。\n\n###### 静态重定位\n\n又称**可重定位装入**。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址仅从**重定位**，将逻辑地址变换为物理地址（地址变换实在装入时一次完成的）。\n\n静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**，也不能再申请内存空间。\n\n###### 动态重定位\n\n又称**动态运行时装入**。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行。**因此装入内存后所有的地址依然是逻辑地址，这种方式需要一个**重定位寄存器支持**。\n\n<img src=\"内存管理（一）\\重定位寄存器.png\" style=\"zoom:120%;\" />\n\n* 采取动态重定位时**允许程序在内存中发生移动**；\n* 可将程序分配到**不连续**的存储区中；\n* 程序运行前只需装入部分代码即可投入运行；\n* 运行期间根据需要动态申请分配内存。\n\n##### 链接的三种方式\n\n###### 静态链接\n\n在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。\n\n<img src=\"内存管理（一）\\静态链接.png\" style=\"zoom: 80%;\" />\n\n###### 装入时动态链接\n\n将各目标模块装入内存时，边装入边链接的链接方式。\n\n<img src=\"内存管理（一）\\装入时动态链接.png\" style=\"zoom:85%;\" />\n\n###### 运行时动态链接\n\n在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。\n\n<img src=\"内存管理（一）\\运行时动态链接.png\" style=\"zoom:90%;\" />\n\n##### 小结\n\n<img src=\"内存管理（一）\\内存的基本知识小节.png\" style=\"zoom:120%;\" />\n\n#### 内存管理的概念\n\n1. 操作系统负责**内存空间的分配与回收**。\n2. 操作系统需要提供某种技术从逻辑上**对内存空间进行扩充**。\n3. 操作系统需要提供**地址转换**功能，负责程序的**逻辑地址**与**物理地址**的转换。\n\n4. 操作系统需要提供**内存保护**功能。保证各进程在各自存储空间内运行，互不干扰。\n\n内存保护的两种方法：\n\n1. 在CPU中设置一对**上、下限寄存器**，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。\n2. 采用**重定位寄存器（基址寄存器）**和**界地址寄存器（限长寄存器）**进行越界检查。重定位寄存器存放进程的**起始物理地址**。界地址寄存器存放进程的**最大逻辑地址**。\n\n<img src=\"内存管理（一）\\内存保护方法二.png\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"内存管理（一）\\内存管理的概念.png\" style=\"zoom:100%;\" />\n\n#### 覆盖与交换\n\n##### 覆盖技术\n\n引入**覆盖技术**，解决**程序大小超过物理内存总和**的问题。\n\n覆盖技术的思想：将**程序分为多个段（多个模块）**。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为**一个固定区**和**若干个覆盖区**。\n\n* 需要常驻内存的段放在**固定区**中，**调入后就不再调出（除非运行结束）**。\n* 不常用的段放在**覆盖区**，**需要用到时调入内存，用不到时调出内存**。\n\n<img src=\"内存管理（一）\\覆盖技术.png\" style=\"zoom:80%;\" />\n\n*必须由程序员声明覆盖结构*，操作系统完成自动覆盖。\n\n**缺点**：对用户不透明，增加了用户编程负担，已成为历史。\n\n##### 交换技术\n\n交换技术的思想：内存空间紧张时，系统将内存中某些进程暂时**换出**外存，把外存中某些已具备运行条件的进程**换入**内存（进程在内存与磁盘间动态调度）。进行了中级调度（内存调度）：决定将哪个处于挂起状态的进程重新调入内存。\n\n1. 应该在外存（磁盘）的什么位置保存被换出的进程？\n\n   具有对换功能的操作系统中，通常把磁盘空间分为**文件区**和**对换区**两部分。**文件区**主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用**离散分配**方式；**对换区**空间只占磁盘空间的小部分，**被换出的进程数据就存放在对换区**。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用**连续分配**方式。总之，对换区的`I/O`速度比文件区的更快。\n\n2. 什么时候应该交换？\n\n   交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。\n\n3. 应该换出哪些进程？\n\n   可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。\n\n*PCB会常驻内存*，不会被换成外存。\n\n##### 小结\n\n<img src=\"内存管理（一）\\覆盖与交换小结.png\" style=\"zoom:120%;\" />\n\n","categories":["操作系统"]},{"title":"LeetCode376-摆动序列","url":"/blog/2020/12/12/LeetCode376-摆动序列/","content":"\n#### 题目描述\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。\n\n例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n\n给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。\n\n<!-- more-->\n\n<img src=\"LeetCode376-摆动序列\\376.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n可以找每次的拐点进行计数，最后再加上首尾两个点即可，比如序列$[1,7,4,9,2,5]$，有4个拐点，加上首尾一共6个点：\n\n<img src=\"LeetCode376-摆动序列\\1.png\" style=\"zoom:80%;\" />\n\n需要考虑特殊情况：\n\n1. 连续几个相同的数恰好都是拐点，如$[1,12,12,12,1]$：\n\n<img src=\"LeetCode376-摆动序列\\2.png\" style=\"zoom:80%;\" />\n\n2. 输入的序列没有拐点且全部是同一个数，如$[1,1,1]$：\n\n<img src=\"LeetCode376-摆动序列\\3.png\" style=\"zoom:80%;\" />\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        int guaidian = 0;\n        for(int i = 1; i < nums.size() - 1; ++i){\n            if(nums[i - 1] > nums[i] && nums[i + 1] > nums[i]){\n                guaidian++;\n            }\n            else if(nums[i - 1] < nums[i] && nums[i + 1] < nums[i]){\n                guaidian++;\n            }\n            // 这一步是为了去除相同的点，如果nums[i]与nums[i + 1]相同，\n            // 那么就让nums[i]等于nums[i - 1]，\n            // 可以保证nums[i + 1]与改变之后的nums[i]不同。\n            else if(i + 1 < nums.size() - 1 && nums[i] == nums[i + 1]){\n                nums[i] = nums[i - 1];\n            }\n        }\n        if(guaidian == 0){\n            auto f = unique(nums.begin(), nums.end());\n            // 输入的序列全部都是同一个数\n            if(f - 1 == nums.begin()){\n                return 1;\n            }\n        }\n        return guaidian + 2;\n    }\n};\n```\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode649-Dota2参议院","url":"/blog/2020/12/11/LeetCode649-Dota2参议院/","content":"\n#### 题目描述\n\nDota2 的世界里有两个阵营：`Radiant`(天辉)和 `Dire`(夜魇)\n\nDota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：\n\n1. `禁止一名参议员的权利`：\n\n参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。\n\n2. `宣布胜利`：\n\n如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。\n\n<!-- more-->\n\n给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。\n\n以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。\n\n假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `Radiant` 或 `Dire`。\n\n<img src=\"LeetCode649-Dota2参议院\\649.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n只想到了暴力法解决。首先记录$senate$中R和D出现次数，再用一个长与$senate$相同的$bool$数组来记录当前字母是否被**消灭**了，初始化都为0，代表没有被**消灭**。遍历$senate$，如果遇到了R，就从R开始找第一个D的位置，直到下一轮循环到它之前的位置；对于D也是一样。这样保证它们能行使自己的权力，除非自己的阵营已经获胜了。\n\n**消灭的策略是：尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴。**\n\n这样做的时间复杂度会很高，用时1452ms。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    string predictPartyVictory(string senate) {\n        int R_cnt = 0;\n        int D_cnt = 0;\n        int len = senate.size();\n        vector<bool> isUsed(senate.size(), 0);\n        for(auto &ch : senate){\n            if(ch == 'R') R_cnt++;\n            else D_cnt++;\n        }\n        while(R_cnt != 0 && D_cnt != 0){\n            for(int i = 0; i < senate.size(); ++i){\n                if(isUsed[i]) continue;\n                if(senate[i] == 'R'){\n                    for(int m = i + 1; m < i + len; ++m){\n                        int j = m % len;\n                        if(senate[j] == 'D' && isUsed[j] == false){\n                            isUsed[j] = true;\n                            D_cnt--;\n                            break;\n                        }\n                    }\n                }\n                else{\n                    for(int m = i + 1; m < i + len; ++m){\n                        int j = m % len;\n                        if(senate[j] == 'R' && isUsed[j] == false){\n                            isUsed[j] = true;\n                            R_cnt--;\n                            break;\n                        }\n                    }\n                }\n                if(R_cnt == 0 || D_cnt == 0) break;\n            }\n        }\n        return R_cnt != 0 ? \"Radiant\" : \"Dire\";\n    }\n};\n```\n\n#### 更进一步\n\n##### 思路\n\n使用一个变量来记录当前参议员之前有几个对手，从而判断自己是否被消灭了。\n\n这里使用$count>0$表示**R在D前面，R可以消灭D**，用$count<0$表示**D在R前面，D可以消灭R**。\n\n执行用时：4ms。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    string predictPartyVictory(string senate) {\n        int count = 0;\n        bool R = true, D = true;\n        while(R && D){\n            R = false;\n            D = false;\n            for(int i = 0; i < senate.size(); ++i){\n                // 如果没被完全消灭，本轮循环结束R和D都为true\n                if(senate[i] == 'R'){\n                    if(count < 0) senate[i] = '0';\n                    else R = true;\n                    // 如果被消灭了计数加一，代表抵挡了一次攻击\n                    // 如果没有被消灭，代表有多了一次消灭敌方机会\n                    // 无论如何都是需要++的，下面的--同\n                    count++;\n                }\n                else if(senate[i] == 'D'){\n                    if(count > 0) senate[i] = '0';\n                    else D = true;\n                    count--;\n                }\n            }\n        }\n        return R != 0 ? \"Radiant\" : \"Dire\";\n    }\n};\n```\n\n#### Reference\n\nhttps://leetcode-cn.com/problems/dota2-senate/solution/649-dota2-can-yi-yuan-tan-xin-suan-fa-ji-siha/","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode860-柠檬水找零","url":"/blog/2020/12/10/LeetCode860-柠檬水找零/","content":"\n#### 题目描述\n\n在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。\n\n顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。\n\n每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。\n\n注意，一开始你手头没有任何零钱。\n\n如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。\n\n<!-- more-->\n\n<img src=\"LeetCode860-柠檬水找零\\860.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n每位顾客付款只有5、10、20美元的选项：\n\n* 收到5元时记录5元零钱的个数；\n\n* 收到10元时需要找零5元并记录10元的个数；\n* 收到20元需要找零15元，但不用记录20元个数，因为不会发生找零20元的情况。\n\n*收到20元找零时应首先选10元零钱，10元用完后再选5元的。比如找零15元，如果只剩下两张5元，一张10元，先从5元开始无法刚好找零15（5+5+10）。*\n\n*需要找零的总数必须大于等于当前用到的零钱的面值，详见代码。*\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool lemonadeChange(vector<int>& bills) {\n        int map[11] = {0};\n        for(int i = 0; i < bills.size(); ++i){\n            if(bills[i] == 5){\n                map[5]++;\n            }\n            else{   \n                int val = bills[i] - 5;\n                for(int j = 10; j >= 5; j /= 2){\n                    // 需要找零的总数必须大于等于当前用到的零钱的面值，val >= j\n                    while(map[j] != 0 && val > 0 && val >= j){\n                        val -= j;\n                        map[j]--;\n                    }\n                    if(val == 0) break;\n                }\n                if(bills[i] <= 10) map[bills[i]]++;\n                if(val != 0) return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode62-不同路径","url":"/blog/2020/12/09/LeetCode62-不同路径/","content":"\n#### 题目描述\n\n一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n与此类似：[LeetCode-不同路径Ⅱ](http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/)，[LeetCode97-交错字符串](http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more)，[LeetCode174-地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)。\n\n<!-- more-->\n\n<img src=\"LeetCode62-不同路径\\62.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n机器人只能往右或者往下，考虑动态规划（如果四个方向都可以走就不可以用动态规划了，得用DFS或者BFS），对于机器人所在的行和列，都只有一条路径可以到达，初始化为1。而除此之外的位置都是可以由其上边和其左边到达，以此类推得到可以到达最终位置的路径总数。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 1));\n        for(int i = 1; i < m; ++i){\n            for(int j = 1; j < n; ++j){\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n```\n\n\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode842-将数组拆分成斐波那契序列","url":"/blog/2020/12/08/LeetCode842-将数组拆分成斐波那契序列/","content":"\n#### 题目描述\n\n给定一个数字字符串 `S`，比如 `S = \"123456579\"`，我们可以将它分成斐波那契式的序列 `[123, 456, 579]​`。\n\n形式上，斐波那契式序列是一个非负整数列表 `F​`，且满足：\n\n* `0 <= F[i] <= 2^31 - 1​`，（也就是说，每个整数都符合 32 位有符号整数类型）\n* `F.length >= 3​`；\n* 对于所有的 `0 <= i < F.length - 2​`，都有 ​`F[i] + F[i+1] = F[i+2]​`成立。\n\n**另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。**\n\n返回从 `S` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]`。\n\n<!-- more-->\n\n<img src=\"LeetCode842-将数组拆分成斐波那契序列\\842.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n不断地截取字符串，看当前字符串对应的数能不能和之前的两个数构成斐波那契序列，如果可以就继续找下一个，不行的话就进行回退。截取完最后一个字符后，如果截取到的数字的个数大于等于3，则说明此数组可以拆分成斐波那契序列。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> splitIntoFibonacci(string S) {\n        if(S.empty()) return {};\n        vector<int> buf;\n        backTrack(S, buf, 0);\n        return buf;\n    }\n    bool backTrack(string &S, vector<int> &buf, int index){\n        if(buf.size() >= 3 && index == S.size())\n            return true;\n        for(int i = index; i < S.size(); ++i){\n            // 不能以0开头\n            if(S[index] == '0' && i > index)\n                break;\n            // 取从index开始到i的字符串并转换为数字\n            string s = S.substr(index, i - index + 1);\n            long num = stol(s, 0, 10);\n            // 如果取出的数大于INT_MAX直接终止\n            if(num > INT_MAX) break;\n            int len = buf.size();\n            // 如果截取的数字大于前两个数字之后，直接终止，因为后面只会越取越大\n            if(len >= 2 && num > (long)buf[len - 1] + (long)buf[len - 2]) break;\n            // 刚开始时buf里不到2个数时，将num加入buf中\n            // 或者buf已经有2个及以上的数了，如果num等于buf的后两个数之和，加入buf中\n            if(len <= 1 || num == (long)buf[len - 1] + (long)buf[len - 2]){\n                buf.push_back(num);\n                if(backTrack(S, buf, i + 1))\n                    return true;\n                // 如果没找到，就将当前的num移除掉\n                buf.pop_back();\n            }\n        }\n        return false;\n    }\n};\n```\n\n#### Reference\n\nhttps://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/","tags":["贪心算法","回溯算法"],"categories":["LeetCode"]},{"title":"进程管理（四）-死锁","url":"/blog/2020/12/07/进程管理（四）-死锁/","content":"\n#### 本次学习要点\n\n1. 死锁的概念\n2. 预防死锁\n3. 避免死锁\n4. 死锁的检测和解除\n\n<!-- more-->\n\n#### 死锁的概念\n\n##### 什么是死锁？\n\n在并发的环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法推进的现象，就是**死锁**。发生死锁后若无外力干涉，这些进程都将无法向前推进。\n\n##### 死锁、饥饿、死循环区别\n\n<img src=\"进程管理（四）-死锁\\死锁、饥饿、死循环区别.png\" style=\"zoom:120%;\" />\n\n##### 死锁产生的必要条件\n\n产生死锁必须同时满足以下四个条件：\n\n* 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的。\n* 不剥夺条件：进程所获得的资源在未使用完之前，**不能由其他进程强行夺走**，只能主动释放。\n* 请求和保持条件：进程**已经保持了至少一个资源**，但又提出了新的资源要求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源**保持**不放。\n* 循环等待条件：存在一种进程**资源的循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。\n\n*注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁。*\n\n##### 什么时候会发生死锁？\n\n1. 对系统资源的竞争。\n2. 进程推进顺序非法。\n3. 信号量的使用不当。\n\n总之，对不可剥夺资源的不合理分配，可能导致死锁。\n\n##### 死锁的处理策略\n\n1. 预防死锁：破坏死锁产生的四个必要条件中的一个。\n2. 避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。\n3. 死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。\n\n<img src=\"进程管理（四）-死锁\\死锁的概念.png\" style=\"zoom:120%;\" />\n\n#### 预防死锁\n\n##### 破坏互斥条件\n\n如果把只能互斥使用的资源改造成允许共享使用，则系统不会进入死锁状态。如：`SPOOLing`技术。\n\n缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，**很多时候都无法破坏互斥条件**。\n\n##### 破坏不剥夺条件\n\n方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。\n\n方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。\n\n缺点：\n\n1. 实现复杂。\n2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法只适合已保存和恢复状态的资源，如CPU。\n3. 反复的申请和释放资源会增加系统开销，降低系统吞吐量。\n4. 若采用方案一，只要暂时得不到某个资源，之前获得的资源都要放弃，以后再重新申请。如果持续发生这种情况，会导致进程饥饿。\n\n##### 破坏请求和保持条件\n\n可以采用**静态分配方法**，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行后，资源归其所有，该进程就不会再请求别的资源了。\n\n缺点：有些资源可能使用很短的时间，如果进程执行期间一直保持所有资源，就会造成严重的资源浪费，资源利用率极低。另外也可能导致某些进程饥饿。\n\n##### 破坏循环等待条件\n\n可采用**顺序资源分配法**，给系统中的资源编号，规定每个进程**必须按编号递增的顺序请求资源**，同类资源（即编号相同的资源）一次申请完。\n\n原理：一个进程只有占有小编号的资源时才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。\n\n缺点：\n\n1. 不方便增加新的设备，因为可能需要重新分配所有的编号。\n2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源的浪费。\n3. 必须按规定的次序申请资源，用户编程麻烦。\n\n<img src=\"进程管理（四）-死锁\\预防死锁.png\" style=\"zoom:120%;\" />\n\n#### 避免死锁\n\n不破坏死锁的必要条件，而是在在资源动态分配的过程中，防止系统进入不安全状态。\n\n##### 系统安全状态\n\n指系统能按某种推进顺序（P1,P2,...,Pn）为每个进程Pi分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称P1,P2,...,Pn为安全序列，若系统无法找到一个安全序列，则称系统处于不安全状态。\n\n并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。\n\n##### 银行家算法\n\n数据结构：\n\n* 长度为m的一维数组Avaliable表示还有多少可用资源。\n* n*m矩阵Max表示各进程对资源的最大需求数。\n* n*m矩阵Allocation表示已经给各进程分配了多少资源。\n* Max - Alllcation = Need 矩阵表示各进程最多还需要多少资源。\n* 长度为m的一维数组Request表示进程此次申请的各种资源数。\n\n银行家算法步骤：\n\n1. 检查此次申请是否超过了之前声明的最大需求数。\n2. 检查此时系统剩余的可用资源是否还能满足这次请求。\n3. 试探着分配，更改各数据结构。\n4. 用安全性算法检查此次分配是否会导致系统进入不安全状态。\n\n安全性算法步骤：\n\n检查当前的剩余可用资源能否满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程只有的资源全部回收。\n\n不断重复上述过程，看最终是否能让所有进程都加入安全序列。\n\n*系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。*\n\n**举例（后面更新）：**\n\n#### 死锁的检测和解除\n\n当可能发生死锁时，系统应当提供两个算法：\n\n1. 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。\n2. 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。\n\n##### 死锁的检测\n\n为了能对系统是否已发生了死锁进行检测，必须：\n\n1. 用**某种数据结构**来保存资源的请求和分配信息。\n2. 提供**一种算法**，利用上述信息来检测系统是否已进入死锁状态。\n\n<img src=\"进程管理（四）-死锁\\死锁的检测.png\" style=\"zoom:120%;\" />\n\n<img src=\"进程管理（四）-死锁\\死锁的检测1.png\" style=\"zoom:80%;\" />\n\n检测死锁的算法：\n\n1. 在资源分配图中，找出既不阻塞又不是孤点的进程Pi (即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中己有空闲资源数景。如下图中，R1没有空闲资源，R2有 —个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中P1是满足这一条件的进程结点，于是将P1的所有边消去。\n2. 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。\n\n<img src=\"进程管理（四）-死锁\\死锁的检测2.png\" style=\"zoom:80%;\" />\n\n**死锁定理**：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统死锁。\n\n##### 死锁的解除\n\n—旦检测出死锁的发生，就应该立即解除死锁。\n补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程 。\n解除死锁的主要方法有：\n\n1. 资源剥夺法。挂起（哲时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。\n\n2. 撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能己经运行了很长时间，己经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。\n3. 进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程历史信息，设罝还原点。\n\n如何决定”对谁动手“？\n\n1. 进程优先级：牺牲优先级低的。\n2. 已执行多长时间：牺牲执行时间短的。\n3. 还要多久完成：让快结束的优先获得资源。\n4. 进程已经使用了多少资源：拥有更多资源的先牺牲。\n5. 进程是交互式的还是批处理式的？：先牺牲批处理式的。\n\n<img src=\"进程管理（四）-死锁\\总结.png\" style=\"zoom:120%;\" />","tags":["死锁"],"categories":["操作系统"]},{"title":"进程管理（三）","url":"/blog/2020/12/04/进程管理（三）/","content":"\n#### 本次学习要点\n\n1. 进程同步、进程互斥\n2. 进程互斥软件/硬件实现方法\n3. 信号量机制及用其实现进程同步等\n4. 管程\n\n<!-- more-->\n\n#### 进程同步、进程互斥\n\n##### 进程同步\n\n进程异步性：指各并发执行的进程以各自独立的、不可预知的速度向前推进。\n\n进程同步：指为完成某种任务而建立的两个或多个进程，这些进程因为需要再某些位置上协调它们的工作次序而产生制约关系。\n\n##### 进程互斥\n\n临界资源：一个时间段内只允许一个进程使用的资源。如摄像头、打印机等。对临界资源的访问必须**互斥**的进行。\n\n进程互斥：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。\n\n对临界资源的互斥访问，可以在逻辑上分为如下四个部分：\n\n```c\ndo{\n\tentry section; // 进入区\n    critical section; // 临界区\n    exit section; // 退出区\n    remainder section;// 剩余区\n}while(true)\n```\n\n1. 进入区：检查是否可以进入临界区，若可以进入，则设置正在访问临界资源的标志（上锁），防止其他进程同时进入临界区。\n2. 临界区：访问临界资源的代码。\n3. 退出区：解除正在访问临界资源的标志（解锁）。\n4. 剩余区：做其他处理。\n\n*临界区时进程中访问临界资源的代码段。*\n\n*进入区和退出区是负责实现互斥的代码段。*\n\n实现对临界资源的互斥访问需要遵循以下四项原则：\n\n1. 空闲让进。\n2. 忙则等待。\n3. 有限等待，请求访问的进程在有限时间内进入临界区（保证不会饥饿）。\n4. 让权等待，进程不能进入临界区时，应立即释放处理机，防止进程忙等待。\n\n<img src=\"进程管理（三）\\同步与互斥.png\" style=\"zoom:120%;\" />\n\n#### 进程互斥软件/硬件实现方法\n\n##### 软件实现方法\n\n###### 单标志法\n\n实现思想：两个进程在**访问完临界区后**会把临界区的使用权转交给另一个进程，**每个进程进入临界区的权限只能被另一个进程赋予**。\n\n主要问题：违背**空闲让进**原则。\n\n###### 双标志先检查\n\n实现思想：**设置**一个布尔型数组`flag[]`，数组中各个元素用来**标记各进程想要进入临界区的意愿**，比如`flag[0]=true`表示着0号进程P0想要进入临界区。每个进程在进入临界区之前先看有没有别的进程想要进入临界区，没有就将自身的`flag[i]`置为`true`，之后开始访问临界区。\n\n主要问题：违反**忙则等待**原则。原因在于进入区的检查和上锁不是一气呵成的，在**检查后，上锁前**可能发生进程切换。\n\n###### 双标志后检查\n\n实现思想：对比双标志先检查法，先进行上锁再进行检查。\n\n主要问题：虽然解决了**忙则等待**，但是违背了**空闲让进**和**有限等待**原则，会因各进程都长期无法访问临界资源而产生**饥饿**现象。\n\n###### Peterson算法\n\n实现思想：对比双标志后检查法，如果双方都争着想进入临界区，可以让进程主动让对方先使用临界区。\n\n主要问题：违背了**让权等待**原则。\n\n<img src=\"进程管理（三）\\进程互斥的软件实现方法.png\" style=\"zoom:120%;\" />\n\n##### 硬件实现方法\n\n###### 中断屏蔽方法\n\n实现思想：利用”开/关中断指令“实现。\n\n```\n>>>\n关中断；// 关中断后不允许当前进程被中断，也必然不会发生进程切换\n临界区；\n开中断；// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区\n>>>\n```\n\n* 优点：简单、高效。\n* 缺点：不适用于对处理机；只适用于操作系统内核进程，不适用于用户进程。\n\n###### TestAndSet(TS指令/TSL指令)\n\n简称TS指令，也称TestAndSetLock指令，或TSL指令。\n\n主要思想：使用硬件实现，将上锁和检查操作变为原子操作，执行过程中不允许被中断。\n\n* 优点：实现简单，适用于多处理机环境。\n* 缺点：不满足**让权等待**原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。\n\n###### Swap指令(XCHG指令)\n\n也叫Exchange指令，或者XCHG指令。\n\n逻辑上与TS指令相同。\n\n<img src=\"进程管理（三）\\进程互斥的硬件实现方法.png\" style=\"zoom:120%;\" />\n\n#### 信号量机制\n\n信号量机制时一种功能较强的机制，可以用来解决互斥和同步问题，它只能被两个标准的原语`wait(S)`和`signal(S)`访问，简称**P操作**和**V操作**。\n\n信号量其实就是一个变量，可以是一个整数，也可以是更复杂的记录型变量，可以用一个信号量来**表示系统中某种资源的数量**。\n\n##### 整型信号量\n\n用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。\n\n```c\nint S = 1; // 表示当前系统中可用的打印机数\nvoid wait(int S){ // wait原语，相当于进入区\n    while(S <= 0); // 资源不够，等待\n    S = S - 1; // 资源够，占用一个资源\n}\nvoid signal(int S){ // signal原语，相当于退出区 \n    S = S + 1; // 使用完资源后，在退出区释放资源\n}\n```\n\n1. 与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。\n2. **检查**和**上锁**一气呵成，避免并发、异步导致的问题。\n3. 存在问题：不满足**让权等待**原则，会发生**忙等**。\n\n##### 记录型信号量\n\n用记录型数据结构表示的信号量。\n\n```c\n/*记录型信号量的定义*/\ntypedef struct{\n    int value; // 剩余资源数\n    struct process *L;// 等待队列\n} semaphore;\n\n```\n\n```c\n/*某进程需要资源时，通过wait原语申请*/\nvoid wait(semaphore S){\n    S.value--;\n    // 如果剩余资源不够，使用block原语使进程由运行态进入阻塞态\n    // 并将其挂到信号量S的等待队列（即阻塞队列）中\n    // 遵循了让权等待原则，不会出现忙等\n    if(S.value < 0){\n\t\tblock(S.L);\n    }\n}\n```\n\n```c\n/*进程使用完资源后，通过signal原语释放*/\nvoid signal(semaphore S){\n    S.value++;\n    // 释放完资源后，若还有别的进程在等待这种资源\n    // 则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态\n    if(S.value <= 0){\n\t\twakeup(S.L);\n    }\n}\n```\n\n#####  用信号量机制实现进程互斥、同步、前驱关系\n\n###### 进程互斥\n\n1. 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）。\n2. 设置**互斥信号量**mutex，**初始值为1**。\n3. 在临界区之前执行P(mutex)。\n4. 在临界区之后执行V(mutex)。\n\n*注意：对不同的临界资源需要设置不同的互斥信号量，P、V操作必须成对出现*。\n\n###### 进程同步\n\n1. 分析什么地方需要实现”同步关系“，即必须保证”一前一后“执行的两个操作（或两句代码）。\n2. 设置**同步信号量**S，**初始值为0**。\n3. 在\"前操作\"之后执行V(S)。\n4. 在”后操作“之前执行P(S)。\n\n###### 信号量机制实现前驱关系\n\n其实每一对前驱关系都是一个进程同步问题（需要保证一前一后操作）。\n\n1. 要为每一对前驱关系各设置一个同步变量。\n2. 在”前操作“之后对相应的同步变量执行V操作。\n3. 在”后操作“之前对相应的同步变量执行P操作。\n\n<img src=\"进程管理（三）\\信号量实现同步与互斥.png\" style=\"zoom:120%;\" />\n\n常见的使用场景\n\n* 生产者消费者问题\n* 多生产者—多消费者模型\n* 吸烟者问题\n* 读者—写者问题\n* 哲学家进餐问题\n\n#### 管程\n\n引入管程的原因：信号量机制编写程序困难，易出错而导致死锁。\n\n管程是一种特殊的软件模块，由这些部分组成：\n\n1. 局部于管程的共享数据结构说明。\n2. 对该数据结构进行操作的一组过程（或函数）。\n3. 对局部于管程的共享数据设置的一组过程。\n4. 管程的名称。\n\n基本特征：\n\n1. 局部于管程的数据只能被局部于管程的过程所访问。\n2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。\n3. **每次仅允许一个进程在管程内执行某个内部过程，即同一时刻只有一个进程在管程内执行某个函数。**\n\n<img src=\"进程管理（三）\\管程.png\" style=\"zoom:120%;\" />\n\n","categories":["操作系统"]},{"title":"C++顺序容器","url":"/blog/2020/11/25/C-顺序容器/","content":"\n#### 本次学习要点\n\n1. 顺序容器概述\n2. 容器库概览\n3. 顺序容器操作\n4. `vector`对象是如何增长的\n5. 额外的`string`操作\n6. 容器适配器\n\n<!-- more-->\n\n#### 顺序容器概述\n\n<img src=\"C-顺序容器\\概述.png\" style=\"zoom:120%;\" />\n\n选择容器的基本原则：\n\n* 尽量使用`vector`。\n* 要求随机访问元素，使用`vector`或者`deque`。\n* 要求在中间插入或删除元素，使用`list`或者`forward_list`。\n* 要求在首尾插入或删除元素且不会在中间插入或者删除，使用`deque`。\n* 如果程序要读取输入，且必须在中间插入，使用`list`，随后拷贝到`vector`。\n\n#### 容器库概览\n\n<img src=\"C-顺序容器\\容器操作.png\" style=\"zoom:120%;\" />\n\n<img src=\"C-顺序容器\\容器操作1.png\" style=\"zoom:120%;\" />\n\n##### 迭代器\n\n`forward_list`迭代器不支持递减运算符。\n\n###### 迭代器范围\n\n**左闭合区间**：`[begin, end)`，表示范围自`begin`开始，于`end`之前结束。\n\n* 如果`begin`与`end`相等，则范围为空。\n* 如果`begin`与`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素。\n* 可以对`begin`递增若干次，使得`begin==end`。\n\n##### 容器类型成员\n\n```cpp\nlist<string>::iterator iter;\nvector<int>::difference_type count\n```\n\n##### begin与end成员\n\n```cpp\nlist<string> a = {\"abc\", \"bcd\", \"cde\"};\nauto it1 = a.begin(); // list<string>::iterator\nauto it2 = a.rbegin(); // list<string>::reverse_iterator\nauto it3 = a.cbegin(); // list<string>::const_iterator\nauto it4 = a.crbegin(); // list<string>::const_reverse_iterator\n```\n\n##### 容器定义及初始化\n\n<img src=\"C-顺序容器\\初始化.png\" style=\"zoom:120%;\" />\n\n**array的使用**\n\n```cpp\narray<int, 10> ia1; // 10个默认初始化的int\narray<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9};\narray<int, 10> ia3 = {42}; // ia3[0]为42， 其余为0\narray<int, 10> ia4 = {}; // 初始化为0\n```\n\n##### 赋值和swap\n\n<img src=\"C-顺序容器\\assign.png\" style=\"zoom:120%;\" />\n\n```cpp\n// assign第一种用法\nlist<string> names;\nvector<const char*> oldstyle;\nnames = oldstyle; // 错误，容器类型不匹配\n// 正确，可以将const char*转为string\nnames.assign(oldstyle.cbegin(), oldstyle.cend()); \n// assign的第二种用法\nlist<string> slist1(1); // 1个元素，为空string\nslist1.assign(10, \"Hiya!\"); // 10个元素，每个都是\"Hiya\"\n```\n\n###### 使用swap\n\nswap操作交换两个相同类型容器的内容\n\n```cpp\nvector<string> svec1(10);\nvector<string> svec2(24);\nswap(svec1, svec2);\n// 元素本身并未交换，swap只是交换了两个容器的内部数据结构\n```\n\n**除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间完成**。**对array会真正交换它们的元素**。\n\n##### 容器大小操作\n\n`size`：返回容器中元素数目。\n\n`empty`：容器是否为空。\n\n`max_size`：返回一个大于或等于该类型容器所能容纳的最大元素数的值。\n\n注：`forward_list`不支持`size`。\n\n##### 关系运算符\n\n```cpp\nvector<int> v1 = {1,3,5,7,9,12};\nvector<int> v2 = {1,3,9};\nvector<int> v3 = {1,3,5,7};\nvector<int> v4 = {1,3,5,7,9,12};\n// v1 < v2 true，在v1[2] < v2[2]\n// v1 < v3 false，所有元素相等，但是v3元素更少\n// v1 == v4 true，元素对应相等且长度相同\n// v1 == v2 false，v2元素比v1少\n```\n\n#### 顺序容器操作\n\n<img src=\"C-顺序容器\\添加元素.png\" style=\"zoom:120%;\" />\n\n##### 使用emplace操作\n\n当调用一个`emplace`成员函数时，将参数传递给元素类型的构造函数。`emplace`成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：\n\n```cpp\nc.emplace_back(\"978-0590353403\", 24, 15.99);\nc.push_back(Sales_data(\"978-0590353403\", 24, 15.99));\n// 错误\nc.push_back(\"978-0590353403\", 24, 15.99);\n```\n\n##### 访问元素\n\n<img src=\"C-顺序容器\\访问元素.png\" style=\"zoom:120%;\" />\n\n##### 删除元素\n\n<img src =\"C-顺序容器\\删除元素.png\" style=\"zoom:120%;\" />\n\n##### 改变容器大小\n\n<img src =\"C-顺序容器\\改变容器大小.png\" style=\"zoom:120%;\" />\n\n##### 容器操作可能使迭代器失效\n\n向容器中添加/删除元素可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。\n\n在向容器添加元素后：\n\n* 容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但插入位置之后的迭代器、指针和引用将会失效。\n* 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，指向存在元素的引用和指针不会失效。\n* 对于`list`和`forward_list`，指向容器的迭代器、指针和引用仍有效。\n\n删除元素时，指向被删除元素的迭代器、指针和引用都会失效。\n\n* 对于`list`和`forward_list`，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针都有效。\n* 对于`deque`，在首尾之外的任何位置删除元素，指向被删除元素外其他元素的迭代器、指针或引用也会失效。删除尾，尾后迭代器会失效，但其他迭代器、引用和指针不受影响；删除首，也不受影响。\n* 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍有效。\n\n*注意：当我们删除元素时，尾后迭代器总会失效*。\n\n#### vector对象是如何增长的\n\n`vector`会分配比新的空间需求更大的内存空间，作为备用。\n\n##### 管理容量的成员函数\n\n<img src=\"C-顺序容器\\管理vector.png\" style=\"zoom:120%;\" />\n\n*`reserve`不改变容器中元素的数量，只影响`vector`预先分配多大的内存空间。*\n\n#### 额外的string操作\n\n<img src=\"C-顺序容器\\额外string.png\" style=\"zoom:120%;\" />\n\n这些构造函数接受一个`string`或一个`const char*`参数，还接受（可选的）指定拷贝多少个字符的参数。\n\n从`const char*`创建`string`时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。且：\n\n* 如果同时传一个计数值，就不必以空字符结尾。\n* 如果未传递计数值且数组未以空字符结尾，或者计数值大于数组大小，则构造函数未定义。\n\n从`string`拷贝时，可选开始位置和计数值。位置大于`size`，构造函数抛出一个*out of range*异常。计数值代表从当前位置拷贝这么多个字符，最多拷贝到`string`结尾。\n\n##### sbustr\n\n<img src=\"C-顺序容器\\substr.png\" style=\"zoom:120%;\" />\n\n##### aapend和replace\n\n1. `append`操作是在`string`末尾进行插入操作的一种简写形式。\n\n```cpp\ns.append(\"123abc\"); // 将\"123abc\"追加在s之后\n```\n\n2. `replace`操作是调用`erase`和`insert`的一种简写形式。\n\n```cpp\ns.erase(11, 3);\ns.insert(11, \"5th\");\n// 等价于\ns.replace(11, 3, \"5th\");\n```\n\n还有`assign`：\n\n```cpp\ns.assign(arg); // 将s中字符替换未arg，返回指向s的引用\n```\n\n`assign`总是替换`string`中所有内容。\n\n##### string的搜索操作\n\n<img src=\"C-顺序容器\\string_find.png\" style=\"zoom:120%;\" />\n\n<img src=\"C-顺序容器\\string_find_form.png\" style=\"zoom:120%;\" />\n\n*`string`搜索返回`string::size_type`类型，是无符号的，因此用`int`表示不是很好的选择。*\n\n##### compare函数\n\n<img src=\"C-顺序容器\\compare.png\" style=\"zoom:120%;\" />\n\n##### 数值转换\n\n```cpp\nstring s = \"pi = 3.14\";\n// 转换s中以数字开始的第一个字串，d=3.14\nd = stod(s.substr(s.find_first_of(\"+-.0123456789\")));\n```\n\n*如果`string`不能转换为数值，抛出`invalid_argument`异常。如果转换的数值无法用任何类型表示，则抛出一个`out_of_range`异常*。\n\n#### 容器适配器\n\n**适配器**是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。比如：`stack`、`queue`、`priority_queue`。\n\n<img src=\"C-顺序容器\\容器适配器.png\" style=\"zoom:120%;\" />\n\n每个适配器都定义了两个构造函数：\n\n1. 默认构造函数创建一个空对象，接受一个容器的构造函数拷贝来初始化适配器。\n\n```cpp\n// 假定dep使一个deque<int>\nstack<int> stk(dep); // 从deq拷贝元素到stk\n```\n\n2. 默认情况下，`stack`和`queue`基于`deque`实现，`priority_deque`基于`vector`。创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。\n\n```cpp\n// 基于vector实现空栈\nstack<string, vector<string>> str_stk;\n// str_stk2在vector上实现，初始化时保存svec的拷贝\nstack<string, vector<string>> str_stk2(svec);\n```\n\n##### 栈适配器\n\n`stack`类型定义在`stack`头文件中。\n\n<img src=\"C-顺序容器\\stack.png\" style=\"zoom:120%;\" />\n\n##### 队列适配器\n\n`queue`和`priority_queue`适配器定义在`queue`头文件中。\n\n<img src=\"C-顺序容器\\queue.png\" style=\"zoom:120%;\" />\n\n<img src=\"C-顺序容器\\queue1.png\" style=\"zoom:120%;\" />\n\n","categories":["C++"]},{"title":"LeetCode148-排序链表","url":"/blog/2020/11/22/LeetCode148-排序链表/","content":"\n#### 题目描述\n\n给你链表的头结点 `head` ，请将其按 升序 排列并返回 排序后的链表 。\n\n**进阶**：\n\n你可以在`O(nlogn)`时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n\n本题可与[LeetCode147-对链表进行插入排序](http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more)，[LeetCode143-重排链表](http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/)共同学习。\n\n<!-- more-->\n\n<img src=\"LeetCode148-排序链表\\示例.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n题目要求用`O(nlogn)`的时间复杂度来进行排序，所以不能用[LeetCode147-对链表进行插入排序](http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more)的方法来进行解，所以采用归并排序的思想对链表进行排序。\n\n使用归并排序首先得找到链表的中间节点，找到中间节点，根据中间节点的位置将链表分为两个部分，再进行归并排序。**中间节点在链表前半部分的末尾，将链表拆开后，要让中间节点的下一个指向空**，再分别对两个链表进行归并排序，最后再合并两个排序好的链表，如下：\n\n```cpp\nListNode* __mergeSort(ListNode *node){\n    // 如果节点为空或只有一个节点，返回当前节点即可\n    if(!node || !node->next)\n        return node;\n    ListNode *fast = node;\n    ListNode *slow = node;\n    while(fast->next && fast->next->next){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    ListNode *l2 = slow->next;\n    slow->next = nullptr;\n\n    ListNode* left = __mergeSort(node);\n    ListNode* right = __mergeSort(l2);\n    return __merge(left, right);\n}\n```\n\n合并的操作需要创建一个新的链表，新的链表根据两个链表的值建立。如果$l1$的值小于$l2$，那么将插入$l1$新的链表中，同时$l1$移动到它的下一个节点；否则将$l2$插入新的链表中，同时$l2$移动到它的下一个节点。插入操作结束后，再将新链表向后移动一个节点（也就是新插入的节点）。**如果两个链表长度不一样（两个链表长度最多差一个），还要判断插入操作结束后哪个链表不为空，如果不为空，它就是新链表的最后一个节点**。\n\n```cpp\nListNode* __merge(ListNode *l1, ListNode *l2){\n    ListNode *dummyNode = new ListNode(-1);\n    ListNode *cur = dummyNode;\n\n    while(l1 && l2){\n        if(l1->val < l2->val){\n            cur->next = l1;\n            l1 = l1->next;\n        }\n        else{\n            cur->next = l2;\n            // cout << l2->val;\n            l2 = l2->next;\n        }\n        cur = cur->next;\n    }\n    cur->next = l1 != nullptr ? l1 : l2;\n    return dummyNode->next;\n}\n```\n\n#### 代码\n\n```cpp\n// 主函数\nListNode* sortList(ListNode* head) {\n    return __mergeSort(head);\n}\n// 其余两个函数\nListNode* __mergeSort(ListNode *node);\nListNode* __merge(ListNode *l1, ListNode *l2);\n```\n\n\n\n","tags":["链表","归并排序"],"categories":["LeetCode"]},{"title":"LeetCode147-对链表进行插入排序","url":"/blog/2020/11/21/LeetCode147-对链表进行插入排序/","content":"\n#### 题目描述\n\n插入排序算法：\n\n1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。\n2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。\n3. 重复直到所有输入数据插入完为止。\n\n本题可与[LeetCode143-重排链表](http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/)，[LeetCode148-排序链表](http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/)共同学习。\n\n<!-- more-->\n\n<img src=\"LeetCode147-对链表进行插入排序\\description.png\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"LeetCode147-对链表进行插入排序\\示例.png\" style=\"zoom:100%;\" />\n\n#### 思路\n\n首先，使用一个指针记录下一个要进行排序的节点；对于当前节点，从头开始寻找插入位置，然后将当前节点插入。\n\n那么需要保存插入位置的前一个节点和后一个节点，从头开始，如果当前节点的值大于后一个节点，那么同时将两个节点后移，否则直接进行插入即可。\n\n最后再将当前节点更新为下一个要进行排序的节点。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        if(!head || !head->next) return head;\n        ListNode *dummyNode = new ListNode(0);\n        ListNode *node = head;\n        while(node){\n            ListNode *next = node->next;\n            // 对排好序的链表进行插入\n            ListNode *pre = dummyNode;\n            ListNode *sorted = dummyNode->next;\n            while(sorted){\n                // 当前点大于后一个点\n                if(node->val > sorted->val){\n                    pre = sorted;\n                    sorted = sorted->next;\n                }\n                else break;\n            }\n            // 此时当前点小于等于最后一个点，可以进行插入\n            // 此时sorted之前的点都已经排好序了\n            pre->next = node;\n            node->next = sorted;\n\n            node = next;\n        }\n        return dummyNode->next;\n    }\n};\n```\n\n","tags":["链表","插入排序"],"categories":["LeetCode"]},{"title":"C++标准库-I/O库","url":"/blog/2020/11/21/C-标准库-I-O库/","content":"\n#### 本次学习要点\n\n1. I/O类\n2. 文件输入输出\n3. string流\n\n<!-- more-->\n\n#### I/O类\n\n`iostream`定义了用于读写流的基本类型。\n\n`fstream`定义了用于读写命名文件的类型。\n\n`sstream`定义了用于读写内存`string`对象的类型。\n\n<img src=\"C-标准库-I-O库\\io类.png\" style=\"zoom:120%;\" />\n\n`I/O`对象无拷贝或赋值，传递和引用不能是`const`的。\n\n##### 条件状态\n\n<img src=\"C-标准库-I-O库\\条件状态.png\" style=\"zoom:120%;\" />\n\n上表是`I/O`类所定义的一些函数和标志，可以访问和操作流的**条件状态**。\n\n由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态最简单的方法是将它当作一个条件使用：\n\n```cpp\nwhile(cin >> word)\n\t// ok：读操作成功\n```\n\n##### 刷新输出缓冲区\n\n```cpp\ncout << \"hi!\" << endl;  // 输出hi和换行，然后刷新缓冲区\ncout << \"hi!\" << flush; // 输出hi后直接刷新缓冲区\ncout << \"hi!\" << ends;  // 输出hi和一个空字符再刷新缓冲区\n```\n\n#### 文件输入输出\n\n头文件`fstream`定义了三个类型来支持文件IO：\n\n1. **ifstream**从一个给定文件读取数据。\n2. **ofstream**向一个给定文件写入数据。\n3. **fstream**可以读写给定文件。\n\n<img src=\"C-标准库-I-O库\\fstream.png\" style=\"zoom:120%;\" />\n\n##### 使用文件流对象\n\n创建文件流对象时，可以提供文件名（可选）。\n\n```cpp\nifstream in(ifile); // 构造一个ifstream并打开给定文件\nofstream out; // 输出文件流未关联到任何文件\n```\n\n##### 成员函数open和close\n\nopen用来判断文件是否打开成功，一旦打开成功，它就保持与对应文件的关联，对于一个已经打开的文件流调用open会失败，直到使用close关闭文件，成功关闭后可以打开新的文件。\n\n```cpp\nifstream in(ifile);\nin.close();\nin.open(ifile + \"2\");\n```\n\n当一个`fstream`对象离开其作用域时，与之关联的文件会自动关闭。\n\n##### 文件模式\n\n<img src=\"C-标准库-I-O库\\文件模式.png\" style=\"zoom:120%;\" />\n\n指定文件模式有如下限制（部分）：\n\n* 只可以对`ofstream/fstream`对象设定out模式。\n* 只可以对`ifstream/fstream`对象设定in模式。\n\n在未指定文件模式时，与`ifstream`关联的文件默认以in模式打开；与`ofstream`关联的文件默认以out模式打开；与`fstream`关联的文件默认以in和out模式打开。\n\n默认情况下，**以out模式打开文件会丢去已有数据**。阻止一个`ofstream`清空给定文件内容的方法是同时指定app模式：\n\n```cpp\n// 在这几条语句中，file1都被截断\n// 隐含以输出模式打开文件并截断文件\nofstream out(\"file1\");\n// 隐含地截断文件\nofstream out1(\"file1\", ofstream::out);\nofstream out2(\"flie2\", ofstream::out | ofstream::trunc);\n// 为了保留文本内容，必须显示指定app模式\n// 隐含为输出模式\nofstream app(\"file1\", ofstream::app);\nofstream app1(\"file2\", ofstream::out | ofstream::app);\n```\n\n*保留被`ofstream`打开地文件中已有数据地唯一方法是显示指定app或in模式（17.5.3节，676页）*。每次调用`open`时都会确定文件模式。\n\n#### string流\n\n`istringstream`从`string`中读取数据。\n\n`ostringstream`向`string`中写入数据。\n\n`stringstream`既可从`string`中读数据也可以向`string`中写数据。\n\n<img src=\"C-标准库-I-O库\\stringstream.png\" style=\"zoom:120%;\" />\n\n##### 使用istringstream\n\n当我们的工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词，通常可以用`istringstream`。\n\n假如一个文件，列出了一些人和他们所拥有的电话号码（一个或多个），输入文件可能如下：\n\n<img src=\"C-标准库-I-O库\\输入文件.png\"  />\n\n定义一个类描述输入数据：\n\n```cpp\nstruct PersonInfo{\n\tstring name;\n\tvector<string> phones;\n};\n```\n\n使用程序读取数据文件如下：\n\n```cpp\nstring line, word; // 分别保存来自输入的一行和单词\nvector<PersonInfo> people;\n// 逐行从输入读取数据，直到cin遇到文件尾（或其他错误）\nwhile(getline(cin, line)){\n\tPersonInfo info;\n    // 将记录绑定到刚输入的行\n    istringstream record(line);\n    record >> info.name;\n    while(record >> word)\n        info.phones.push_back(word);\n    people.push_back(info);\n}\n```\n\n##### 使用ostringstream\n\n当我们逐步构造输出，最后一起进行打印时，可以使用ostringstream。对上一节的例子，逐个验证电话号码并将其格式化。将有效的号码输出到一个新文件中；对于无效的号码不输出到文件中，并打印一条包含人名和无效号码的错误信息。\n\n```cpp\nfor(const auto &entry : people){\n    ostringstream formatted, badNums;\n    for(const auto &nums : entry.phones){\n        // 如果号码无效，将数的字符串写入badNums\n        if(!valid(nums)){\n            badnums << \" \" << nums;\n        }\n        // 号码有效，将格式化的字符串写入formatted\n        else{\n            formatted << \" \" format(nums);\n        }  \n    }\n    // 没有错误的数，打印名字和格式化的数\n    if(badNums.str().empty())\n        os << entry.name << \" \" << formatted.str() << endl;\n    // 否则，打印名字和错误的数\n    else\n        cerr << \"input error:\" << entry.name  \n        << \"invalid number(s)\" << badNums.str() << endl;\n}\n```\n\n假设两个函数`valid`和`format`已知，分别完成电话号码的验证和格式化功能。","categories":["C++"]},{"title":"进程管理（二）","url":"/blog/2020/11/17/进程管理（二）/","content":"\n#### 本次学习要点\n\n1. 处理机调度概念、层次\n2. 进程调度的时机/切换与过程/方式\n3. 调度算法的评价指标\n4. 非交互性调度算法\n5. 交互性调度算法\n\n<!-- more-->\n\n#### 处理机调度概念、层次\n\n**处理机调度**是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理及分配给它运行，以实现进程并发的执行。\n\n**调度的三个层次**\n\n1. 高级调度（作业调度）\n   * 按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使他（们）获得竞争处理机的权利。\n   * **作业调入一次（建立PCB），调出一次（撤销PCB）。**\n   * 高级调度主要是指调入的问题，只有调入的时机需要操作系统来确定，调出必然是作业结束时刻。\n   * 执行频率低。\n\n2. 中级调度（内存调度）\n\n   * 引入虚拟存储技术后，可将在暂时不能运行的进程调至外存等待，此时状态称为**挂起态。**\n   * PCB不会调到外存，而是常驻内存，被挂起的进程PCB会被放到挂起队列中。\n   * 中级调度就是决定将哪个处于挂起态的进程重新调入内存。\n   * 一个进程可能会被多次调出、调入内存，中级调度频率高于高级调度。\n\n   * 进程的挂起态与七状态模型。\n\n   <img src=\"进程管理（二）\\7states.png\"  />\n\n3. 低级调度（进程调度）\n\n   * 按照某种方法从就绪队列中选取一个进程，将处理机分配给他。\n   * 是**最基本的一种调度。**\n   * 频率很高，一般几十毫秒一次。\n\n **三层调度的联系、对比**\n\n<img src=\"进程管理（二）\\三层调度的联系及对比.png\"  />\n\n*调度算法要研究的问题*：**高级调度、进程调度**\n\n#### 进程调度的时机/切换与过程/方式\n\n##### 进程调度的时机\n\n<img src=\"进程管理（二）\\进程调度的时机.png\"  />\n\n需要注意：\n\n1. 进程在**操作系统内核程序临界区**中*不能*进行调度与切换\n   * 内核程序临界区时用来访问某种内核数据结构的（如进程的就绪队列，由各就绪进程的PCB组成）。\n   * 内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。\n2. 进程处于**临界区**时*可以*进行处理机调度\n   * 如打印机在打印完成之前，进程一直处于临界区内并将临界资源上锁，但打印机是慢速设备，如果此时不允许进程调度会导致CPU一直空闲。\n   * 普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，因此普通临界区可以进行调度和切换。\n\n##### 进程调度的切换与过程\n\n*狭义的进程调度*指的是从就绪队列中选中一个要运行的进程，可以是刚刚被暂停的进程，也可能是另外一个进程，后者需要进程切换。\n\n*广义的进程调度*指包含了选择一个进程和进程切换两个步骤。\n\n*进程切换*是指一个进程让出处理机，由另一个进程占用处理机的过程。进程切换的过程主要完成了：\n\n1. 对原来运行进程各种数据的保存。\n2. 对新的进程各种数据的恢复。\n\n**注意**：进程切换时由代价的，过于频繁的进行进程调度、切换，会使整个系统的效率降低。\n\n##### 进程调度的方式\n\n1. 非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。\n2. 剥夺调度方式，又称抢占方式。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合与分时操作系统、实时操作系统。\n\n#### 调度算法的评价指标\n\n<img src=\"进程管理（二）\\调度算法的评价指标.png\"  />\n\n##### CPU利用率\n\n$$\n利用率=\\frac{忙碌的时间}{总时间}\n$$\n\n##### 系统吞吐量\n\n单位时间内完成作业的数量。\n$$\n系统吞吐量=\\frac{总共完成了多少道作业}{总共花了多少时间}、\n$$\n\n#####  周转时间\n\n从**作业被提交给系统开始**，到**作业完成为止**的这段时间间隔，它包括4个部分：\n\n1. 作业在外存后备队列上等待作业调度（高级调度）的时间。\n2. 进程在就绪队列上等待进程调度（低级调度）的时间。\n3. 进程在CPU上执行的时间。\n4. 进程等待I/O操作完成的时间。\n\n后三项可能发生多次。\n$$\n周转时间=作业完成时间-作业提交时间\n$$\n\n$$\n平均周转时间=\\frac{各作业周转时间之和}{作业数}\n$$\n\n$$\n带权周转时间=\\frac{作业周转时间}{作业实际运行的时间}=\\frac{作业完成时间-作业提交时间}{作业实际运行的时间}\n$$\n\n$$\n平均带权周转时间=\\frac{各作业带权周转时间之和}{作业数}\n$$\n\n后两个比较重要，带权周转时间和周转时间都是越短越好。\n\n##### 等待时间\n\n进程/作业处于等待处理机状态时间之和。\n\n对于**进程**来说，等待时间就是指建立进程后等待被服务的时间之和，在等待I/O完成的期间其实进程也是被服务的，不计入等待时间内。\n\n对于**作业**来说，不仅考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。\n\n##### 响应时间\n\n从用户**提交请求**到**首次产生响应**所用的时间。\n\n#### 非交互性调度算法\n\n##### 先来先服务（FCFS, First Come First Serve）\n\n<img src=\"进程管理（二）\\先来先服务.png\"  />\n\n##### 最短作业优先（SJF, Shortest Job First）\n\n最短作业/进程优先得到服务；既可用于作业调度，也可用于进程调度，用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”；SJF和SPF是**非抢占式的算法**，也有**抢占式的版本**—**最短剩余时间优先**算法（SRTN, Shortest Remaining Time Next）。\n\n短作业/进程优先调度算法：每次调度时选择**当前已到达**且**运行时间最短**的作业/进程，对比FCFS，SPF的平均等待/周转/带权周转的时间都要低。\n\n最短剩余时间优先算法：每当有进程加入，就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间**更短**，则由新进程**抢占**处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。对比非抢占式的算法，其平均等待/周转/带权周转的时间都要低。\n\n<img src=\"进程管理（二）\\SJF.png\"  />\n\n##### 最高响应比优先（HRRN, Highest Response Ratio Next）\n\n非抢占式的调度算法，只有当前运行的进程**主动放弃CPU时**，才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。\n$$\n响应比=\\frac{等待时间+要求服务时间}{要求服务时间}\n$$\n<img src=\"进程管理（二）\\HRRN.png\"  />\n\n #### 交互性调度算法\n\n ##### 时间片轮转（RR, Round-Robin）\n\n轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列头的进程），常用于分时操作系统。\n\n如果**时间片过大**，使得每个进程可以在一个时间片内完成，则时间片轮转调度算法退化为**先来先服务**算法，且会增加进程响应时间。\n\n如果**时间片过小**，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比列减少。\n\n一般来说，设计时间片时要让切换进程的开销占比不超过1%。\n\n<img src=\"进程管理（二）\\RR.png\"  />\n\n##### 优先级调度算法\n\n*非抢占式的优先级调度算法*：每次调度时选择当前已到达且优先级最高的进程。当前进程**主动**放弃处理机时发生调度。\n\n*抢占式的优先级调度算法*：每次调度时选择当前已到达且优先级最高的进程。当前进程**主动**放弃处理机时发生调度。另外，当**就绪队列发生改变时**也需要检查是否会发生抢占。\n\n1. *静态优先级*：创建进程时确定，之后一直不变。\n2. *动态优先级*：创建进程时有一个初始值，之后会根据情况动态的调整优先级。\n\n如何合理设置优先级，通常情况下：\n\n* 系统进程优先级**高于**用户进程\n* 前台进程优先级**高于**后台进程\n* 操作系统**更偏好I/O型进程（I/O繁忙型进程）**\n  * I/O设备和CPU可以并行工作，最好让其尽早投入工作\n\n采取动态优先级，何时调整：\n\n* 某进程在就绪队列中等待很长时间，可适当提高其优先级\n* 某进程占用处理机运行了很长时间，可适当降低其优先级\n* 某进程频繁进行I/O操作，可适当提升其优先级\n\n<img src=\"进程管理（二）\\优先级调度算法.png\"  />\n\n##### 多级反馈队列调度算法\n\n<img src=\"进程管理（二）\\多级反馈队列调度算法.png\"  />\n\n**总结**：\n\n<img src=\"进程管理（二）\\总结.png\"  />\n\n","categories":["操作系统"]},{"title":"进程管理（一）","url":"/blog/2020/11/11/进程管理（一）/","content":"\n#### 本次学习要点\n\n1. 进程的定义、组成、组织方式、特征\n2. 线程\n\n<!-- more-->\n\n#### 进程\n\n##### 一、进程的概念 \n\n多道程序环境下引入*进程*的概念，为了更好地描述和控制程序的并发执行，实现操作系统的并发行和共享性。\n\n1. 进程控制块(Process Control Block, PCB)：描述进程的基本情况和运行状态，进而控制和管理进程，**PCB是进程存在的唯一标志**。\n\n2. **进程映像（进程实体）**由程序段、相关数据段和PCB构成，进程映像是静态的，进程是动态的。\n\n3. **进程**是**进程实体**的运行过程，是系统进行资源分配和调度的一个独立单位。\n\n4. **进程的典型定义**：\n   1. 进程是程序的一次执行过程\n   2. 进程是一个程序及其数据在处理及上顺序执行时所发生的活动\n   3. 进程时具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n\n##### 二、进程的组成\n\n<img src=\"进程管理\\进程的组成.png\"  />\n\n##### 三、进程的特征\n\n1. 动态性：进程是程序的一次执行过程，是动态地产生、变化和消失的，**最基本特征**\n2. 并发性：内存中有多个进程实体，各进程可并发执行\n3. 独立性：进程是能独立运行、独立获得资源、独立接受调度的**基本单位**\n4. 异步性：各进程按照独立的、**不可预知**的速度向前推进，操作系统要提供**进程同步机制**来解决异步问题\n5. 结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成\n\n##### 四、进程的状态与转换\n\n<img src=\"进程管理\\进程的状态.png\"  />\n\n创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB\n\n终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB\n\n###### 进程的三种基本状态\n\n1. 运行态：占有CPU，并在CPU上运行（单核处理器下，每个时刻最多一个进程处于运行态）\n2. 就绪态：已经具备运行条件，但由于没有空闲CPU，暂时不能运行（万事俱备，只欠CPU）\n3. 阻塞态：又称等待态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机），或等待输入/输出完成。即使处理机空闲，该进程也不能运行\n\n###### 进程状态的转换\n\n<img src=\"进程管理\\进程的状态转换.png\"  />\n\n就绪态->运行态：进程被调度\n\n运行态->就绪态：时间片到，或CPU被其他高优先级的进程抢占\n\n运行态->阻塞态：等待系统分配资源，或等到某事件发生（*主动行为*）\n\n阻塞态->就绪态：资源分配到位，等待的事件发生（*被动行为*）\n\n##### 五、进程控制\n\n进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为**原语**，**原语**的特点是在**执行期间不允许中断**，它是一个不可分割的基本单位，**原语采用关中断指令和开中断指令实现**。\n\n###### 进程的创建\n\n<img src=\"进程管理\\进程的创建.png\"  />\n\n###### 进程的终止\n\n<img src=\"进程管理\\进程的终止.png\"  />\n\n###### 进程的阻塞和唤醒\n\n进程的阻塞和唤醒要成对出现\n\n<img src=\"进程管理\\进程的阻塞和唤醒.png\"  />\n\n###### 进程切换\n\n<img src=\"进程管理\\进程的切换.png\"  />\n\n##### 六、进程通信\n\n<img src=\"进程管理\\进程通信.png\"  />\n\n ###### 共享存储\n\n两个进程对共享空间的访问必须是互斥的，通过操作系统提供的工具实现。操作系统只负责提供共享空间和同步互斥工具（如P、V操作）。\n\n方法：\n\n1. 基于数据结构的共享，低级通信方式\n\n2. 基于存储区的共享，高级通信方式\n\n###### 消息传递\n\n进程间数据交换以**格式化的消息**为单位，包括消息头和消息体。进程通过操作系统提供的“发送信息/接受信息”两个原语进行数据交换。\n\n方法：\n\n1. 直接通信方式，发送进程将消息直接发送给接收进程，挂在接收进程的消息缓冲队列上\n2. 间接通信方式，消息要先发送到中间实体（信箱）中，也称“信箱通信方式”\n\n###### 管道通信\n\n1. 管道通信采用半双工，若要实现双向同时通信，需要设置两个管道\n2. 各进程要互斥地访问管道\n3. 管道满时，写进程write()系统调用被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程read()被阻塞\n4. 如果**没写满就不允许读**，如果**没读空就不允许写**\n5. 数据一旦被读出，就从管道中被抛弃，意味着读进程最多只能有一个\n\n#### 线程\n\n有的进程可能需要“同时”做很多事，而传统的进程只能串行的执行一系列程序。为此，引入了“线程”来增加并发度，**引入线程后，线程成为了程序执行流的最小单位**。\n\n引入线程后，进程只作为除CPU之外的系统资源的分配单位，线程则作为处理机的分配单元。\n\n<img src=\"进程管理\\线程.png\"  />\n\n##### 一、线程的实现方式\n\n1. 用户级线程\n\n<img src=\"进程管理\\用户级线程.png\" style=\"zoom:80%;\" />\n\n2. 内核级线程\n\n<img src=\"进程管理\\内核级线程.png\" style=\"zoom:80%;\" />\n\n3. 二者组合方式，将n个用户级线程映射到m个内核级线程上（n>=m）\n\n<img src=\"进程管理\\组合线程实现.png\" style=\"zoom:80%;\" />\n\n操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。\n\n##### 二、多线程模型\n\n有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。\n\n1. 多对一模型：多个用户级线程映射到一个内核级线程\n\n<img src=\"进程管理\\多线程1.png\" style=\"zoom:80%;\" />\n\n优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。\n\n缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。\n\n2. 一对一模型：一个用户级线程映射到一个内核级线程\n\n<img src=\"进程管理\\多线程2.png\" style=\"zoom:80%;\" />\n\n优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行。\n\n缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，线程管理成本高，开销大。\n\n3. 多对多模型：n个用户级线程映射到m个内核级线程（n>=m）\n\n<img src=\"进程管理\\多线程3.png\" style=\"zoom:80%;\" />\n\n克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。","categories":["操作系统"]},{"title":"图论（二）","url":"/blog/2020/11/03/图论2/","content":"\n#### 本次学习要点\n\n1. 读取一个图\n2. 深度优先搜索DFS\n3. 广度优先搜索BFS\n\n<!-- more-->\n\n#### 从文件中读取一个图\n\n如果要从已有的文件中读取并构建一张图，需要使用到C++的IO库，使用头文件`fstream`和`sstream`，类型如下:\n\n**fstream:**\n\n* `ifstream, wifstream`从文件中读取数据\n* `ofstream, wofstram`向文件中写入数据\n* `fstream, wfstream`读写文件\n\n**sstream:**\n\n* `istringstream, wistringfstream`从`string`中读取数据\n* `ostringstream, wosringstream`向`string`中写入数据\n* `stringstream, wstringstream`读写`string`\n\n##### 读文件—类的实现\n\n```cpp\ntemplate <typename Graph>\nclass ReadGraph {\npublic:\n    ReadGraph(Graph &graph, const string &filename){\n        ifstream file(filename);\n        string line;\n        int V, E;\n\n        assert(file.is_open());\n        assert(getline(file, line));\n        // 首先读入顶点数和边数\n        stringstream ss(line);\n        ss >> V >> E;\n        assert(V == graph.V());\n        // 读入每一条边\n        for(int i = 0; i < E; ++i){\n            assert(getline(file, line));\n            stringstream ss(line);\n            int a, b;\n            ss >> a >> b;\n            assert(a >= 0 && a < V);\n            assert(b >= 0 && b < V);\n            graph.addEdge(a, b);\n        }\n    }\n};\n```\n\n###### 测试主函数\n\n```cpp\nint main(){\n    string filename = \"testG2.txt\";\n    // G2是有6个顶点的无向图\n    SparseGraph g1(6, false);\n    ReadGraph<SparseGraph> readGraph1(g1, filename);\n    // 在两种头文件中新加show函数打印结果\n    g1.show();\n\n    cout << endl;\n\n    DenseGraph g2(6, false);\n    ReadGraph<DenseGraph> readGraph2(g2, filename);\n    g2.show();\n\n    return 0;\n}\n// 输出\nvertex 0:       1 2 5\nvertex 1:       0 2 3 4\nvertex 2:       0 1\nvertex 3:       1 4 5\nvertex 4:       1 3\nvertex 5:       0 3\n\nvertex 0:       0 1 1 0 0 1\nvertex 1:       1 0 1 1 1 0\nvertex 2:       1 1 0 0 0 0\nvertex 3:       0 1 0 0 1 1\nvertex 4:       0 1 0 1 0 0\nvertex 5:       1 0 0 1 0 0\n```\n\n#### 深度优先搜索（DFS）\n\n与二叉树的深度优先搜索遍历不同，二叉树总会遇到空，但是图可能成环，或者无向图，所以遍历时应记录每个节点是否被遍历了。\n\n##### 连通分量\n\n无向图Graph的极大连通子图称为G的**连通分量**( Connected Component)。任何**连通图**的连通分量只有一个，即是其自身，**非连通的无向图**有多个连通分量。如图所示，无向图共有4个连通分量：\n\n<img src=\"图论2\\dfs1.png\"  />\n\n对于一个非连通的无向图来说，可以用DFS得到Graph共有几个连通分量。\n\n```cpp\ntemplate <typename Graph>\nclass Components {\nprivate:\n    Graph &G;\n    bool *visited; // 当前节点是否被遍历过\n    int ccount;\t// 记录连通分量总数\n    int *id;\n\n\tvoid dfs(int v){\n    \tvisited[v] = true;\n    \t// 相当于并查集，让同一个联通分量中的节点指向同一个数\n    \tid[v] = ccount;\n    \t// 编译器无法判断是Graph的一个类型还是一个成员变量，需加关键字typename\n    \ttypename Graph::adjIterator adj(G, v);\n    \tfor(int i = adj.begin(); !adj.end(); i = adj.next()){\n        \tif(!visited[i])\n            \tdfs(i);\n    \t}\n\t}\npublic:\n    Components(Graph &graph): G(graph){\n        visited = new bool[G.V()];\n        id = new int[G.v()];\n        ccount = 0;\n        // 初始化\n        for(int i = 0; i < G.V(); ++i){\n            visited[i] = false;\n            id[i] = -1;\n        }\n        for(int i = 0; i < G.V(); ++i){\n            if(!visited[i]){\n                dfs(i);\n                ccount++;\n            }\n        }\n    }\n    ~Components(){\n        delete[] visited;\n        delete[] id;\n    }\n    int count(){\n        return ccount;\n    }\n    // 查询两个节点是否相连\n    bool isConnected(int v, int w){\n        assert(v >= 0 && v < G.V());\n        assert(w >= 0 && w < G.V());\n        return id[v] == id[w];\n    }\n};\n```\n\n###### 测试主函数\n\n对于图`testG1.txt`和`testG2.txt`，先从文件中读取到稀疏图中，再对此图进行DFS得到连通分量的个数，两个文件内容分别为：\n\n* testG1:\n\n<img src=\"图论2\\testG1.png\"  />\n\n* testG2:\n\n<img src=\"图论2\\testG2.png\"  />\n\n```cpp\nint main(){\n    string filename1 = \"testG1.txt\";\n\n    SparseGraph g1(13, false);\n    ReadGraph<SparseGraph> readGraph1(g1, filename1);\n    Components<SparseGraph> component1(g1);\n    cout << \"TestG1.txt, Component Count: \"<< component1.count() << endl;\n\n    string filename2 = \"testG2.txt\";\n    SparseGraph g2(6, false);\n    ReadGraph<SparseGraph> readGraph2(g2, filename2);\n    Components<SparseGraph> component2(g2);\n    cout << \"TestG2.txt, Component Count: \" << component2.count() << endl;\n\n    return 0;\n}\n// 输出\nTestG1.txt, Component Count: 3\nTestG2.txt, Component Count: 1\n```\n\n##### 获得两点之间的一条路径\n\n使用DFS可以找连通图两点之间的一条路径，但不一定是最短路径。对于稀疏图，复杂度为O(V+E)，对于稠密图，复杂度为O(V^2)。对于下图，寻找节点0到节点6的一条路径。\n\n<img src=\"图论2\\dfs2.png\"  />\n\n在遍历每个节点时，可以存储当前节点是由哪个节点遍历到的，以此可以反推出原始节点到当前节点的一条路径。\n\n```cpp\ntemplate <typename Graph>\nclass Path {\nprivate:\n    Graph &G;\n    int s; // 源节点\n    bool *visited;\n    int *from; // 当前节点是由哪个节点遍历到的\n    void dfs(int v){\n        visited[v] = true;\n        typename Graph::adjIterator adj(G, v);\n        for(int i = adj.begin(); !adj.end(); i = adj.next()){\n            if(!visited[i]){\n                // 节点i是由节点v遍历到的\n                from[i] = v;\n                dfs(i);\n            }\n        }\n    }\npublic:\n    Path(Graph &graph, int s): G(graph){\n        // 算法初始化\n        assert(s >= 0 && s < G.V());\n\n        visited = new bool[G.V()];\n        from = new int[G.V()];\n        for(int i = 0; i < G.V(); ++i){\n            visited[i] = false;\n            from[i] = -1;\n        }\n        this->s = s;\n        // 寻路\n        dfs(s);\n    }\n    ~Path(){\n        delete [] visited;\n        delete [] from;\n    }\n    bool hasPath(int w){\n        assert( w >= 0 && w < G.V() );\n        return visited[w];\n    }\n    void path(int w, vector<int> &vec){\n        stack<int> s;\n        int p = w;\n        // 找到从源节点到目标节点所经过的每一个节点入栈\n        while(p != -1){\n            s.push(p);\n            // 将p更新为可以到达p的一个节点\n            p = from[p];\n        }\n        vec.clear();\n        while(!s.empty()){\n            // 出栈是正向路径\n            vec.push_back(s.top());\n            s.pop();\n        }\n    }\n    void showPath(int w){\n        vector<int> vec;\n        path(w, vec);\n        for(int i = 0; i < vec.size(); ++i) {\n            cout << vec[i];\n            if (i == vec.size() - 1)\n                cout << endl;\n            else\n                cout << \" -> \";\n        }\n    }\n};\n```\n\n###### 测试主函数\n\n```cpp\nint main() {\n    string filename = \"testG2.txt\";\n    SparseGraph g = SparseGraph(7, false);\n    ReadGraph<SparseGraph> readGraph(g, filename);\n    g.show();\n    cout << endl;\n\n    Path<SparseGraph> dfs(g, 0);\n    cout << \"DFS : \";\n    dfs.showPath(6);\n\n    return 0;\n}\n// 输出\nvertex 0:       1       2       5       6\nvertex 1:       0\nvertex 2:       0\nvertex 3:       4       5\nvertex 4:       3       5       6\nvertex 5:       0       3       4\nvertex 6:       0       4\n\nDFS : 0 -> 5 -> 3 -> 4 -> 6\n```\n\n#### 广度优先搜索（BFS）\n\n使用深度优先搜索可以找到无权图两个节点之间的最短路径，复杂度与DFS相同。\n\n##### 最短路径—类的实现\n\n```cpp\ntemplate <typename Graph>\nclass ShortestPath {\nprivate:\n    Graph &G;\n    int s;\n    bool *visited;\n    int *from;\n    int *ord; // 当前点到源节点的最短距离\npublic:\n    ShortestPath(Graph &graph, int s): G(graph){\n        // 算法初始化\n        assert(s >= 0 && s < G.V());\n\n        visited = new bool[graph.V()];\n        from = new int[graph.V()];\n        ord = new int[graph.V()];\n        for( int i = 0 ; i < graph.V() ; i ++ ){\n            visited[i] = false;\n            from[i] = -1;\n            ord[i] = -1;\n        }\n        this->s = s;\n\n        queue<int> q;\n        // 无向图最短路径算法\n        q.push(s);\n        visited[s] = true;\n        ord[s] = 0;\n        while(!q.empty()){\n            int v = q.front();\n            q.pop();\n            typename Graph::adjIterator adj(G, v);\n            for(int i = adj.begin(); !adj.end(); i = adj.next()){\n                if(!visited[i]){\n                    q.push(i);\n                    visited[i] = true;\n                    from[i] = v;\n                    ord[i] = ord[v] + 1;\n                }\n            }\n        }\n    }\n    ~ShortestPath(){\n        delete [] visited;\n        delete [] from;\n        delete [] ord;\n    }\n    bool hasPath(int w){\n        assert( w >= 0 && w < G.V() );\n        return visited[w];\n    }\n\n    void path(int w, vector<int> &vec){\n        assert( w >= 0 && w < G.V() );\n        stack<int> s;\n        int p = w;\n        while( p != -1 ){\n            s.push(p);\n            p = from[p];\n        }\n        vec.clear();\n        while( !s.empty() ){\n            vec.push_back( s.top() );\n            s.pop();\n        }\n    }\n    void showPath(int w){\n        assert( w >= 0 && w < G.V() );\n        vector<int> vec;\n        path(w, vec);\n        for( int i = 0 ; i < vec.size() ; i ++ ){\n            cout<<vec[i];\n            if( i == vec.size()-1 )\n                cout<<endl;\n            else\n                cout<<\" -> \";\n        }\n    }\n    int length(int w){\n        assert( w >= 0 && w < G.V() );\n        return ord[w];\n    }\n};\n```\n\n###### 测试主函数\n\n```cpp\nint main() {\n    string filename = \"testG2.txt\";\n    SparseGraph g = SparseGraph(7, false);\n    ReadGraph<SparseGraph> readGraph(g, filename);\n    g.show();\n    cout<<endl;\n\n    Path<SparseGraph> dfs(g,0);\n    cout<<\"DFS : \";\n    dfs.showPath(4);\n\n    ShortestPath<SparseGraph> bfs(g,0);\n    cout<<\"BFS : \";\n    bfs.showPath(4);\n    cout<< \"Shortest length : \" << bfs.length(4);\n    return 0;\n}\n// 输出\nvertex 0:       1 2 5 6\nvertex 1:       0\nvertex 2:       0\nvertex 3:       4 5\nvertex 4:       3 5 6\nvertex 5:       0 3 4\nvertex 6:       0 4\n\nDFS : 0 -> 5 -> 3 -> 4\nBFS : 0 -> 5 -> 4\nShortest Length : 2\n```\n\n#### 完整工程：\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git\n\n","categories":["算法与数据结构"]},{"title":"图论（一）","url":"/blog/2020/10/27/图论1/","content":"\n#### 本次学习要点\n\n1. 图的基本概念\n2. 图的两种表示方法及实现\n3. 对图进行遍历\n\n<!-- more-->\n\n#### 图的基本概念\n\n##### 基本组成\n\n* 节点（Vertex）\n* 边（Edge）\n\n使用场景：交通运输，社交网络，互联网，工作安排，脑区活动，程序状态执行（自动机）等。\n\n##### 图的分类\n\n* 无向图（Undirected Graph）\n* 有向图（Directed Graph）\n\n无向图是一种特殊的有向图，比如A指向B，同时B指向A\n\n* 无权图（Unweighted Graph）\n* 有权图（Weighted Graph）\n\n其他概念：图的连通性，简单图（无自环边与平行边）\n\n<img src=\"图论1/7-1-1.png\" style=\"zoom:80%;\" />\n\n#### 图的两种表示方法及实现（邻接矩阵与邻接表）\n\n##### 邻接矩阵（适合表示稠密图Dense Graph）\n\n<img src=\"图论1\\7-2-1.png\" style=\"zoom:80%;\" />\n\n**实现：**\n\n```cpp\nclass DenseGraph{\nprivate:\n    int n, m;      // 节点数和边数\n    bool directed; // 是否是有向图\n    vector<vector<bool>> g;\npublic:\n    DenseGraph(int n, bool directed){\n        this->n = n;\n        this->m = 0;\n        this->directed = directed;\n        for(int i = 0; i < n; i++){\n            g.push_back(vector<bool>(n, false));\n        }\n    }\n    ~DenseGraph(){};\n    int V(){ return n;} // 图的节点总数\n    int E(){ return m;} // 图的边总数\n    // 增加节点v与节点w之间的一条边\n    void addEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n        if(hasEdge(v, w)) return; // 处理了平行边，并且防止边数m多加一次\n        g[v][w] = true;\n        if(!directed) // 如果是无向图\n            g[w][v] = true;\n        m++;\n    }\n    bool hasEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n        return g[v][w];\n    }\n};\n```\n\n##### 邻接表（适合表示稀疏图Sparse Graph）\n\n<img src=\"图论1\\7-2-2.png\" style=\"zoom:80%;\" />\n\n**实现：**\n\n```cpp\nclass SparseGraph{\nprivate:\n    int n, m;\n    bool directed;\n    vector<vector<int>> g;\npublic:\n    SparseGraph(int n, bool directed){\n        this->n = n;\n        this->m = 0;\n        this->directed = directed;\n        for(int i = 0; i < n; ++i){\n            g.push_back(vector<int>());\n        }\n    }\n    ~SparseGraph(){}\n    int V(){ return n;} // 图的节点总数\n    int E(){ return m;} // 图的边总数\n    void addEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n\n        g[v].push_back(w);\n        if(v != w && !directed) // 处理了自环边，并且防止边数m多加一次\n            g[w].push_back(v);\n        m++;\n    }\n    bool hasEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n\n        for(int i = 0; i < g[v].size(); ++i){\n            if(g[v][i] == w) // 节点v与w相连\n                return true;\n            return false;\n        }\n    }\n};\n```\n\n#### 对图进行遍历——迭代器的实现\n\n```mermaid\ngraph LR\n\t0-->3;\n\t0-->5;\n\t0-->8;\n```\n\n在邻接矩阵中如下：\n\n| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 0    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | 1    |\n\n在邻接表中如下：\n\n| 0    | 1    | 2    | 3    |\n| ---- | ---- | ---- | ---- |\n| 0    | 3    | 5    | 8    |\n\n如果要遍历某个节点的所有邻边，可以借鉴迭代器的思想。\n\n##### 稠密图（邻接矩阵中）\n\n在`DenseGraph`类中实现：\n\n```cpp\n// 迭代器实现\n// 顶点的邻边按顺序输出\nclass adjIterator {\nprivate:\n    DenseGraph &G;\n    int index; // 遍历到的节点坐标\n    int v;\npublic:\n    adjIterator(DenseGraph &graph, int v) : G(graph) {\n        this->v = v;\n        this->index = -1;\n    }\n    int begin() {\n        index = -1;\n        return next();\n    }\n    int next() {\n        index += 1;\n        for (index; index < G.V(); index++) {\n            if (G.g[v][index]) // 如果v与index相连\n                return index;\n        }\n        return -1; // 没有邻边\n    }\n    bool end() {\n        return index >= G.V();\n    }\n};\n```\n\n##### 稀疏图（邻接表中）\n\n在`SparseGraph`类中实现：\n\n```cpp\nclass adjIterator{\nprivate:\n    SparseGraph &G;\n    int index;\n    int v;\npublic:\n    adjIterator(SparseGraph &graph, int v):G(graph){\n        this->v = v;\n        // 与稠密图不同的是，这里的index表示遍历到v的第index个节点，不表示节点index\n        this->index = index; \n    }\n    int begin(){\n        index = 0;\n        if(G.g[v].size())\n            return G.g[v].size();\n        return -1;\n    }\n    int next(){\n        index += 1;\n        if(index < G.g[v].size())\n            return G.g[v][index];\n        return -1; // 返回-1说明已经遍历结束，此时index = G.g[v].size()\n    }\n    bool end(){\n        return index >= G.g[v].size();\n    }\n};\n```\n\n**测试用主函数：**\n\n```cpp\nint main() {\n    int N = 10;\n    int M = 30;\n\n    srand(time(NULL));\n\n    // Sparse Graph\n    // 存在平行边\n    SparseGraph g1(N, false);\n    for(int i = 0; i < M; ++i){\n        int a = rand() % N;\n        int b = rand() % N;\n        g1.addEdge(a, b);\n    }\n    // O(E)\n    for(int v = 0; v < N; ++v){\n        cout << v << \" : \";\n        SparseGraph::adjIterator adj(g1, v);\n        for(int w = adj.begin(); !adj.end(); w = adj.next()){\n            cout << w << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n    // Dense Graph\n    // 存在自环边\n    DenseGraph g2(N, false);\n    for(int i = 0; i < M; ++i){\n        int a = rand() % N;\n        int b = rand() % N;\n        g2.addEdge(a, b);\n    }\n    // O(V^2)\n    for(int v = 0; v < N; ++v){\n        cout << v << \" : \";\n        DenseGraph::adjIterator adj(g2, v);\n        for(int w = adj.begin(); !adj.end(); w = adj.next()){\n            cout << w << \" \";\n        }\n        cout << endl;\n    }\n}\n```\n\n**测试结果**\n\n```\n// Sparse Graph\n// 可以看出存在平行边\n0 : 3 6 6 7 6\n1 : 9 2\n2 : 7 9 5 1 9\n3 : 5 0 5 6 4 9 5\n4 : 6 3 8 6 8\n5 : 9 7 3 2 3 3 9\n6 : 9 4 0 3 9 0 4 0\n7 : 5 2 8 9 0\n8 : 7 8 9 4 4\n9 : 5 2 6 1 7 3 6 8 5 2\n\n// Sparse Graph\n// 可以看出存在自环边\n0 : 0 2 4\n1 : 4 5 7 9\n2 : 0 4 8\n3 : 3 4 5 6\n4 : 0 1 2 3 6 7 9\n5 : 1 3 6\n6 : 3 4 5 7 8 9\n7 : 1 4 6 7\n8 : 2 6 8\n9 : 1 4 6\n```\n\n#### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git\n","categories":["算法与数据结构"]},{"title":"LeetCode143-重排链表","url":"/blog/2020/10/27/LeetCode143-重排链表/","content":"\n本题同时解决**LeetCode206-反转链表**和**LeetCode876-链表的中间结点**\n\n#### 题目描述\n\n给定一个单链表 $L$：$L0→L1→…→Ln-1→Ln$ ，\n将其重新排列后变为： $L0→Ln→L1→Ln-1→L2→Ln-2→…$\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n本题可与[LeetCode147-对链表进行插入排序](http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more)，[LeetCode148-排序链表](http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/)共同学习。\n\n<!-- more-->\n\n<img src=\"LeetCode143-重排链表\\示例.png\"  />\n\n#### 思路\n\n观察链表，对于长度为偶数的链表，如示例1，可以将2之后的子链表进行反转得到$4->3$，然后再与剩下的链表$1->2$交叉合并，得到$1->4->2->3$；\n\n长度为奇数的链表同理，找到中间结点3，将3之后的子链表反转得到$5->4$，再与剩下的链表$1->2->3$进行合并，得到$1->5->2->4->3$。\n\n#### 链表的中间结点\n\n```cpp\n// 对于偶数长度链表，找到的是中间靠后的一个\nListNode* midNode(ListNode *root){\n    if(!root || !root->next) \n        return root;\n    ListNode *fast = root;\n    ListNode *slow = root;\n    while(fast && fast->next){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    return slow;\n}\n// 对于偶数长度链表，找到的是中间靠前的一个\nListNode* midNode(ListNode *root){\n    if(!root || !root->next) \n        return root;\n    ListNode *fast = root;\n    ListNode *slow = root;\n    while(fast->next && fast->next->next){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    return slow;\n}\n```\n\n#### 反转链表\n\n```cpp\nListNode* reverseList(ListNode *root){\n    ListNode *pre = nullptr;\n    ListNode *cur = root;\n    while(cur){\n        ListNode *tmp = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = tmp;\n    }\n    return pre;\n}\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if(!head) return;\n        ListNode *mid = midNode(head);\n        ListNode *l2 = mid->next;\n        mid->next = nullptr; \n        l2 = reverseList(l2);\n        mergeList(head, l2);\n    }\n    ListNode* midNode(ListNode *root){\n        ListNode *fast = root;\n        ListNode *slow = root;\n        while(fast && fast->next){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n    ListNode* reverseList(ListNode *root){\n        ListNode *pre = nullptr;\n        ListNode *cur = root;\n        while(cur){\n            ListNode *tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp;\n        }\n        return pre;\n    }\n    void mergeList(ListNode *l1, ListNode* l2){\n        ListNode *tmp1;\n        ListNode *tmp2;\n        while(l1 && l2){\n            tmp1 = l1->next;\n            l1->next = l2;\n            tmp2 = l2->next;\n            l2->next = tmp1;\n            l1 = tmp1;\n            l2 = tmp2;\n        }\n    }\n};\n```\n\n","tags":["链表"],"categories":["LeetCode"]},{"title":"二叉树的三种遍历方法（迭代）","url":"/blog/2020/10/19/二叉树的三种遍历方法（迭代）/","content":"\n**概要**\n\n1. 二叉树的前序遍历\n2. 二叉树的中序遍历\n3. 二叉树的后序遍历\n\n<!-- more-->\n\n递归进行二叉树的遍历比较简单，学习使用迭代法进行二叉树的遍历，主要是使用栈这种数据结构。\n\n#### 二叉树的前序遍历\n\n前序遍历的顺序为：中—左—右\n\n```cpp\nvector<int> preorderTraversal(TreeNode* root) {\n    vector<int> preOrder;\n    stack<TreeNode*> st;\n    st.push(root);\n    while(!st.empty()){\n        TreeNode *node = st.top();\n        st.pop();\n        if(node){\n            preOrder.push_back(node->val);\n            // 这里需要注意，前序遍历第二次遍历的是左节点\n            // 所以先将右节点入栈，再将左节点入栈，保证左节点先出栈\n            st.push(node->right);\n            st.push(node->left);\n        }\n    }\n    return preOrder;\n}\n```\n\n#### 二叉树的中序遍历\n\n中序遍历的顺序为：左—中—右\n\n```cpp\nvector<int> inorderTraversal(TreeNode* root) {\n    vector<int> res;\n    stack<TreeNode*> st;\n    TreeNode *node = root;\n    // 先判断根节点不为空，进入迭代，后面再根据栈是否为空进行迭代\n    while(!st.empty() || node){\n        // 当前节点存在，查看其左节点情况，如果其左节点不存在，那就弹出当前节点\n        // 再查看其右节点情况，如果右节点也不存在，就弹出当前栈顶（也就是上一个左节点）\n        if(node){\n            st.push(node);\n            node = node->left;\n        }\n        else{\n            node = st.top();\n            st.pop();\n            res.push_back(node->val);\n            node = node->right;\n        }\n    }\n    return res;\n}\n```\n\n#### 二叉树的后序遍历\n\n后序遍历的顺序为：左—右—中\n\n##### 根据二叉树结构遍历\n\n```cpp\nvector<int> postorderTraversal(TreeNode* root) {\n    stack<TreeNode *> st;\n    vector<int> res;\n    TreeNode *cur = root;\n    TreeNode *pre;\n    while(cur || !st.empty()){\n        // 首先当前节点的左子树入栈\n        while(cur != nullptr){\n            st.push(cur);\n            cur = cur->left;\n        }\n        // 取出最后一个左节点\n        cur = st.top();\n        // 如果当前节点的右节点为空或者已经遍历过了，那么就记录当前节点\n        if(!cur->right || cur->right == pre){\n            res.push_back(cur->val);\n            pre = cur;\n            // 如果记录了当前节点，那么当前节点必须置为空，否则会陷入第一个while中死循环\n            cur = nullptr;\n            st.pop();\n        }\n        // 否则查看当前节点的右节点\n        else{\n            cur = cur->right;\n        }\n    }\n    return res;\n}\n```\n\n动画演示：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/di-gui-die-dai-qu-qiao-san-chong-fang-fa-quan-jie-/\n\n##### 破坏结构遍历\n\n```cpp\nvector<int> postorderTraversal(TreeNode* root) {\n    if(!root) return {};\n    stack<TreeNode*> st;\n    vector<int> res;\n    st.push(root);\n    while(!st.empty()){\n        TreeNode *node = st.top();\n        st.pop();\n        if(node){\n            res.push_back(node->val);\n            st.push(node->left);\n            st.push(node->right);\n        }\n    }\n    // 得到的结果是中—右—左，需要反转一下得到左—右—中\n    reverse(res.begin(), res.end());\n    return res;\n}\n```\n\n","tags":["二叉树"],"categories":["算法与数据结构"]},{"title":"C++类的一些知识点","url":"/blog/2020/10/18/C-类的一些知识点/","content":"\n《C++ Primer》第七章内容——类\n\n**部分总结**\n\n<!-- more-->\n\n#### 第七章：类\n\n1. ##### 友元\n\n* 类可以允许其他类或者函数访问它的非共有成员，方法是令其他类或者函数（可以是成员函数也可以是非成员函数）成为它的友元。一般来说，在类的开始或者结束前位置集中声明友元。如果希望类的用户能够调用某个友元函数，那么就需要在类中友元声明之外再进行一次声明。\n\n  ```cpp\n  class Sales_data{\n  friend Sales_data add(const Sale_data&, const Sale_data&);\n  public:\n      /.../\n  private:\n      /.../\n  };\n  // 非成员函数声明\n  Sales_data add(const Sale_data&, const Sale_data&);\n  ```\n\n* 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元的关系不具有传递性。\n\n  ```cpp\n  class Screen{\n      // Window_mgr的成员可以访问Screen类的私有部分\n      friend class Window_mgr;\n      /.../\n  }\n  // 也可以只为某个成员函数提供访问权限\n  class Screen{\n      // Window_mgr::clear必须再Screen类之前声明\n      friend void Window_mgr::clear(ScreenIndex);\n      /.../\n  }\n  ```\n\n2. **构造函数**\n\n* 使用构造函数初始值列表来初始化成员。\n\n* 如果成员是引用或者const时，必须通过函数初始值列标将其初始化：\n\n  ```cpp\n  class ConstRef{\n  public:\n  \tConstRef(int ii);\n  private:\n  \tint i;\n  \tconst int ci;\n  \tint &ri;\n  }\n  ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(ii);\n  ```\n\n3. **类的静态成员**\n\n* 适用于类的成员直接与类相关，而不是与类的各个对象关联，比如说：银行的利率\n\n* 静态成员可以是public或者private，使用关键字static，成员函数不用通过作用域运算符就能直接使用静态成员。静态成员不是由类的构造函数初始化的，一般在类的外部定义和初始化每个静态成员，只能定义一次：\n\n  ```cpp\n  class Account{\n  public:\n      void calculate() { amount += amount * interestRate; };\n      static double rate() { return interestRate; };\n      static void rate(double);\n  private:\n      string owner;\n      double amount;\n      static double interestRate;\n      static double initRate(){\n  \t\treturn 1.0;\n      };  \n  };\n  void Account::rate(double newRate){\n      interestRate = newRate;\n  }\n  // 定义并初始化一个静态成员\n  double Account::interestRate = initRate();\n  // test\n  int main() {\n      Account c1;\n      double r;\n      r = c1.rate();\n      // 输出1\n      cout << r << \" \";\n      \n      Account::rate(0.8);\n      r = c1.rate();\n      // 输出0.8\n      cout << r << \" \";\n      return 0;\n  }\n  ```\n","tags":["Class"],"categories":["C++"]},{"title":"LCP19-秋叶收藏集","url":"/blog/2020/10/11/LCP19-秋叶收藏集/","content":"\n### 题目描述\n\n小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。\n出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。\n\n<!-- more-->\n\n<img src=\"LCP19-秋叶收藏集\\image-20201011112801516.png\" style=\"zoom:80%;\" />\n\n### 思路\n\n用三个状态来标记其中的每一个部分，0和2表示前面和后面的红色，1表示中间的黄色，于是三部分结构为「0、1、2」。\n\n定义`dp[i][j]`表示：对**[0..i]**片叶子进行调整，并且第**i**片叶子处于**j**状态的最小操作数，所以有下面三种情况：\n\n1. 当**j = 0**时，第**i**片叶子应为红色，并且第**i - 1**片叶子也应该处于**j = 0**的状态：\n\n$$\ndp[i][0] = dp[i-1][0] + isYellow(i)\n$$\n\n$$\nisYellow(i)=\n\\begin{cases}\n1& \\text{leaves[i] = 'y'}\\\\\\\\\n0& \\text{leaves[i] = 'r'}\n\\end{cases}\n$$\n\n如果是黄色，那么需要进行一次操作修改颜色：\n\n2. 当**j = 1**时，第**i**片叶子应为黄色，第**i - 1**片叶子可以处于**j = 0**或**j = 1**的状态，所以取其中的较小值：\n\n$$\ndp[i][1] = min(dp[i-1][1], dp[i-1][0]) + isRed(i)\n$$\n\n$$\nisRed(i)=\n\\begin{cases}\n1& \\text{leaves[i] = 'r'}\\\\\\\\\n0& \\text{leaves[i] = 'y'}\n\\end{cases}\n$$\n\n​\t\t如果是红色，那么需要进行一次操作修改颜色：\n\n3. 当**j = 2**时，第**i**片叶子应为红色，第**i - 1**片叶子可以处于**j = 2**或**j = 1**的状态（不能取**j = 0**的状态，因为每种状态至少含有一片叶子，中间必须存在有黄色叶子），再取其中的较小值：\n\n$$\ndp[i][2] = min(dp[i-1][2], dp[i-1][1]) + isYellow(i)\n$$\n\n如果是黄色，那么需要进行一次操作修改颜色，公式同1\n\n最终答案为`dp[n-1][2]`。\n\n***初始化条件：***\n\n1. 要保证每种状态都有叶子，则叶子数量应大于等于状态数量，对于`dp[i][j]`，有**i >= j**；如果**i < j**，那么可以令`dp[i][j] = INT_MAX`；\n2. 对于**i = 0**，**j**也必须为0，于是有`dp[0][0] = isYellow(0)`。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minimumOperations(string leaves) {\n        vector<vector<int>> dp(leaves.size(), vector<int>(3));\n        dp[0][0] = leaves[0] == 'y';\n        // 不合要求的,实际上也不会遇到dp[0][2]这种情况\n        dp[0][1] = dp[0][2] = dp[1][2] = INT_MAX;\n        for(int i = 1; i < leaves.size(); ++i){\n            int isYellow = leaves[i] == 'y';\n            int isRed = leaves[i] == 'r';\n            dp[i][0] = dp[i - 1][0] + isYellow;\n            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0]) + isRed;\n            if(i >= 2) dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + isYellow;\n        }\n        return dp[leaves.size() - 1][2];\n    }\n}\n```\n\n也可以优化空间，使用3个变量来代替状态转移数组：\n\n```cpp\nclass Solution {\npublic:\n    int minimumOperations(string leaves) {\n        int n = leaves.size();\n        // dp[0][0]\n        int start = leaves[0] == 'y';\n        // dp[0][1]\n        int mid = INT_MAX;\n        // dp[1][2]\n        int last = INT_MAX;\n        // 初始化转移变量\n        int start2, mid2, last2 = INT_MAX, red = 0, yellow = 0;\n        for(int i = 1; i < n; ++i){\n            red = leaves[i] == 'r';\n            yellow = leaves[i] == 'y';\n            start2 = start + yellow;\n            mid2 = min(start, mid) + red;\n            if(i >= 2) last2 = min(mid, last) + yellow;\n\n            start = start2;\n            mid = mid2;\n            last = last2;\n        }\n        return last;\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/UlBDOe/solution/qiu-xie-shou-cang-ji-by-leetcode-solution/","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode701-二叉搜索树中的插入操作","url":"/blog/2020/10/09/LeetCode701-二叉搜索树中的插入操作/","content":"\n### 题目描述\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。\n\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。\n\n<!-- more-->\n\n<img src=\"LeetCode701-二叉搜索树中的插入操作\\示例.png\" style=\"zoom:80%;\" />\n\n* 给定的树上的节点数介于 0 和 10^4 之间\n* 每个节点都有一个唯一整数值，取值范围从 0 到 10^8\n* -10^8 <= val <= 10^8\n* 新值和原始二叉搜索树中的任意节点值都不同\n\n### 思路\n\n二叉搜索树满足父节点值大于其左孩子的值小于其右孩子的值，即当前节点大于以它为根节点的左子树的所有值，并且小于其右子树的所有值。根据这个性质，只需要判断`val`与当前节点的值的大小关系来寻找插入位置。\n\n### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if(!root) return new TreeNode(val);\n        if(val < root->val)\n            root->left = insertIntoBST(root->left, val);\n        if(val > root->val)\n            root->right = insertIntoBST(root->right, val);\n        return root;\n    }\n};\n```\n\n","tags":["二叉搜索树"],"categories":["LeetCode"]},{"title":"LeetCode106-从中序与后序遍历序列构造二叉树","url":"/blog/2020/09/27/LeetCode106-从中序与后序遍历序列构造二叉树/","content":"\n### 题目描述\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n**注意:**\n你可以假设树中没有重复的元素。\n\n<!--more -->\n\n<img src=\"LeetCode106-从中序与后序遍历序列构造二叉树\\示例.png\"  />\n\n\n\n### 思路\n\n对于二叉树的题，大部分都是通过递归来解决的，此题也不例外，需要注意的是，要充分利用二叉树中序遍历和后序遍历的性质。\n\n* 中序遍历二叉树(左子树—根节点—右子树)，根节点的左边是左子树，右边是右子树；\n* 后序遍历二叉树(左子树—右子树—根节点)，根节点是最后输出的。\n\n在后序遍历数组中找到根节点之后，再从中序遍历数组中搜索根节点的左边，由此坐标将数组分开，分别就是当前根节点下的左子树和右子树：\n\n<img src=\"LeetCode106-从中序与后序遍历序列构造二叉树\\pic1.png\"  />\n\n上图中`inorder`数组中，3是在`postorder`找到的根节点，由此节点分开，`inorder`数组中绿色部分是左子树，黄色部分是右子树，在`posorder`数组中也是一样的。\n\n* 定义`inorder`数组中3的位置为**rootIn**，数组起始位置为**iStart**，结束位置为**iEnd**；\n* 定义`postorder`数组数组起始位置为**pStart**，结束位置为**pEnd**；\n\n根据以上定义，`inorder`数组中左子树起止位置为`iStart->rootIn-1`，右子树起止位置为`rootIn+1->iEnd`；`postorder`数组中左子树起止位置为`pStart->pStart+rootIn-iStart-1`，右子树起止位置为`pStart+rootIn-iStart->pEnd-1`，图来自leetcode题解(https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/)：\n\n<img src=\"LeetCode106-从中序与后序遍历序列构造二叉树\\pic2.png\"  />\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    unordered_map<int, int> map;\n    vector<int> post;\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int cnt = 0;\n        // 使用一个map记录中序遍历数值的位置\n        for(auto &num : inorder){\n            map[num] = cnt++;\n        }\n        post = postorder;\n        TreeNode *node = dfs(0, inorder.size() - 1, 0, postorder.size() - 1);\n        return node;\n    }\n    TreeNode* dfs(int iStart, int iEnd, int pStart, int pEnd){\n        if(iStart > iEnd || pStart > pEnd) return nullptr;\n        int root = post[pEnd];\n        int rootIn = map[root];\n        TreeNode *node = new TreeNode(root);\n        node->left = dfs(iStart, rootIn - 1, pStart, pStart + rootIn - iStart - 1);\n        node->right = dfs(rootIn + 1, iEnd, pStart + rootIn - iStart, pEnd - 1);\n        return node;\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/","tags":["二叉树","递归"],"categories":["LeetCode"]},{"title":"LeetCode200-岛屿数量","url":"/blog/2020/09/20/LeetCode200-岛屿数量/","content":"\n### 题目描述\n\n给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n**使用并查集解决此问题**\n\n<!-- more-->\n\n<img src=\"LeetCode200-岛屿数量\\示例.png\" style=\"zoom:80%;\" />\n\n### 思路\n\n在`grid`中遇到`'1'`时，搜索其四周（上下左右），如果发现值也为`'1'`，那么将他们合并，同时将当前位置值置为`'0'`，直到遍历到最后一个元素。\n\n并查集进行初始化时，遇到`'1'`则增加计数值`count`，在后续的合并操作中，如果两者根节点不同，要进行合并时，计数值`count`要减1，说明两个节点进行了连接。\n\n### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(vector<vector<char>> &grid){\n        count = 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(grid[i][j] == '1'){\n                    parent.push_back(n * i + j);\n                    count++;\n                }\n                else parent.push_back(-1);\n                rank.push_back(0);\n            }\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 对于根不同的情况，将其相连，计数减1\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            // 随便指一个\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.empty()) return 0;\n        unionFind uf(grid);\n        int m = grid.size();\n        int n = grid[0].size();\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(grid[i][j] == '1'){\n                    grid[i][j] = '0';\n                    if(i - 1 >= 0 && grid[i - 1][j] == '1') uf.unionElem(n * i + j, n * (i - 1) + j);\n                    if(i + 1 < m && grid[i + 1][j] == '1') uf.unionElem(n * i + j, n * (i + 1) + j);\n                    if(j - 1 >= 0 && grid[i][j - 1] == '1') uf.unionElem(n * i + j, n * i + j - 1);\n                    if(j + 1 < n && grid[i][j + 1] == '1') uf.unionElem(n * i + j, n * i + j + 1);\n                }\n            }\n        }\n        return uf.getCount();\n    }\n};\n```\n\n","tags":["并查集"],"categories":["LeetCode"]},{"title":"并查集(Union Find)","url":"/blog/2020/09/06/并查集-Union-Find/","content":"\n### 本次学习要点\n\n1. 并查集的基本概念及实现(Quick_Find/Quick_Union)\n2. 基于size优化与基于rank优化\n3. 路径压缩\n\n<!-- more-->\n\n### 并查集的基本概念及实现\n\n#### 基本概念\n\n并查集是一种特殊的图，较图论而言要简单一些。对于图论来说，主要解决的问题是**连接问题和路径问题**，而并查集只是回答前者——连接问题。比如网络节点间的连接状态，数学中集合类的实现等。\n\n并查集支持两个动作（合并两个节点，查询某个节点）：\n\n* union(p, q)\n* find(p)\n\n用来回答一个问题（两个节点是否相连接）：\n\n* isConnected(p, q)\n\n并查集可以用数组来表示，基本数据表示如下（0~4，5~9互相连接）：\n\n|      |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  id  |  0   |  0   |  0   |  0   |  0   |  1   |  1   |  1   |  1   |  1   |\n\n#### 基本实现(Quick_Find)\n\n```cpp\nclass UnionFind1 {\nprivate:\n    int *id;\n    int count;\npublic:\n    UnionFind1(int n){\n        count = n;\n        id = new int[n];\n        for(int i = 0; i < n; i++)\n            id[i] = i;\n    }\n    ~UnionFind1(){\n        delete [] id;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        return id[p];\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pID = find(p);\n        int qID = find(q);\n        if(pID == qID) return;\n        // 让p指向q，复杂度O(n)\n        for(int i = 0; i < count; i++){\n            if(id[i] == pID)\n                id[i] = qID;\n        }\n    }\n};\n```\n\n#### 基本实现(Quick_Union)\n\n将每一个元素，看作是一个节点：\n\n<img src=\"并查集-Union-Find\\quickUnion.png\" style=\"zoom:67%;\" />\n\n对于上图，将7和3连接，只需要把7的根节点指向3的根节点（反过来也行）。\n\n|   i    |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| parent |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n\n`parent[i]`表示`i`指向的父亲元素是谁。\n\n```cpp\nclass UnionFind2 {\nprivate:\n    int *parent;\n    int count;\npublic:\n    UnionFind2(int count){\n        this->count = count;\n        parent = new int[count];\n        for(int i = 0; i < count; i++)\n            parent[i] = i;\n    }\n    ~UnionFind2(){\n        delete [] parent;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        // 寻找根节点，复杂度O(n)\n        while(p != parent[p])\n            p = parent[p];\n        return p;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 让p指向q，复杂度O(1)\n        parent[pRoot] = qRoot;\n    }\n};\n```\n\n### 并查集的优化\n\n#### 基于size的优化\n\n之前实现的并查集中`Union(p, q)`操作都是让p的根节点指向q，如下图：\n\n<img src=\"并查集-Union-Find\\size1.png\" style=\"zoom: 80%;\" />\n\n如果实现`union(9, 4)`，那么9的根节点9将指向4的根节点8；相应的如果实现`union(4, 9)`则会出现将4的根节点8指向了9，如此一来，查找4的根节点需要的时间就更多了，我们完全可以在`union`操作之前进行判断，将元素少的集合的根节点指向元素多的集合的根节点，用一个数组`sz[i]`来表示以i为根集合中元素的个数。\n\n```cpp\nclass UnionFind3 {\nprivate:\n    int *parent;\n    int *sz;\n    int count;\npublic:\n    UnionFind3(int count){\n        this->count = count;\n        parent = new int[count];\n        sz = new int[count];\n        for(int i = 0; i < count; i++) {\n            parent[i] = i;\n            sz[i] = 1;\n        }\n    }\n    ~UnionFind3(){\n        delete [] parent;\n        delete [] sz;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        // 寻找根节点，复杂度O(n)\n        while(p != parent[p])\n            p = parent[p];\n        return p;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 基于size优化\n        if(sz[pRoot] < sz[qRoot]){\n            parent[pRoot] = qRoot;\n            sz[qRoot] += sz[pRoot];\n        }\n        else{\n            parent[qRoot] = pRoot;\n            sz[pRoot] += sz[qRoot];\n        }\n    }\n};\n```\n\n#### 基于rank的优化\n\n基于size的优化会出现下面一个问题：\n\n<img src=\"并查集-Union-Find\\rank1\" style=\"zoom:80%;\" />\n\n根节点为7的size是大于根节点为8的size的，所以基于size的优化会使8指向7，如下图：\n\n<img src=\"并查集-Union-Find\\rank2\" style=\"zoom:80%;\" />\n\n这样一来，这棵树的层数变成了4，一种更合理的方式是根据当前根节点的树的高度来进行优化，如下图，这样树的层数为3：\n\n<img src=\"并查集-Union-Find\\rank3\" style=\"zoom:80%;\" />\n\n我们可以用一个数组`rang[i]`表示根节点为i的树的高度。\n\n```cpp\nclass UnionFind4 {\nprivate:\n    int *parent;\n    int *rank;\n    int count;\npublic:\n    UnionFind4(int count){\n        this->count = count;\n        parent = new int[count];\n        rank = new int[count];\n        for(int i = 0; i < count; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n    }\n    ~UnionFind4(){\n        delete [] parent;\n        delete [] rank;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        // 寻找根节点，复杂度O(n)\n        while(p != parent[p])\n            p = parent[p];\n        return p;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 基于size优化\n        if(rank[pRoot] < rank[qRoot]){\n            // 不用维护层数\n            parent[pRoot] = qRoot;\n        }\n        else if (rank[pRoot] > rank[qRoot]){\n            // 不用维护层数\n            parent[qRoot] = pRoot;\n        }\n        else{ \n            // rank[pRoot] == rank[qRoot]\n            // 层数加1\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n    }\n};\n```\n\n### 路径压缩(Path Compression)\n\n之前我们的`find(p)`操作中，递归查找的复杂度为`O(1)`，如下图，要查找4的根节点需要4次递归：\n\n<img src=\"并查集-Union-Find\\pathcompression1\" style=\"zoom:80%;\" />\n\n|        |  0   |  1   |  2   |  3   |  4   |\n| :----: | :--: | :--: | :--: | :--: | :--: |\n| parent |  0   |  0   |  1   |  2   |  3   |\n\n如果将4指向3的父节点2（指向其父节点的父节点），会得到下图：\n\n<img src=\"并查集-Union-Find\\pathcompression2\"  />\n\n由于根节点指向自己，所以不会出现无效的情况，继续将p更新为`parent[p]`，得到下图：\n\n<img src=\"并查集-Union-Find\\pathcompression3\"  />\n\n这样一来，所有节点的路径都进行了压缩，查找的时间复杂度近乎是`O(1)`的。\n\n```cpp\n// 循环\nint find(int p){\n    assert(p >= 0 && p < count);\n    // 路径压缩\n    while(p != parent[p]){\n        parent[p] = parent[parent[p]];\n        p = parent[p];\n    }\n    return p;\n}\n// 递归\nint find(int p){\n    assert(p >= 0 && p < count);\n    if(p != parent[p])\n        parent[p] = find(parent[p]);\n    return parent[p];\n}\n```\n\n### 测试\n\n对每种并查集的工程执行100w次`union`操作和100w次`find`操作：\n\n<img src=\"并查集-Union-Find\\test\" style=\"zoom:80%;\" />\n\n区别还是很明显的。\n\n### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git","categories":["算法与数据结构"]},{"title":"快速排序(Quick sort)","url":"/blog/2020/08/15/快速排序-quick-sort/","content":"\n### 本次学习要点\n\n1. 快速排序基本实现及优化\n2. 双路快速排序\n3. 三路快速排序\n\n<!-- more-->\n\n### 快速排序\n\n#### 基本实现\n\n快速排序的基本思想很简单，对于`l`处的数`val`，与`j`处的数进行交换，使得坐标小于`j`的所有数都小于`val`，而位于`j`之后的数都应该大于`val`，如下图所示：\n\n<img src=\"快速排序-quick-sort\\1-1\" style=\"zoom:80%;\" />\n\n而实现这一操作的过程称为`partition`，具体过程如下：\n\n<img src=\"快速排序-quick-sort\\1-2\"  />\n\n1. 对于上图，`arr[l+1...j] < v`，`arr[j+1...i-1] > v`，当前位置`i`的值为`e`；\n\n* 如果`e > v`，将`e`放在`> v`后面，同时`i++`；\n\n* 如果`e < v`，将`i`处的值`e`与`j`下一个位置的值进行交换，然后`j++,i++`；\n\n  <img src=\"快速排序-quick-sort\\1-3\"  />\n\n  <img src=\"快速排序-quick-sort\\1-4\"  />\n\n2. 继续步骤1，会得到以下结果：\n\n<img src=\"快速排序-quick-sort\\1-5\"  />\n\n3. 此时满足`arr[l+1...j] < v`，`arr[j+1...i-1] > v`，再将`l`和`j`位置进行交换：\n\n<img src=\"快速排序-quick-sort\\1-6\"  />\n\n4. 重复步骤1-3，直到递归结束。\n\n代码如下：\n\n```cpp\n//\n// Created by Zxy on 2020/8/16.\n//\n#include <iostream>\n#include <cassert>\n#include <ctime>\n#include \"sortHelper.h\"\nusing namespace std;\n\n// 对arr[l...r]部分进行partition操作\n// 返回p，使arr[l...p-1] < arr[p]; arr[p+1...r] > arr[p]\ntemplate <typename T>\nint partition(T arr[], int l, int r){\n    T v = arr[l];\n    // arr[l+1...j] < v; arr[j+1...i) > v\n    // 初始状态时两个区间都为空\n    int j = l;\n    for(int i = l + 1; i <= r; ++i){\n        // 实际上当前值大于等于v时，将e都直接放在<v后面\n        if(arr[i] < v){\n            swap(arr[j + 1], arr[i]);\n            j++;\n        }\n    }\n    swap(arr[l], arr[j]);\n    return j;\n}\n\n// 对arr[l...r]部分进行快速排序\ntemplate <typename T>\nvoid __quickSort(T arr[], int l, int r){\n    if(l >= r) return;\n    int p = partition(arr, l, r);\n    __quickSort(arr, l, p - 1);\n    __quickSort(arr, p + 1, r);\n}\n\ntemplate <typename T>\nvoid quickSort(T arr[], int n){\n    __quickSort(arr, 0, n - 1);\n}\n\nint main(){\n    int *arr = generateRandomArray(10, 1, 50); // 产生10个1到50间的随机数\n    cout << \"排序前数组为：\" << endl;\n    printArray(arr, 10); // 打印数组\n    cout << endl;\n    quickSort(arr, 10);\n    cout << \"排序后数组为：\" << endl;\n    printArray(arr, 10);\n    cout << endl;\n    return 0;\n}\n```\n\n输出结果为：\n\n<img src=\"快速排序-quick-sort\\1-7\"  />\n\n#### 优化\n\n对于上述的快速排序算法有一个很大的缺点，如果数组近乎有序，复杂度可能退化至O(n^2)，大于`v`或者小于`v`的部分分配不均匀。比如对于数组`[3,1,1,2,2,2]`，经过第一次`partition`时，3放在了数组的末尾，左边5个数全部小于3，而右边没有大于3的数。\n\n对于这种情况，我们可以不取数组`l`处的值作为`v`，而是在数组中随机取一个值作为分界点`v`，然后再进行`partition`操作，此时快速排序复杂度的数学期望为O(nlogn)，具体的推导百度一下。修改如下：\n\n```cpp\ntemplate <typename T>\nint partition(T arr[], int l, int r){\n\t// 修改\n    swap(arr[rand() % (r - l + 1) + l], arr[l]);\n    T v = arr[l];\n    // arr[l+1...j] < v; arr[j+1...i) > v\n    // 初始状态时两个区间都为空\n    int j = l;\n    for(int i = l + 1; i <= r; ++i){\n        if(arr[i] < v){\n            swap(arr[j + 1], arr[i]);\n            j++;\n        }\n    }\n    swap(arr[l], arr[j]);\n    return j;\n}\n\ntemplate <typename T>\nvoid quickSort(T arr[], int n){\n\t// 修改\n    srand(time(NULL));\n    __quickSort(arr, 0, n - 1);\n}\n```\n\n直观的对比一下两种思路对完全随机数组和近乎有序数组的排序速度（其中`swap time`表示对于产生一个有序数组，随机取两个数进行交换，一共交换的次数）：\n\n<img src=\"快速排序-quick-sort\\1-8\"  />\n\n### 双路快速排序\n\n虽然解决了近乎有序数组的排序问题，但是对于数组中存在大量重复键值时，复杂度也可能退化为O(n^2)，如下图所示：\n\n<img src=\"快速排序-quick-sort\\2-1\"  />\n\n我们之前的`partition`操作中，当前值大于等于v时，将e都直接放在小于v最后一个的后面，所以可能出现上述情况。现在我们对于等于v时两边都可以进行收缩，使得`partition`操作更加均匀：\n\n<img src=\"快速排序-quick-sort\\2-2\"  />\n\n话不多说，看代码更容易理解：\n\n```cpp\ntemplate <typename T>\nint partition2(T arr[], int l, int r){\n    swap(arr[rand() % (r - l + 1) + l], arr[l]);\n    T v = arr[l];\n    // arr[l+1...i) <= v; arr(j...r] => v\n    // 初始状态时两个区间都为空\n    int i = l + 1, j = r;\n    while(1){\n        while(i <= r && arr[i] < v) i++;\n        while(j >= l + 1 && arr[j] > v) j--;\n        // 此时i指向第一个大于等于v的位置，j指向最后一个小于等于v的位置\n        if(i > j) break;\n        swap(arr[i], arr[j]);\n        i++;\n        j--;\n    }\n    swap(arr[l], arr[j]);\n    return j;\n}\ntemplate <typename T>\nvoid __quickSort2(T arr[], int l, int r){\n    if(l >= r) return;\n    int p = partition2(arr, l, r);\n    __quickSort2(arr, l, p - 1);\n    __quickSort2(arr, p + 1, r);\n}\ntemplate <typename T>\nvoid quickSort2(T arr[], int n){\n    __quickSort2(arr, 0, n - 1);\n}\n```\n\n<img src=\"快速排序-quick-sort\\2-3\"  />\n\n### 三路快速排序\n\n要给含有大量重复键值的数组排序同时避免对等于v的值进行交换，还可以进行三路的快速排序：\n\n<img src=\"快速排序-quick-sort\\3-1\"  />\n\n现在根据v将数组分为三个部分，分别是：`arr[l+1...lt] < v`，`arr[lt+1...i-1] == v`，`arr[gt...r] > v`。\n\n* 如果`e == v`，`i++`；\n* 如果`e < v`，将e和`lt+1`位置交换，同时`lt++，i++`；\n* 如果`e > v`，将e和`gt-1`位置交换，成为大于v的第一个位置，`gt--`；\n* 最后将`l`和`lt`位置交换，再对小于v部分和大于v部分继续排序。\n\n<img src=\"快速排序-quick-sort\\3-2\"  />\n\n<img src=\"快速排序-quick-sort\\3-3\"  />\n\n数组中`arr[l...lt-1] < v`，`arr[lt...gt-1] == v`，`arr[gt...r] > v`。\n\n代码如下：\n\n```cpp\ntemplate <typename T>\nvoid __quickSort3(T arr[], int l, int r){\n    if(l >= r) return;\n    swap(arr[l], arr[rand() % (r - l +1 ) + l]);\n    T v = arr[l];\n    int lt = l;     // arr[l+1...lt] < v\n    int gt = r + 1; // arr[gt...r] > v\n    int i = l + 1;    // arr[lt+1...i) == v\n    while(i < gt){\n        if(arr[i] < v){\n            swap(arr[i], arr[lt+1]);\n            i++;\n            lt++;\n        }\n        else if(arr[i] > v){\n            swap(arr[i], arr[gt-1]);\n            gt--;\n        }\n        else i++; // arr[i] == v\n    }\n    swap( arr[l] , arr[lt] );\n    __quickSort3(arr, l, lt-1);\n    __quickSort3(arr, gt, r);\n}\ntemplate <typename T>\nvoid quickSort3(T arr[], int n){\n    srand(time(NULL));\n    __quickSort3( arr, 0, n-1);\n}\n```\n\n<img src=\"快速排序-quick-sort\\3-4\"  />\n\n双路快速排序和三路快速排序都是在对近乎有序数组优化的基础上，对数组存在大量重复键值时进行优化，所以时间复杂度都是O(nlogn)。\n\n### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git","categories":["算法与数据结构"]},{"title":"C++11之lambda表达式","url":"/blog/2020/08/02/C-11之lambda表达式/","content":"\n学习C++11标准中的新特性——lambda表达式\n\n<!-- more-->\n\n### 向算法传递函数\n\n***\n\n如果需要sort按照自己定义的方式进行排序，需要使用其第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个**谓词**。\n\n***\n\n#### 谓词\n\n1. 定义：谓词是一个**可以调用的表达式**，返回的结果可以被调用\n2. 分类：一元谓词和二元谓词\n   1. 一元谓词：只接受单一的参数\n   2. 二元谓词：接受两个参数\n3. 接受谓词的算法对输入序列中的**元素**调用谓词，因此**元素**必须能转换为谓词的参数类型\n\n`sort`函数接受一个**二元谓词**，假如我们要按字符串的长度升序排序，可以定义一个比较函数`isShorter`：\n\n```cpp\n// 比较函数，用来按长度排序单词\n// 必须是引用类型！！！\nbool isShorter(const string &s1, const string &s2){\n    return s1.size() < s2.size();\n}\n// 按长度由短至长排序words\nsort(words.begin(), words.end(), isShorter);\n\n# words = {\"foxs\", \"jumps\", \"end\", \"kid\"}\n# 输出结果为end kid foxs jumps\n```\n\n***注：针对同一长度的单词，`sort`是不稳定的，如果要保持对应的字典序，可以调用`stable_sort`***\n\n### lambda表达式\n\n对于一个对象或者表达式，如果对其可以使用调用运算符`()`，则称它为可调用的，可以将其传入算法。一个`lambda`表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。\n\n---\n\n**与任何函数相似，一个`lambda`具有一个返回类型，一个参数列表和一个函数体**\n\n**不同的是，`lambda`可以定义在函数内部**\n\n---\n\n一个`lambda`表达式具有如下形式：\n\n```cpp\n[capture list] (parameter list) -> return type { function body }\n```\n\n* `[capture list]`（捕获列表）是一个`lambda`**所在函数中**定义的局部变量的列表（通常为空）\n* `return type`、`parameter list`和`function body`与普通函数一样，分别为返回类型，参数列表和函数体，但是`lambda`必须使用尾置返回\n\n我们可以忽略参数列表和返回类型，但必须永远包括捕获列表和函数体：\n\n```cpp\n// 我们定义了一个可调用对象f，它不接受参数，返回42\nauto f = [] { return 42; };\n```\n\n`lambda`的调用方式与普通函数相同，使用调用运算符：\n\n```cpp\n// 输出42\ncout << f() << endl;\n```\n\n在此例中，当调用`f`时，参数列表为空并且忽略了返回类型，`lambda`根据函数体代码确定返回类型，如果函数体只有一个`return`语句，则返回类型从返回表达式的类型推断而来，否则返回`void`。\n\n***注：如果函数体中包含任何单一`return`语句之外的内容，且未指定返回类型，返回`void`***\n\n#### 向lambda传递参数\n\n与一个普通函数调用类似，调用一个`lambda`给定实参被用来初始化`lambda`形参，类型需要匹配。但是`lambda`不能有默认参数（比如：`int fun(int a = 1, int b = 1) { return a + b; }`）。因此，一个`lambda`调用的实参数目永远和形参数目相等，一旦形参初始化完毕，就可以执行函数体了。\n\n我们可以写出来一个与`isShorter`功能完全一样的`lambda`函数：\n\n```cpp\n[] (const string &s1, const string &s2)\n\t{ return s1.size() < s2.size(); }\n```\n\n空捕获列表表示不使用函数中的局部变量，如下所示，之前的`sort`函数可以改写如下：\n\n```cpp\nsort(words.begin(), words.end(), \n\t[] (const string &s1, const string &s2)\n\t{ return s1.size() < s2.size(); });\n```\n\n#### 使用捕获列表\n\n假如我们现在要找到`words`中第一个长度大于`sz`的单词的位置，可以编写一个可以传递给`find_if`的可调用表达式。一个`lambda`表达式**只能使用明确指明的变量**，在下面的例子中，`lambda`会捕获`sz`，，并只有单一的`string`参数（因为`find_if`只支持一元谓词），其函数体会将`string`的大小与捕获的`sz`进行比较：\n\n```cpp\n[sz] (const string &s)\n{ return s.size() >= sz; };\n```\n\n##### 调用`find_if`函数\n\n使用此`lambda`，查到第一个长度大于等于给定`sz`元素\n\n```cpp\nauto wc = find_if(words.begin(), words.end(),\n     [sz] (const string &s)\n     { return s.size() >= sz; });\n// 输出满足size >= sz第一个元素的值和位置\n// 如果没有找到，返回words.end()的一个拷贝\n// 取sz = 4\ncout << \"value:\" << *wc << \"position:\" << wc - words.begin();\n# value:foxs    position:2\n```\n\n##### `for_each`算法\n\n打印出长度大于等于`sz`的所有单词：\n\n```cpp\nfor_each(wc, words.end(), [] (const string &s) { cout << s << \" \";});\n# foxs jumps\n```\n\n### lambda捕获和返回\n\n我们可以认为，当向一个函数传递一个`lambda`时，同时定义了一个新类型和该类型的对象，传递的参数就是此编译器生成的**类的类型**的**未命名对象**。\n\n**默认情况下，由`lambda`生成的类，数据成员包含捕获列表中的变量，在`lambda`对象创建时被初始化。**\n\n#### 值捕获（后面更改不会影响值）\n\n与参数传递不同之处在于，被捕获的变量的值在`lambda`创建时拷贝，而不是调用时拷贝\n\n```cpp\nsize_t v1 = 42; // 局部变量\nauto f = [v1] { return v1; };\nv1 = 0;\nauto j = f();\n# j为42；f保存我们创建它时的拷贝，因此修改v1不会影响lambda内对应的值\n```\n\n#### 引用捕获（后面更改会影响变量值）\n\n```cpp\nsize_t v2 = 42; // 局部变量\nauto f2 = [&v2] { return v2; };\nv2 = 0;\nauto jj = f2();\n# jj为0；f2保存v1的引用\n# 需要注意的是必须确保被引用的对象在lambda执行的时候是存在的\n# 如果可能的话，避免捕获指针或引用（C++ Primer 351页）\n```\n\n#### 隐式捕获\n\n我们可以让编译器根据`lambda`函数体中的代码来推断我们要使用哪些变量，在捕获列表中写一个`&`表示捕获引用，`=`表示采用值捕获方式，我们可以重写`find_if`函数\n\n```cpp\n// sz为隐式值捕获\nauto wc = find_if(words.begin(), words.end(),\n     [=] (const string &s)\n     { return s.size() >= sz; });\n```\n\n如果想对一部分变量使用值捕获，一部分使用引用捕获，可以混合使用隐式捕获和显示捕获：\n\n```cpp\nostream &os = cout;\nchar c = ' ';\n// os隐式引用捕获，c显示值捕获\nfor_each(wc, words.end(), [&, c] (const string &s) { os << s << c;});\n// os显示引用捕获，c隐式值捕获\nfor_each(wc, words.end(), [=, &os] (const string &s) { os << s << c;});\n```\n\n1. **当我们使用混合捕获时，捕获列表第一个变量必须是一个&或者=，定义了默认捕获方式为引用或值。**\n2. **混合捕获时，显示捕获的变量必须使用与隐式捕获不同的方式，即：显示引用捕获，隐式值捕获或者显示值捕获，隐式引用捕获。**\n\n#### 指定lambda返回类型\n\n标准库函数`transform`：接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中的每个元素调用可调用对象，并将结果写到目的位置：\n\n```cpp\n// 取绝对值\nvector<int> vv1{-1, 1, 3, -20, 7};\ntransform(vv1.begin(), vv1.end(), vv1.begin(),\n          [] (int i) { return i < 0 ? -i : i; });\n# 1,1,3,20,7\n```\n\n如果写成以下形式就会产生编译错误：\n\n```cpp\ntransform(vv1.begin(), vv1.end(), vv1.begin(),\n          [] (int i) { if (i < 0) return -i; else return i; });\n```\n\n这是因为函数体中不止一个`return`语句，`lambda`无法判断返回类型。如果我们需要为其定义返回类型，必须用尾置的方式：\n\n```cpp\ntransform(vv1.begin(), vv1.end(), vv1.begin(),\n          [] (int i) -> int { if (i < 0) return -i; else return i; });\n```\n\n### 参数绑定\n\n---\n\n对于只在一两个地方使用的函数，使用`lambda`是很方便的，多次使用或者函数体比较长的话定义一个函数来实现更好。但是对于捕获局部变量的`lambda`表达式来说，用函数代替就不太容易了。\n\n---\n\n在之前的`find_if`函数中，我们可以容易写出来一个相同功能的函数：\n\n```cpp\nbool check_size(const string &s, string::size_type sz){\n\treturn s.size() >= sz;\n}\n```\n\n但是`find_if`函数只支持一元谓词，直接使用肯定是不可以的。\n\n#### 标准库bind函数\n\n使用`bind`函数可以解决上述问题，此函数定义在头文件`functional`中，可以将`bind`函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。\n\n调用形式为：\n\n```cpp\nauto newCallable = bind(callable, arg_list)\n```\n\n* `newCallable`本身是一个可调用对象\n* `arg_list`是一个逗号分隔的参数列表，对应给定`callable`的参数\n\n当我们调用`newCallable`时，`newCallable`会调用`callable`，并传递给它`arg_list`中的参数。\n\n`arg_list`中的参数可能包含形如`_n`的名字，其中`n`是一个整数，称为**占位符**，表示占据了传递给`newCallable`参数的位置。\n\n##### 绑定`check_size`的`sz`参数\n\n一个简单的例子，使用`bind`生成一个调用`check_size`的对象：\n\n```cpp\n// check4是一个可调用对象，接受一个string类型的参数\n// 使用此string和值4调用check_size\n// 注意要使用using std::placeholder::_1或using namespace std::placeholders\nauto check4 = bind(check_size, _1, 4);\n# 此bind调用只有一个占位符，表示check4只接受单一参数\n# 占位符在arg_list的第一个位置，表示check4的此参数对应check_size的第一个参数，是const string&\n# 因此调用check4必须传递给它一个string类型的参数，check4将其传给check_size\n```\n\n```cpp\nstring s = \"hello\";\nbool b1 = check4(s);\ncout << b1 << endl;\n# 1\n```\n\n此时我们可以改写`find_if`函数：\n\n```cpp\nauto wcc = find_if(words.begin(), words.end(),\n     \tbind(check_size, _1, sz));\nfor_each(wcc, words.end(), [] (const string &s) { cout << s << \" \";});\n# foxs jumps\n// 对比之前的find_if\nauto wc = find_if(words.begin(), words.end(),\n     [sz] (const string &s)\n     { return s.size() >= sz; });\n```\n\n### Reference\n\n《C++ Primer》370-383","tags":["lambda"],"categories":["C++"]},{"title":"LeetCode63-不同路径Ⅱ","url":"/blog/2020/07/26/LeetCode63-不同路径Ⅱ/","content":"\n本题与[**97交错字符串**](http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more)，[**174-地下城游戏**](https://leetcode-cn.com/problems/dungeon-game/)分析与解法相似\n\n### 题目描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n<!-- more-->\n\n<img src=\"LeetCode63-不同路径Ⅱ\\question\" style=\"zoom:80%;\" />\n\n<img src=\"LeetCode63-不同路径Ⅱ\\question1\" style=\"zoom:;\" />\n\n### 分析\n\n对于输入为二维数组的题目中出现了只能向下或者向右移动的字眼，一般来说考虑动态规划。这道题的不同之处是设置了障碍物，如果遇到了1则表示**不可达**，假如`m = 2, n = 2`，并且无障碍物，我们可以得到下图：\n\n<img src=\"LeetCode63-不同路径Ⅱ\\solution1\" style=\"zoom:80%;\" />\n\n那么对于`(0,1)`和`(1,0)`位置，都只有一条通路可达：\n\n<img src=\"LeetCode63-不同路径Ⅱ\\solution2\" style=\"zoom:80%;\" />\n\n最后对于末尾处`(1,1)`，它的上边和左边可以到达，所以到达它的路径为`1 + 1 = 2`条：\n\n<img src=\"LeetCode63-不同路径Ⅱ\\solution3\" style=\"zoom:80%;\" />\n\n通过观察我们发现，在不遮挡的情况下，可以到达当前位置的路径数就是当前位置的上边和左边路径数的总和。\n\n对于存在障碍物的情况，我们直接令到达它的路径数为0，这样也就满足的题目的要求。\n\n#### 定义dp数组\n\n根据上述分析，`dp[i][j]`表示有多少条路径可以到达`(i,j)`，如果网格中此处值为1，也就是有障碍的情况下，`dp[i][j] = 0`。表示无法到达，路径数为0。\n\n#### 初始化\n\n在**交错字符串**中使用的是从前往后遍历的思想，这里换一种思路，从后往前进行遍历。对于最后一个位置`dp[m-1][n-1]`，如果第`m - 1`行或者`n - 1`列其他位置可以到达最后位置，则为1，否则为0，只要在网格中往回走遇到了1，在那之后`dp`数组的值都为0。\n\n```cpp\nlong long dp[m][n];\nfor(int i = 0; i < m; ++i){\n\tfor(int j = 0; j < n; ++j)\n\t\tdp[i][j] = 0;\n}\n// 最后一行到end初始化为1\n// 注意有有一个为1，后面都被阻挡\nfor(int j = n - 1; j >= 0 && obstacleGrid[m - 1][j] == 0; --j){\n\tdp[m - 1][j] = 1; \n}\n// 最后一列到end初始化为1\nfor(int i = m - 1; i >= 0 && obstacleGrid[i][n - 1] == 0; --i){\n\tdp[i][n - 1] = 1;\n}\n```\n\n#### 状态转移方程\n\n```cpp\nif(obstacleGrid[i][j] == 0)\n    dp[i][j] = dp[i+1][j] + dp[i][j+1];\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        // 从后往前必须long long\n        long long dp[m][n];\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j)\n                dp[i][j] = 0;\n        }\n        // 最后一行到end初始化为1\n        // 注意有有一个为1，后面都被阻挡\n        for(int j = n - 1; j >= 0 && obstacleGrid[m - 1][j] == 0; --j){\n                dp[m - 1][j] = 1; \n        }\n        // 最后一列到end初始化为1\n        for(int i = m - 1; i >= 0 && obstacleGrid[i][n - 1] == 0; --i){\n                dp[i][n - 1] = 1;\n        }\n        for(int i = m - 2; i >= 0; --i){\n            for(int j = n - 2; j >= 0; --j){\n                if(obstacleGrid[i][j] == 0)\n                {\n                    dp[i][j] = dp[i + 1][j] + dp[i][j + 1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/unique-paths-ii/solution/jian-dan-dpbi-xu-miao-dong-by-sweetiee/","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode97-交错字符串","url":"/blog/2020/07/18/LeetCode97-交错字符串/","content":"\n在看了题解之后才慢慢意识到，这道题和[**63-不同路径Ⅱ**](https://leetcode-cn.com/problems/unique-paths-ii/)，[**174-地下城游戏**](https://leetcode-cn.com/problems/dungeon-game/)是非常相似的，题目虽然具有一定难度，但都是有迹可循。它们都可以抽象为在二维数组中，从起始到末尾找路径的问题。上面两个问题还未更新，跳转位置是题目链接。\n\n### 题目描述\n\n给定三个字符串 *s1*, *s2*, *s3*, 验证 *s3* 是否是由 *s1* 和 *s2* 交错组成的。\n\n<!-- more-->\n\n<img src=\"LeetCode97-交错字符串\\question1\"  />\n\n### 分析\n\n交错的意思是：如果第一次取了`s1`，那么第二次必须取`s2`，反之亦然。取多少和哪一个先取都是不一定的，只是要求交错即可。\n\n对于`s1 = \"bacc\", s2 = \"aabcce\", s3 = \"abaacbccec\"`，这个示例是可以匹配的，按照**可以匹配**的过程分析如下：\n\n1. 首先只能取`s2`中的`a`，再继续往下取`a`时，与`s3`已经无法匹配了；\n2. **再取`s1`中的`b`或者`ba`都是可以的**，这里取`b`\n3. 再取`s2`中的`a`，此时匹配到`aba`\n4. 再取`s1`中的`ac`，此时匹配到`abaac`\n5. 再取`s2`中的`bcce`，此时匹配到`abaacbbe`\n6. 再取`s1`中的`c`，此时完全匹配\n\n#### 定义dp数组\n\n`dp[i][j]`表示`s1`的前`i`个字符和`s2`的前`j`个字符是否匹配，我们可以将刚才的分析表示为下图：\n\n<img src=\"LeetCode97-交错字符串\\question1_dp\" style=\"zoom:80%;\" />\n\n上图是不是很像一个路径问题，而且只能向右或者向下移动，进一步说明是用动态规划来解决，如果还可以往上或者左，那就不能用动态规划来做了，得考虑`dfs`之类的算法。\n\n分析中的第二步，也就是图中`true`的其他可能。\n\n#### 初始化\n\n```cpp\n// 都为空时匹配\ndp[0][0] = 1\n// 对于第一行和第一列，当前值若无法匹配，则当前值和之后的都无法匹配\nif(i == 0) dp[0][j] = s2[0,j) == s3[0,j)\nif(j == 0) dp[i][0] = s2[0,i) == s3[0,i)\n```\n\n#### 状态转移方程\n\n```cpp\ndp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1])\n\t|| (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1])\n```\n\n### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        int m = s1.size(), n = s2.size();\n        if(m + n != s3.size()) return false;\n        // bool dp[m + 1][n + 1] = {false};\n        bool **dp = new bool*[m + 1];\n        for(int i = 0; i <= m; ++i){\n            dp[i] = new bool[n + 1];\n        }\n        for(int i = 0; i <= m; ++i){\n            for(int j = 0; j <= n; ++j){\n                dp[i][j] = 0;\n            }\n        }\n        // 初始化\n        dp[0][0] = true;\n        for(int j = 1; j <= n && (s2.substr(0, j) == s3.substr(0, j)); ++j) \n            dp[0][j] = true;\n        for(int i = 1; i <= m && (s1.substr(0, i) == s3.substr(0, i)); ++i) \n            dp[i][0] = true;\n        \n        for(int i = 1; i <= m; ++i){\n            for(int j = 1; j <= n; ++j){\n                dp[i][j] = (dp[i - 1][j] && (s1[i - 1] == s3[i + j - 1])) ||\n                            (dp[i][j - 1] && (s2[j - 1] == s3[i + j - 1]));\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/","tags":["动态规划"],"categories":["LeetCode"]},{"title":"Verilog基础2","url":"/blog/2020/07/14/Verilog基础2/","content":"\n## Verilog基础\n\n学习verilog基础语法2\n\n<!-- more-->\n\n### 第五章 FPGA基本实践\n\n#### 流水灯实践\n\n```verilog\nmodule v1(\n    input clk,\t\t\t// 时钟输入\n    input rst,\t\t\t// 复位信号\n    output [7:0] led\t// LED输出\n    );\nreg [7:0] ledtemp = 8'b0000_0001;\t// led初始值\nreg [23:0] divclk_cnt = 0;\t\t\t// 24位计数值\nreg divclk = 0;\t\t\t\t\t\t// 低频时钟\nassign led = ledtemp;\t// 实现将寄存器变量值赋给LED输出\n\tparameter halfduty_cntvalue = 12500000;\nalways @ ( posedge clk )\t\t\t// 把系统时钟分频50Mhz/25000000 = 2Hz\nbegin\n\tif( divclk_cnt == halfduty_cntvalue)\t// 计数满后翻转\n\t\tbegin\n\t\t\tdivclk = ~divclk;\n\t\t\tdivclk_cnt = 0;\n\t\tend\n\t\telse begin\n\t\t\tdivclk_cnt = divclk_cnt + 1'b1;\n\t\tend\n\tend\nalways @ ( posedge divclk )\nbegin\n\tif( !rst )\n\t\tbegin\n\t\t\tledtemp = 8'b0000_0001;\n\t\tend\n\telse if ( ledtemp[7] == 1 )\n\t\tledtemp = 8'b0000_0001;\t\t// 瀹炵幇寰幆绉讳綅\n\telse\n\t\tledtemp = ledtemp << 1;\nend\n\nendmodule\n```\n\n仿真代码：\n\n```verilog\nmodule sim3;\nreg clk;\nreg rst;\nwire led;\n\nv1 uut( clk, rst, led );\ninitial begin\n    clk = 0;\n    rst = 1;\nend\nalways #10 clk = ~clk; // 每隔10ns反转，周期是20ns，频率也就是50MHz\nendmodule\n```\n\n仿真图如下：\n\n<img src=\"Verilog基础2\\image1\"  />\n\n从**ledtemp**可以看出进行了左移的操作\n\n<img src=\"Verilog基础2\\image2\"  />\n\n完成一次循环之后回到**00000001**","categories":["FPGA"]},{"title":"Verilog基础1","url":"/blog/2020/07/14/Verilog基础1/","content":"\n## Verilog基础\n\n学习verilog基础语法1\n\n<!-- more-->\n\n## 第二章 基本语法\n\n#### 数据类型及变量\n\n查找表**LUT**\n\n1. 线网型变量wire\n   1. 信号间连接作用，只能将其连接到某处而不能进行赋值\n   2. 没有时序限定，与其它块语句并行执行\n   3. 不保存状态，值随时可以改变，不受时钟信号限制\n   4. input和output默认位wire\n   5. wire是组合逻辑的赋值，在时序控制always**块外**并使用**assign**进行赋值\n2. 寄存器类型reg\n   1. 值可以改变\n   2. 常用来表示时序控制always块内的指定信号\n3. 符号常量parameter\n\n#### 语句\n\n1. 连续赋值语句**assign**\n\n   assign语句用于对wire型变量赋值，例如`assign c = a & b`，a，b是wire型变量或寄存器变量，c必须是wire型变量或其他线网型变量。\n\n2. 过程赋值语句**`=`和`<=`**\n\n   1. 用于对reg型变量赋值，在过程块中使用过程赋值语句\n   2. 非阻塞(`<=`)：多条非阻塞赋值在过程块中同时完成赋值操作，多条语句相当于同时执行\n   3. 阻塞(`=`)：在一个块语句中，如果有多条阻塞赋值语句，在前面的赋值语句没有完成之前，后面的语句就不能执行`=`\n   4. 对于阻塞，在当前时钟就赋值了，而非阻塞是在下一个时钟进行赋值\n\n3. 过程说明语句**always**\n\n   1. always块包含一个或一个以上的语句（如：过程赋值语句、条件语句和循环语句等），在运行的过程中，在时钟控制下被反复执行，也就是说，时钟有效边沿来了就执行\n   2. 在always块中被赋值的只能是寄存器reg型变量\n   3. 书写方法：`always @ (敏感信号表达式)`\n\n   ```verilog\n   always @ (clk) // 只要clk发生变化就触发\n   always @ (posedge clk) // clk上升沿触发\n   always @ (negedge clk) // clk下降沿触发\n   always @ (negedge clk1 or posedge clk2) // clk1下降沿或者clk2上升沿触发\n   always @ (*) // 任何输入信号变化了都触发\n   ```\n\n\n4. 结构说明语句initial\n\ninitial语句用于对寄存器变量赋予初值\n\n5. 条件语句**if-else**\n\n6. 条件语句**case**\n\n   ```\n   case(表达式)\t<case分支项>\tendcase\n   case 分支项的一般格式：\n   分支表达式：语句；\n   默认项(default)  语句；\n   ```\n\n7. 循环语句\n\n   1. **forever**语句：连续执行的语句\n\n   ```\n   格式: forever begin 语句块 end\n   forever常用于仿真代码中\n   ```\n\n   2. **repeat**\n   3. **while**\n   4. **for** 尽量少用，循环次数固定\n\n## 第三章 组合逻辑电路\n\n#### 多数表决器的实现\n\n1. **逻辑表达式**：`f = a&b|a&c|b&C`\n2. **RTL分析**：在左侧的流程导航器`Flow Navigator`中的详细设计`Elaborated Design` 部分按右键，在弹出的菜单中选`New Elaborated Design`之后得到RTL电路图（RTL意思是寄存器传输级，生成寄存器传输级别的电路，并非综合后的电路），在开发过程中RTL分析不是必须的，但是能帮助我们检测错误。\n3. **综合**：将RTL级别的设计描述转换成逻辑门级的逻辑描述。单击流程导航窗口综合`Synthesis`项下的`Run Synthesis`进入综合，综合完毕后点击`Schematic`打开原理图。\n\n4. **仿真**：新建仿真文件，然后编辑内容，再点击`Run Simulation`\n5. **编程和调试**：首先生成比特流，然后再进行硬件调试\n\n#### **3-8译码器设计和IP核**\n\n1. 译码器设计步骤与多数表决器相同，也是组合逻辑电路\n2. **IP核**：点击顶部的**Tools**，然后点击**Create and Package IP**项，之后一直**Next**，进入以下页面：\n\n<img src=\"Verilog基础1\\image1\" style=\"zoom:80%;\" />\n\n没什么问题后点击**Review and Package**中的**Package IP**\n\n#### 调用IP核实现多数表决器\n\n## 第四章 时序逻辑电路\n\n时钟同步状态机：时序电路的状态变化发生的时间有一个统一的时钟信号的指定边沿来激励。\n\n#### 实现11001序列发生器\n\n1. 画出状态转移图\n\n<img src=\"Verilog基础1\\image2\"  />\n\n2. 画出状态转移表\n\n| Q0 Q1 Q2 | Q0* Q1* Q2* |  Z   |\n| :------: | :---------: | :--: |\n|   000    |     001     |  1   |\n|   001    |     010     |  1   |\n|   010    |     011     |  0   |\n|   011    |     100     |  0   |\n|   100    |     000     |  1   |\n\n3. 根据状态转移表画卡诺图求解。（未使用的状态用无关项表示）\n\n| Q2/Q0Q1 |  00   |  01   |  11   |  10   |\n| :-----: | :---: | :---: | :---: | :---: |\n|    0    | 001/1 | 011/0 | ddd/d | 000/1 |\n|    1    | 010/1 | 100/0 | ddd/d | ddd/d |\n\n4. 得到转移方程和输出方程\n\n   1. 转移方程：\n      $$\n      Q0* = Q1Q2\\\\\n      Q1* = Q1'Q2 + Q1Q2'\\\\\n      Q2* = Q0'Q2'\n      $$\n\n   2. 输出方程\n\n   $$\n   Z = Q1'\n   $$\n\n5. 判断自启动，FPGA设计可以给出初始态，所以可以忽略\n\n6. 使用D触发器，写出激励方程\n   $$\n   D0 = Q0* = Q1Q2\\\\\n   D1 = Q1* = Q1'Q2 + Q1Q2'\\\\\n   D2 = Q2* = Q0'Q2'\n   $$\n\n7. 建立工程编写程序\n\n```verilog\nmodule seq_11001_1(\n\tinput  clk,\n\toutput led\n    );\nreg [5:0] divclk_cnt = 0;\nreg divclk = 0;\nreg q0 = 0;\nreg q1 = 0;\nreg q2 = 0;\nalways @ ( posedge clk )\nbegin\n\tif(divclk_cnt == 25) // 50分频 25低25高 默认32位宽\n\tbegin\n\t\tdivclk = ~divclk;\n\t\tdivclk_cnt = 0;\t\t\n\tend\n\telse begin\n\t\tdivclk_cnt = divclk_cnt + 1'b1;\n\tend\nend\n\nassign led = ~q1;\nalways @ (posedge divclk)\nbegin\n\tq0 <= q1&q2;\n\tq1 <= ~q1&q2|q1&~q2;\n\tq2 <= ~q0&~q2;\nend\t\nendmodule\n```\n\n仿真文件：\n\n```verilog\nmodule sim1;\nreg clk;\nwire led;\nseq_11001_1 uut( clk, led );\ninitial begin\n    clk = 0;\nend\nalways #10 clk = ~clk;\nendmodule\n```\n\n8. 仿真\n\n<img src=\"Verilog基础1\\image3\"  />\n\n从图可知，和状态转移表一致\n\n#### 状态图直接描述法实现序列发生器\n\n根据上部分**1**中的状态转移图可以直接实现**11001**序列发生器，实现代码如下：\n\n```verilog\nmodule seq_11001_2(\n    input clk,\n    output led\n    );\nreg led;\nreg [31:0] divclk_cnt = 0;\nreg divclk = 0;\nreg [2:0] state = state_A;\nparameter // 符号常量\nstate_A = 3'b000,state_B = 3'b001,state_C = 3'b010,state_D = 3'b011,state_E = 3'b100;\nalways @ ( posedge clk )\nbegin\n\tif(divclk_cnt == 25)\n\tbegin\n\t\tdivclk = ~divclk;\n\t\tdivclk_cnt = 0;\n\tend\n\telse begin\n\t\tdivclk_cnt = divclk_cnt + 1;\n\tend\nend\nalways @ ( posedge divclk )\nbegin\n\tcase( state )\n\t\tstate_A:begin\n\t\t\tstate <= state_B;\n\t\t\tled <= 1;\n\t\tend\n\t\tstate_B:begin\n\t\t\tstate <= state_C;\n\t\t\tled <= 1;\n\t\tend\n\t\tstate_C:begin\n\t\t\tstate <= state_D;\n\t\t\tled <= 0;\n\t\tend\n\t\tstate_D:begin\n\t\t\tstate <= state_E;\n\t\t\tled <= 0;\n\t\tend\n\t\tstate_E:begin\n\t\t\tstate <= state_A;\n\t\t\tled <= 1;\n\t\tend\n        // 表示当前状态不属于以上状态，让状态回到state_A\n\t\tdefault:begin\n\t\t\tstate <= state_A;\n\t\t\tled <= 1;\n\t\tend\n\tendcase\nend\n\nendmodule\n```\n\n仿真图如下：\n\n<img src=\"Verilog基础1\\image4\"  />\n\n当`state = 000`时，在`divclk`的下一个上升沿时`led = 1`，以此类推\n\n","categories":["FPGA"]},{"title":"LeetCode718-最长重复子数组","url":"/blog/2020/07/03/LeetCode718-最长重复子数组/","content":"\n### 题目描述\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n<!-- more-->\n\n<img src=\"LeetCode718-最长重复子数组\\示例.png\" style=\"zoom: 80%;\" />\n\n### 分析\n\n题目的意思很好理解，如示例所示，公共的子数组除了单一的数值`[1],[2],[3]`，也有`[2,1],[3,2,1]`这些数组，其中最长的就是`[3,2,1]`这个数组，长度为3。像题目出现**最长，最短**之类的字都可以考虑用动态规划去解决。\n\n#### 一、定义dp数组的含义\n\n数组A长5，数组B长5，我们假设存在一个`6×6`的`dp`矩阵，使得矩阵坐标从1开始，同时保证边界位置上的计算，并初始化所有值为0。**矩阵表示固定A的值时，到B数组的当前值与到A固定值的公共数组长度**：\n\n<img src=\"LeetCode718-最长重复子数组\\index.png\"  />\n\n我们固定A数组，然后去遍历B数组。假如`A[i]=B[j]`时，公共数组的长度在上一次长度的基础上+1，否则不变，在后续分析中可以看到。\n\n比如说`A[0]=1`，此时遍历B数组，`B[0]=3`，两个值不等。因为我们建立数组时候起始坐标是从1开始的，所以`dp[1][1] = 0`。继续遍历B数组，可以得到以下结果：\n\n```\ndp[1][2] = 0\ndp[1][3] = 1\ndp[1][4] = 0\ndp[1][5] = 0\n```\n\n<img src=\"LeetCode718-最长重复子数组\\index1.png\"  />\n\n接下来改变A值，`A[1]=2`，可以得到：\n\n```\ndp[2][1] = 0\ndp[2][2] = 1\ndp[2][3] = 0\ndp[2][4] = 0\ndp[2][5] = 0\n```\n\n<img src=\"LeetCode718-最长重复子数组\\index2.png\"  />\n\n同理`A[2]=3`：\n\n<img src=\"LeetCode718-最长重复子数组\\index3.png\"  />\n\n当`A[3]=2,B[1]=2`时，此时满足`value(A)==value(B)`，所以`dp[4][2] = dp[3][1] + 1 = 2 `，如图：\n\n<img src=\"LeetCode718-最长重复子数组\\index4.png\"  />\n\n当`A[4]=1,B[2]=1`时，此时满足`value(A)==value(B)`，所以`dp[5][3] = dp[4][2] + 1 = 3`，如图：\n\n<img src=\"LeetCode718-最长重复子数组\\index5.png\"  />\n\n遍历完一次B数组后更新最大长度，所以最后最大的公共数组长度就是3。\n\n#### 二、状态转移方程\n\n根据上述分析，可以得到：\n\n```cpp\nif(A[i-1] == B[j-1])\n    dp[i][j] = dp[i-1][j-1] + 1;\n```\n\n#### 三、代码实现\n\n```cpp\nclass Solution {\npublic:\n    int findLength(vector<int>& A, vector<int>& B) {\n        int res = 0;\n        int **dp = new int*[A.size()+1];\n        for(int i = 0; i < A.size() + 1; i++){\n            dp[i] = new int[B.size()+1];\n        }\n        for(int i = 0; i < A.size() + 1; i++){\n            for(int j = 0; j < B.size() + 1; j++){\n                dp[i][j] = 0;\n            }\n        }\n        // 从前往后\n        for(int i = 1; i <= A.size(); i++){\n            for(int j = 1; j <= B.size(); j++){\n                if(A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\n                res = max(res, dp[i][j]);\n            }\n        }\n        return res;\n    }\n};\n```\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"堆排序(heap sort)","url":"/blog/2020/06/27/堆排序-heap-sort/","content":"\n堆排序是一种特殊的排序算法，涉及到了优先级的概念\n\n更新于2020/7/12\n\n### 本次学习要点\n\n1. 了解优先队列的一些概念\n2. 堆排序概念及实现\n\n<!-- more-->\n\n### 优先队列\n\n* 普通队列：FIFO\n* 优先队列：出队顺序与入队无关，与优先级有关\n\n为什么选择优先队列？\n\n比如：在10000000个元素中选择前100名？(在N个元素中选择前M个)\n\n* 排序算法复杂度 O(NlogN)\n* 优先队列 O(NlogM)\n\n优先队列的实现方法：\n\n<img src=\"D:堆排序-heap-sort\\实现方式.png\" style=\"zoom:80%;\" />\n\n使用普通数组在出队时需要遍历一次找到优先级最高的元素；顺序数组在每次插入的时候也要遍历一次找到相应的位置；使用堆这种结构可以让入队出队复杂度都为O(logN)。\n\n### 堆的基本实现\n\n#### 二叉堆(Binary Heap)\n\n二叉堆类似于二叉树，是一种树状结构，可以用数组来存储二叉堆，以最大堆为例。\n\n最大堆：\n\n* **堆中的某个节点值不大于其父亲节点(不意味着层数越高，数值越大)**\n* **堆总是一棵完全二叉树(这也是可以用数组表示的原因)**\n\n<img src=\"堆排序-heap-sort\\二叉堆1.png\" style=\"zoom:80%;\" />\n\n给每个节点按照从上到小，从左到右进行编号，可以有以下的性质：\n\n* **左节点的序号是父节点的二倍**\n* **右边序号为父节点的二倍加1**\n\n<img src=\"堆排序-heap-sort\\二叉堆2.png\" style=\"zoom:80%;\" />\n\n用1来做起始标号是经典实现办法，数组对应的标号就是节点的索引：\n\n<img src=\"堆排序-heap-sort\\数组1.png\"  />\n\n```cpp\n# 找到i的父节点序号\nparent[i] = i / 2\n# i节点的孩子节点序号\nleftChild[i] = 2 * i\nrightChild[i] = 2 * i + 1\n```\n\n构建堆的基本结构：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\npublic:\n    MaxHeap(int capacity){\n        data = new Item[capacity+1];\n        count = 0;\n    }\n    ~MaxHeap(){\n        delete[] data;\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count == 0;\n    }\n};\n```\n\n#### 添加元素(Shift Up)\n\n由于是用数组实现的堆，所以添加一个新的元素相当于在数组的末尾添加了一个元素：\n\n<img src=\"堆排序-heap-sort\\数组2.png\"  />\n\n相应的树形结构如下：\n\n<img src=\"堆排序-heap-sort\\shiftup1.png\" style=\"zoom:80%;\" />\n\n显然此时不符合最大堆的定义，新加入的52大于其父节点16，所以两个需要交换位置，以此类推，将52放在合适的位置，如下图所示：\n\n<img src=\"堆排序-heap-sort\\shiftup2.png\" style=\"zoom: 67%;\" />\n\n最终数组里的值为下图：\n\n<img src=\"堆排序-heap-sort\\数组3.png\"  />\n\n**Shift Up**代码实现(在基本结构基础上)：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\n    int capacity;\n    void shiftUp(int k){\n        // 孩子节点大于父节点需要交换，并更新节点位置\n        while( k > 1 && data[k/2] < data[k] ){\n            swap( data[k/2], data[k] );\n            k /= 2;\n        }\n    }\npublic:\n    MaxHeap(int capacity){\n        data = new Item[capacity+1];\n        count = 0;\n        this->capacity = capacity;\n    }\n    void insert(Item item){\n        assert( count + 1 <= capacity );\n        //添加新元素\n        data[count+1] = item;\n        count ++;\n        shiftUp(count);\n    }\n```\n\n#### 取出元素(Shift Down)\n\n对于堆来说，每次只能取根节点的那个元素，在这里就是取最大的元素。\n\n取出最大的元素后，根节点的位置就空出来了，这时候把最后一个元素补充到根节点处(保证仍然是一棵完全二叉树)，此时作为计数的变量`count--`，最后一个数组中的元素可以不动，使用`count`来卡住边界。\n\n<img src=\"堆排序-heap-sort\\shiftdown1.png\" style=\"zoom:80%;\" />\n\n此时数组中的元素为：\n\n<img src=\"堆排序-heap-sort\\数组4.png\"  />\n\n此时16也不满足最大堆的定义，接下来要调整这些元素的位置。将16一步一步的向下挪，直到合适的位置，所以叫**Shift Down**，不过每次下挪，有两个方向可以走，具体怎么选？**需要找到子节点中更大的那个值进行交换**，这样就可以保证子节点一定是不大于父节点的，过程如下：\n\n<img src=\"堆排序-heap-sort\\shiftdown2.png\" style=\"zoom:80%;\" />\n\n此时数组中的元素为：\n\n<img src=\"堆排序-heap-sort\\数组5\"  />\n\n**Shift Down**代码实现(在基本结构基础上)：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\n    int capacity;\n    void shiftDown(int k){\n        // 判断k是否有孩子\n        // 对于完全二叉树，有左孩子就代表一定有孩子\n        while( 2*k <= count ){\n            int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置\n            // j+1为右孩子，需要判断是否存在\n            // 再判断应该和哪个孩子交换\n            if( j+1 <= count && data[j+1] > data[j] ) // 右孩子大\n                j ++; // j代表右孩子，否则为左孩子\n            // data[j] 是 data[2*k]和data[2*k+1]中的最大值\n            if( data[k] >= data[j] ) break;\n            swap( data[k] , data[j] );\n            k = j; // 交换后的新节点，继续Shift Down\n        }\n    } \npublic:\n    Item extractMax(){\n        assert( count > 0 );\n        Item ret = data[1];\n\n        swap( data[1] , data[count] );\n        count --;\n        shiftDown(1);\n\n        return ret;\n    }\n    Item getMax(){\n        assert( count > 0 );\n        return data[1];\n    }\n};\n```\n\n#### Heapify(将普通数组变为堆)\n\n<img src=\"堆排序-heap-sort\\数组6.png\"  />\n\n对于以上数组，可以直接构建成堆，不用先进行插入元素，二叉树形式为下图：\n\n<img src=\"堆排序-heap-sort\\heapify1.png\" style=\"zoom:80%;\" />\n\n对于上图的树来说，所有的叶子节点都是一个最大堆：\n\n<img src=\"堆排序-heap-sort\\heapify2\" style=\"zoom:80%;\" />\n\n第一个非叶子节点的位置为`count/2`，即`10/2=5`，对于每个非叶子节点进行**Shift Down**操作。\n\n<img src=\"堆排序-heap-sort\\heapify3\" style=\"zoom: 67%;\" />\n\n**Heapify**代码实现：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\n    int capacity;\n    void shiftDown(int k){\n        // 判断k是否有孩子\n        // 对于完全二叉树，有左孩子就代表一定有孩子\n        while( 2*k <= count ){\n            int j = 2*k; \n            // 在此轮循环中,data[k]和data[j]交换位置\n            // j+1为右孩子，需要判断是否存在\n            // 再找到值更大的孩子\n            if( j+1 <= count && data[j+1] > data[j] ) \n                j ++;\n            // 如果孩子中最大值小于等于父节点的值，就不用交换了\n            if( data[k] >= data[j] ) break;\n            swap( data[k] , data[j] );\n            // 交换后的新节点，继续Shift Down\n            k = j; \n        }\n    } \npublic:\n    // 根据数组直接构造最大堆\n    MaxHeap(Item arr[], int n){\n        data = new Item[n+1];\n        capacity = n;\n\n        for( int i = 0 ; i < n ; i ++ )\n            data[i+1] = arr[i];\n        count = n;\n\n        for( int i = count/2 ; i >= 1 ; i -- )\n            shiftDown(i);\n    }\n    Item extractMax(){\n        assert( count > 0 );\n        Item ret = data[1];\n\n        swap( data[1] , data[count] );\n        count --;\n        shiftDown(1);\n\n        return ret;\n    }\n};\n```\n\n### 原地堆排序(从小到大)\n\n在之前构建一个堆需要额外的n个空间，实际上给定数组时候在原地也可以进行堆排序，过程如图所示：\n\n<img src=\"堆排序-heap-sort\\原地1.png\" style=\"zoom:80%;\" />\n\n* 先对数组进行`Heapify`操作，则V就是最大值，V和W进行交换，此时最大值在末尾\n* 此时V之前的数组不再是最大堆，对W进行`ShiftDown`操作使之前的数组再次成为最大堆\n* 再次把此时的V和W(倒数第二个元素)进行交换，以此类推。\n\n**此时的索引是从0开始的**，所以最后一个非叶子节点的索引为`(count-1)/2`，对于节点**i**，有：\n\n```cpp\nparent[i] = (i - 1) / 2;\nleft child[i] = 2 × i + 1;\nright child[i] = 2 × i + 2;\n```\n\n<img src=\"堆排序-heap-sort\\原地2.png\" style=\"zoom:80%;\" />\n\n对应的数组为：\n\n<img src=\"堆排序-heap-sort\\原地3.png\"  />\n\n代码实现：\n\n```cpp\npublic:\nvoid heapsort(T arr[], int n){\n    // heapify\n    // from 第一个非叶子节点\n    for(int i = (n - 1) / 2; i >= 0; --i)\n        __shiftDown(arr, n, i);\n    // i最后为1，当只有也给元素时无需进行操作\n    for(int i = n - 1; i > 0; --i){\n        swap(arr[0], arr[i]);\n        __shiftDown(arr, i, 0);\n    }\n}\nprivate:\nvoid __shiftDown(T arr[], int n, int k){\n    // 从0开始索引，k为父节点\n    while(2 * k + 1 < n){ // 如果左孩子存在\n        int j = 2 * k + 1;\n        // 以下操作是为了与左右孩子中更大的那个交换\n        if(j + 1 < n && arr[j+1] > arr[j])\n            j += 1;\n        if(arr[k] >= arr[j])\n            break;\n        swap(arr[k], arr[j]);\n        k = j;\n    } \n        \n}\n```\n\n### 索引堆(Index Heap)\n\n当进行堆排序之后，坐标和值的关系也就不复存在了，如果我们要继续使用坐标和值之间的关系，就需要对索引进行堆排序，以最大索引堆为例：\n\n<img src=\"堆排序-heap-sort\\index_heap1.png\" style=\"zoom:80%;\" />\n\n* `data`数组并未改变，只有`index`数组发生了改变(**根据data改变index**)\n* 堆顶的元素`index[1] = 10`，表示堆顶的元素是**10索引**所指向的`data[10]`，即62\n* 同理可得，`index[2] = 9`表示62的左孩子是**9索引**所指向的`data[9] = 41`，`index[3] = 7`表示62的右孩子是**7索引**所指向的`data[7] = 28`，以此类推\n\n**优点**：只有索引`index整型`数组发生了改变，`data`并未改变，`data`的类型并没有限制\n\n对于`shiftDown`和`shiftUp`变化不大，同时可以支持返回最大值的索引值，也可以根据索引值就直接返回`data`，最重要的操作是修改数据内容。\n\n```cpp\nvoid change( int i , Item newItem ){\n\n    i += 1;\n    data[i] = newItem;\n\n    // 找到indexes[j] = i, j表示data[i]在堆中的位置\n    // 之后shiftUp(j), 再shiftDown(j)，再次将index构建为最大堆\n\t// 这里用的是遍历，复杂度较高O(n + logn)\n    for( int j = 1 ; j <= count ; j ++ )\n        if( indexes[j] == i ){\n            shiftUp(j);\n            shiftDown(j);\n            return;\n        }\n}\n```\n\n#### 优化(change)\n\n<img src=\"堆排序-heap-sort\\index_heap2.png\"  />\n\n* `reverse[i]`表示索引`i`在`index`中的位置\n* 比如我们要查找`i = 4`这个索引在`index`中的位置，先找到`rev[4] = 9`，那么索引`i = 4`就在`index[9]`处，时间复杂度为O(1)\n\n```cpp\nindexes[i] = j;\nreverse[j] = i;\n\nindexes[reverse[i]] = i;\nreverse[indexes[i]] = i;\n```\n\n在`swap`操作中需要修改`reverse`\n\n代码如下：\n\n```cpp\npublic:\n    IndexMaxHeap(int capacity){\n\n        data = new Item[capacity+1];\n        indexes = new int[capacity+1];\n        reverse = new int[capacity+1];\n        // 初始化为0，代表不存在\n        for( int i = 0 ; i <= capacity ; i ++ )\n            reverse[i] = 0;\n\n        count = 0;\n        this->capacity = capacity;\n    }\n    ~IndexMaxHeap(){\n        delete[] data;\n        delete[] indexes;\n        delete[] reverse;\n    }\n    // 传入的i对用户而言,是从0索引的\n    void insert(int i, Item item){\n        assert( count + 1 <= capacity );\n        assert( i + 1 >= 1 && i + 1 <= capacity );\n\n        i += 1;\n        data[i] = item;\n        indexes[count+1] = i;\n        reverse[i] = count+1;\n        count++;\n\n        shiftUp(count);\n    }\n\t// 抽取最大的元素\n    Item extractMax(){\n        assert( count > 0 );\n\n        Item ret = data[indexes[1]];\n        swap( indexes[1] , indexes[count] );\n        // 此时最后一个元素没有意义了\n        // 此时的堆顶的第一个元素的reverse需要更新\n        reverse[indexes[count]] = 0;\n        reverse[indexes[1]] = 1;\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n\t// 抽取最大元素的坐标\n    int extractMaxIndex(){\n        assert( count > 0 );\n\n        int ret = indexes[1] - 1;\n        swap( indexes[1] , indexes[count] );\n        reverse[indexes[count]] = 0;\n        reverse[indexes[1]] = 1;\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n\t// 返回最大元素的值\n    Item getMax(){\n        assert( count > 0 );\n        return data[indexes[1]];\n    }\n\t// 返回最大元素的坐标\n    int getMaxIndex(){\n        assert( count > 0 );\n        return indexes[1]-1;\n    }\n\t// 保证不越界\n    bool contain( int i ){\n        assert( i + 1 >= 1 && i + 1 <= capacity );\n        return reverse[i+1] != 0;\n    }\n\t// 返回i处的元素值\n    Item getItem( int i ){\n        assert( contain(i) );\n        return data[i+1];\n    }\n\t// 改变i处的元素值\n    void change( int i , Item newItem ){\n\n        assert( contain(i) );\n        i += 1;\n        data[i] = newItem;\n\n        int j = reverse[i];\n        shiftUp( j );\n        shiftDown( j );\n    }\n```\n\n```cpp\nprivate:   \n    void shiftUp( int k ){\n\n        while( k > 1 && data[indexes[k/2]] < data[indexes[k]] ){\n            swap( indexes[k/2] , indexes[k] );\n            reverse[indexes[k/2]] = k/2;\n            reverse[indexes[k]] = k;\n            k /= 2;\n        }\n    }\n    void shiftDown( int k ){\n\n        while( 2*k <= count ){\n            int j = 2*k;\n            if( j + 1 <= count && data[indexes[j+1]] > data[indexes[j]] )\n                j += 1;\n\n            if( data[indexes[k]] >= data[indexes[j]] )\n                break;\n\n            swap( indexes[k] , indexes[j] );\n            reverse[indexes[k]] = k;\n            reverse[indexes[j]] = j;\n            k = j;\n        }\n    }\n```\n\n### 用堆解决第一节问题思路\n\n使用堆实现优先队列，动态选择优先级最高的任务执行。\n\n第一节中的问题，在10000000个元素中选出前100名(在N个元素中选前M个元素)，维护一个优先队列(长度为100)，每次把最小的移除，遍历完成后，最后剩下的100个元素就是前100个元素。\n\n### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git\n\n","categories":["算法与数据结构"]},{"title":"string操作总结(不定期更新)","url":"/blog/2020/06/25/string操作总结/","content":"\n总结一下C++中string的常见用法，包括但不局限于：\n\n1. 初始化\n2. string对象上的操作（包括取子串）\n3. 查找/删除/替换\n4. 与数值的相互转换\n\n<!-- more-->\n\n### 初始化\n\n```cpp\n//默认初始化，s1为空\nstring s1;\n//用s1初始化s2\nstring s2(s1);\n//s3为字面值\"value\"的副本，直接初始化\nstring s3(\"value\");\n//与上述等价，不同之处在于这里是拷贝初始化\nstring s3 = \"value\";\n//类似vector，n个'c'组成字符串s4\nstring s4(n, 'c');\n```\n\n### string对象上的操作\n\n```cpp\n//从is读取一行给s，返回is\ngetline(is, s)\n//判断是否为空\ns.empty()\n//s的长度\ns.size() / s.length()\n//完全一样则相等，大小写敏感\ns1 == s2\n//字典序比较，大小写敏感\n<, <=, >, >=\n```\n\n#### 两个string对象相加\n\n```cpp\nstring s1 = \"hello, \", s2 = \"world\";\n//s3 = \"hello, world\"\nstring s3 = s1 + s2;\n//s1 = \"hello, world\"\ns1 += s2; \t\t\t\n```\n\n#### 字面值和string对象相加\n\n当把string对象和字符字面值及字符串字面值混在一起相加时，必须确保`+`的两侧运算对象至少有一个string：\n\n```cpp\nstring s4 = s1 + \",\"; \t\t//√\nstring s5 = \"hello\" + \",\"\t//×\n```\n\n注意：字符串字面值与string是不同类型，以上操作是自动进行了类型转换。\n\n#### 处理string对象中的字符\n\n```cpp\n//定义在头文件cctype中\nisalnum(c)\t\t//当c是字母或数字为真\nisalpha(c)\t\t//当c是字母为真\niscntrl(c)\t\t//当c是控制字符为真，ASCII码前32\nisdigit(c)\t\t//当c是数字为真\nislower(c)\t\t//当c是小写字母为真\nisupper(c)\t\t//当c是大写字母为真\nispunct(c)\t\t//当c是标点符号为真\nisspace(c)\t\t//当c是空白为真(空格，回车，制表符等)\ntolower(c)\t\t//如果c为大写字母，转为小写，否则不变\ntoupper(c)\t\t//如果c为小写字母，转为大写，否则不变\n```\n\n**范围for语句**\n\n```cpp\n//打印s1的所有内容\n//仅访问时可加上const\n//简化类型名可用auto代替\nstring s1 = \"zhaoxingyu\"\nfor(string s : s1)\n    cout << s;\n//同时修改s1内容全为a\nfor(string &s : s1)\n    s = 'a';\n```\n\n#### 取子串\n\n```cpp\n//s.substr(pos, n)\n//取s中从pos开始长度为n的子串\n//如果pos超过s.size()则抛出out_of_range异常\n//如果pos+n超过s.size()则substr自动调整n值，只拷贝到s末尾\nstring s = \"hello world\";\nstring str = s.substr(0, 5);\t//str = \"hello\"\n```\n\n### 查找/删除/替换\n\n#### 查找函数find\n\nstring中的find函数返回子串/字符第一次出现在母串中的位置，类型为size_t，可以把它视为一个范围很大的int类型。如果没有找到，返回一个npos标记，是一个很大的整数。\n\n```cpp\n//size_t pos = s.find(str, startPos)\n//str为子串或字符，startPos为开始搜索位置，缺省时默认为0\nstring s = \"hello world\";\nstring str = \"world\";\nsize_t pos = s.find(str);\t//等价于pos = s.find(\"world\")，返回6\nsize_t pos1 = s.find(\"c\");\t//等价于pos1 = s.find('c')，返回npos\n```\n\n还可以从后往前反向查找，函数为rfind\n\n``` cpp\nstring s = \"hello world\";\nsize_t pos = s.rfind(\"l\"); \t//返回9\n```\n\n其他一些find函数\n\n```cpp\n//返回子串首次出现位置\npos = s.find_first_of(str);\n//返回字串最后出现位置\npos = s.find_last_of(str);\n```\n\n#### 删除函数erase\n\nstring中提供的成员函数可以用来删除字符串中的字符，这里主要介绍`erase`方法\n\n1. 从给定位置pos开始删除长度为n的字符串\n\n```cpp\n//basic_string & erase(size_type pos=0, size_type n=npos)\n//n缺省时默认为删除到末尾\nstring s = \"hello world\";\ns.erase(5);\t\t\t//从位置5开始全部删除，s = \"hello\";\ns.erase(0, 2); \t\t//从0开始删除长度为2的字符串，s = \"llo\"\n```\n\n2. 删除迭代器位置处的单个字符，并返回**下个元素**的迭代器\n\n```cpp\n//iterator erase(const_iterator position)\nstring s = \"hello world\";\ns.erase(s.begin());\t//s = \"ello world\";\n```\n\n3. 删除迭代器`[first, last)`区间的所有字符,返回一个指向被删除的最后一个元素的下一个字符的迭代器.\n\n```cpp\n//iterator erase(const_iterator first, const_iterator last)\nstring s = \"hello world\";\n//iter = s.erase(s.begin() + 1, s.end() - 1); \t //可以直接删除\nauto iter = s.erase(s.begin() + 1, s.end() - 1); //删除并返回迭代器\n//s = \"hd\"，*iter = d\n```\n\n**注：也可以用pop_back()删除最后一个元素**\n\n#### 替换函数replace\n\n1. 用str替换指定字符串从pos开始长度为len的字符串\n\n```cpp\n//string& replace(size_t pos, size_t len, const string& str)\n//注意这里的str必须是string对象，不能是char字符\nstring s = \"hello world\";\nstring str = \"#\";\ns = s.replace(0, 5, str);\t//s = \"# world\"\n```\n\n2. 用str替换迭代器起始位置到终止位置的字符串\n\n```cpp\n//string& replace(const_iterator it1, const_iterator it2, const string& str)\n//注意这里的str必须是string对象，不能是char字符\nstring s = \"hello world\";\nstring str = \"#\";\ns = s.replace(s.begin(), s.begin() + 5, str);\t//s = \"# world\"\n```\n\n3. 用重复n次的c字符替换从指定位置pos长度为len的字符串\n\n```cpp\n//string& replace(size_t pos, size_t len, size_t n, char c)\n//注意这里的c必须是char类型，不能是string对象\nstring s = \"hello world\";\nchar c = '#';\ns = s.replace(0, 5, 2, c);\t//s = \"## world\"\n```\n\n4. 用重复n次的c字符替换从指定迭代器位置到终止位置的字符串\n\n```cpp\n//string& replace (const_iterator i1, const_iterator i2, size_t n, char c)\n//注意这里的c必须是char类型，不能是string对象\nstring s = \"hello world\";\nchar c = '#';\ns = s.replace(s.begin(), s.end(), 2, c);\t//s = \"## world\"\n```\n\n### string与int相互转换\n\n#### string转int\n\n```cpp\n# string直接转int\n//stoi(s, pos, b) 把字符串s从pos开始转换成b进制的int\nstring s = \"123\";\n//a = 123，如果里面含有非数字，那么从pos开始连续的字符串型数字才会被转为数字\nint a = stoi(s, 0, 10);\t\n//stol(s,p,b)\t把字符串s从p开始转换成b进制的long\n//stoul(s,p,b)\t把字符串s从p开始转换成b进制的unsigned long\n//stoll(s,p,b)\t把字符串s从p开始转换成b进制的long long\n//stoull(s,p,b)\t把字符串s从p开始转换成b进制的unsigned long long\n//stof(s,p)\t\t把字符串s从p开始转换成float\n//stod(s,p)\t\t把字符串s从p开始转换成double\n//stold(s,p)\t把字符串s从p开始转换成long double\n# char型数组字符串转int\n//c_str()函数返回一个指向正规C字符串的指针, 内容与string串相同\n//string类对象的成员函数c_str()把string转换为c类型字符串\n//如果string不是数字形式的则转换结果为0\n//实际步骤为string->char*->int\nstring s = \"123\";\nint a = atoi(s.c_str());\t//a = 123\n```\n\n#### int转string\n\n```cpp\n//to_string(val) 将val转为string\nint val = 100;\nstring s = to_string(val);\t//s = \"100\"\n```\n\n### 参考\n\n查找/删除/替换：\n\n1. https://www.cnblogs.com/xzxl/p/7243490.html\n\n2. https://blog.csdn.net/cai_niaocainiao/article/details/81260902?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase\n\n3. https://blog.csdn.net/u010472607/article/details/80431604\n\n字符串转数值\n\nhttps://blog.csdn.net/sinat_40872274/article/details/81367815","tags":["string"],"categories":["C++"]},{"title":"git提交失败-ssh重置","url":"/blog/2020/06/25/git提交失败-ssh重置/","content":"\n一段时间不提交，就容易出现“Please make sure you have the correct access rights and the repository exists.”，原因是ssh key出现了问题，记录一下解决方法，省的每次都去百度细节。\n\n**用手机热点可以提交成功，尚不清楚原因(updated：2020/7/15)** \n\n<!-- more -->\n\n1. 重新配置身份信息\n   * `git config --global user.name \"yourname\"`\n   * `git config --global user.email \"your@email.com\"`\n\n2. 删除.ssh文件夹下的所有文件\n3. 输入命令`ssh-keygen -t rsa -C \"your@email.com\"`，出现提示直接回车\n4. 此时在.ssh文件夹下生成**id_rsa**和**id_rsa.pub**，用记事本打开**id_rsa.pub**并复制所有内容\n5. 打开github主页并进入到`SSH and GPG keys`中，新建shh，把刚才复制的内容粘贴进去\n6. 输入命令`ssh -T git@github.com`，出现提示输入`yes`，不是直接回车\n7. **重新打开**git进行提交\n\n以上所有git操作都在hexo根目录下\n\n","categories":["Hexo"]},{"title":"LeetCode139-单词拆分","url":"/blog/2020/06/25/LeetCode139-单词拆分/","content":"\n这道题我一开始没想到可以用动态规划来做，先试着用暴力做了，结果通过34/36，看似只剩下3个没通过，但是问题很大，不好修改，具体原因后面分析。\n\n### 题目描述\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n* 拆分时可以重复使用字典中的单词。\n* 你可以假设字典中没有重复的单词。\n\n<!--more -->\n\n<img src=\"LeetCode139-单词拆分\\示例.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这道题题意还是挺好理解的，给定字符串s，从字典wordDict中取出单个或多个字符串（可重复），最后如果可以拼接成s，返回true，反之返回false。\n\n一开始暴力的思路就是遍历字典中的每一个字符串看是否出现在s中，如果出现了，那么用#号来代替s中的出现的子串，并且继续搜索，搜索完成后，将s中的#号清空，如果此时s为空，那么代表s可以被拆分，返回true。但是对于以下的例子：\n\n```cpp\ns = \"abbbc\"\nwordDict = [\"ab\", \"b\", \"bbc\"]\n```\n\ns可以由ab+bbc组合而成。但是用暴力法，只会搜到ab+b+b，再往下就搜索不到了，返回了false。如果需要修改，要用到dfs的思想，进行深搜，但是不剪枝也容易超时。在看了答案之后才知道可以用动态规划来做，而且很好理解。\n\n按照第二个示例来说，`s = \"applepenapple\", wordDcit = [\"apple\", \"pen\"]`，从s的第一个字符`a`开始遍历：\n\n* 当等于`apple`时候，存在与字典中，就可以认为在第5个字符处是可以拆的；\n* 继续向后遍历，当得到`applepen`时，增加了字符串`pen`，且它存在于字典中，所以可以知道第8个字符处也是可拆的；\n* 直到`applepenapple`时，增加了`apple`，且它存在于字典中，最后一个字符即第13个字符处可拆。\n\n从上述分析可以知道，如果最后一个字符处可拆，就返回true，否则返回false。\n\n#### 定义dp数组\n\n首先，`dp`数组应该是`bool`类型，长度为`s.length()+1`，并且`dp[0]=true`，否则dp数组全是false。**dp数组含义为当前位置的字符是否可以被拆分**。\n\n如果`dp[j]`代表当前位置，`dp[i]`是某一起始位置，那么就需要检查从`i`到`j`的子串是否在字典中，如果在，并且`dp[i]`是可以拆分的，那么`dp[j]`也应该是可以拆分的，否则`dp[j]=false`。\n\n#### 状态转移方程\n\n根据上面的分析，可以容易写出以下的状态转移方程，同时将字典放入`unordered_map`中方便查找：\n\n```cpp\ndp[j] = dp[i] && dict.count(s.substr(i, j - i))\n```\n\n#### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        // 存入字典，方便查找\n        unordered_map<string, bool> dict; \n        for(const auto &word : wordDict) dict[word] = true;\n        // 初始化dp数组，如果s为空，返回true\n        // 实际上只初始化dp[0]即可\n        bool *dp = new bool[s.length() + 1];\n        dp[0] = true; \n        for(int i = 1; i <= s.length(); i++){\n            dp[i] = false;\n        }\n        for(int j = 1; j <= s.length(); j++){\n            for(int i = j - 1; i >= 0; i--){\n                dp[j] = dp[i] && dict.count(s.substr(i, j - i));\n                if(dp[j]) break;\n            }\n        }\n        return dp[s.length()];    \n    }\n};\n```\n\n### 参考资料\n\nhttps://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-ju-jue-zhuang-xcong-jian-dan-de-xi/\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode739-每日温度","url":"/blog/2020/06/13/LeetCode739-每日温度/","content":"\n这次主要学习一下单调栈这种数据结构，同时用此数据结构解决739题\n\n### 题目描述\n\n请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n\n<!--more -->\n\n### 单调栈\n\n先学习一下单调栈这种数据结构，单调栈就是栈的基础上使用一定的逻辑，使栈中的元素单调递增或者递减，一般只处理一种典型的问题，叫做**下一个更大的元素**，这个问题是说：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。举例如下：给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。\n\n可以这样思考，把数组元素想象成人，如何求2的下一个更大的元素呢？如果2的下一个人比2还低或者一样高，那么就会被2遮挡住，直到第一个比他高的人，他挡不住了，就是答案。\n\n<img src=\"LeetCode739-每日温度\\人.jpg\" style=\"zoom: 30%;\" />\n\n代码实现如下：\n\n```cpp\nvector<int> nextGreaterElement(vector<int>& nums) {\n    vector<int> ans(nums.size()); // 存放答案的数组\n    stack<int> s;\n    for (int i = nums.size() - 1; i >= 0; i--) { // 倒着往栈里放\n        while (!s.empty() && s.top() <= nums[i]) { // 判定个子高矮，nums在s之前\n            s.pop(); // 矮个起开，反正也被挡着了。。。\n        }\n        ans[i] = s.empty() ? -1 : s.top(); // 这个元素身后的第一个高个\n        s.push(nums[i]); // 入栈\n    }\n    return ans;\n}\n```\n\n<img src=\"LeetCode739-每日温度\\栈.png\" style=\"zoom: 80%;\" />\n\n以上图是栈中元素的变化情况，只有当新的高个子来临，才会有出栈的操作。\n\n### 分析及代码实现\n\n上面已经把单调栈阐述了一遍，本题唯一的区别是要返回还需要多少天，而不是那天的温度，所以要用栈来存储一下温度的坐标，根据当前温度的坐标与栈顶温度坐标的差作为返回值。\n\n代码如下：\n\n```cpp\nvector<int> dailyTemperatures(vector<int>& T) {\n    vector<int> ans(T.size());\n    stack<int> s; // 这里放元素索引，而不是元素\n    for (int i = T.size() - 1; i >= 0; i--) {\n        while (!s.empty() && T[s.top()] <= T[i]) {\n            s.pop();\n        }\n        ans[i] = s.empty() ? 0 : (s.top() - i); // 得到索引间距\n        s.push(i); // 加入索引，而不是元素\n    }\n    return ans;\n}\n```\n\n### 扩展：如何处理循环数组\n\n同样是**下一个更大的元素**，现在假设给你的数组是个环形的，如何处理？\n\n给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 。通过取模运算符%就可以模拟环形数组的效果。\n\n```cpp\nvector<int> arr{1,2,3,4,5};\nint n = arr.length(), index = 0;\nwhile (true) {\n    cout << arr[index % n] << endl;\n    index++;\n}\n```\n\n一种方法是将数组翻倍，然后进行取模运算，节省空间的做法是直接将循环的坐标变成之前的2倍，代码看起来更容易理解，如下：\n\n```cpp\nvector<int> nextGreaterElements(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> res(n); // 存放结果\n    stack<int> s;\n    // 假装这个数组长度翻倍了\n    for (int i = 2 * n - 1; i >= 0; i--) {\n        while (!s.empty() && s.top() <= nums[i % n])\n            s.pop();\n        res[i % n] = s.empty() ? -1 : s.top();\n        s.push(nums[i % n]);\n    }\n    return res;\n}\n```\n\n### 参考资料\n\n《labuladong的算法小抄》 单调栈","tags":["单调栈"],"categories":["LeetCode"]},{"title":"LeetCode126-单词接龙2","url":"/blog/2020/06/07/LeetCode126-单词接龙2/","content":"\n这是今天的每日一题，难度为hard，不过与之前软挑赛的题目有很多相似之处，但是我还是没做出来，还是要多总结。最后看了别人的答案，用BFS+DFS才解决这个问题。\n\n### 题目描述\n\n给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：\n\n1. 每次转换只能改变一个字母。\n2. 转换过程中的中间单词必须是字典中的单词。\n\n**说明**：\n\n* 如果不存在这样的转换序列，返回一个空列表。\n* 所有单词具有相同的长度。\n* 所有单词只由小写字母组成。\n* 字典中不存在重复的单词。\n* 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。\n\n<!--more -->\n\n<img src=\"LeetCode126-单词接龙2\\示例.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n对于beginWord，一次只能更改一个字母，同时更改后的字母必须出现在wordList中，所以考虑将wordList放入一个集合中，方便每次判断是否在集合内。一开始我考虑的是直接用DFS解决，虽然DFS可以找到所有路径，然后从中挑选最短，但是它无法直接找到最短路径。如果某条长度过长，很容易出现超时，事实上在刷题群里很多大佬已经出现了这个问题，所以只能找别的办法。直接用BFS是可以的，在找最短的同时记录路径，我没有尝试，之后可以再试试，我选择了使用BFS+DFS的方法，使用BFS建立逆邻接表，使用DFS在逆邻接表基础上搜索答案。\n\n#### BFS建立逆邻接表\n\n使用BFS可以找到最短的路径，可以建立一个逆邻接表，用来表示可以到达当前节点的所有节点(当然这些节点必须是出现在wordList之中的)，**我们用curr代表当前节点，temp代表更改一个字母后的节点**。\n\n使用`unordered_map<string, vector<string>> neighbor`来表示，就拿示例1来说，如下图所示：<img src=\"LeetCode126-单词接龙2\\邻接表.png\"  />\n\n上图表示可以到达cog的节点为dog和log，具体的实现还是需要一个记录当前节点深度的哈希表`unordered_map<string, int> depth`，用来判断curr是否可达temp，同时省去一些不必要的遍历。具体操作是：首先队列弹出curr节点，检查和它相差一个字母的temp是否在wordList中出现，如果出现了：\n\n* 没有记录过(`depth[temp] = 0`)，记录`curr->temp`，同时`depth[temp] = depth[curr] + 1`，将temp入队\n* 记录过并且相邻(`depth[temp] = depth[curr] + 1`)，同时避免不是直接相邻的遍历，也避免了往回遍历。如下表，遍历改变pot一个字母的节点时，可能再次出现hot，但是此时`depth[hot] = 1 != depth[pot] + 1 = 2`所以避免了再次遍历hot。\n\n```nginx\n   hot\n /       \\\npot     hit\n \\        /\n    pit\n```\n\n通过以上步骤就可以建立逆临界表，代码实现如下：\n\n```cpp\nunordered_map<string,int> depth;\nunordered_map<string,vector<string>> neighbor;\n//将wordList添加至集合中\nunordered_set<string> wordSet(wordList.begin(),wordList.end());\n//使用BFS建立逆邻接表\ndepth[beginWord]=1;\nqueue<string> Q;\nQ.push(beginWord);\n//从begin到end建图\nwhile(!Q.empty()){\n\tstring curr=Q.front();\n\tQ.pop();\n    for(int i=0;i<curr.size();++i){\n        string temp=curr;\n        for(char c='a';c<='z';++c){\n            temp[i]=c;\n            //如果修改后的这个temp是在集合里面\n            if(wordSet.count(temp)){\n           \t\t//这个temp还没被添加进neighbor\n                if(depth[temp] == 0){ \n                    Q.push(temp);\n                    depth[temp]=depth[curr]+1;\t//更新深度\n                    neighbor[temp].push_back(curr);\n                    }\n                //已经被添加并且相邻\n                else if(depth[temp]==depth[curr]+1){\n\n                    neighbor[temp].push_back(curr);\n                }\n            }\n        }\n    }\n}\n```\n\n#### DFS从逆邻接表中搜索答案\n\n在上一步的BFS中已经存储了每个点的逆邻接点，我们从endWord沿着neighbor往回进行搜索，直到到达beginWord，将已经记录的路径(path)进行反转，存入最终的res中；如果无法到达，则DFS执行至末尾，将path重置(省去了使用&path引用的pop_back()操作)。代码如下：\n\n```cpp\nvoid dfs(string &begin, string &curr, vector<string> path, unordered_map<string, vector<string>> &neighbor, vector<vector<string>> &res){\n\tif(curr == begin){\n        path.push_back(curr);\n        reverse(path.begin(), path.end());\n        res.push_back(path);\n        return;\n    }\n    path.push_back(curr);\n    for(auto &word : neighbor[curr]){\n        dfs(begin, word, path, neighbor, res);\n    }\n}\n```\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n\n        vector<vector<string>> res;\n        //如果wordList中没有endWord，则返回空\n        if(find(wordList.begin(), wordList.end(), endWord) == wordList.end())\n            return res; \n        vector<string> path;\t//记录路径\n        unordered_map<string, int> depth;\t//记录深度\n        //存储节点的逆邻接\n        unordered_map<string, vector<string>> neighbor;\t\n        //将wordList添加至集合中\n        unordered_set<string> wordset(wordList.begin(), wordList.end());\n        depth[beginWord] = 1;\n        queue<string> Q;\n        Q.push(beginWord);\n        while(!Q.empty()){\n            string curr = Q.front();\n            Q.pop();\n            for(int i = 0; i < curr.size(); i++){\n                string temp = curr;\n                for(char c = 'a'; c <= 'z'; c++){\n                    temp[i] = c;\n                    //如果修改后的这个temp是在集合里面\n                    if(wordset.count(temp)){\n                        //这个temp还没被添加进neighbor\n                        if(depth[temp] == 0){\n                            Q.push(temp);\n                            depth[temp] = depth[curr] + 1;\t//更新深度\n                            neighbor[temp].push_back(curr);\n                        }\n                        //已经被添加并且相邻\n                        else if(depth[temp] == depth[curr] + 1){\n                            neighbor[temp].push_back(curr);\n                        }\n                    }\n                }\n            }\n        }\n        dfs(beginWord, endWord, path, neighbor, res);\n        return res;\n    }\n\n    void dfs(string &begin, string &curr, vector<string> path, unordered_map<string, vector<string>> &neighbor, vector<vector<string>> &res){\n        //当前点已经等于beginWord\n        if(curr == begin){\n            path.push_back(curr);\n            reverse(path.begin(), path.end());\t//反转\n            res.push_back(path);\n            return;\n        }\n        path.push_back(curr);\n        for(auto &word : neighbor[curr]){\n            dfs(begin, word, path, neighbor, res);\n        }\n\t\t//如果没有逆邻接，则执行完毕此函数后，path还原为上一次的值，即省去了pop_back()\n    }\n};\n```\n\n### 参考\n\nhttps://leetcode-cn.com/problems/word-ladder-ii/solution/zhe-ti-you-xie-nan-bie-ren-de-dai-ma-zuo-xia-zhu-s/","tags":["BFS","DFS"],"categories":["LeetCode"]},{"title":"LeetCode837-新21点","url":"/blog/2020/06/06/LeetCode837-新21点/","content":"\n### 题目描述\n\n爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：\n\n爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。\n\n当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？\n\n<!--more -->\n\n<img src=\"LeetCode837-新21点\\示例.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这道题一看不太明白什么意思，看过港片的都知道，在牌面加起来不大于21点时候，谁的牌面最大，谁就能获胜。这道题其实是求爱丽丝获胜的概率，不过点数为N，可以把规则复述一下：\n\n1. 她可以从`[1,W]`的牌中任意取一张，可以无限重复取，也就是说取到范围中某张牌的概率一直是`1/W`；\n2. 如果她手上的牌总额小于K时，她就会继续抽牌，大于等于K时就停止抽牌；\n3. 停止抽牌后，和N进行比较，当小于等于N时，她就获胜了，求获胜的概率。\n\n#### 定义dp数组的含义\n\n定义`dp[x]`为她手上牌面为x时，能获胜的概率。因为每次从`[1,W]`中抽取的机会都是均等的，所以`dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W]) `。x最多可以到`K-1`，因为x等于K时会停止抽牌，所以当抽牌结束后，她可能达到的最大牌面是`K-1+W`，开始时她的牌面为0，所以用长度为K+W的dp数组就够了，最后`dp[0]`，也就是爱丽丝还没有抽牌时的胜率就是最终答案。\n\n#### 状态转移方程\n\n其实上一步已经提到了状态转移方程：`dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W]) `，但是dp数组具体应该怎么算呢，可以把它看成一个填格子的游戏，如下图：\n\n<img src=\"LeetCode837-新21点\\image1.png\" style=\"zoom:80%;\" />\n\n将格子分为两个部分，在橘黄色的格子中，爱丽丝是可以抽牌的，而在蓝色的格子中是不可以的。我们每次需要W个格子的结果进行状态转移。\n\n在蓝色的格子中，对于`[K,K+W-1]`中小于等于N的值，相应的`dp[i]`概率就是1，反之为0，在初始化时候进行。\n\n<img src=\"LeetCode837-新21点\\image2.png\" style=\"zoom:80%;\" />\n\n接下来，从K-1处根据状态转移方程进行dp数组的计算。在计算K-2处概率值时，在上一步用一个中间变量`sumw`保存`[K,K+W-1]`的概率之和，这样新的概率和`sumw = sumw - dp[K-1+W] + dp[K-1]`，提高效率。这样从最右边橘黄色格子一直填到最左边，就是最后的结果dp[0]。\n\n#### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    double new21Game(int N, int K, int W) {\n        vector<double> dp(K + W, 0);\n        double sumw = 0;\n        for(int i = K; i <= K + W - 1; i++){\n            if(i <= N) dp[i] = 1;\n            sumw += dp[i];\n        }\n        for(int i = K-1; i >=0; i--){\n            dp[i] = (double)1 / W * sumw; //概率可能是小数，需要强制类型转换\n            sumw = sumw - dp[i+W] + dp[i]; \n            //这里就是减去最右边概率dp[i+W]，加上最左边概率dp[i]\n        }\n        return dp[0];\n    }\n};\n```\n\n### 参考资料\n\nhttps://leetcode-cn.com/problems/new-21-game/solution/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/\n\n\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode877-石子游戏","url":"/blog/2020/05/28/LeetCode877-石子游戏/","content":"\n### 题目描述\n\n亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。\n\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。\n\n<!--more -->\n\n<img src=\"LeetCode877-石子游戏\\877.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这个题其实一定是先手获胜，为了更具有一般性，假设**石头的堆数可以是任意正整数**，那么就能打破先手必定获胜的局面了，比如`piles = [1, 100, 3]`，先手不管拿1还是3，能够决胜的100都会被后手拿走，后手获胜。\n\n**博弈问题的难点在于，两个人要轮流进行选择，而且都很精明，应该如何编程表示这个过程呢？**首先明确 dp 数组的含义，只要找到「状态」和「选择」，一切就水到渠成了。\n\n#### 一、定义 dp 数组的含义\n\n先看一下dp数组的最终样子，再介绍其含义\n\n<img src=\"LeetCode877-石子游戏\\dp.png\" style=\"zoom:50%;\" />\n\n定义dp数组是二维的，并且每个单元包含first和second两个属性，将这两个属性简写为fir和sec。如按上图的数据，我们说 `dp[1][3].fir = 10`，`dp[0][1].sec = 3`。\n\n**以下是对 dp 数组含义的解释：**\n\n```cpp\ndp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。\ndp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。\n\n举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始\ndp[0][1].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。\ndp[1][3].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。\n```\n\n我们想求的答案是先手和后手最终分数哪个更大，按照这个定义也就是 `dp[0][n-1].fir`和`dp[0][n-1].sec`哪个更大。\n\n#### 二、状态转移方程\n\n要写状态转移方程，需要找到所有**状态**和每个状态可以做出的**选择**，然后择优。\n\n根据前面对 dp 数组的定义，**状态**显然有三个：**开始的索引 i，结束的索引 j，当前轮到的人。**\n\n```cpp\ndp[i][j][fir or sec]\n其中：\n0 <= i < piles.length\ni <= j < piles.length\n```\n\n对于这个问题的每个状态，可以做的**选择**有两个：**选择最左边的那堆石头，或者选择最右边的那堆石头。**\n\n这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？根据我们对 dp 数组的定义，很容易解决这个难点，**写出状态转移方程：**\n\n```cpp\ndp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)\nleft = piles[i] + dp[i+1][j].sec //选择最左边的石头堆\nright = piles[j] + dp[i][j-1].sec //选择最右边的石头堆\n# 解释：我作为先手，面对 piles[i...j] 时，有两种选择：\n# 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]\n# 在上一轮中，我是作为后手的；\n# 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]\n# 在上一轮中，我是作为后手的。\n\nif 先手选择左边:\n    dp[i][j].sec = dp[i+1][j].fir\nif 先手选择右边:\n    dp[i][j].sec = dp[i][j-1].fir\n# 解释：我作为后手，要等先手先选择，有两种情况：\n# 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]\n# 此时轮到我，我变成了先手；\n# 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]\n# 此时轮到我，我变成了先手。\n根据 dp 数组的定义，我们也可以找出base case，也就是最简单的情况：\n\ndp[i][j].fir = piles[i]\ndp[i][j].sec = 0\n其中 0 <= i == j < n\n# 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]，i != j时可以不需要初始化\n# 那么显然先手的得分为 piles[i]\n# 后手没有石头拿了，得分为 0\n```\n\n<img src=\"LeetCode877-石子游戏\\dp1.png\" style=\"zoom:50%;\" />\n\n这里需要注意一点，我们发现 base case 是斜着的，而且我们推算`dp[i][j]`时需要用到`dp[i+1][j]`和`dp[i][j-1]`:\n\n<img src=\"LeetCode877-石子游戏\\dp2.png\" alt=\"dp2\" style=\"zoom:50%;\" />\n\n```c++\n# 举例：若i = 0, j = 1\n# dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)\ndp[0][1].fir = max(piles[0] + dp[1][1].sec, piles[1] + dp[0][0].sec)\n    \t\t = max(3 + 0, 9 + 0) = 9\n# 先手选择右边第一堆\n# if 先手选择右边: dp[i][j].sec = dp[i][j-1].fir\ndp[0][1].sec = dp[0][0].fir = 3\ndp[0][1] = {9, 3}\n```\n\n所以说算法不能简单的一行一行遍历 dp 数组，**而要斜着遍历数组：**\n\n<img src=\"LeetCode877-石子游戏\\dp3.png\" style=\"zoom:50%;\" />\n\n如何斜着遍历二维数组是个问题，这里我不是很会，只是有个框架，具体的细节还需要再消化消化\n\n```c++\n# 遍历的是橘黄色的部分\nfor (int l = 2; l <= n; l++) {\n        for (int i = 0; i <= n - l; i++) {\n            int j = l + i - 1;\n            /*操作段*/\n        }\n}\n```\n\n#### 三、代码实现\n\n实现fir和sec这个单元可以用pair容器，也可以用`dp[n][n][2]`这种三维数组，我在这里使用了结构体。\n\n```c++\nclass Solution {\npublic:\n    struct Pair{\n        int fir;\n        int sec;\n        Pair() {};\n        Pair(int a, int b){\n            this->fir = a;\n            this->sec = b;\n        } \n    };\n    bool stoneGame(vector<int>& piles) {\n        int n = piles.size();\n        Pair** dp = new Pair*[n];\n        for(int i = 0; i < n; i++){\n            dp[i] = new Pair[n];\n        }\n        for(int i = 0; i < n; i++){\n            dp[i][i].fir = piles[i];\n            dp[i][i].sec = 0;\n        }\n\n        for(int l = 2; l <= n; l++){\n            for(int i = 0; i <= n - l; i++){\n                int j = l + i - 1;\n\n                int left = dp[i+1][j].sec + piles[i];\n                int right = dp[i][j-1].sec + piles[j];\n                if(left > right){\n                    dp[i][j].fir = left;\n                    dp[i][j].sec = dp[i+1][j].fir;\n                }\n                else{\n                    dp[i][j].fir = right;\n                    dp[i][j].sec = dp[i][j-1].fir;\n                }\n            }\n        }\n        if(dp[0][n-1].fir > dp[0][n-1].sec) return true;\n        return false;\n    }\n};\n```\n\n### 参考资料\n\n《labuladong的算法小抄》 动态规划之博弈问题","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode300-最长上升子序列","url":"/blog/2020/05/26/LeetCode300-最长上升子序列/","content":"\n### 题目描述\n\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n<!--more -->\n\n<img src=\"LeetCode300-最长上升子序列\\sl.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这是一道动态规划的经典入门题，这里的子序列不一定是连续的。比如示例中`[2, 3, 7, 101]`，只要是递增的，就是上升子序列，我需要找到这里面最长的上升子序列的长度。\n\n动态规划一般是由历史信息推断当前信息的，并且历史信息是是独立的子问题，相互之间不会影响。现在考虑一个dp数组，如果说dp[0]到dp[i-1]都可以得到了，如果可以推出dp[i]，就可以得到dp数组的全部结果。\n\n#### 一、定义dp数组的含义\n\n我们可以定义dp[i]表示以nums[i]这个数结尾的最长上升子序列的长度。举两个例子：\n\n<img src=\"LeetCode300-最长上升子序列\\ex1.png\" style=\"zoom:80%;\" />\n\n根据这个定义，最终结果(子序列的最大长度)就是dp数组中的最大值。\n\n#### 二、状态转移方程\n\n这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：\n\n我们已经知道了 dp[0]到dp[4] 的所有结果，我们如何通过这些已知结果推出 dp[5] 呢？\n\n<img src=\"LeetCode300-最长上升子序列\\ex2.png\" style=\"zoom:80%;\" />\n\n根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。\n\nnums[5] = 7，既然是递增子序列，我们只要找到前面那些结尾比 7 小的子序列，然后把 7 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。\n\n当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。\n\n```cpp\nfor (int j = 0; j < i; j++) {\n    if (nums[i] > nums[j]) \n        dp[i] = max(dp[i], dp[j] + 1);\n} \n# dp数组需要初始化为1，因为自己本身也算一个序列\n# 当i = 5时\n# nums[5] > nums[2] dp[5] = max{dp[5], dp[2] + 1} = max{1, 2} = 2\n# nums[5] > nums[3] dp[5] = max{dp[5], dp[3] + 1} = max{2, 2 + 1} = 3\n# nums[5] > nums[4] dp[5] = max{dp[5], dp[4] + 1} = max{3, 2 + 1} = 3\n# 所以dp[5] = 3\n```\n\n根据上述的状态转移公式，就可以得到dp数组的所有值，我们再取其中的最大值，就是答案。\n\n#### 三、代码实现\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        vector<int> dp(nums.size(), 1);\n\n        for(int i = 0; i < nums.size(); i++){\n            for(int j = 0; j < i; j++){\n                if(nums[i] > nums[j])\n                    dp[i] = max(dp[i],dp[j] + 1); \n                //dp[i]是指历史中的最大长度，否则后面的长度+1小于历史最大长度时，会覆盖\n            }\n        }\n        return *max_element(dp.begin(), dp.end());\n    }\n};\n```\n\n### 参考资料\n\n《labuladong的算法小抄》 动态规划设计：最长递增子序列","tags":["动态规划"],"categories":["LeetCode"]},{"title":"2020学习/工作计划","url":"/blog/2020/04/30/2020学习计划/","content":"\n### 概要\n\n1. 写在前面\n2. 疫情期间的工作\n3. 反思自己的不足\n4. 2020学习/工作计划\n\n<!--more -->\n\n#### 写在前面\n\n2020年已经过去了四分之一，我才意识到需要做一个全年计划。这几个月来，小计划不断，但是都没有很好的完成，并且很容易受到外界因素的干扰，自己不知道自己到底**需要做什么**，于是看似做了不少东西，但是意义不大。我觉得全年的学习生活应该有一个基调，一年中总是要完成一些事情的。来到西电读研是进一步的学习机会，我要抓住这个机会。\n\n#### 疫情期间都做了什么？\n\n1. 首先是帮助师兄改了一个polar码的scl译码方法，其实到现在我对其原理也不是很明白，只是知道代码怎么用...\n2. 开始刷leetcode的题目，目前大概刷了100+，还是有一定的作用的。完成了\n   - 数据结构部分：队列和栈，数组和字符串，二分查找(83%)，链表(46%)\n   - 算法：BFS，DFS，双指针\n   - C++中vector，map，set等容器的使用，发现自己掌握的真是冰山一角\n\n3. 阅读了机器学习的几篇论文，主要是了解了随机梯度下降(SGD)方法，后面还需要进一步学习\n4. 很有限的学习了机器学习，矩阵论相关的内容\n5. 参加了华为的软件精英挑战赛，西北赛区第十名，进入复赛\n\n#### 自己的不足\n\n真正认识自己的不足也是在比赛期间，当你看到你辛辛苦苦半个月做出来的成果别人只需要几天，并且成绩还比你好的多的时候，你就越发的感觉到自己的渺小，我后悔的事情太多了，本科时候没有参加ACM是最大的错误，无论是数学建模或者是电赛，对于以后要进军互联网来说都没有ACM的奖牌作用大。不过我也意识到了这是教育之间的差异，有些人在中学的时候就开始接触比赛了，到了大学继续比赛那肯定更加熟练。我在高中的时候谈到计算机估计想的就是装个软件，换个内存条什么的，编程这个词都不知道啥意思，更不用说参加信息类的比赛了。。。为社么别人可以做到那些，我做不到，这并不全是自己的问题，种一棵树从现在开始也不迟，**虽然已经知道和别人的差距很大，但是只要是能缩小差距，那就是自己的进步**！还有一年的时间，一年是很快的，而且还有实验室的事情需要忙，所以时间很紧迫，千万不能再浪费了！\n\n#### 2020学习/工作计划\n\n1. 继续刷leetcode，学习了新算法，新思路或者新的函数之后在博客中进行总结，至少一周一篇，并且要做好题目的分类，算法和思路在tags中注明算法/思路，函数在tags中注明函数，在分类中注明C++。其中保证每周做7题以上，对于过于简单的题不计算在内，书籍**《算法》**。\n2. 继续学习C++，把**《C++ Prime》**过一遍，每周在博客总结一次，标签：C++ Prime，分类：C++；辅助阅读**《STL源码剖析》**和**《Effective C++》**标签：书名，分类：C++\n3. **《计算机网络 自顶向下方法》**前四章内容\n4. **《UNIX 网络编程》《UNIX 环境高级编程》** 辅助书籍**《Unix/Linux 编程实践教程》**\n5. **《深入理解计算机系统》**三四章可以先不看\n6. 机器学习的相关课程：吴恩达机器学习基础课程，CS231n计算机视觉课程，适应阅读英文论文，加强英语的学习\n7. 积极参加有水平的比赛\n8. 阅读一本非专业的书籍，陶冶陶冶情操？\n\n","categories":["生活随笔"]},{"title":"LeetCode17-电话号码的字母组合","url":"/blog/2020/02/16/LeetCode17-电话号码的字母组合/","content":"\n### 题目描述\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n已知数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n<!--more -->\n\n<img src=\"LeetCode17-电话号码的字母组合\\1.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n字符串的长度不确定，所以用循环直接解决不实际；\n\n可以由下至上进行递归来求解，以“23”为例，如图：\n\n```mermaid\ngraph TD\nA[2] -->|a| B[3]\nA[2] -->|b| C[3]\nA[2] -->|c| D[3]\nB[3] -->|d| E[ad]\nB[3] -->|f| F[af]\nB[3] -->|g| G[ag]\nC[3] -->|d| H[bd]\nC[3] -->|f| I[bf]\nC[3] -->|g| J[bg]\nD[3] -->|d| K[cd]\nD[3] -->|f| L[cf]\nD[3] -->|g| M[cg]\n```\n\n记数字2为第0层，那么数字3为第1层，需要一个变量level，记录当前遍历数字的位置。递归表现在：如果选择了’a'，那么就需要再进行三次选择‘d’ ‘f’ ‘g’后才可以输出，再选择'b'，以此类推。即递归到最后一层，输出一次递归结果，全部递归完成，得到最终结果。\n\n具体算法如下：\n\n* 建立一个**map**，用来存储数字与其对应的字符串，当然，这里的数字是char类型。\n* 递归函数中，首先判断**level**，如果等于**digits**中数字的个数，那么将当前的结果并入**res**，然后返回。\n* 否则通过**digits**中的数字找到对应的字符串，然后遍历取出整个字符串，将每个字符串都加到当前的组合后面，再调用递归函数。\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        if(digits.empty()) return {};\n        map<char,string> num_str{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},\n                                {'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        vector<string> res;\n        combin(digits,num_str,0,\"\",res);\n        return res;\n    }\n    void combin(string digits,map<char,string> num_str,int level,string out,vector<string> &res)\n    {\n        //递归\n        if(level == digits.length())\n        {\n            res.push_back(out);\n            return;\n        }\n        string buf = num_str[digits[level]];\n        for(int i=0;i<buf.length();i++)\n        {\n            combin(digits,num_str,level+1,out+buf[i],res);\n        }\n    }\n};\n```\n\n","tags":["递归"],"categories":["LeetCode"]},{"title":"转载：时间复杂度O(logn)意味着什么？（侵删）","url":"/blog/2020/01/01/转载：时间复杂度O-logn-意味着什么？（侵删）/","content":"\n<p>&nbsp;</p>\n<ul><li>原文地址：https://github.com/xitu/gold-miner/blob/master/TODO/what-does-the-time-complexity-o-log-n-actually-mean.md</li>\n\t<li>原文作者：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F%40maazrk\" rel=\"nofollow\">Maaz</a></li>\n\t<li>译文出自：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner\" rel=\"nofollow\">掘金翻译计划</a></li>\n\t<li>译者：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcdpath\" rel=\"nofollow\">cdpath</a></li>\n\t<li>校对者：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fzaraguo\" rel=\"nofollow\">zaraguo (zaraguo)</a>,&nbsp;<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwhatbeg\" rel=\"nofollow\">whatbeg (Qiu Hu)</a></li>\n</ul><p>&nbsp;</p>\n\n<!-- more -->\n\n<p><em>友情提示：如果图片挂了，请翻墙或者点击原文地址阅读。</em></p>\n<p>&nbsp;</p>\n<p>预先知道算法的复杂度是一回事，了解其后的原理是另一件事情。</p>\n<p>&nbsp;</p>\n<p>不管你是计算机科班出身还是想有效解决最优化问题，如果想要用自己的知识解决实际问题，你都必须理解时间复杂度。</p>\n<p>先从简单直观的 O(1) 和 O(n) 复杂度说起。O(1) 表示一次操作即可直接取得目标元素（比如字典或哈希表），O(n) 意味着先要检查 n 个元素来搜索目标，但是 O(log n) 是什么意思呢？</p>\n<p>你第一次听说 O(log n) 时间复杂度可能是在学二分搜索算法的时候。二分搜索一定有某种行为使其时间复杂度为 log n。我们来看看是二分搜索是如何实现的。</p>\n<p>因为在最好情况下二分搜索的时间复杂度是 O(1)，最坏情况（平均情况）下 O(log n)，我们直接来看最坏情况下的例子。已知有 16 个元素的有序数组。</p>\n<p>举个最坏情况的例子，比如我们要找的是数字 13。</p>\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20191121164646526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70\"></p>\n<p>十六个元素的有序数组</p>\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20191121164704291.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70\"></p>\n<p>选中间的元素作为中心点（长度的一半）</p>\n<p><img alt=\"\" class=\"has\" height=\"191\" src=\"https://img-blog.csdnimg.cn/20191121164715238.jpeg\" width=\"628\"></p>\n<p>13 小于中心点，所以不用考虑数组的后一半</p>\n<p><img alt=\"\" class=\"has\" height=\"134\" src=\"https://img-blog.csdnimg.cn/20191121164726473.jpeg\" width=\"411\"></p>\n<p>重复这个过程，每次都寻找子数组的中间元素</p>\n<p>&nbsp;</p>\n<p><img alt=\"\" class=\"has\" height=\"101\" src=\"https://img-blog.csdnimg.cn/20191121164751215.jpeg\" width=\"285\"></p>\n<p><img alt=\"\" class=\"has\" height=\"91\" src=\"https://img-blog.csdnimg.cn/20191121164811565.jpeg\" width=\"223\"></p>\n<p>每次和中间元素比较都会使搜索范围减半。</p>\n<p>所以为了从 16 个元素中找到目标元素，我们需要把数组平均分割 4 次，也就是说，</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164824637.png\" width=\"288\"></p>\n<p>简化后的公式</p>\n<p>类似的，如果有 n 个元素，</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164908192.png\" width=\"301\"></p>\n<p>&nbsp;</p>\n<p>归纳一下</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164916433.png\" width=\"275\"></p>\n<p>分子和分母代入指数</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164930660.png\" width=\"275\"></p>\n<p>等式两边同时乘以 2^k</p>\n<p><img alt=\"\" class=\"has\" height=\"100\" src=\"https://img-blog.csdnimg.cn/20191121164955503.png\" width=\"285\"></p>\n<p>最终结果</p>\n<p>现在来看看「对数」的定义：</p>\n<blockquote>\n<p>为使某数（底数）等于一给定数而必须取的乘幂的幂指数。</p>\n</blockquote>\n\n<p>也就是说可以写成这种形式</p>\n<p><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdnimg.cn/2019112116500667.png\" width=\"331\"></p>\n<p>对数形式</p>\n<p>所以 log n 的确是有意义的，不是吗？没有其他什么可以表示这种行为。</p>\n<p>就这样吧，我希望我讲得这些你都搞懂了。在从事计算机科学相关的工作时，了解这类知识总是有用的（而且很有趣）。说不定就因为你知道算法的原理，你成了小组里能找出问题的最优解的人呢，谁知道呢。祝好运！</p>","tags":["时间复杂度"],"categories":["转载"]},{"title":"链式栈","url":"/blog/2019/12/29/链式栈/","content":"\n### 本次学习要点\n\n1. 编写链式栈\n2. 括号匹配问题\n\n<!--more -->\n\n### 概述\n\n在程序中同时使用多个栈的情况下，使用链式栈不但可以提高存储效率，同时还可以达到共享存储空间的目的。\n\n链式栈的结构如图所示，一般都不使用头结点，而进行直接实现。\n\n<img src=\"链式栈\\结构图.png\" style=\"zoom: 50%;\" />\n\n#### 1. 结点类模板\n\n```c++\ntemplate<typename ElemType>\nstruct Node\n{\n\tElemType data;\n\tNode<ElemType> *next;\n\n\tNode();\n\tNode(ElemType item, Node<ElemType> *link);\n};\ntemplate<typename ElemType>\nNode<ElemType>::Node()\n{\n\tnext = NULL;\n}\ntemplate<typename ElemType>\nNode<ElemType>::Node(ElemType item, Node<ElemType> *link)\n{\n\tdata = item;\n\tnext = link;\n}\n```\n\n#### 2. 链式栈类模板\n\n```c++\ntemplate<typename ElemType>\nclass LinkStack\n{\nprotected:\n\tNode<ElemType> *top;//栈顶指针\n\tint count;//元素个数\n\npublic:\n\tLinkStack();//构造函数\n\tvirtual~LinkStack();//析构函数\n\tint Length() const;//栈的长度\n\tbool Empty() const;//栈是否为空\n\tvoid Clear();//清空栈\n\tvoid Traverse(void(*visit)(const ElemType&)) const;//对每个对象调用visit\n\tbool Push(const ElemType &e);//压栈\n\tbool Top(ElemType &e) const;//返回栈顶元素\n\tbool Pop(ElemType &e);//出栈\n\tLinkStack(const LinkStack<ElemType>&copy);//复制构造函数模板\n\tLinkStack<ElemType>&operator=(const LinkStack<ElemType>&copy);\n};\n```\n\n#### 3. 成员函数\n\n```c++\ntemplate<typename ElemType>\nLinkStack<ElemType>::LinkStack()\n{\n\ttop = NULL;\n\tcount = 0;\n}\ntemplate<typename ElemType>\nLinkStack<ElemType>::~LinkStack()\n{\n\tClear();\n}\ntemplate<typename ElemType>\nint LinkStack<ElemType>::Length() const\n{\n\treturn count;\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Empty() const\n{\n\treturn top == NULL;\n}\ntemplate<typename ElemType>\nvoid LinkStack<ElemType>::Clear()\n{\n\tElemType tmpElem;\n\twhile (!Empty())\n\t{\n\t\tPop(tmpElem);\n\t}\n}\ntemplate<typename ElemType>\nvoid LinkStack<ElemType>::Traverse(void(*visit)(const ElemType &)) const\n{\n\tNode<ElemType> *tmpPtr;\n\tLinkStack<ElemType> tmps;\n\tfor (tmpPtr = top; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\ttmps.Push(tmpPtr->data);\n\t}\n\tfor (tmpPtr = tmps.top; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\t(*visit)(tmpPtr->data);\n\t}\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Push(const ElemType &e)\n{\n\tNode<ElemType> *newTop = new Node<ElemType>(e, top);\n\tif (newTop == NULL)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\ttop = newTop;\n\t\tcount++;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Top(ElemType &e) const\n{\n\tif (Empty())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\te = top->data;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Pop(ElemType &e)\n{\n\tif (Empty())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *old_top = top;\n\t\te = old_top->data;\n\t\ttop = old_top->next;\n\t\tdelete old_top;\n\t\tcount--;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nLinkStack<ElemType>::LinkStack(const LinkStack<ElemType> &copy)\n{\n\t//由栈copy构造新栈——复制构造函数模板\n\tif (copy.Empty())\n\t{\n\t\ttop = NULL;\n\t\tcount = 0;\n\t}\n\telse\n\t{\n\t\ttop = new Node<ElemType>(copy.top->data,copy.top);//栈顶\n\t\tcount = copy.count;\n\n\t\tNode<ElemType> *buttomPtr = top;//栈底\n\t\tfor (Node<ElemType>*tmpPtr = copy.top->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)//从copy中第二个值开始取，第一个已经被复制给top(buttomPtr)\n\t\t{\n\t\t\tbuttomPtr->next = new Node<ElemType>(tmpPtr->data,tmpPtr->next);\n\t\t\tbuttomPtr = buttomPtr->next;\n\t\t}\n\t}\n}\ntemplate<typename ElemType>\nLinkStack<ElemType>&LinkStack<ElemType>::operator=(const LinkStack<ElemType> &copy)\n{\n\t//将栈copy赋值给当前栈——重载赋值运算符\n\tif (&copy != this)\n\t{\n\t\tif (copy.Empty())\n\t\t{\t//copy为空\n\t\t\ttop = NULL;\n\t\t\tcount = 0;\n\t\t}\n\t\telse\n\t\t{\t//copy非空，复制栈\n\t\t\tClear();\n\t\t\ttop = new Node<ElemType>(copy.top->data,copy.top);\n\t\t\tcount = copy.count;\n\n\t\t\tNode<ElemType>*buttomPtr = top;\n\t\t\tfor (Node<ElemType>*tmpPtr = copy.top->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t\t\t{\n\t\t\t\tbuttomPtr->next = new Node<ElemType>(tmpPtr->data,tmpPtr-next);\n\t\t\t\tbuttomPtr = buttomPtr->next;\n\t\t\t}\n\t\t}\n\t}\n\treturn *this;\n}\n```\n\n#### 4. main()\n\n```c++\n#include<iostream>\n#include\"alg.h\"\nusing namespace std;\n\ntemplate<typename ElemType>\nvoid display(ElemType &e)\n{\n\tcout << e << \" \";\n}\n\nint main()\n{\n\tLinkStack<int> l1;\n\tint e1,e2;\n\tcout << \"输入的三个数分别为5，1，2\" << endl;\n\tl1.Push(5);\n\tl1.Push(1);\n\tl1.Push(2);\n\tcout << \"当前栈长为：\" << endl;\n\tcout << l1.Length() << endl;\n\tcout << \"弹出栈顶，返回值为：\" << endl;\n\tl1.Pop(e1);\n\tcout << e1 << endl;\n\tcout << \"当前栈长为：\" << endl;\n\tcout << l1.Length() << endl;\n\tl1.Top(e2);\n\tcout << \"返回当前栈顶元素：\\n\";\n\tcout << e2 << endl;\n\tcout << \"输出l1当前栈内元素(dir:bottom->top)：\\n\";\n\tl1.Traverse(display); cout << endl;\n\n\tLinkStack<int> l2(l1);\n\t//l2 = l1;//将l1复制给l2\n\n\tcout << \"输出l2当前栈内元素(dir:bottom->top)：\\n\";\n\tl2.Traverse(display); cout << endl;\n\treturn 0;\n}\n```\n\n测试结果如图：\n\n<img src=\"链式栈\\结果图.png\" style=\"zoom: 80%;\" />\n\n#### 问题\n\n设计一个算法判别用字符串表示的表达式中括号()[]{}是否配对出现，括号之间无优先级。\n\n算法思路：\n\n如果读入的字符为(、[、{，则进栈；\n\n若读入的字符为)，如果栈空则说明不匹配；栈顶括号为(，则出栈匹配，否则不匹配，此时栈顶为[、{或空；\n\n若读入的字符为]，如果栈空则说明不匹配；栈顶括号为[，则出栈匹配，否则不匹配，此时栈顶为(、{或空；\n\n若读入的字符为}，如果栈空则说明不匹配；栈顶括号为{，则出栈匹配，否则不匹配，此时栈顶为[、(或空；\n\n若读入其他字符，则继续读入；\n\n扫描完各字符后，如栈为空则匹配，否则不匹配（括号数量为偶数，但括号不一定匹配）\n\n代码如下：\n\n```c++\nbool match(char *s)\n{\n\tLinkStack<char> tmps;//临时栈\n\tchar tmpch;//临时字符\n\n\tfor (unsigned int i = 0; i < strlen(s); i++)\n\t{\n\t\tif (s[i] == '(' || s[i] == '[' || s[i] == '{')\n\t\t{\n\t\t\ttmps.Push(s[i]);\n\t\t}\n\t\telse if (s[i] == ')')\n\t\t{\n\t\t\tif (tmps.Empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmps.Top(tmpch), tmpch == '(')\n\t\t\t{\n\t\t\t\ttmps.Pop(tmpch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == ']')\n\t\t{\n\t\t\tif (tmps.Empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmps.Top(tmpch), tmpch == '[')\n\t\t\t{\n\t\t\t\ttmps.Pop(tmpch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '}')\n\t\t{\n\t\t\tif (tmps.Empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmps.Top(tmpch), tmpch == '{')\n\t\t\t{\n\t\t\t\ttmps.Pop(tmpch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (tmps.Empty())\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n```\n\n测试代码：\n\n```c++\ncout << \"无括号优先级\" << endl;\nchar *s1 = \"{a*[c+d*(e+f)]}\";\nchar *s2 = \"{a*[c+d*[e+f)]}\";\nstring True = \"匹配\";\nstring False = \"不匹配\";\nstring s1_result = match(s1) ? True : False;\nstring s2_result = match(s2) ? True : False;\ncout << s1 << '\\t';\ncout << s1_result << endl;\ncout << s2 << '\\t';\ncout << s2_result << endl;\n```\n\n运行结果：\n\n<img src=\"链式栈\\匹配问题.png\"  />\n\n","categories":["算法与数据结构"]},{"title":"循环链表解决约瑟夫问题","url":"/blog/2019/11/18/循环链表解决约瑟夫问题/","content":"\n### 本次学习要点\n\n1. 编写循环链表，由单链表修改得到\n2. 使用循环链表解决约瑟夫问题\n\n<!--more -->\n\n### 循环链表与单链表的不同之处\n\n循环链表是另外一种线性表链式存储结构，它的节点结构与单链表相同，与单链表不同的是在循环链表中的表尾节点的`next`不为空（NULL），而是指向头节点，所以循环链表为空的条件为`head->next==head`,如图所示：\n\n<img src=\"循环链表解决约瑟夫问题\\非空循环链表.png\" style=\"zoom: 67%;\" />\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a)非空循环链表\n\n<img src=\"循环链表解决约瑟夫问题\\空循环链表.png\" style=\"zoom: 67%;\" />\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(b)空循环链表\n\n循环链表的操作与线性表的操作基本相同，只是将算法中的循环条件改为`temPtr`是否等于头指针，以下给出与单链表不同之处：\n\n```c++\ntemplate<typename ElemType>\nNode<ElemType> * SimpleCircLinkList<ElemType>::GetElemPtr(int position) const\n//返回指向第position个结点的指针,时间复杂度O(n)\n{\n\tif (position == 0)\n\t{\n\t\treturn head;\n\t}\n\t\n\tNode<ElemType> *tmpPtr = head->next; //用tmpPtr遍历线性表以查找第position个结点\n\tint pos = 1;\t\t\t\t\t//tmpPtr所指结点的位置\n\n\twhile (tmpPtr != head&&pos < position)\n\t{\t//顺指针向后查找，直到tmpPtr指向第position个结点\n\t\ttmpPtr = tmpPtr->next;\n\t\tpos++;\n\t}\n\tif (tmpPtr != head&&pos == position)\n\t{\t//查找成功\n\t\treturn tmpPtr;\n\t}\n\telse\n\t{\t//查找失败\n\t\treturn NULL;\n\t}\n}\n```\n\n```c++\ntemplate<typename ElemType>\nint SimpleCircLinkList<ElemType>::Length() const\n//返回线性表元素的个数\n{\n\tint count = 0;\n\tfor (Node<ElemType> *tmpPtr = head->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\tcount++;\n\t\tif (tmpPtr == head) break;\n\t}\n\treturn count;\n}\n```\n\n```c++\ntemplate<typename ElemType>\nbool SimpleCircLinkList<ElemType>::Empty() const\n//如果线性表为空，返回true，否则返回false\n{\n\treturn head->next == head;\n}\n```\n\n```C++\ntemplate<typename ElemType>\nvoid SimpleCircLinkList<ElemType>::Traverse(void(*visit)(const ElemType &)) const\n//依次对线性表每个元素调用函数(*visit)\n{\n\tfor (Node<ElemType> * tmpPtr = head->next; tmpPtr != head; tmpPtr = tmpPtr->next)\n\t{\n\t\t(*visit)(tmpPtr->data);\n\t}\n}\n```\n\n### 循环列表解决与瑟夫问题\n\n问题描述：一个旅行社要从n个旅客中选出一名旅客，为他提供免费旅行服务，选择方法是让n个旅客围成一个圆圈，然后从信封中取出一张纸条，用上面写着的正整数m(m<n)作为报数值，第一个人从1开始一个人一个人按顺时针报数，报到第m个旅客时，令其出列。然后从下一个人开始，从1顺时针报数，报到第m个游客时，再令其出列，如此下去，直到只剩下一个人为止。此人即为优胜者。如n=8，m=3，出列的顺序为3、6、1、5、2、8、4，最初编号为7的游客获得免费旅行服务。（待更新算法详细步骤）\n\n```\n//main.cpp\n#include<iostream>\n#include\"alg.h\"\n\nusing namespace std;\n\ntemplate<typename ElemType>\nvoid display(ElemType &e)\n{\n\tcout << e << \" \";\n}\n//循环链表解决约瑟夫问题\nint main()\n{\n\tSimpleCircLinkList<int> la;\n\tint n = 8, m = 3;\n\tint position = 1;\n\tint out, winer;\n\tfor (int k = 1; k <= n; k++)\n\t{\n\t\tla.Insert(k, k);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tif (position > la.Length())\n\t\t\t{\n\t\t\t\tposition = 1;\n\t\t\t}\n\t\t\tposition++;\n\t\t}\n\t\tposition--;\n\t\tla.Delete(position, out);\n\t\tcout << out << \" \";\n\t}\n\t\tla.GetElem(1, winer);\n\t\tcout << endl << \"优胜者：\" << winer << endl;\n\t\treturn 0;\n}\n```\n\n执行结果：\n\n<img src=\"循环链表解决约瑟夫问题\\结果.png\"  />\n\n","categories":["算法与数据结构"]},{"title":"单链表的基本操作","url":"/blog/2019/10/30/单链表的基本操作/","content":"\n### 本次学习要点（更新于2019.12.3）\n\n1. 掌握线性表的抽象数据类型\n2. 掌握链表的基本操作\n3. 学习链表的较复杂的操作\n\n<!--more -->\n\n### 线性表的抽象数据类型\n\n1. `int Length() const`\n\n* 初始条件：线性表已存在\n* 操作结果：返回线性表中元素的个数\n\n2. `bool Empty() const`\n\n* 初始条件：线性表已存在\n* 操作结果：判断线性表是否为空\n\n3. `void Clear()`\n\n* 初始条件：线性表已存在\n* 操作结果：清空线性表\n\n4. `void Traverse(void(*visit)(const ElemType &))`\n\n* 初始条件：线性表已存在\n* 操作结果：对每个元素调用函数(*visit)\n\n5. `bool GetElem(int position,ElemType &e) const`\n\n* 初始条件：线性表已存在，1<=position<=Length()\n* 操作结果：用e返回第position处的元素值\n\n6. `bool SetElem(int position,const ElemType &e) `\n\n* 初始条件：线性表已存在，1<=position<=Length()\n* 操作结果：设置第position处的元素值为e\n\n7. `bool Delete(int position,ElemType &e)`\n\n* 初始条件：线性表已存在，1<=position<=Length()\n* 操作结果：删除第position个元素，并用e返回其值，长度减少1\n\n8. `bool Insert(int position,const ElemType &e)`\n\n* 初始条件：线性表已存在，1<=position<=Length()+1\n* 操作结果：在第position前插入元素e，长度加1\n\n#### 思考\n\n函数声明中的`const`是什么作用？在不同位置的意思分别是什么？\n\n答：在成员函数后的`const`指常成员函数，不能更改类成员变量的值；在变量前的`const`指常变量，在函数体重不能更改变量值。\n\n### 单链表的实现\n\n```c++\n//文件名alg.h\n//结点结构体模板\ntemplate<typename ElemType>\nstruct Node\n{\n//数据成员\n\tElemType data;\n\tNode<ElemType> *next;\n//构造函数模板\n\tNode();//无参数的构造函数模板\n\tNode(ElemType item, Node<ElemType> *link);//已知数据元素和后继指针建立结构\n};\n//结点模板的实现部分\ntemplate<typename ElemType>\nNode<ElemType>::Node()\n//构造后继指针为空的结点\n{\n\tnext = NULL;\n}\ntemplate<typename ElemType>\nNode<ElemType>::Node(ElemType item, Node<ElemType> *link)\n//构造一个数据元素为item和后继指针为link的结点\n{\n\tdata = item;\n\tnext = link;\n}\n//线性链表简单实现为数据成员只有头指针，成员函数模板与顺序表相似\n\n\n//简单线性链表类模板\ntemplate<typename ElemType>\nclass SimpleLinkList\n{\nprotected:\n\tNode<ElemType> *head;\n\tNode<ElemType> *GetElemPtr(int position) const;//返回指向第position个结点的指针\npublic:\n\tSimpleLinkList();\n\tvirtual~SimpleLinkList();\n\tint Length() const;\n\tbool Empty() const;\n\tvoid Clear();\n\tvoid Traverse(void(*visit)(const ElemType &)) const;\n\tbool GetElem(int position, ElemType &e) const;\n\tbool SetElem(int position, const ElemType &e);\n\tbool Delete(int position, ElemType &e);\n\tbool Insert(int position, const ElemType &e);\n\tSimpleLinkList(const SimpleLinkList<ElemType> &copy);\n\tSimpleLinkList<ElemType>&operator=(const SimpleLinkList<ElemType>&copy);\n};\n\n//辅助函数模板的实现\t\ntemplate<typename ElemType>\nNode<ElemType> * SimpleLinkList<ElemType>::GetElemPtr(int position) const\n//返回指向第position个结点的指针,时间复杂度O(n)\n{\n\tNode<ElemType> *tmpPtr = head; //用tmpPtr遍历线性表以查找第position个结点\n\tint pos = 0;\t\t\t\t\t//tmpPtr所指结点的位置\n\n\twhile (tmpPtr != NULL&&pos < position)\n\t{\t//顺指针向后查找，知道tmpPtr指向第position个结点\n\t\ttmpPtr = tmpPtr->next;\n\t\tpos++;\n\t}\n\tif (tmpPtr != NULL&&pos == position)\n\t{\t//查找成功\n\t\treturn tmpPtr;\n\t}\n\telse\n\t{\t//查找失败\n\t\treturn NULL;\n\t}\n}\n\n//成员函数的实现\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>::SimpleLinkList()\n//构造一个空链表\n{\n\thead = new Node<ElemType>;\n}\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>::~SimpleLinkList()\n//销毁线性表\n{\n\tClear();\n\tdelete head;\n}\ntemplate<typename ElemType>\nint SimpleLinkList<ElemType>::Length() const\n//返回线性表元素的个数\n{\n\tint count = 0;\n\tNode<ElemType> *tmpPtr;\n\tfor (tmpPtr = head->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\tcount++;\n\t}\n\treturn count;\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::Empty() const\n//如果线性表为空，返回true，否则返回false\n{\n\treturn head->next == NULL;\n}\ntemplate<typename ElemType>\nvoid SimpleLinkList<ElemType>::Clear()\n//清空线性表\n{\n\tElemType tmpElem;\n\twhile (!Empty())\n\t{\t//线性表非空，删除第一个元素\n\t\tDelete(1, tmpElem);\n\t}\n}\ntemplate<typename ElemType>\nvoid SimpleLinkList<ElemType>::Traverse(void(*visit)(const ElemType &)) const\n//依次对线性表每个元素调用函数(*visit)\n{\n\tfor (Node<ElemType> * tmpPtr = head->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\t(*visit)(tmpPtr->data);\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::GetElem(int position, ElemType &e) const\n//当线性表存在第position给元素时，用e返回其指，返回true，否则\n//返回false\n{\n\tif (position<1 || position>Length())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> * tmpPtr;\n\t\ttmpPtr = GetElemPtr(position);\n\t\te = tmpPtr->data;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::SetElem(int position, const ElemType &e)\n//将线性表的第position个位置的元素设置成e，position合法时返回true，否则\n//返回false\n{\n\tif (position<1 || position>Length())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *tmpPtr;\n\t\ttmpPtr = GetElemPtr(position);\n\t\ttmpPtr->data = e;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::Delete(int position, ElemType &e)\n{\n\tif (position<1 || position>Length())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *tmpPtr;\n\t\ttmpPtr = GetElemPtr(position - 1);//取出指向第position-1个结点的指针\n\t\tNode<ElemType> *nextPtr;          //新建指针nextPtr\n\t\tnextPtr = tmpPtr->next;           //新指针为tmpPtr的后继\n\t\ttmpPtr->next = nextPtr->next;     //删除position处的结点\n\t\te = nextPtr->data;                //用e返回其值\n\t\tdelete nextPtr;                   //释放被删结点\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::Insert(int position, const ElemType &e)\n{\n\tif (position<1 || position>Length() + 1)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *tmpPtr;\n\t\ttmpPtr = GetElemPtr(position - 1);\n\t\tNode<ElemType> *nextPtr;\n\t\tnextPtr = new Node<ElemType>(e, tmpPtr->next);\n\t\ttmpPtr->next = nextPtr;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>::SimpleLinkList(const SimpleLinkList<ElemType> &copy)\n{\n\t//未写\n}\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>&SimpleLinkList<ElemType>::operator=(const SimpleLinkList<ElemType>&copy)\n{\n\t//未写\n}\n\n```\n\n```c++\n//文件名main.cpp\n//单链表的基本操作\n#include<iostream>\n#include\"alg.h\"\n\nusing namespace std;\n\ntemplate<typename ElemType>\nvoid display(ElemType &e)\n{\n\tcout << e << \" \";\n}\n\nint main()\n{\n\tSimpleLinkList<int> test;//定义空链表\n\tSimpleLinkList<int> test1;//定义空链表\n\tint e = 0;//返回值\n\tint e1 = 50;\n\tint n = 8;\n\tfor (int k = 1; k <= n; k++)//建立链表\n\t{\n\t\ttest.Insert(k, k);\n\t}\n\tcout << \"建立的链表:\";\n\ttest.Traverse(display);//显示数据\n\tcout << endl;\n\n\tcout << \"链表的长度为:\";\n\tcout << test.Length() << endl;\n\n\tcout << \"链表是否为空(0代表非空):\";\n\tcout << test.Empty() << endl;\n\n\tcout << \"返回第五个位置的值(5)(GetElem):\";\n\ttest.GetElem(5, e);//返回第五个值\n\tcout << e << endl;\n\n\tcout << \"设置第五个位置的值(50)(SetElem):\";\n\ttest.SetElem(5, e1);//设置第五个值为e1;\n\tcout << e1 << endl;\n\n\tcout << \"输出当前的链表:\";\n\ttest.Traverse(display);//显示数据\n\tcout << endl;\n\t\n\tcout << \"删除第5个元素:\";\n\ttest.Delete(5, e);\n\tcout << \"删除的元素值为:\" << e << endl;\n\n\tcout << \"链表的长度为:\";\n\tcout << test.Length() << endl;\n\n\tcout << \"输出当前的链表:\";\n\ttest.Traverse(display);//显示数据\n\tcout << endl;\n\n\tcout << \"清空线性表(Clear)\";\n\ttest.Clear();\n\tcout << endl;\n\n\tcout << \"链表是否为空(0代表非空):\";\n\tcout << test.Empty() << endl;\n\n\treturn 0;\n}\n```\n\n执行结果：\n\n<img src=\"单链表的基本操作\\基本操作.png\" style=\"zoom: 50%;\" />\n\n### 一个问题\n\n已知线性表la和lb中的数据元素按值递增，现在要将la和lb合并成新的线性表lc，使lc中的数据元素扔递增有序。","categories":["算法与数据结构"]},{"title":"Git的基本使用(三)-Stash、Checkout和Reset（未完待续）","url":"/blog/2019/10/08/Git的基本使用-Stash、Checkout和reset/","content":"\n### 本次学习要点\n\n`Stash、Checkout`和`Reset`指令\n\n经常有这样的事情发生，当你正在进行项目中某一部分的工作，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点，所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 `git stash`。\n\n<!--more -->\n\n### 基本指令-stash\n\n```\ngit stash \n#保存当前工作区所有内容到当前分支的储藏栈的栈顶(工作区会变为最后一次commit时的内容)。\ngit stash apply \n#应用当前分支的储藏栈栈顶的储藏到工作区。\ngit stash apply <stash id> \n#应用当前分支的储藏栈指定位置的储藏到工作区，例如git stash apply stash@{0}。\ngit stash list \n#列出当前分支的储藏栈详细信息。\ngit stash drop <stash id> \n#移除当前分支的储藏栈指定位置的储藏。\ngit stash pop\n#从git栈中获取到最近一次stash进去的内容，恢复工作区的内容，获取之后，会删除栈中对应的stash。\n```\n\n- 唯一需要注意的是，`git stash apply`并不会改变储藏栈的内容，所以如果你觉得之前的那个储藏没用了，请手动调用`git stash drop <stash id>`清理储藏栈。特别的，`git stash pop`会自动应用当前分支的储藏栈栈顶的储藏到工作区，并将其从栈顶移除。\n\n#### 练习一\n\n1. 新建一个仓库，建立文件`test.txt`，随意键入一段内容（123），提交。\n2. 创建分支`feature`，修改`test.txt`文件内容（321）然后运行`git status`可以看到以下中间过程的内容：\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n3. 现在你想切换分支，但是你还不想提交你正在进行中的工作；所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 `git stash`。\n\n```\n$ git stash\nSaved working directory and index state WIP on master: 7ac5b3d master注释\n#test.txt中的内容变成了“123”，工作区内容变为最后一次提交的内容\n```\n\n4. 这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 `git stash list`：\n\n```\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\n```\n\n5. 切换到分支`feature`并且使用指令`git stash pop`，观察`test.txt`中的内容变化。\n\n```\n$ git stash pop\nOn branch feature\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (81b72af21b8037e4b185820e3a86b78d95b9f8d8)\n#文档内容变成了“321”，也就是master修改后的工作区，但现在pop命令把储藏的栈顶弹出，是在feature分支进行工作的，此时feature的工作区是修改后的文档。\n```\n\n6. 再次使用指令`git stash`，然后`git checkout master`，再次使用`git stash pop`，那么修改后的文档就是在`master`工作区了，最后直接查看工作区状态。\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n#### 练习二\n\n在练习一基础上使用`apply`指令：\n\n1. 当前工作区为`master`，`test.txt`中的内容是修改后的321，使用`stash`指令存储当前的工作区。\n\n```\n$ git stash\nSaved working directory and index state WIP on master: 7ac5b3d master注释\n\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\n```\n\n2. 此时`test.txt`内容为（123），修改其内容（1234），然后进行`add`（不进行此操作也可以），再进行一次存储。\n\n```\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\nstash@{1}: WIP on master: 7ac5b3d master注释\n#现在堆栈里存储了两个工作区，工作区空\n$ git status\nOn branch master\nnothing to commit, working tree clean\n#test.txt中内容变为“123”\n```\n\n3. 使用`apply`指令将堆栈中的栈顶应用到当前工作区，当前的栈顶应该是`stash@{0}`，所以内容应该恢复为“1234”。\n\n```\n$ git stash apply\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n#打开test.txt发现内容已经变回“1234”\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\nstash@{1}: WIP on master: 7ac5b3d master注释\n#堆栈中的内容不会主动删除，继续保存下来\n```\n\n4. 修改`test.txt`中的“1234”为“123”（初始工作区），然后使用`git stash apply`指令将栈中的`stash@{1}`（修改后的工作区，内容是“321”）返回到工作区，此时文档内容是“321”。\n\n```\n$ git stash apply stash@{1}\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n#test.txt中的内容是“321”\n```\n\n#### 一些标注\n\n##### 练习一\n\n初始工作区的`test.txt`内容为：123\n\n第一次修改后的`test.txt`内容为：321\n\n最后`master`中的`stash@{0}`内容为：321\n\n##### 练习二\n\n初始`master`中的`stash@{0}`内容为：321\n\n修改初始的工作区中的`test.txt`内容为：1234\n\n进行存储，`stash@{0}->stash@{1}`，内容为：321\n\n此时`stash@{0}`中的内容为：1234\n\n本次练习最后结果改回了“1234”。","tags":["Git"],"categories":["Git"]},{"title":"Git的基本使用(二) --撤销提交","url":"/blog/2019/09/29/Git的基本使用-撤销提交/","content":"\n### 本次学习要点：\n\nGit的撤销提交操作\n\n与回滚不同，如果认为某次的提交是有问题的，需要撤回这次的提交，应该怎么做呢？\n\n<!-- more -->\n\n### 主要指令\n\n```\n$ git revert <SHA ID>\n```\n\n该指令可以直接把某一次的提交取消，所有在本次提交中发生变更的文件都会还原回上一次提交的内容。因为针对同一分支master操作，所以会产生冲突（解决方法见一），解决冲突后，再将文件放入缓存区，进行提交.\n\n```\n$ git reset <之前某个版本ID>\n$ git reset --hard <之前某个版本ID>\n```\n\n上述指令是不安全的撤销方式。当年使用`git reset`来重置记录时，所有**在此之后**的记录都将永久消失，**但是还会保留当前的提交**。如果带上参数`--hard`，还会直接清空工作区里的所有变更（**如果此时做了修改但是还没有提交，那么直接就会被撤销到未改动的时刻**），直接使工作区内容撤销到指定提交的时刻，是一种比较暴力的撤销方式。\n\n### 实现1\n\n1. 新建一个库，新建一个文件`text.txt` ，输入内容“1”，保存后提交。并以此类推，一共得到三次提交，内容分别是“1”，“2”，“3”，使用`git log`查看提交历史。\n\n```\n$ git log\ncommit 51df17687ea6bb6a53ed24d614ddcfe9e455e9f9\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:47:24 2019 +0800\n\n    3.第三次提交\n    sign off:<543040659@qq.com>\n\ncommit 9e71ea1c78ff7aa910959e02acb44e8e3373a805\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:46:38 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 3d4d2f3a3f44c0fcb5d4357d85abf5cb33304e97\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:45:09 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n2. 使用`git revert`进行撤销操作，撤销到第二次提交，那么结果应该是显示第一次提交的内容，即“1”。\n\n```\n$ git revert 9e71ea\n```\n\n3. 此时产生了冲突，打开`test.txt`，将第三次的提交内容删除，留下内容“1”，不解决冲突无法提交。然后再加入缓存区，进行提交（当时没有记录，这里只有进行操作的指令，没有结果，失策失策）。\n\n```\n$ git add test.txt\n$ git status\t#可以看到test.txt加入了缓存，可以不写\n$ git commit\n```\n\n4. 最后使用`git log`查看提交记录，会产生一个新的提交记录，并且之前记录都会存在，所以是一种安全的撤销操作。\n\n```\n$ git log\ncommit 57124efed6dd52b7224c3e3b5ee0be7042cee27b (HEAD -> master)\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:50:18 2019 +0800\n\n    Revert \"2.第二次提交\"\n\n    This reverts commit 9e71ea1c78ff7aa910959e02acb44e8e3373a805.\n\ncommit 51df17687ea6bb6a53ed24d614ddcfe9e455e9f9\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:47:24 2019 +0800\n\n    3.第三次提交\n    sign off:<543040659@qq.com>\n\ncommit 9e71ea1c78ff7aa910959e02acb44e8e3373a805\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:46:38 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 3d4d2f3a3f44c0fcb5d4357d85abf5cb33304e97\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:45:09 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n总结：revert指令可以使版本撤销到之前的某一次提交，并且在那次提交中改变的部分都会还原为上一次提交的内容（比如撤销到第二次，那么内容就会还原为第一次提交的内容），并且在这个过程中会产生冲突，按照我的理解，产生冲突之后修改的txt文档，决定了还原的最终结果。如果我在解决冲突的过程中，留下了“3”，而不是“1”，那么还原的内容应该是“3”。\n\n### 实现2\n\n1. 新建一个库，新建一个文件`text.txt` ，输入内容“1”，保存后提交。并以此类推，一共得到三次提交，内容分别是“1”，“2”，“3”，使用`git log`查看提交历史。\n\n```\n$ git log\ncommit 9e541291495cfe4c57b62f699ff17deed99bd853 (HEAD -> master)\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:56:32 2019 +0800\n\n    3.第三次提交\n    sign off:<543040659@qq.com>\n\ncommit 1d0feb4e586995b4d1bd6e3d78af5350b2726b68\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:55:37 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 47bbd152043e6f2de771413739b2fccadad6893d\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:54:36 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n2. 使用`git reset`进行撤销操作1。先改变`test.txt`中的内容，开始应为“3”，现在可以任意改变，假如改为“5”，然后执行指令（撤销到第三次），并得到以下结果：\n\n```\n$ git reset 9e5412\nUnstaged changes after reset:\nM       test.txt\n```\n\n执行的结果就是`test.txt`文档中的”5”又变成了“3”，成功！\n\n3. 使用`git reset`进行撤销操作2。直接执行指令撤销到第二次，得到以下结果：\n\n```\n$ git reset 1d0fe\nUnstaged changes after reset:\nM       test.txt\n#再执行git log指令\n$ git log\ncommit 1d0feb4e586995b4d1bd6e3d78af5350b2726b68 (HEAD -> master)\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:55:37 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 47bbd152043e6f2de771413739b2fccadad6893d\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:54:36 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n可以发现第三次的提交已经没有了，所以是一种不安全的撤销，此时`test.txt`中应为“2”，如果你此时修改了文档中的内容，再执行以上步骤，文档中的内容修改会被继续保留下来，与下面的有所不同。\n\n4. 使用`git reset --hard`进行撤销操作。如前所述，此指令会直接撤销到**当前提交时刻的原始版本**（以撤销到第二次为例）。\n\n```\n$ git reset --hard 1d0feb\nHEAD is now at 1d0feb4 2.第二次提交\n```\n\n我们一开始在第二次提交时，里面的内容就是“2”，现在执行上述指令后，`test.txt`中就是“2”。如果把`test.txt`中的内容修改为“5”，甚至你已经进行add指令加入到了缓存，但是没有提交，那么再次执行上述hard指令后，文档中的内容又变成了“2”，你之前的所有修改都白费了，所以要特别小心，慎用！\n\n## 最后\n\n这次的练习收获很多，不过只是很浅显的一些理解，不免有些理解不到位或者容易产生歧义的地方。如果有哪里有疑问，可以和我联系进行讨论。\n\n","tags":["Git"],"categories":["Git"]},{"title":"Git的基本使用(一)","url":"/blog/2019/09/26/Git的基本使用（一）/","content":"\n### 本次学习要点：\n\n1. 如何建立一个本地仓库\n2. 设置你的个性化信息\n3. 工作区与缓存区\n\n4. 提交与历史\n\n<!--more -->\n\n### 如何建立一个本地仓库\n\n有两种方法，一种是Git GUI，一种是Git Bush，第一步都是先建立一个空文件夹。\n\n1. 在文件夹空白处右键，选择Git GUI Here，点击Create New Repository，OK。\n2. 在文件夹空白处右键，选择Git Bush Here，输入`git init`，OK。\n\n### 设置你的个性化信息\n\nGit是一个团队开发工作，你对团队的每次贡献都会有相应的记录。所以此时你应该告诉这个仓库你的个人信息，主要包括两个：\n\n- **邮箱** 邮箱是别人联系你的途径，当然你应当留意你的个人隐私问题，这个内容我们会放到之后的几章中讲，此处你可以随便填写一个邮箱。\n- **姓名** 你可以填真名或是化名，取决于你的实际开发和协作环境。\n\n1. 打开Git Bash界面，我们输入指令`git config --help`来查看`git config`的帮助文档。【–help】是一个很有用的指令参数，当你忘了某个指令的使用方法，你都可以如此进行搜寻。\n2. 我们可以看到如此一行：\n\n```\nuser.email\n\tYour email address to be recorded in any newly created commits. \n\tCan be overridden by the GIT_AUTHOR_EMAIL, GIT_COMMITTER_EMAIL, \n\tand EMAIL environment variables. See git-commit-tree(1).\n```\n\n* 使用`git config user.email <你的Email>`进行邮箱的设置。同样的，`git config user.name <你的名字或化名>`可以设置该本地仓库的所有者姓名。\n\n* 当你设置完这些值之后，可以打开`.gti/config`，查看到你刚刚所设置邮箱和姓名。\n\n### 工作区与缓存区\n\n<img src=\"Git的基本使用（一）\\GitFlow.jpg\" style=\"zoom:50%;\" />\n\n​                                                            上图来源于西电腾讯TIC-Git的培训资料\n\nGit的基本工作流程，目前阶段我们需要知道三个区域：**工作区域**、**缓存区**和**仓库记录**。其中，仓库记录是由**历史记录**构成的，因为历史纪录是一棵树状结构，也被叫做(History Tree)。\n\n- 用户在工作区域(或工作目录)中进行的修改会被Git检测到，通过`add`指令被提交到缓存区。\n- 缓存区中的文件是工作区域中的文件的一次快照备份，你之后在工作区域中做任何修改都不会影响到缓存区中同一个文件的内容，除非再次使用`add`指令更新缓存区。\n- 当你觉得工作做得差不多了，你可以使用`commit`指令，把缓存区中的文件提交到仓库记录，仓库记录会自动生成一次历史记录。你可以简单认为仓库记录就是个数据库，一次`commit`指令就是一次数据库写入请求。从此之后该记录将一直留在仓库中，你也可以把工作区中的数据文件随时回滚到当时提交的这个版本。\n- 缓存区中的文件在并未被`commit`之前，并不会被写入记录，也就意味着有些操作会导致你丢失缓存区的文件快照备份(如`checkout`等)。\n\n```\ngit add <filename>\n#添加文件至缓存区\ngit status\n#查看当前缓存区的状态\ngit commit\n#将缓存区的文件提交到仓库\n```\n\n### 提交与历史\n\n* 打开Git Bash，键入`git log`，即可查看提交的历史纪录。如果对当前提交不满意，找到上一次提交的版本ID值(SHA ID)，键入命令`git checkout <SHA ID>`，此时版本便已回滚到了之前那个版本，当前的提交会直接删除掉。\n\n* 在Vim界面中，按字母a来进入编辑模式，编辑完毕后按ESC键退出编辑，再按大写锁定，按ZZ来退出Vim。\n\n编辑模板\n\n提交了xxxx\n\n来自：Zxy<<543040659@qq.com>>","tags":["Git"],"categories":["Git"]},{"title":"Sublime Text3安装Emmet插件遇到的问题及解决","url":"/blog/2019/09/16/Sublime-text3安装Emmet插件遇到的问题及解决/","content":"\n# 写在前面\n\n最近对前端的知识准备进行一个入门，首先学习一下html文档的写法，第一步就是选择一个合适的开发工具。<!-- more -->当然，html文件也可以用记事本的方式进行编写，不过在尝试了记事本编写之后还是放弃了，缩进或者格式都得自己来，无疑是给自己徒增烦恼。\n\n在进行一番查看之后，选择了Sublime Text3这款工具来编写html文件，这款工具目前也比较流行，具体的好处就是可以带很多插件，提高你写代码的效率。这里附上ST3的下载网址：\n\nhttp://www.sublimetext.com/3\n\n# 为什么使用Emmet这个插件？\n\n在没有安装Emmet之前，Sublime Text的使用貌似和记事本没有什么不同，也是得自己写结构，区别就是颜色好看了些，而安装了Emmet之后就不同了，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度，可以直接使用 !+tab 快速得到一个标准的html5文档，如下图所示：\n\n<img src=\"Sublime-text3安装Emmet插件遇到的问题及解决\\ST界面.png\" style=\"zoom:50%;\" />\n\n# 安装Emmet插件\n\n这里已经默认你安装了Package Control，这个组件是用来安装/删除插件和其他一些功能要用到的（目前我就用到了安装和删除两个功能）。\n\n## 自动安装法\n\n这个方法就是看你运气，不过过程一定是正确的，但由于各种原因（墙、网络之类的）安装不成功的大有人在，所以先写一下自动安装法。\n\n1. 在Sublime Text3的主页面按**CTRL+SHIFT+P**打开Package Control\n2. 输入**install**，选择第一个回车\n3. 这时候会让你选择需要安装的插件，你输入**Emmet**，选择第一个回车即可\n4. 左下角会显示下载PyV8，在提示**PyV8 binary successfully loaded**即安装完成\n5. 重启Sublime Text3，安装完成！\n\n当然，一般人像我运气一样的，这样是成功不了的（坏笑）。\n\n## 手动安装法\n\n### 1.安装PyV8\n\n在你安装Emmet时，你可能出现下面这种错误提示：\n\n***Sublime Text Error while loading PyV8 binary: exit code 1 Try to manually install Pyv8 form https://github.com/emetio/pyv8-binaries***\n\n出现这种情况的原因就是下载PyV8这个包不成功，那么你就得手动去下载，这个里也把网址给你了，如下：https://github.com/emmetio/pyv8-binaries 选择合适你电脑的版本去下载，这个必须记住，不然可能会用不了，我第一次就犯了这个错误。因为我电脑装了python3.7，所以我选择了 **pyv8-win64-p3**，我把下载地址也贴出来，不过因为gtihub是国外的网站，所以下载会很慢，链接如下：\n\nhttps://github.com/emmetio/pyv8-binaries/raw/master/pyv8-win64-p3.zip\n\n下载好了之后，对它进行解压，得到下面这个文件：\n\n<img src=\"Sublime-text3安装Emmet插件遇到的问题及解决\\pyv8.png\" style=\"zoom:80%;\" />\n\n接下来按照以下的步骤做就ok了：\n\n1. 打开Sublime Text\n2. 依次选择首选项 -> 浏览插件目录（我的汉化了，不然是Preferences ->Browse Packages）\n3. 新建PyV8文件夹\n4. 在PyV8文件夹把上图中的文件复制过来\n5. 重启Sublime Text\n\n现在你就可以在ST3中使用Emmet的功能了，不过还有运气不好的人，还是不能用，比如说我，那么继续往下看。\n\n### 2.手动安装Emmet\n\n如果你还是无法使用Emmet，但是你在首选项菜单中的Package Settings还能看到Emmet的身影，然而那只是个空壳，继续进入插件目录，你会发现没有与Emmet相关的文件夹的存在，那么你就需要自己手动安装Emmet。下载地址如下（下载也比较慢，但是只有200k左右）：\n\nhttps://codeload.github.com/sergeche/emmet-sublime/zip/master\n\n下载好了之后，继续进入插件目录（首选项 -> 浏览插件目录），把解压后的文件放进去，如图：\n\n<img src=\"Sublime-text3安装Emmet插件遇到的问题及解决\\emmet.png\" style=\"zoom:50%;\" />\n\n接下来你再重启ST就行了，需要注意的是，如果你没有装PyV8，那么你打开ST之后它会自动再一次下载这个包，同样可能出现1中的问题，那么你可以先把PyV8装好，再手动安装Emmet，重启之后就大功告成，终于装好啦！我属于运气最差的那种，不好的都让我遇到了，刚接触花了几个小时才弄明白，虽然最后成功了，我还是流下了没有技术的眼泪。。。","categories":["前端"]},{"title":"一个测试文档","url":"/blog/2019/09/06/一个测试文档/","content":"\n目前没有特别需要写的东西，就收藏几个网站，便于之后写文章时查阅语法\n\n<!-- more -->\n\n参考网站：\n\n[1]https://www.jianshu.com/p/56d99a3049a5\n\n[2]https://blog.csdn.net/u014061630/article/details/81359144\n\n记录一下: [我的博客](https://www.xingyuzhao.ltd)\n\n**使用该`<!-- more -->`标志来控制文章的摘要预览，因为这种方式可以让摘要也按照css文件中的样式来渲染。如果使用了自动摘要的功能，你会发现文章摘要是一大团没有样式的文本，很是难看。**\n\n","tags":["Markdown语法"],"categories":["Hexo"]},{"title":"使用hexo遇到的问题及解决方案","url":"/blog/2019/09/05/使用hexo遇到的问题及解决方案/","content":"使用hexo遇到的问题及解决\n\n<!-- more -->\n\n#### 上传步骤\n\n1. hexo generate\n2. hexo server (http://localhost:4000/)\n3. hexo deploy\n\n#### 公式的显示问题\n\n公式内换行使用`//`时，会被识别成转义字符，需要再加上`//`，故需要使用`////`。\n\n如果使用**kramed**对公式进行渲染，会导致序号的显示出现问题，所以又改了回来，继续使用**marked**。","categories":["Hexo"]}]