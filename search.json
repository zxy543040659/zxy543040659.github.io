[{"title":"LeetCode435-无重叠区间","url":"//www.xingyuzhao.ltd/blog/2020/12/31/LeetCode435-无重叠区间/","content":"\n#### 题目描述\n\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n\n**注意**:\n\n可以认为区间的终点总是大于它的起点。\n区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n\n<!-- more-->\n\n<img src=\"LeetCode435-无重叠区间\\435.png\"  />\n\n#### 思路\n\n首先对二维数组排序，对其中的每个一维数组，先按照元素的第一个升序排列，如果第一个元素相同，再按照第二个升序排列。\n\n如此一来，为了使移除的区间数最小，那么就需要**从重叠的区间中选出右端点最小的一个**，那样就可以尽可能留下更多不重叠的空间（所以说只按照第二个元素升序排列也是可以的）。\n\n排序后，如果前一个数组的第二个元素在第二个数组范围之内，就留下前一个数组，用它把第二个数组覆盖；如果前一个数组第二个元素大于第二个数组的后一个元素，那么留下第二个数组，不用进行覆盖，但是前一个数组是需要移除的。这两种情况下，都需要移除操作。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), [](vector<int> &v1, vector<int> &v2) -> bool{\n            if(v1[0] < v2[0])\n                return true;\n            else if(v1[0] == v2[0])\n                return v1[1] < v2[1];\n            else\n                return false;\n        });\n        // sort(intervals.begin(), intervals.end());\n        // for(auto &v1 : intervals){\n        //     for(auto &v2 : v1)\n        //         cout << v2 << \" \";\n        // }\n        int cnt = 0;\n        for(int i = 1; i < intervals.size(); ++i){\n            if(intervals[i - 1][1] > intervals[i][0] && intervals[i - 1][1] <= intervals[i][1]){\n                intervals[i][0] = intervals[i - 1][0];\n                intervals[i][1] = intervals[i - 1][1];\n                cnt++;\n            }\n            else if(intervals[i - 1][1] > intervals[i][0] && intervals[i - 1][1] > intervals[i][1]){\n                cnt++;\n            }\n            else continue;\n        }\n        return cnt;\n    }\n};\n```\n\n#### Reference\n\nC++ STL sort作用于二维vector 效果和应用：\n\nhttps://blog.csdn.net/y625658683/article/details/104154089\n\n#### Appendix\n\n对于二维数组，`sort`是把`vector<int>`作为一个一维数组对象，整体进行比较和排序。\n\n默认比较两个`int`向量的规则是：\n\n从第一个元素开始比，第一个元素小的，整个向量就小，如果第一个元素一样，再比较第二个，第二个元素小的，整个向量小，依此类推。`sort`默认按从小到大排序。\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode1046-最后一块石头的重量","url":"//www.xingyuzhao.ltd/blog/2020/12/30/LeetCode1046-最后一块石头的重量/","content":"\n#### 题目描述\n\n有一堆石头，每块石头的重量都是正整数。\n\n每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n\n如果 `x == y`，那么两块石头都会被完全粉碎；\n如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。\n\n<!-- more-->\n\n#### 思路及代码\n\n##### 链表\n\n###### 思路\n\n每次寻找最大的两个石头重量进行碰撞，直到链表为空或只剩下一个元素：\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        if(stones.size() <= 1) return stones.empty() ? 0 : stones[0];\n        list<int> li(stones.begin(), stones.end());\n        while(!li.empty()){\n            auto it1 = max_element(li.begin(), li.end());\n            int val1 = *it1;\n            li.erase(it1);\n            auto it2 = max_element(li.begin(), li.end());\n            int val2 = *it2;\n            if(val2 != val1)\n                *it2 = abs(val1 - val2);\n            else li.erase(it2);\n            if(li.size() == 1) break;\n        }\n        return li.empty() ? 0 : *li.begin();\n    }\n};\n```\n\n##### 优先队列\n\n###### 思路\n\n大顶堆，每次前两个出队元素就是石头中重量最大的两个。\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        priority_queue<int, vector<int>, less<int>> p_q(stones.begin(), stones.end());\n        while(!p_q.empty()){\n            if(p_q.size() == 1) break;\n            int v1 = p_q.top();\n            p_q.pop();\n            int v2 = p_q.top();\n            p_q.pop();\n            int v = abs(v1 - v2);\n            if(v != 0) p_q.push(v);\n        }\n        return p_q.empty() ? 0 : p_q.top();\n    }\n};\n```\n\n","tags":["链表","优先队列"],"categories":["LeetCode"]},{"title":"LeetCode330-按要求补齐数组","url":"//www.xingyuzhao.ltd/blog/2020/12/29/LeetCode330-按要求补齐数组/","content":"\n#### 题目描述\n\n给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 `[1, n]` 区间内选取任意个数字补充到 $nums$ 中，使得 `[1, n]` 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。\n\n<!-- more-->\n\n<img src=\"LeetCode330-按要求补齐数组\\330.png\"  />\n\n#### 思路\n\n如果区间 $[1,x)$ 的所有数都被覆盖了：\n\n*  如果$nums[i]\\in[1,x)$，那么区间 $[1+nums[i],x+nums[i])$ 中所有数也会被覆盖。由于 $nums[i]\\geq1$ ，则此时 $x\\in[1+nums[i],x+nums[i])$，覆盖区间可以更新为 $[1,x+nums[i])$。\n*  如果 $nums[i]$ 恰好等于 $x$ ，那么覆盖区间变为 $[1,x+nums[i])$。不需要补充 $x$ 。\n* 否则，补充 $x$ ，则区间 $[1,x]$ 全部覆盖；并且可以得到覆盖区间 $[1+x,x+x)=[x+1,2x)$。两者取交集得到此时覆盖数字区间 $[1,2x)$，此时覆盖的数字最多（如果取小于 $x$ 的数，覆盖区间会变小，这是不希望看到的， $x$ 不能取两次，每个数字只能取一次）。\n* 当 $x>n$ 时，就可以结束了。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minPatches(vector<int>& nums, int n) {\n        // 初始区间为空，表示已经覆盖\n        long long x = 1;\n        int index = 0;\n        int times = 0;\n        while(x <= n){\n            if(index < nums.size() && nums[index] < x){\n                x += nums[index++];\n            }\n            else if(index < nums.size() && nums[index] == x){\n                x += nums[index++];\n            }\n            else{\n                x <<= 1;\n                times++;\n            }\n        }\n        return times;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/","tags":["贪心算法","数学"],"categories":["LeetCode"]},{"title":"LeetCode309-最佳买卖股票时机含冷冻期","url":"//www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-最佳买卖股票时机含冷冻期/","content":"\n#### 题目描述\n\n给定一个整数数组，其中第 $i$ 个元素代表了第 $i$ 天的股票价格 。\n\n* 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n* 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n  卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n<!-- more-->\n\n<img src=\"LeetCode309-最佳买卖股票时机含冷冻期\\309.png\"  />\n\n#### 思路\n\n本题与其他股票问题不同之处在于**卖出之后至少间隔一天才能够买入**，可以多次买入卖出。\n\n##### 定义dp数组\n\n$dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益。\n\n$dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。\n\n##### 状态转移方程\n\n* 如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：\n  $$\n  dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])\n  $$\n\n* 如果当天持有股票，那么前一天可以持有股票或者前两天未持有股票，当天买入（如果前一天持有且卖出股票，当天就不能买入了；前一天如果未持有且没有卖出股票，就与前两天未持有，当天买入等价了）：\n  $$\n  dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i])\n  $$\n\n##### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。假设有第零天，那么收益应也为 $0$。\n\n```cpp\ndp[0][0] = 0;\ndp[0][1] = -prices[0];\ndp[-1][0] = 0; // 用dp_0 = 0代替\n```\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        int dp_0 = 0;\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(dp[i - 1][1], (i - 2 < 0 ? dp_0 : dp[i - 2][0]) - prices[i]);\n        }\n        return dp[prices.size() - 1][0];\n    }\n};\n```\n\n##### 空间优化\n\n由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        int profit = 0;\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, profit - prices[i]);\n            profit = profit0;\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机]()\n\n[LeetCode122-买卖股票的最佳时机II]()\n\n[LeetCode122-买卖股票的最佳时机III]()\n\n[LeetCode122-买卖股票的最佳时机 IV]()\n\n[LeetCode309-最佳买卖股票时机含冷冻期]()\n\n[LeetCode714-买卖股票的最佳时机含手续费]()\n\n","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode121-买卖股票的最佳时机","url":"//www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-买卖股票的最佳时机/","content":"\n#### 题目描述\n\n给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n**注意**：你不能在买入股票前卖出股票。\n\n<!-- more-->\n\n<img src=\"LeetCode121-买卖股票的最佳时机\\121.png\"  />\n\n#### 思路\n\n##### 贪心算法\n\n###### 策略\n\n从前往后遍历找到最小的价格买入，再往后找到最大的价格卖出即可。\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        stack<int> st;\n        int res = 0;\n        st.push(prices[0]);\n        for(int i = 1; i < prices.size(); i++)\n        {\n            if(prices[i] <= st.top())\n            {\n                st.pop();\n                st.push(prices[i]);\n            }\n            else\n            {\n                int m = prices[i] - st.top();\n                res = res > m ? res : m;\n            }\n        }\n        return res;\n    }\n};\n```\n\n##### 动态规划\n\n本题是[LeetCode122-买卖股票的最佳时机II]()的简化版，这道题与其最大的区别在于限制交易次数为 **一次**，找到最小的起点之后，再去找最大的终点即可。\n\n###### 定义dp数组\n\n$dp[i][0]$ 表示第 $i$ 天不持有股票可获得的最大收益。\n\n$dp[i][1]$ 表示第 $i$ 天持有股票可获得的最大收益。\n\n###### 状态转移方程\n\n* 如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：\n  $$\n  dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])\n  $$\n\n* 如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入（只能持有一次，所以第一次持有时的利润为$-prices[i]$）：\n  $$\n  dp[i][1]=max(dp[i-1][1],-prices[i])\n  $$\n\n###### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。\n\n```cpp\ndp[0][0] = 0;\ndp[0][1] = -prices[0];\n```\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(dp[i - 1][1], -prices[i]);\n        }\n        return dp[prices.size() - 1][0];\n    }\n};\n```\n\n###### 空间优化\n\n由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, -prices[i]);\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机]()\n\n[LeetCode122-买卖股票的最佳时机II]()\n\n[LeetCode122-买卖股票的最佳时机III]()\n\n[LeetCode122-买卖股票的最佳时机 IV]()\n\n[LeetCode309-最佳买卖股票时机含冷冻期]()\n\n[LeetCode714-买卖股票的最佳时机含手续费]()","tags":["动态规划","贪心算法","栈","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode123-买卖股票的最佳时机III","url":"//www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-买卖股票的最佳时机III/","content":"\n#### 题目描述\n\n给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。\n\n**注意**: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n<!-- more-->\n\n<img src=\"LeetCode123-买卖股票的最佳时机III\\123.png\"  />\n\n#### 思路\n\n本题是[LeetCode122-买卖股票的最佳时机II]()的升级版，这道题与其最大的区别在于限制交易次数为 **两次**，所以选择哪两次交易至关重要。\n\n##### 定义dp数组\n\n需要记录当前还剩下多少次交易次数，还有当天是否持有股票（ $k=0,1,2$ ）。\n\n$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。\n\n$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。\n\n##### 状态转移方程\n\n* 第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：\n  $$\n  dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);\n  $$\n\n* 第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：\n  $$\n  dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n  $$\n\n##### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：\n\n```cpp\n// 剩余交易i次，获得收益初始化\nfor(int i = 0; i <= k; ++i){\n    dp[0][i][0] = 0;\n    dp[0][i][1] = -prices[0];\n}\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2 + 1, vector<int>(2)));\n        for(int i = 0; i <= 2; ++i){\n            dp[0][i][0] = 0;\n            dp[0][i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = 2; j > 0; --j){\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n        return dp[prices.size() - 1][2][0];\n    }\n};\n```\n\n#### 空间优化\n\n由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(2 + 1, vector<int>(2));\n        for(int i = 0; i <= 2; ++i){\n            dp[i][0] = 0;\n            dp[i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = 2; j > 0; --j){\n                dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]);\n                dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]);\n            }\n        }\n        return dp[2][0];\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机]()\n\n[LeetCode122-买卖股票的最佳时机II]()\n\n[LeetCode122-买卖股票的最佳时机III]()\n\n[LeetCode122-买卖股票的最佳时机 IV]()\n\n[LeetCode309-最佳买卖股票时机含冷冻期]()\n\n[LeetCode714-买卖股票的最佳时机含手续费]()\n\n","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode122-买卖股票的最佳时机II","url":"//www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-买卖股票的最佳时机II/","content":"\n#### 题目描述\n\n给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n<!-- more-->\n\n<img src=\"LeetCode122-买卖股票的最佳时机II\\122.png\"  />\n\n#### 思路\n\n##### 贪心算法\n\n###### 策略\n\n本题要求尽可能地完成更多地交易，所以可以使用贪心策略，在局部价格最低时买入，在局部价格最高时卖出，重复此操作直到最后一天，最后一天不持有股票时收益最大。\n\n* 局部最低：如果后一天价格低于前一天价格，更新局部最低，否则已经是局部最低\n* 局部最高：在持有股票后，当前价格的下一天价格降低，说明已经达到局部最高\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int res = 0;\n        int val = prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            if(prices[i] <= val) {\n                val = prices[i];\n            }\n            else{\n                if(i + 1 < prices.size() && prices[i + 1] < prices[i]){\n                    res += prices[i] - val;\n                    val = prices[i + 1];\n                    i++;\n                }\n                // 最后一天如果还持有股票应该卖出\n                if(i + 1 == prices.size()){\n                    res += prices[i] - val;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n###### 另一种策略\n\n把股票的交易价格看成曲线图，找出图中上升的部分，即为交易获利。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int> prices)\n    {\n        int sum = 0;\n        for(int i=0; i<prices.size()-1; i++)\n        {\n            if(prices[i] < prices[i + 1])\n            sum += prices[i + 1] - prices[i];\n        }\n        return sum;\n    }\n};\n```\n\n##### 动态规划\n\n###### 定义dp数组\n\n每天的状态可以为持有股票或不持有股票，所以使用 $dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益； $dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。本题交易次数 **+∞** 。\n\n######  状态转移方程\n\n* 如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：\n  $$\n  dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])\n  $$\n\n* 如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入：\n  $$\n  dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])\n  $$\n\n###### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。\n\n```cpp\ndp[0][0] = 0;\ndp[0][1] = -prices[0];\n```\n\n###### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = 0;\n        dp[0][1] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n        }\n        return dp[prices.size() - 1][0];\n    }\n};\n```\n\n###### 空间优化\n\n由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, profit0 - prices[i]);\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机]()\n\n[LeetCode122-买卖股票的最佳时机II]()\n\n[LeetCode122-买卖股票的最佳时机III]()\n\n[LeetCode122-买卖股票的最佳时机 IV]()\n\n[LeetCode309-最佳买卖股票时机含冷冻期]()\n\n[LeetCode714-买卖股票的最佳时机含手续费]()","tags":["动态规划","贪心算法","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode188-买卖股票的最佳时机IV","url":"//www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-买卖股票的最佳时机IV/","content":"\n#### 题目描述\n\n给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。\n\n**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n<!-- more-->\n\n<img src=\"LeetCode188-买卖股票的最佳时机IV\\188.png\"  />\n\n#### 思路\n\n本题是[LeetCode122-买卖股票的最佳时机II]()的升级版，这道题与其最大的区别在于限制交易次数为 **k** 次，所以选择在何时交易至关重要。\n\n因为买入卖出至少得两天，所以最大的交易次数不会超过 $prices.size()/2$ 。如果 $k\\geq{prices.size()/2}$ ，那么本题就退化为122题。\n\n##### 定义dp数组\n\n需要记录当前还剩下多少次交易次数，还有当天是否持有股票。\n\n$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。\n\n$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。\n\n##### 状态转移方程\n\n* 第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：\n  $$\n  dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);\n  $$\n\n* 第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：\n  $$\n  dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n  $$\n\n##### 初始化\n\n在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：\n\n```cpp\n// 剩余交易i次，获得收益初始化\nfor(int i = 0; i <= k; ++i){\n    dp[0][i][0] = 0;\n    dp[0][i][1] = -prices[0];\n}\n// 在没有进行股票交易时不允许持有股票\n// 这个系列中没有用到，记录学习一下\ndp[-1][k][1] = -INF;\ndp[i][0][1] = -INF;\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if(k == 0 || prices.empty()) return 0;\n        if(k >= prices.size() / 2){\n            return maxprofit(prices);\n        }\n        vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(k + 1, vector<int>(2, 0)));\n        // 最多交易i次，获得的收益\n        for(int i = 0; i <= k; ++i){\n            dp[0][i][0] = 0;\n            dp[0][i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = k; j > 0; --j){\n                // 第i天不持有，前一天不持有或前一天持有今天卖出\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                // 第i天持有，前一天持有或前一天不持有今天买入\n                dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n        return dp[prices.size() - 1][k][0];\n    }\n    int maxprofit(vector<int> &prices){\n        if(prices.empty()) return 0;\n        int profit0 = 0;\n        int profit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(profit0, profit1 + prices[i]);\n            int new1 = max(profit1, profit0 - prices[i]);\n            profit0 = new0;\n            profit1 = new1;\n        }\n        return profit0;\n    }\n};\n```\n\n#### 空间优化\n\n由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        if(k == 0 || prices.empty()) return 0;\n        if(k >= prices.size() / 2){\n            return maxprofit(prices);\n        }\n        vector<vector<int>> dp(k + 1, vector<int>(2));\n        // 最多交易i次，获得的收益\n        for(int i = 0; i <= k; ++i){\n            dp[i][0] = 0;\n            dp[i][1] = -prices[0];\n        }\n        for(int i = 1; i < prices.size(); ++i){\n            for(int j = k; j > 0; --j){\n                // 第i天不持有，前一天不持有或前一天持有今天卖出\n                dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]);\n                // 第i天持有，前一天持有或前一天不持有今天买入\n                dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]);\n            }\n        }\n        return dp[k][0];\n    }\n    int maxprofit(vector<int> &prices){\n        if(prices.empty()) return 0;\n        int fit0 = 0;\n        int fit1 = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int new0 = max(fit0, fit1 + prices[i]);\n            int new1 = max(fit1, fit0 - prices[i]);\n            fit0 = new0;\n            fit1 = new1;\n        }\n        return fit0;\n    }\n};\n```\n\n#### Reference\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机]()\n\n[LeetCode122-买卖股票的最佳时机II]()\n\n[LeetCode122-买卖股票的最佳时机III]()\n\n[LeetCode122-买卖股票的最佳时机 IV]()\n\n[LeetCode309-最佳买卖股票时机含冷冻期]()\n\n[LeetCode714-买卖股票的最佳时机含手续费]()","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode205-同构字符串","url":"//www.xingyuzhao.ltd/blog/2020/12/27/LeetCode205-同构字符串/","content":"\n#### 题目描述\n\n给定两个字符串 ***s*** 和 ***t***，判断它们是否是同构的。\n\n如果 ***s*** 中的字符可以被替换得到 ***t*** ，那么这两个字符串是同构的。\n\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\n\n本题是[LeetCode290-单词规律](http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more)的简化版。\n\n<!--more-->\n\n<img src=\"LeetCode205-同构字符串\\205.png\"  />\n\n#### 思路\n\n##### 方法一\n\n与[LeetCode290-单词规律](http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more)基本一致。\n\n##### 方法二\n\n此题字母大小写均可，数组初始化时为0，每对字符都应唯一映射为同一个数。如果两个数不同，返回`false`，否则返回`true`。\n\n#### 代码\n\n##### 方法一\n\n```cpp\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        unordered_map<char, unordered_set<char>> map1;\n        unordered_map<char, unordered_set<char>> map2;\n        for(int i = 0; i < s.size(); ++i){\n            map1[s[i]].insert(t[i]);\n            map2[t[i]].insert(s[i]);\n            if(map1[s[i]].size() > 1 || map2[t[i]].size() > 1) return false;\n        }\n        return true;\n    }\n};\n```\n\n##### 方法二\n\n```cpp\nclass Solution {\npublic:\n    int map1[256];\n    int map2[256];\n    bool isIsomorphic(string s, string t) {\n        for(int i = 0; i < s.size(); ++i){\n            if(map1[s[i]] != map2[t[i]]) return false;\n            map1[s[i]] = i + 1;\n            map2[t[i]] = i + 1;\n        }\n        return true;\n    }\n};\n```\n\n#### Reference\n\n官方题解评论区：\n\nhttps://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/","tags":["字符串","哈希表"],"categories":["LeetCode"]},{"title":"LeetCode85-最大矩形","url":"//www.xingyuzhao.ltd/blog/2020/12/26/LeetCode85-最大矩形/","content":"\n#### 题目描述\n\n给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。\n\n本题与[LeetCode84-柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)基本一致。\n\n <!-- more-->\n\n<img src=\"LeetCode85-最大矩形\\85.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n如图，使坐标值竖向移动，求出每个坐标轴下的矩形最大面积，再从中取最大值就是最大的矩形：\n\n<img src=\"LeetCode85-最大矩形\\坐标轴.png\" style=\"zoom:80%;\" />\n\n很明显在图三中得到最大矩形，面积为6。求当前坐标轴下的最大矩形面积与[LeetCode84-柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/c-dan-diao-zhan-si-lu-qing-xi-you-tu-you-ip3c/)方法一致。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        if(matrix.empty()) return 0;\n        int res = 0;\n        vector<int> preHeights;\n        for(int i = 0; i < matrix.size(); ++i){\n            vector<int> heights;\n            for(int j = 0; j < matrix[0].size(); ++j){\n                if(i == 0){\n                    heights.push_back(matrix[i][j] - '0');    \n                }\n                else{\n                    if(matrix[i][j] == '1') \n                        heights.push_back(preHeights[j] + matrix[i][j] - '0');\n                    else\n                        heights.push_back(0);\n                }\n            }\n            preHeights = heights;\n            res = max(res, maxArea(heights));\n        }\n        return res;\n    }\n    int maxArea(vector<int> &heights){\n        heights.push_back(0);\n        stack<int> st;\n        int mArea = 0;\n        for(int i = 0; i < heights.size(); ++i){\n            int area = 0;\n            while(!st.empty() && heights[i] < heights[st.top()]){\n                int v = st.top();\n                st.pop();\n                int right = i;\n                int left = st.empty() ? 0 : st.top() + 1;\n                area = heights[v] * (right - left);\n                mArea = max(mArea, area);\n            }\n            st.push(i);\n        }\n        return mArea;\n    }\n};\n```\n\n#### Reference\n\n评论区：https://leetcode-cn.com/problems/maximal-rectangle/comments/","tags":["贪心算法","单调栈"],"categories":["LeetCode"]},{"title":"LeetCode84-柱状图中最大的矩形","url":"//www.xingyuzhao.ltd/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/","content":"\n#### 题目描述\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n<!-- more-->\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\84.png\"  />\n\n#### 思路\n\n找到当前高度下的最大矩形面积，然后从所有得到的面积中挑出最大的那一个就是能够勾勒出来矩形的最大面积，如下：\n\n1. 第1个高度，当前面积为2。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-1.png\"  />\n\n2. 第2个高度，当前面积为6。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-2.png\"  />\n\n3. 第3个高度，当前面积为10。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-3.png\"  />\n\n4. 第4个高度，当前面积为6。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-4.png\"  />\n\n5. 第5个高度，当前面积为8。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-5.png\"  />\n\n6. 第6个高度，当前面积为3。\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-6.png\"  />\n\n综上，面积最大出现在第三个高度，此时面积为5。\n\n我们需要找到当前高度下可以构成矩形的左边界和右边界，再去计算矩形的面积，使用单调栈来实现：\n\n* 计算高度：如果当前高度小于栈顶元素，此时的栈顶就是上一次高度的最大值（准确一点，是上一次高度最大值的坐标），将其记录并出栈，这时候就可以计算上一个高度面积的最大值了，直到遇到栈顶元素小于等于当前元素或者栈为空，在此之前会一直计算高度\n\n* 寻找边界：当前遍历到的坐标 $i$ 就是右边界，左边界就是 $st.top()+1$（对于示例，当遍历到第二个2时，坐标为4，作为**右边界**；经过一系列的出栈操作，栈中**最后剩下**的元素坐标为1，而**左边界**就应该是**1+1​**而不是1），**如果栈为空，那么左边界就是0**。如下图：\n\n<img src=\"LeetCode84-柱状图中最大的矩形\\示例-边界.png\"  />\n\n所以为了提供坐标6，还需要给高度矩阵后面续上一个0。\n\n由于找到了下一个小于栈顶高度的值时才会计算面积，所以对于示例，最后得到的结果及顺序如下：\n\n|       坐标       |  0   |  1   |  2   |  3   |  4   |  5   |\n| :--------------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|       高度       |  2   |  1   |  5   |  6   |  2   |  3   |\n| 当前坐标最大面积 |  2   |  6   |  10  |  6   |  8   |  3   |\n|  面积出现的顺序  |  1   |  6   |  3   |  2   |  5   |  4   |\n\n即，真正得到的面积结果为`2, 6, 10, 3, 8, 6`。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        heights.push_back(0);\n        stack<int> st;\n        int mArea = 0;\n        for(int i = 0; i < heights.size(); ++i){\n            int area = 0;\n            while(!st.empty() && heights[i] < heights[st.top()]){\n                int v = st.top();\n                st.pop();\n                int right = i;\n                int left = st.empty() ? 0 : st.top() + 1;\n                area = heights[v] * (right - left);\n                mArea = max(mArea, area);\n            }\n            st.push(i);\n        }\n        return mArea;\n    }\n};\n```\n\n#### Reference\n\nCSDN：https://blog.csdn.net/Zolewit/article/details/88863970","tags":["贪心算法","单调栈"],"categories":["LeetCode"]},{"title":"LeetCode365-水壶问题","url":"//www.xingyuzhao.ltd/blog/2020/12/25/LeetCode365-水壶问题/","content":"\n#### 题目描述\n\n有两个容量分别为 `x` 升和 `y` 升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 `z` 升的水？\n\n如果可以，最后请用以上水壶中的一或两个来盛放取得的 `z` 升水。\n\n你允许：\n\n* 装满任意一个水壶\n* 清空任意一个水壶\n* 从一个水壶向另外一个水壶倒水，直到装满或者倒空\n\n<!-- more-->\n\n<img src=\"LeetCode365-水壶问题\\365.png\"  />\n\n#### 思路\n\n这道题实际上是一个数学问题，需要有先验知识——[贝祖定理](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&fromid=5185441)：若 $a, b$ 是整数，且$gcd(a,b)=d$，那么对于任意的整数 $x$$，y$，$ax+by$ 都一定是 $d$ 的倍数，特别地，一定存在整数 $x$,  $y$，使 $ax+by=d$ 成立。$gcd(a,b)$ 用来求 $a, b$ 的最大公约数，称为辗转相除法。\n\n实际上，每次操作只会让桶里的水增加`x`或增加`y`，减少`x`或减少`y`，两个桶不可能同时有水且不满，观察所有的操作都至少有一个桶是空的或满的。如果往一个不满的桶里加水或将其倒空是没有意义的，这是因为：\n\n* 向有水且不满的桶加水是没有意义的：\n  * 另一个桶满，加水等价于从初始状态给两个桶加满水\n  * 另一个桶空，加水等价于将不满的桶加满\n* 将有水且不满的桶倒掉是没有意义的：\n  * 另一个桶满，倒水等价于从初始状态给另一个桶加满水\n  * 另一个桶空，倒水等价于两个桶都没水，回到初始状态\n\n所以每次操作只会给水的总量带来`x`或`y`的变化量，所以目标为找到一组 $a, b$ ，满足：\n$$\nax+by=z\n$$\n根据贝祖定理，当且仅当`z`是  $a, b$ 最大公约数倍数时，有解。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int gcd(int a, int b){\n        if(a < b) swap(a, b);\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    bool canMeasureWater(int x, int y, int z) {\n        if(x + y < z) return false;\n        if(x == 0 || y == 0){\n            return z == 0 || x + y == z;\n        }\n        if(z % gcd(x, y) == 0) return true;\n        return false;\n    }\n};\n```\n\n#### Reference\n\n官方题解：\n\nhttps://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/\n\n#### 附录\n\n要满足$z\\le{x+y}$，且这样的 $a, b$ 存在，目标就可以达成，是因为：\n\n* 若 $a\\ge0, b\\ge0$时，可以达成\n\n* 若 $a<0$ ，那么执行以下操作：\n\n  * 将`y`壶倒满\n  * 将`y`壶中水倒入`x`壶\n  * 如果`y`不为空，那么`x`肯定是满的，把`x`**倒空**，再把`y`剩下的倒入`x`壶\n\n  重复以上操作直到某一步`x`壶进行了 $a$ 次倒空，`y`壶进行了 $b$ 次倒水操作。\n\n* 若 $b<0$，方法同上，`x`与`y`互换。\n\n","tags":["数学"],"categories":["LeetCode"]},{"title":"LeetCode12-整数转罗马数字","url":"//www.xingyuzhao.ltd/blog/2020/12/25/LeetCode12-整数转罗马数字/","content":"\n#### 题目描述\n\n罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n<img src=\"LeetCode12-整数转罗马数字\\12.png\"  />\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n* `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n* `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n* `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\n\n<!-- more-->\n\n#### 思路\n\n主要是处理那些特殊的样例，结合代码，对于示例中的1994，去掉1000后还剩下994，这个900的表示是特殊的，所以如果当前 $num$ 范围是900-999，就需要加上\"CM\"；$num$ 还剩下94，这个90也是特殊的，所以如果当前 $num$ 范围是90-99，就需要加上\"XC\"；最后剩下4，所以加上\"IV\"，得到结果\"MCMXCIV\"。\n\n**需要注意`if`语句的顺序不能改变，就像状态机一样，执行完一个状态后才能执行下一个状态**。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        // 前面几行针对特定案例，注释了也不影响\n        if(num == 4) return \"IV\";\n        if(num == 9) return \"IX\";\n        if(num == 40) return \"XL\";\n        if(num == 90) return \"XC\";\n        if(num == 400) return \"CD\";\n        if(num == 900) return \"CM\";\n        string res;\n        while(num){\n            if(num / 1000 != 0){\n                res += string(num / 1000, 'M');\n                num -= num / 1000 * 1000;\n            }\n            else if(num >= 900 && num < 1000){\n                res += \"CM\";\n                num -= 900;\n            }\n            else if(num / 500 != 0){\n                res += string(num / 500, 'D');\n                num -= num / 500 * 500;\n            }\n            else if(num >= 400 && num < 500){\n                res += \"CD\";\n                num -= 400;\n            }\n            else if(num / 100 != 0){\n                res += string(num / 100, 'C');\n                num -= num / 100 * 100;\n            }\n            else if(num >= 90 && num < 100){\n                res += \"XC\";\n                num -= 90;\n            }\n            else if(num / 50 != 0){\n                res += string(num / 50, 'L');\n                num -= num / 50 * 50;\n            }\n            else if(num >= 40 && num < 50){\n                res += \"XL\";\n                num -= 40;\n            }\n            else if(num / 10 != 0){\n                res += string(num / 10, 'X');\n                num -= num / 10 * 10;\n            }\n            else if(num == 9){\n                res += \"IX\";\n                break;\n            }\n            else if(num / 5 != 0){\n                res += string(num / 5, 'V');\n                num -= num / 5 * 5;\n            }\n            else if(num == 4){\n                res += \"IV\";\n                break;\n            }\n            else if(num / 1 != 0){\n                res += string(num / 1, 'I');\n                num = 0;\n            }\n        }\n        return res;\n    }\n};\n```\n\n","tags":["贪心算法","状态机"],"categories":["LeetCode"]},{"title":"内存管理（三）","url":"//www.xingyuzhao.ltd/blog/2020/12/25/内存管理（三）/","content":"\n#### 本次学习要点\n\n1. 基本分页存储管理的基本概念\n2. 基本地址变换机构\n3. 具有快表的地址变换机构\n4. 基本分段存储管理方式\n5. 段页式管理方式\n\n<!-- more-->\n\n#### 基本分页存储管理的基本概念\n\n##### 连续分配方式的缺点\n\n1. 固定分区分配：内存利用率低，会产生大量的内部碎片。\n2. 动态分区分配：会产生很多外部碎片，可以通过“紧凑”处理，但代价很高。\n\n如果允许将一个程序分散的装入到许多不相邻的分区中，便可充分利用内存——非连续分配方式（离散分配方式）。\n\n##### 基本分页存储管理思想\n\n把内存分为一个个相等的小分区，再按照分区大小把进程拆分为一个个小部分。\n\n*如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高*。\n\n##### 分页存储的基本概念\n\n**页框**：将内存空间分为一个个**大小相等的分区**，每个分区就是一个页框，也称为”页帧“、”内存块“、”物理块“。\n\n**页框号**：每个页框的编号，其他名称同上。从0开始。\n\n**页**：将用户进程的地址空间分为**与页框大小相等**的一个个区域，称为”页“或者”页面“。\n\n**页号**：每个页面的编号，也是从0开始。\n\n操作系统**以页框为单位为各个进程分配**内存空间。进程的**页面**与内存的**页框**有**一一对应**的关系。\n\n##### 地址转换\n\n###### 进程在内存中连续存放\n\n重定位寄存器：存放装入模块的起始位置。\n\n思想：模块在内存中的“起始地址” + 目标内存单元相对于起始位置的“偏移量”。\n\n###### 进程在内存中非连续存放\n\n<img src=\"内存管理（三）\\进程在内存中非连续存放.png\" style=\"zoom:80%;\" />\n\n如何计算进程在内存中的存放位置？\n\n1. 计算出逻辑地址对应的页号：\n   $$\n   页号=逻辑地址/页面长度（取整）\n   $$\n\n2. 该页号对应页面在内存中的起始位置： 操作系统的某种数据结构记录\n\n3. 逻辑地址在页面内的偏移量：\n   $$\n   页内偏移量=逻辑地址\\%页面长度\n   $$\n\n4. 物理地址 = 页面地址+ 页内偏移量\n\n对于逻辑地址为80的内存单元：\n\n1. 在1号页 : $80 / 50 = 1$\n2. 该页在内存中的起始地址为450\n3. 内存单元相对于该页起始地址偏移量为 $80\\%50=30$\n4. 实际物理地址为 $450+30=480$\n\n为了方便计算页号、页内偏移量，**页面大小**一般取**2的整数幂**。\n\n假设用32个二进制位表示逻辑地址，页面大小为 $2^{12}B=4096B=4KB$。\n\n* 0号页逻辑地址空间为0~4095，用二进制表示为：\n\n  `0000_0000_0000_0000_0000_0000_0000_0000~0000_0000_0000_0000_0000_1111_1111_1111`\n\n* 1号页逻辑地址空间为4096~8191，用二进制表示为：\n\n  `0000_0000_0000_0000_0001_0000_0000_0000~0000_0000_0000_0000_0001_1111_1111_1111`\n\n* 2号页逻辑地址空间为4096~8191，用二进制表示为：\n\n  `0000_0000_0000_0000_0010_0000_0000_0000~0000_0000_0000_0000_0010_1111_1111_1111`\n\neg：逻辑地址4097，用二进制表示为：`0000_0000_0000_0000_0001_0000_0000_0001`。\n\n若1号页在内存中的起始地址为X，则逻辑地址4097对应的物理地址为：`X+0000_0000_0001`。\n\n结论：\n\n如果每个页面大小为 $2^KB$，用二进制数表示逻辑地址，则末尾的 $K$ 位为**页内偏移量**，其余部分就是**页号**。所以让**每个页面的大小为2的整数幂**。\n\n###### 分页存储管理的逻辑地址结构\n\n<img src=\"内存管理（三）\\分页存储管理的逻辑地址结构.png\"  />\n\n**如果有 $K$ 位表示“页内偏移量”，则说明系统中一个页面的大小是 $2^K$ 个内存单元**。\n\n**如果有 $M$ 位表示“页号”，则说明在该系统中，一个进程最多允许有 $2^M$ 个页面**。\n\n##### 页表\n\n为了能知道进程的每个页面在内存中存放的位置，操作系统要为**每个进程建立一张页表**。\n\n<img src=\"内存管理（三）\\页表.png\"  />\n\n上述的第五条，是因为：\n\n假设内存大小位4GB，页面大小位4KB，则每个页表项至少为多少个字节？\n\n$4GB=2^{32}B$\n\n$4KB=2^{12}B$\n\n $4GB$ 内存会被划分为 $2^{32}/2^{12}=2^{20}$ 个内存块，所以内存块号的范围是 $0\\sim2^{20}-1$ ，所以至少需要20个二进制位才能表示内存块号，即至少需要3个字节。\n\n各页表项会**按顺序且连续的**存在在内存中，如果该页表在内存中存放的起始位置为X，则M号页对应的页表项一定是存放在内存地址为 $X+3*M$ 处。\n\n因此，只需要知道**页表存放的起始位置**和**页表项长度**。即可找到各个页号对应的页表项存放的位置。\n\n##### 小结\n\n<img src=\"内存管理（三）\\分页存储管理小结.png\"  />\n\n#### 基本地址变换机构\n\n用于实现逻辑地址到物理地址转换的一组硬件机构。\n\n在**系统中**设置一个**页表寄存器（PTR）**，存放：\n\n* 页表在内存中的起始地址F\n* 页表长度M\n\n进程还未执行时，上述两个参数存放在**进程控制块（PCB）**中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。**页面大小是2的整数幂**。\n\n##### 地址变换过程\n\n设页面大小为L，逻辑地址A到物理地址E的变换过程如下：\n\n<img src=\"内存管理（三）\\逻辑地址2物理地址.png\"  />\n\n1. 计算页号P和页内偏移量W\n2. 比较页号P和页表长度M，若 $P\\geq{M}$ ，则产生越界\n3. 页表中页号P对应的 $页表项地址=页表起始地址F+页号P\\times页表项长度M$ ，取出该页表项内容b即为内存块号\n4. 计算 $E=b\\times L+W$，用得到的物理地址E去访问内存\n\n**注意**：\n\n* 页表长度：当前页表中总共有几个页表项，即总共有几个页（用户进程）\n* 页表项长度：每个页表项占多大的存储空间\n* 页面大小：一个页面占多大的存储空间（与页框大小一致，用户进程）\n\n##### 一个例题\n\n若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。\n\n等价描述：某系统**按字节寻址**，逻辑地址结构中，**页内偏移量占10位**（说明一个页面的大小位2^10B=1KB），页号2对应的内存块号b=8，将逻辑地址A=2500转换位物理地址E。\n\n1. 计算页号P、页内偏移量W\n\n$$\nP=A/L=2500/1024=2\\\\\\\\\nW=A\\%L=2500\\%1024=452\n$$\n\n2. 页号2没有越界，存放内存块号为b=8\n3. 计算物理地址E\n\n$$\nE=b\\times L+W=8\\times 1024+425=8644\n$$\n\n分页式存储管理系统中，只要确定每个页面的大小，逻辑地址结构就确定了。因此，**页式管理中地址是一维的**。即，只要给出逻辑地址，系统会自动算出页号、页内偏移量，**不需要**显示的告诉系统页内偏移量占多少位。\n\n##### 对页表项大小的进一步探讨\n\n之前说过一个页表项占据3B的内存，如果一个页面为4KB，则每个页框可以存放4096/3=1365个页表项，则会剩下4096%3=1B的页内碎片，如果**每个页表项占4个字节**，则每个页框刚好可存放1024个页表项。\n\n除此之外，如果**每个页表项占据3个字节**，则1365号页表项地址为 $X+3\\times1365+1$。如果**每个页表项占4个字节**，则1024号页表项地址为 $X+4\\times1024$，更方便计算。\n\n理论上，页表项长度为3B即可表示内存块号的范围，但是**为了方便页表查询，常常会让一个页表项占据更多的字节，使得每个页面恰好可以装得下整数个页表项**。\n\n##### 小结\n\n<img src=\"内存管理（三）\\基本地址变换机构.png\"  />\n\n#### 具有快表的地址变换机构\n\n基本地址变换机构的改进版本。\n\n##### 局部性原理\n\n* 时间局部性：如果程序执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很有可能再次被访问（程序中一般存在大量循环）。\n* 空间局部性：如果程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（数据在内存中连续存放）。\n\n之前提到的**基本地址变换机构**中，每访问一个逻辑地址，都**需要查询内存中的页表**。由于局部性原理，可能**连续很多次查到的都是同一个页表项**。可以利用这个特性减少访问页表的次数。\n\n##### 快表（TLB）\n\n也称联想寄存器（TLB），是一种**访问速度比内存快很多**的**高速缓冲存储器**，存储当前访问的若页表项，加速地址变换过程。相对应的**内存**中的页表称为**慢表**。\n\n##### 引入快表后，地址的变换过程\n\n<img src=\"内存管理（三）\\引入快表后的地址变换过程.png\"  />\n\n1. CPU给出逻辑地址，由**硬件**得到页号、页内偏移量，将页号与快表中的所有页号进行比较。\n2. 找到匹配的页号，直接从**快表**中取出该页对应的内存块号，将内存块号和页内偏移量拼接成物理地址，再访问该物理地址对应的内存单元。因此**快表命中**，访问某个逻辑地址仅需**一次访存**。\n3. 未找到匹配的页号，访问**内存中的页表**，找到对应页表项，根据页表项得到页面存放的内存块号，再将内存块号和页内偏移量拼接得到物理地址，再根据物理地址访问对应的内存单元。因此**快表未命中**，访问某个逻辑地址需要**两次访存**（找到页表项后，同时将其**存入快表**，若快表已满，则按照一定算法对旧的页表进行替换）。\n\n由于局部性原理，快表命中率可达**90%**以上。\n\n##### 小结\n\n<img src=\"内存管理（三）\\快表小结.png\"  />","tags":["分页存储"],"categories":["操作系统"]},{"title":"LeetCode455-分发饼干","url":"//www.xingyuzhao.ltd/blog/2020/12/25/LeetCode455-分发饼干/","content":"\n#### 题目描述\n\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n\n对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j]` >= `g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n<!-- more-->\n\n<img src=\"LeetCode455-分发饼干\\455.png\"  />\n\n#### 思路\n\n先将两个数组分别排序，使用两个指针分别指向两个数组的首元素，当饼干值满足胃口值时，两个指针后移；否则只需要将饼干数组的指针进行后移，直到满足胃口值或到达数组末尾。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int i = 0, j = 0;\n        int cnt = 0;\n        while(i < g.size() && j < s.size()){\n            if(s[j] >= g[i]){\n                cnt++;\n                i++;\n                j++;\n            }\n            else j++;\n        }\n        return cnt;\n    }\n};\n```\n\n","tags":["贪心算法","双指针"],"categories":["LeetCode"]},{"title":"LeetCode135-分发糖果","url":"//www.xingyuzhao.ltd/blog/2020/12/24/LeetCode135-分发糖果/","content":"\n#### 题目描述\n\n老师想给孩子们分发糖果，有 *N* 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。\n\n你需要按照以下要求，帮助老师给这些孩子分发糖果：\n\n* 每个孩子至少分配到 1 个糖果。\n* 相邻的孩子中，评分高的孩子必须获得更多的糖果。\n\n那么这样下来，老师至少需要准备多少颗糖果呢？\n\n<!-- more-->\n\n<img src=\"LeetCode135-分发糖果\\135.png\"  />\n\n#### 思路\n\n用数组 $store$ 记录每个孩子得到的糖果数，$store[i]$ 表示第 $i$ 个孩子获得的糖果数。\n\n首先找到最低的评分，这个位置记为 $pos$，最低分孩子的糖果数必为1，所以可以得到 $store[pos]=1$ ，以 $pos$为界，将评分数组分为两个部分分别操作，两个部分是**互不影响**的。\n\n<img src=\"LeetCode135-分发糖果\\评分数组.png\" style=\"zoom:80%;\" />\n\n1. 对于 $pos$ 之前（包括 $pos$），往回遍历评分数组，在不越界的条件下可以得到：\n\n   <img src=\"LeetCode135-分发糖果\\从后往前1.png\" style=\"zoom:80%;\" />\n\n   1. 如果前一个评分小于当前评分：\n\n      1. 当前糖果数不为1，那么前一个孩子获得的糖果置为1，结束；\n\n      2. 当前糖果数为1，那么前一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于前一个孩子获得的糖果数（前一个评分小于当前评分）。所以需要从前一个位置开始往后遍历：\n\n         1. 如果遇到**后一个评分大于当前评分，并且后一个的糖果等于当前糖果数（上图红线）**，需要给后一个糖果数加1，保证后一个的糖果大于当前糖果数。\n\n            <img src=\"LeetCode135-分发糖果\\从后往前2.png\" style=\"zoom:80%;\" />\n\n         2. 如果后一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。\n\n            <img src=\"LeetCode135-分发糖果\\从后往前3.png\" style=\"zoom:80%;\" />\n\n   2. 如果前一个评分等于当前评分，前一个糖果数为1\n\n   3. 如果前一个评分大于当前评分，前一个糖果数为当前糖果数加1\n\n2. 对于 $pos$ 之后（包括 $pos$），往后遍历评分数组，在不越界的条件下：\n\n   <img src=\"LeetCode135-分发糖果\\从前往后1.png\" style=\"zoom:80%;\" />\n\n   1. 如果后一个评分小于当前评分：\n\n      1. 当前糖果数不为1，那么后一个孩子获得的糖果置为1，结束；\n\n      2. 当前糖果数为1，那么后一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于后一个孩子获得的糖果数（后一个评分小于当前评分）。所以需要从后一个位置开始往前遍历：\n\n         1. 如果遇到**前一个评分大于当前评分，并且前一个的糖果等于当前糖果数（上图红线）**，需要给前一个糖果数加1，保证前一个的糖果大于当前糖果数。\n\n            <img src=\"LeetCode135-分发糖果\\从前往后2.png\" style=\"zoom: 80%;\" />\n\n         2. 如果前一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。\n\n            <img src=\"LeetCode135-分发糖果\\从前往后3.png\" style=\"zoom:80%;\" />\n\n   2. 如果后一个评分等于当前评分，后一个糖果数为1\n\n   3. 如果后一个评分大于当前评分，后一个糖果数为当前糖果数加1\n\n最终结果：\n\n| ratings | 2    | 3    | 3    | 1    | 3    | 2    | 2    | 1    |\n| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| store   | 1    | 2    | 2    | 1    | 2    | 1    | 2    | 1    |\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        if(ratings.empty()) return 0;\n        auto iter = min_element(ratings.begin(), ratings.end());\n        int val = *iter;\n        int pos = iter - ratings.begin();\n        vector<int> store(ratings.size(), 0);\n        store[pos] = 1;\n        // 从pos往前\n        for(int i = pos; i >= 0; --i){\n            if(i - 1 >= 0 && ratings[i - 1] < ratings[i]){\n                if(store[i] != 1) store[i - 1] = 1;\n                else{\n                    store[i - 1] = 1;\n                    for(int j = i - 1; j < pos; ++j){\n                        // 往后走\n                        // 下一个评分比当前评分高，并且下一个的糖果又没当前糖果多\n                        if(ratings[j + 1] > ratings[j] && store[j + 1] <= store[j]){\n                            store[j + 1] += 1;\n                        }\n                        if(ratings[j + 1] == ratings[j]) break;                        \n                    }\n                }\n            }\n            else if(i - 1 >= 0 && ratings[i - 1] == ratings[i]){\n                store[i - 1] = 1;\n            }\n            else if(i - 1 >= 0 && ratings[i - 1] > ratings[i]){\n                store[i - 1] = store[i] + 1;\n            }\n        }\n        // 从pos往后\n        for(int i = pos; i < ratings.size(); ++i){\n            if(i + 1 < ratings.size() && ratings[i + 1] < ratings[i]){\n                if(store[i] != 1) store[i + 1] = 1;\n                else{\n                    store[i + 1] = 1;\n                    for(int j = i + 1; j > pos; --j){\n                        // 往前走\n                        // 上一个评分比当前评分高，并且上一个的糖果又没当前糖果多\n                        if(ratings[j - 1] > ratings[j] && store[j - 1] <= store[j]){\n                            store[j - 1] += 1;\n                        }\n                        if(ratings[j - 1] == ratings[j]) break;\n                    }\n                }\n            }\n            else if(i + 1 < ratings.size() && ratings[i + 1] == ratings[i]){\n                store[i + 1] = 1;\n            }\n            else if(i + 1 < ratings.size() && ratings[i + 1] > ratings[i]){\n                store[i + 1] = store[i] + 1;\n            }\n        }\n        // for(auto &v : store) cout << v << \" \";\n        int sum = accumulate(store.begin(), store.end(), 0);\n        return sum;\n    }\n};\n```\n\n#### 更进一步\n\n##### 思路\n\n**相邻的孩子中，评分高的孩子必须获得更多的糖果**。这句话可以拆为两个规则分别处理：\n\n* 左规则：当 $ratings[i-1]<ratings[i]$ 时，$i$ 获得的糖果要多于 $i-1$ 。\n* 右规则：当 $ratings[i]>ratings[i+1]$ 时，$i$ 获得的糖果要多于 $i+1$ 。\n\n遍历数组两次，分别得到每一个孩子满足左规则和右规则的糖果数，取两者之间的最大值就是这个孩子最少分配的糖果数。\n\n在实际代码中，我们先计算出左规则 $left$ 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        if(ratings.empty()) return 0;\n        vector<int> left(ratings.size());\n        for(int i = 0; i < ratings.size(); ++i){\n            if(i - 1 >= 0 && ratings[i] > ratings[i - 1]){\n                left[i] = left[i - 1] + 1;\n            }\n            else\n                left[i] = 1;\n        }\n        int right = 0, ret = 0;\n        for(int i = ratings.size() - 1; i >= 0; --i){\n            if(i + 1 < ratings.size() && ratings[i] > ratings[i + 1]){\n                right++;\n            }\n            else{\n                right = 1;\n            }\n            ret += max(left[i], right);\n        }\n        return ret;\n    }\n};\n```\n\n#### Reference\n\n官方题解：https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode387-字符串中的第一个唯一字符","url":"//www.xingyuzhao.ltd/blog/2020/12/23/LeetCode387-字符串中的第一个唯一字符/","content":"\n#### 题目描述\n\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n<!-- more-->\n\n<img src=\"LeetCode387-字符串中的第一个唯一字符\\387.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n用一个哈希表记录一下每个字母出现的次数，返回第一个出现次数为1的字母位置即可。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        int cnt[26] = {0};\n        for(auto &ch : s)\n            cnt[ch - 'a']++;\n        int pos = -1;\n        for(int i = 0; i < s.size(); ++i){\n            if(cnt[s[i] - 'a'] == 1){\n                pos = i;\n                break;\n            }      \n        }\n        return pos;\n    }\n};\n```\n\n","tags":["字符串","哈希表"],"categories":["LeetCode"]},{"title":"LeetCode103-二叉树的锯齿形层序遍历","url":"//www.xingyuzhao.ltd/blog/2020/12/22/LeetCode103-二叉树的锯齿形层序遍历/","content":"\n#### 题目描述\n\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n<!-- more-->\n\n例如：\n给定二叉树 `[3,9,20,null,null,15,7]`,\n\n<img src=\"LeetCode103-二叉树的锯齿形层序遍历\\103.png\"  />\n\n#### 思路\n\n这道题和二叉树的层序遍历很相似，无非就是遍历完每一层需要改变一次方向，使用一个标志位标记从前往后或者从后往前遍历。可以使用双端队列，根据标志位决定从队列的那一头开始遍历。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if(!root) return {};\n        vector<vector<int>> res;\n        deque<TreeNode*> deq;\n        deq.push_back(root);\n        int dir = 0;\n        while(!deq.empty()){\n            vector<int> buf;\n            // 前往后\n            if(dir == 0){\n                dir = 1;\n                int n = deq.size();\n                for(int i = 0; i < n; ++i){\n                    TreeNode* tmp = deq.front();\n                    buf.push_back(tmp->val);\n                    // 前向时需要先将左边的点入队，保证下次遍历的顺序正确\n                    if(tmp->left) deq.push_back(tmp->left);\n                    if(tmp->right) deq.push_back(tmp->right);\n                    deq.pop_front();\n                }\n                res.push_back(buf);\n            }\n            // 后往前\n            else{\n                dir = 0;\n                int n = deq.size();\n                for(int i = 0; i < n; ++i){\n                    TreeNode* tmp = deq.back();\n                    buf.push_back(tmp->val);\n                    // 后向时需要先将右边的点入队，保证下次遍历的顺序正确\n                    if(tmp->right) deq.push_front(tmp->right);\n                    if(tmp->left) deq.push_front(tmp->left);\n                    deq.pop_back();\n                }\n                res.push_back(buf);\n            }        \n        }\n        return res;\n    }\n};\n```\n\n#### 附录\n\n[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)：\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(!root) return {};\n        vector<vector<int>> res;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int n = q.size();\n            vector<int> buf;\n            for(int i = 0; i < n; ++i){\n                TreeNode *node = q.front();\n                q.pop();\n                buf.push_back(node->val);\n                if(node->left) q.push(node->left);\n                if(node->right) q.push(node->right);\n            }\n            res.push_back(buf);\n        }\n        return res;\n    }\n};\n```\n\n","tags":["二叉树"],"categories":["LeetCode"]},{"title":"C++关联容器","url":"//www.xingyuzhao.ltd/blog/2020/12/21/C-关联容器/","content":"\n#### 本次学习要点\n\n1. 使用关联容器\n2. 关联容器概述\n3. 关联容器操作\n4. 无序容器\n\n<!-- more-->\n\n关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是**map**和**set**。\n\n* `map`中元素是一些关键字-值（key-value）对，关键字起到索引的作用，值则表示于索引相关联的数据。\n* `set`中每个元素只包含一个关键字，支持高效的关键字查询操作-检查一个给定的关键字是否在set中。\n\n<img src=\"C-关联容器\\关联容器类型.png\"  />\n\n类型`map`和`multimap`定义在头文件`map`中；`set`和`multiset`定义在头文件`set`中；无序容器定义在头文件`unordered_map`和`unordered_set`中。\n\n#### 使用关联容器\n\n##### 使用map\n\n单词计数程序：\n\n```cpp\nmap<string, size_t> word_count;\nstring count;\nwhile(cin >> word)\n\t++word_count[word];\nfor(const auto &w : word_count)\n    cout << w.first << \" occurs \" << w.second\n    << ((w.second > 1) ? \" times\" : \" time\") << endl;\n```\n\n此程序读取输入，报告每个单词出现多少次。`map`保存的每个元素中，关键字是`string`，值是`size_t`类型。如果`word`还未在`map`中。下标运算符会创建一个新元素。从`map`中提取一个元素时，会得到一个`pair`类型的对象，`pair`用`first`成员保存关键字，用`second`成员保存对应的值。\n\n##### 使用set\n\n对上一个程序扩展，忽略常见单词，如“the”、“and”、“or”等。可以用`set`保存想忽略的单词，只对不在集合中的单词统计出现次数：\n\n```cpp\nmap<string, size_t> word_count;\nset<string> exclude = {\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\",\n                       \"the\", \"but\", \"and\", \"or\", \"an\", \"a\"};\nstring count;\nwhile(cin >> word)\n    if(exclude.find(word) == exclude.end())\n\t\t++word_count[word];\n```\n\n在`if`中，`find`返回一个迭代器。如果给定关键字在`set`中，迭代器指向该关键字。否则，`find`返回尾后迭代器。\n\n#### 关联容器概述\n\n##### 定义关联容器\n\n当定义一个`map`时，必须指明**关键字类型**和**值类型**；而定义一个`set`时，只需要指明**关键字类型**。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。\n\n```cpp\nmap<string, size_t> word_count; // 空容器\n// 列表初始化\nset<string> exclude = {\"The\", \"But\", \"And\", \"Or\", \"An\", \"A\",\n                       \"the\", \"but\", \"and\", \"or\", \"an\", \"a\"};\n// 三个元素；authors将姓映射为名\nmap<string, string> authors = { {\"zhao\", \"xingyu\"},\n                                {\"zhou\", \"yanxuan\"}};\n```\n\n初始化`map`时，每对映射用花括号包含：{*key*, *value*}。\n\n##### 初始化multimap或multiset\n\n`map`和`set`的关键字都是唯一的。容器`multiset`和`multimap`没有此限制，它们都允许多个元素具有相同的关键字。\n\n```cpp\n// 定义一个有20哥元素的vector，保存0到9每个整数的两个拷贝\nvector<int> ivec;\nfor(vector<int>::size_type i = 0; i != 10; ++i){\n    ivec.push_back(i);\n    ivec.push_back(i);\n}\n// iset包含来自ivec的不重复的元素；miset包含所有20个元素\nset<int> iset(ivec.begin(), ivec.end());\nmultiset<int> miset(ivec.begin(), ivec.end());\ncout << ivec.size() << endl;\ncout << iset.size() << endl;\ncout << miset.size() << endl;\n```\n\n##### 关键字类型的要求\n\n###### 有序容器的关键字类型\n\n所提供的操作必须在关键字类型上定义一个**严格弱序**。可以将严格弱序看作“小于”（**书上是\"小于等于\"，网上查到为小于**），它必须具备以下性质：\n\n* 两个关键字不能同时“小于”对方\n* 如果k1\"小于\"k2，k2“小于”k3，那么k1必须”小于“k3\n* 如果存在两个关键字，任何一个都不”小于“另一个，那么我们称这两个关键字是”等价“的。并且等价具有传递性。\n\n如果两个关键字等价，那么容器将它们视作相等来处理。\n\n###### 使用关键字类型的比较函数\n\n在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数的形式提供真正的比较操作（其类型必须与尖括号中指定的类型相吻合）。\n\n例如：我们不能直接定义一个`Sales_data`的`multiset`，因为`Sales_data`没有`<`运算符。以下函数在`ISBN`成员上定义一个严格弱序：\n\n```cpp\nbool compareIsbn(const Sales_data &lhs, const Sales_data &rhs){\n    return lhs.isbn() < rhs.isbn();\n}\n```\n\n**要使用自己定义的操作**，在定义`multiset`时必须提供两个类型：**关键字类型**Sales_data以及**比较操作类型**——应该是一种函数指针类型，可以指向`compareIsbn`：\n\n```cpp\n// bookstore中多条记录可以有相同的ISBN\n// bookstore中的元素以ISBN的顺序进行排列\nmultiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);\n```\n\n**当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数的指针**。`bookstore`中的元素将按它们的`ISBN`成员的值升序排列。\n\n##### pair类型\n\n`pair`标注库类型定义在头文件`utility`中。`pair`保存两个数据成员，它是一个用来生成特定类型的模板。\n\n```cpp\npair<string, string > anon;\npair<string, size_t> word_count;\npair<string, vector<int>> line;\n```\n\n`pair`的默认构造函数对数据成员进行值初始化。以下三种初始化都是可以的：\n\n```cpp\npair<int, int> p = {1,1};\npair<int, int> q{1,1};\npair<int, int> m(1,1);\n```\n\n<img src=\"C-关联容器\\pair上的操作.png\"  />\n\n###### 创建pair对象的函数\n\n新标准下，可以对返回值进行列表初始化：\n\n```cpp\npair<string, int> process(vector<string> &v){\n\t// 处理v\n    if(!v.empty())\n        return {v.back(), v.back().size()}; // 列表初始化\n    else\n        return pair<string, int>(); // 隐式构造返回值\n}\n```\n\n早期版本必须显式的构造返回值：\n\n```cpp\nif(!v.empty())\n    return pair<string, int>(v.back(), v.back().size());\n```\n\n还可以使用`make_pair`来生成`pair`对象，`pair`的两个类型来自于`make_pair`的参数：\n\n```cpp\nif(!v.empty())\n\treturn make_pair(v.back(), v.back().size());\n```\n\n#### 关联容器操作\n\n<img src=\"C-关联容器\\关联容器额外的类型别名.png\"  />\n\n```cpp\nset<string>::value_type v1; // v1是一个string\nset<string>::key_value v2; // v2是一个string\nmap<string, int>::value_type v3; // v3是一个pair<const string, int>\nmap<string, int>::key_type v4; // v4是一个string\nmap<string, int>::mapped_type v5; // v5是一个int\n```\n\n只有`map`类型（`unordered_map、unordered_multimap、multimap、map`）才定义了`mapped_type`;\n\n##### 关联容器迭代器\n\n解引用一个关联容器的迭代器时，得到一个类型为容器的`value_type`的值的**引用**。对`map`而言，`value_type`是一个`pair`类型，其`first`成员保存`cosnt`的关键字，`second`成员保存值。\n\n```cpp\n// 获得指向word_count中一个元素的迭代器\nauto map_it = word_count.begin();\n// *map_it是指向一个pair<const string, size_t>对象的引用\n// 或者使用(*map_it).first，(*map_it).second\ncout << map_it->first; // 打印此元素的关键字\ncout << \" \" << map_it->second; // 打印此元素的值\nmap_it->first = \"new key\"; // 错误：关键字是const的\n++map_it->second; // 正确：可以通过迭代器改变元素 \n```\n\n###### set的迭代器是const的\n\n虽然`set`类型同时定义了`iterator`和`const_iterator`类型， 但两种类型都只允许读`set`中的元素。\n\n```cpp\nset<int> iset = {0,1,2,3,4,5,6};\nset<int>::iterator set_it = iset.begin();\nif(set_it != iset.end()){\n    *set_it = 42; // 错误：set中的关键字是只读的\n    cout << *set_it << endl; // 正确：可以读关键字\n}\n```\n\n###### 遍历关联容器\n\n`map`和`set`都支持之前所说的`begin`和`end`操作。\n\n```cpp\nauto map_it = word_count.cbegin();\nwhile(map_it != word_count.cbegin()){\n    cout << map_it->first << \" occurs\"\n         << map_it->second << \" times\" << endl;\n    ++map_it;\n}\n```\n\n###### 关联容器和算法\n\n通常不对关联容器使用泛型算法，有其专用算法。如果真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的位置。\n\n##### 添加元素\n\n使用关联容器的`insert`成员向容器中添加一个元素或一个元素范围：\n\n```cpp\nvector<int> ivec = {2,4,6,8,2,4,6,8}; // ivec有8个元素\nset<int> set2;\nset2.insert(ivec.cbegin(), ivec.cend()); // set2有4个元素\nset2.insert({1,3,5,7,1,3,5,7}); // set2现在有8个元素\n```\n\n###### 向map添加元素\n\n对一个`map`进行`insert`操作时，必须记住元素类型是`pair`。\n\n```cpp\n// 向word_count插入word的4种方法\nword_count.insert({word, 1});\nword_count.insert(make_pair(word, 1));\nword_count.insert(pair<string, size_t>(word, 1));\nword_count.insert(map<string, size_t>::value_type(word, 1));\n```\n\n<img src=\"C-关联容器\\关联容器insert操作.png\"  />\n\n###### 检测insert返回值\n\n`insert`(或`emplace`)返回的值依赖于容器类型和参数。对于**不包含重复关键字**的容器，添加单一元素的`insert`和`emplace`版本返回一个`pair`，告诉我们插入操作是否成功。`pair`的`first`成员是一个**迭代器**，指向**具有给定关键字的元素**；`second`成员是一个`bool`值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则`insert`什么事情也不做，且返回值中的`bool`部分为`false`。如果关键字不存在，元素被插入容器中，且`bool`值为`true`。\n\n例子，重写单词计数程序：\n\n```cpp\nmap<string, size_t> word_count;\nstring word;\nwhile(cin >> word){\n    auto ret = word_count.insert({word, 1});\n    if(!ret.second)\n        ++ret.first->second;\n}\n```\n\n###### 展开递增语句\n\n* **ret**：保存`insert`返回的值，是一个**pair**\n* **ret.first**：是一个`map`迭代器，指向具有给定关键字的元素\n* **ret.first->**：解引用此迭代器，提取`map`种元素，元素也是一个`pair`\n* **ret.first->second**：`map`中元素的值部分\n* **++ret.first->second**：递增此值\n\n###### 向multiset或multimap添加元素\n\n```cpp\nmultimap<string, string> authors;\n// 插入第一个元素，关键字为zxy\nauthors.insert({\"zxy\", \"c++泛型算法\"});\n// 正确：添加第二个元素，关键字也是zxy\"\nauthors.insert({\"zxy\", \"c++关联容器\"});\n```\n\n这里`insert`操作返回一个指向新元素的迭代器。无需返回一个`bool`值，因为`insert`总是向这类容器中加入一个新元素。\n\n##### 删除元素\n\n关联容器定义了三个版本的`erase`，如下：\n\n<img src=\"C-关联容器\\关联容器erase操作.png\"  />\n\n后两个与顺序容器一样，第一个是关联容器额外提供的，它接受一个`key_type`类型。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除元素的数量。\n\n* 对于保存不重复关键字的容器，`erase`的返回值总是0或1。0表示要删除的元素不在容器中\n* 对于允许重复关键字的容器，删除元素的数量可能大于1\n\n##### map的下标操作\n\n`map`和`unordered_map`容器提供了下标运算符和一个对应的`at`函数：\n\n<img src=\"C-关联容器\\map和unordered_map的下标操作.png\"  />\n\n**`set`类型不支持下标，因为`set`中元素本身就是关键字，同时也不能对`multimap`或者`unordered_multimap`进行下标操作，因为这些容器中可能有多个值与一个关键字相关联**。\n\n<img src=\"C-关联容器\\map_note.png\"  />\n\n###### 使用下标操作的返回值\n\n当对一个`map`进行下标操作时，会获得一个`mapped_type`对象；但当解引用一个`map`迭代器时，会得到一个`value_type`对象。与其他下标运算符相同的是，`map`的下标运算符返回一个左值，所以既可以读也可以写元素。\n\n<img src=\"C-关联容器\\map下标_note.png\"  />\n\n##### 访问元素\n\n关联容器提供多种查找一个指定元素的方法，应该使用哪个取决我们要解决什么问题。\n\n<img src=\"C-关联容器\\在一个关联容器种查找元素的操作.png\"  />\n\n```cpp\nset<int> iset{0,1,2,3,4,5,6};\niset.find(1); // 返回一个迭代器，指向key = 1的元素\niset.find(11); // 返回一个迭代器，其值等于iset.end()\niset.count(1); // 返回1\niset.count(11); // 返回0\n```\n\n###### 对map和find代替下标操作\n\n如果我们只是想知道一个给定的关键字是否在`map`中，而不想改变`map`（下标操作会插入一个未在`map`的元素）。这种情况下应该使用`find`：\n\n```cpp\nif(word_count.find(\"foobar\") == word_count.end())\n\tcout << \"foobar is not in the map\" << endl;\n```\n\n###### 在multimap或multiset中查找元素\n\n如果一个`multimap`或`multiset`中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。\n\n例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。可以用三种不同方法来解决这个问题。最直观的方法是使用`find`和`count`。\n\n```cpp\nstring search_item(\"zxy\"); // 作者\nauto entries = authors.count(search_item); // 元素的数量\nauto iter = authors.find(search_item); // 作者的第一本书\n// 查找此作者所有著作\nwhile(entries){\n    cout << iter->second << endl; // 打印书名\n    ++iter; // 下一本\n    --entries; // 打印一次，计数减一\n}\n```\n\n<img src=\"C-关联容器\\multimap或multiset中查找元素_note.png\"  />\n\n###### 一种不同的，面向迭代器的解决办法\n\n可以使用`lower_bound`和`upper_bound`来解决。\n\n* 关键字在容器中，`lower_bound`返回迭代器将指向第一个具有给定关键字的元素，`upper_bound`返回迭代器指向最后一个匹配关键字元素之后的位置\n* 关键字不在容器中，两者返回一个不影响排序的关键字插入位置\n\n因此，使用相同关键字调用`lower_bound`和`upper_bound`会得到关键字元素的范围。我们可以重写程序：\n\n```cpp\nfor(auto beg = authors.lower_bound(search_item),\n    end = authors.upper_bound(search_item);\n    beg != end; ++ beg)\n    cout << beg->second << endl;\n```\n\n<img src=\"C-关联容器\\lower_bound和upper_bound_note.png\"  />\n\n###### equal_range函数\n\n此函数接受一个关键字，返回一个**迭代器`pair`**（不是`pair`对象）。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。再次修改程序\n\n```cpp\nfor(auto pos = authors.equal_range(search_item);\n\tpos.first != pos.second; ++pos.first)\n    cout << pos.first->second << endl;\n```\n\n##### 一个单词转换的map\n\n程序功能：给定一个`string`，将它转换为另一个`string`。我们需要根据单词转换文件将待转换的文本转换为我们想要的样子：\n\n单词转换文件：\n\n```\nk okay?\ny why\nr are\nu you\npic picture\nthk thank!\nl8r later\n```\n\n待转换文本：\n\n```\nwhere r u\ny dont u send me a pic\nk thk l8r\n```\n\n转换结果：\n\n```\nwhere are you\nwhy dont you send me a picture\nokay? thanks! later\n```\n\n###### 单词转换程序\n\n```cpp\n// map_file 转换规则\n// input 待转换文本\nvoid word_transform(ifstream &map_file, ifstream &input, ofstream &output){\n    auto trans_map = buildMap(map_file);\n    string text; // 保存输入中的每一行\n    while(getline(input, text)){ // 读取每一行输入\n        istringstream stream(text); // 读取每个单词\n        string word;\n        bool firstword = true; // 控制是否打印空格\n        while(stream >> word){\n            if(firstword)\n                firstword = false;\n            else\n                output << \" \"; // 单词间打印一个空格\n            output << transform(word, trans_map); // 打印输出\n        }\n        output << endl; // 完成一行的转换\n    }\n}\n```\n\n###### 建立转换映射\n\n```cpp\nmap<string, string> buildMap(ifstream & map_file){\n\tmap<string, string> trans_map; // 保存转换规则\n    string key; // 要转换的单词\n    string value; // 替换后的内容\n    // 读取第一个单词存入key，剩余存入value（包括标点）\n    // map_file>>key流只读取第一个空格前string，剩下的流由getline读取到value中\n    while(map_file >> key && getline(map_file, value))\n        if(value.size() > 1) // 检查是否有转换规则\n            trans_map[key] = value.substr(1); // 跳过前导空格，getline不会跳过前导空格\n        else\n            throw runtime_error(\"no rule for \" + key);\n    return trans_map;\n}\n```\n\n###### 生成转换文本\n\n```cpp\nconst string& transform(const string &s, const map<string, string> &m){\n    auto map_it = m.find(s);\n    if(map_it != m.cend())\n        return map_it->second; // 使用替换短语\n    else return s; // 否则返回原string\n}\n```\n\n#### 无序容器\n\n新标准定义了**4**个**无序关联容器**，这些容器使用一个哈希函数和关键字类型的`==`运算符。\n\n###### 使用无序容器\n\n用于`map`和`set`的操作也能用于`unordered_map`和`unordered_set`，如`find、insert`等。无序容器也有允许重复关键字的版本。\n\n###### 管理桶\n\n无序容器在存储上组织为**一组桶**，每个桶保存零个或多个元素。**无序容器使用一个哈希函数将元素映射到桶**。\n\n* 为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。\n\n* 容器将具有一个特定哈希值的所有元素都保存在相同的桶中。\n* 如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。\n\n因此，无序容器的性能依赖于**哈希函数的质量**和**桶的数量和大小**。\n\n对于相同的参数，哈希函数必须总是产生相同的结果。**理想情况下，哈希函数将每个特定的值映射到唯一的桶**。但是，**将不同关键字的元素映射到相同的桶也是允许的**。\n\n* 当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。\n* 计算一个元素的哈希值和在桶中搜索通常都是很快的操作。\n* 如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。\n\n以下这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。\n\n<img src=\"C-关联容器\\无序容器管理操作.png\"  />\n\n###### 无序容器对关键字类型的要求\n\n默认情况下，无序容器使用关键字类型`==`运算符来比较元素，它们还使用一个`hash<key_type>`类型的对象来**生成每个元素的哈希值**。\n\n* 无序容器支持关键字是**内置类型(包括指针类型)**、**`string`**或者**智能指针**类型的无序容器。\n* 无序容器**不能**直接定义**关键字类型为自定义类类型的无序容器**。与容器不同，不能直接使用哈希模板，而必须提供我们自己的`hash`模板版本。\n* 不使用默认的`hash`，而是使用一种类似于**为有序容器重载关键字类型**的默认比较操作。\n\n为了能将`Sale_data`用作关键字，我们需要提供函数来替代`==`运算符和哈希值计算函数。我们从定义这些重载函数开始：\n\n```cpp\nsize_t hasher(const Sales_data &sd){\n    return hash<string>()(sd.isbn());\n}\nbool eqOp(const Sales_data &lhs, const Sales_data &rhs){\n    return lhs.isbn() == rhs.isbn();\n}\n```\n\n`hasher`函数使用标准库`hash`类型对象计算`ISBN`成员的哈希值，该哈希值建立在`string`之上。\n\n`eqOp`函数通过比较`ISBN`号来比较两个`Salas_data`。\n\n使用以上函数来定义一个`unordered_multiset`：\n\n```cpp\nusing SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;\n// 参数是桶大小、哈希函数指针和相等性判断运算符指针\nSD_miltiset bookstore(42, hasher, eqOp);\n```\n\n此集合的哈希和相等性判断操作与`hasher`和`eqOp`函数有着相同的类型。在定义`bookstore`时可以将我们希望它使用的函数的指针传递给它。\n\n如果类定义了`==`运算符，则可以只重载哈希函数：\n\n```cpp\n// 使用FooHash生成哈希值；Foo必须有==运算符\nunordered_set<Foo, decltype(FooHash)*> fooSet(10, FoolHash);\n```\n\n","categories":["C++"]},{"title":"LeetCode746-使用最小花费爬楼梯","url":"//www.xingyuzhao.ltd/blog/2020/12/21/LeetCode746-使用最小花费爬楼梯/","content":"\n#### 题目描述\n\n数组的每个索引作为一个阶梯，第`i`个阶梯对应着一个非负数的体力花费值 `cost[i]`(索引从0开始)。\n\n每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。\n\n您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。\n\n<!-- more-->\n\n<img src=\"LeetCode746-使用最小花费爬楼梯\\746.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n像这种爬楼梯问题考虑动态规划，当前状态花费 $dp[i]$ 可以由上一次 $dp[i-1]$ 或者上上次 $dp[i-2]$ 中的最小花费得到（对应爬一层台阶和爬两层台阶），其次当前状态还有体力消耗 $cost[i]$，所以可以定义状态转移方程：\n$$\ndp[i]=min(dp[i-1],dp[i-2])+cost[i]\n$$\n当楼梯只有两阶时，假定有第三阶，那么到达第三阶的花费就为0，初始化如下：\n\n``` cpp\ndp[0] = cost[0];\ndp[1] = cost[1];\ncost.push_back(0);\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        vector<int> dp(cost.size() + 1, 0);\n        cost.push_back(0);\n        dp[0] = cost[0];\n        dp[1] = cost[1];\n        for(int i = 2; i < dp.size(); ++i){\n            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];\n        }\n        return dp[dp.size() - 1];\n    }\n};\n```\n\n\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode316-去除重复字母","url":"//www.xingyuzhao.ltd/blog/2020/12/20/LeetCode316-去除重复字母/","content":"\n#### 题目描述\n\n给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。\n\n<!-- more-->\n\n<img src=\"LeetCode316-去除重复字母\\316.png\"  />\n\n#### 思路\n\n对于一个字符串来说，如果 $s[i]>s[i+1]$ ，去除此时的 $s[i]$ 可以使剩下的字符串字典序最小。我们将 $s[i]$ 称为**关键字符**。\n\n从前往后遍历字符串。假定在 $s[i-1]$ 之前所有的**关键字符**都已经去除，那么在扫描 $s[i]$ 时，新出现的**关键字符**只能出现在 $s[i]$ 或者其后的位置。\n\n所以用栈来维护去除**关键字符**后得到的字符串。如果栈顶字符大于 $s[i]$ ，说明栈顶字符应当被去除，此时新的栈顶字符就与 $s[i]$ 相邻（保持相对位置）。重复此操作，直到栈为空或者栈顶字符不大于 $s[i]$ 。\n\n还需要满足 $s$ 中的每个字符都出现在新字符串中且只出现一次，所以还需要考虑：\n\n* 如果字符 $s[i]$ 已经存在于栈中，则不再将此字符加入栈，所以需要记录字符是否被使用过\n* 弹出栈顶字符时，如果后面再没有此字符（此字符剩余数量为0），则不能弹出，所以需要记录每个字符出现的次数；如果可以弹出，需要将此字符再次置为未使用的状态\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n\tstring removeDuplicateLetters(string s) {\n        int cnt[26] = {0}; // 记录字符使用次数\n        bitset<26> vis; // 记录字符是否被使用\n        for(auto &ch : s) cnt[ch - 'a']++;\n        stack<char> st;\n        for(auto &ch : s){\n            // 如果字符没被使用\n            if(!vis[ch - 'a']){\n                // 如果栈不为空且栈顶字符大于当前字符，需要看是否弹出\n                while(!st.empty() && st.top() > ch){\n                    // 如果此字符串剩余次数不为0，可以弹出，并且此字符置为「未使用」\n                    if(cnt[st.top() - 'a'] > 0){\n                        vis[st.top() - 'a'] = 0;\n                        st.pop();\n                    }\n                    else break;\n                }\n                // 当前字符入栈，并且置为「已使用」\n                vis[ch - 'a'] = 1;\n                st.push(ch);\n            }\n            // 当前字符被使用了一次\n            cnt[ch - 'a']--;\n        }\n        // 取出栈中字符并输出\n        string res;\n        while(!st.empty()){\n            res += st.top();\n            st.pop();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n\t}\n};\n```\n\n\n\n#### Reference\n\n官方题解：\n\nhttps://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/","tags":["贪心算法","单调栈"],"categories":["LeetCode"]},{"title":"C++泛型算法（二）","url":"//www.xingyuzhao.ltd/blog/2020/12/19/C-泛型算法（二）/","content":"\n#### 本次学习要点\n\n1. 再探迭代器\n2. 泛型算法结构\n3. 特定容器算法\n\n<!-- more-->\n\n#### 再探迭代器\n\n标准库在头文件`iterator`中还定义了额外集中迭代器。包括：\n\n* **插入迭代器（insert iterator）**：这些迭代器被绑定在一个容器上，可用来向容器插入元素。\n* **流迭代器（stream iterator）**：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。\n* **反向迭代器（reverse iterator）**：这些迭代器向前而不是向后移动（**书上写的是向后而不是向前，疑问？**），除了`forward_list`之外的标准库容器都有反向迭代器。\n* **移动迭代器（move iterator）**：这些专用的迭代器不是拷贝其中的元素，而是移动它们。后面会提到。\n\n##### 插入迭代器\n\n插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。\n\n插入器有三种类型，差异在于元素插入的位置：\n\n* **back_inserter**：创建一个使用`push_back`的迭代器。\n* **front_inserter**：创建一个使用`push_front`的迭代器。\n* **inserter**创建一个使用`insert`的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。**元素将被插入到给定得到所表示的元素之前**。\n\n<img src=\"C-泛型算法（二）\\插入迭代器_note.png\"  />\n\n当调用`inserter(c, iter)`时，会得到一个迭代器，接下来使用它时，会将元素插入到`iter`原来所指向的元素之前的位置。即，如果`it`是由`iterator`生成的迭代器，则下面两段代码效果一样：\n\n```cpp\n*it = val;\n// 等价于\nit = c.insert(it, val); // it指向新加入的元素\n++it; // 递增it使它指向原来的元素\n```\n\n`front_inserter`生成的迭代器的行为于`inserter`生成的迭代器完全不一样。当我们使用`front_inserter`时，元素总是插入到容器第一个元素之前。即使我们传递给`inserter`的位置原来是指向第一个元素的，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：\n\n```cpp\nlist<int> lst{1,2,3,4};\nlist<int> lst2, lst3; // 空list\n// 拷贝完成后，lst2包含4 3 2 1\ncopy(lst.begin(), lst.end(), front_inserter(lst2));\n// 拷贝完成后，lst3包含1 2 3 4\ncopy(lst.begin(), lst.end(), inserter(lst3, lsr3.begin());\n```\n\n##### iostream迭代器\n\n虽然`iostream`不是迭代器，但标准库定义了一个可以用于这些IO类型对象的迭代器。**iostream_iterator**读入输入流，**ostream_iterator**向一个输出流写数据。这些迭代器将它们对应的流当作一个特定的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。\n\n###### istream_iterator操作\n\n当创建一个流迭代器时，必须指定将要读写的对象类型。一个`istream_iterator`使用`>>`来读取流。因此，`istream_iterator`要读取的类型必须定义了输入运算符。当创建一个`istream_iterator`时，我们可以将它绑定到一个流。\n\n```cpp\nistream_iterator<int> int_it(cin); // 从cin读取int\nistream_iterator<int> int_eof; // 尾后迭代器\nifstream in(\"afile\");\nistream_iterator<string> str_it; // 从\"afile\"读取字符串\n```\n\n下面是一个用`istream_iterator`从标准输入读取数据，存入一个`vector`的例子：\n\n``` cpp\nistream_iterator<int> in_iter(cin); // 从cin读取int\nistream_iterator<int> eof; // istream尾后迭代器\nwhile(in_iter != eof){\n    // 后置递增运算读取流，返回迭代器的旧值\n    // 解引用迭代器，获得从流读取的前一个值\n    vec.push_back(*in_iter++);\n}\n```\n\n`eof`被定义为空的`istream_iterator`，从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等。\n\n上述程序可以改写如下：\n\n```cpp\nistream_iterator<int> in_iter(cin), eof; // 从cin读取int\nvector<int> vec(in_iter, eof); // 从迭代器范围构造vec\n```\n\n<img src=\"C-泛型算法（二）\\istream_iterator操作.png\" style=\"zoom: 80%;\" />\n\n###### 使用算法操作流迭代器\n\n```cpp\nistream_iterator<int> in(cin), eof;\ncout << accumulate(in, eof, 0) << endl;\n```\n\n此调用会计算出从标准输入读取的值的和。\n\n###### istream_iterator允许使用懒惰求值\n\n当我们将一个`istream_iterator`绑定到一个流时，标准库并不保证迭代器立即从流读取数据。可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。\n\n###### ostream_iterator操作\n\n我们可以对具有输出运算符`<<`的类型定义`ostream_iterator`。创建一个`ostream_iterator`时，可选第二个参数，它是一个**C**风格字符串（**即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）**。在输出的每个元素之后都会打印此字符串。并且必须将`ostream_iterator`绑定到一个指定的流，不允许空的或表示尾后位置的`ostream_iterator`。\n\n<img src=\"C-泛型算法（二）\\ostream_iterator操作.png\" style=\"zoom:80%;\" />\n\n我们可以用`ostream_iterator`来输出值的序列：\n\n```cpp\nostream_iterator<int> out_iter(cout, \" \");\nfor(auto e : vec)\n\t*out_iter++ = e; // 赋值语句实际上将元素写到cout\ncout << endl;\n// 下面的也行，但不推荐\nostream_iterator<int> out_iter(cout, \" \");\nfor(auto e : vec)\n\tout_iter = e; // 赋值语句将元素写到cout\ncout << endl;\n```\n\n运算符`*`和`++`不对`ostream_iterator`对象做任何操作。第一种写法流迭代器的使用与其他迭代器的使用保持一致。\n\n可以通过`copy`来打印`vec`中的元素，更简单：\n\n```cpp\ncopy(vec.begin(), vec.end(), out_iter);\ncout << endl;\n```\n\n###### 使用流迭代器处理类类型\n\n对于之前的`Sales_item`既有输入运算符也有输出运算符，可以使用IO迭代器重写书店程序：\n\n```cpp\n// 原始程序\nSales_item total; // 保存下一条交易记录的变量\n// 读入第一条交易记录，并确保有数据可以处理\nif(cin >> total){\n    Sales_item trans; // 保存和的变量\n    // 读入并处理剩余交易记录\n    while(cin >> trans){\n        // 如果我们仍在处理相同的书\n        if(total.isbn() == trans.isbn())\n            totao += trans; // 更新销售总额\n        else{\n            // 打印前一本书的结果\n            cout << total << endl;\n            total = trans; // total现在表示下一本书的销售额\n        }\n    }\n    cout << total << endl;\n}\n// 使用IO迭代器重写\nistream_iterator<Sales_item> item_iter(cin), eof;\nostream_iterator<Sales_item> out_iter(cout, \"\\n\");\n// 将第一笔交易记录存在sum中，并读取下一条记录\nSales_item sum = *item_iter++;\nwhile(item_iter != eof){\n    // 如果当前交易记录（存在item_iter中）有相同的ISBN号\n    if(item_iter->isbn() == sum.isbn())\n        sum += *item_iter++;\n    else{\n        out_iter = sum;\n        sum = *item_iter++;\n    }\n}\nout_iter = sum;\n```\n\n##### 反向迭代器\n\n顾名思义，反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增和递减含义会颠倒过来。递增一个反向迭代器（`++it`）会移动到前一个元素；递减一个反向迭代器（`--it`）会移动到后一个元素。反向迭代器也有`const`和非`const`版本。\n\n<img src=\"C-泛型算法（二）\\反向迭代器.png\" style=\"zoom:80%;\" />\n\n下面是一个例子：\n\n```cpp\nvector<int> vec = {1,2,3,4,5,6};\nfor(auto r_iter = vec.crbegin(); r_iter != vec.crend(); ++r_iter)\n    cout << *r_iter << endl;\n// 打印6，5，4，3，2，1\n```\n\n可以通过向`sort`传递一对反向迭代器来将`vector`整理为递减：\n\n```cpp\nsort(vec.begin(), vec.end()); // 递增\nsort(vec.rbegin(), vec.rend()); // 递减\n```\n\n###### 反向迭代器和其他迭代器间的关系\n\n假定有一个名为`line`的`string`，保存着以逗号分隔的单词列表，我们希望打印`line`中的第一个单词，可以使用`find`完成：\n\n```cpp\nauto comma = find(line.cbegin(), line.cend(), ',');\ncout << string(line.cbegin(), comma) << endl;\n```\n\n如果`line`中有逗号，那么`comma`将指向这个逗号，否则它指向`line.cend()`。如果希望打印最后一个单词：\n\n```cpp\nauto rcomma = find(line.crbegin(), line.crend(), ',');\n```\n\n当我们试图打印找到的单词时，不能用以下代码：\n\n```cpp\n// 错误，对于FIRST,MIDDLE,LAST会打印出TSAL\ncout << string(line.crbegin(), rcomma) << endl;\n```\n\n需要做的是，将`rcomma`转换为一个普通迭代器，能在`line`中正向移动。可以调用`reverse_iterator`中的`base`成员来完成这一转换，此成员函数会返回其对应的普通迭代器：\n\n```cpp\ncout << string(rcomma.base(), line.cend()) << endl;\n```\n\n<img src=\"C-泛型算法（二）\\反向迭代器_使用base.png\" style=\"zoom:80%;\" />\n\n需要注意的是：\n\n<img src=\"C-泛型算法（二）\\反向迭代器_note.png\" style=\"zoom: 80%;\" />\n\n#### 泛型算法结构\n\n算法所要求的迭代器操作可以分为5个迭代器类别：\n\n<img src=\"C-泛型算法（二）\\迭代器类别.png\" style=\"zoom:80%;\" />\n\n##### 5类迭代器\n\n对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。**而这种错误很多编译器不会给出任何警告和提示**。\n\n###### 输入迭代器（input iterator）\n\n可以读取序列中的元素。一个输入迭代器必须支持：\n\n* 用于比较两个迭代器的相等和不相等运算符（`==、!=`）\n* 用于推进迭代器的前置和后置递增运算（`++`）\n* 用于读取元素的解引用运算符（`*`）；解引用只会出现在赋值运算符的右侧\n* 箭头运算符（`->`），等价于`(*it).member`，即，解引用迭代器，并提取对象的成员\n\n输入迭代器只用于顺序访问，只能用于单边扫描算法。算法`find`和`accumulate`要求输入迭代器；而`istream_iterator`是一种输入迭代器。\n\n###### 输出迭代器（output iterator）\n\n可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：\n\n* 用于推进迭代器的前置和后置递增运算（`++`）\n* 解引用运算符（`*`），只出现在赋值运算符的左侧\n\n例如，`copy`函数的第三个参数就是输出迭代器；`ostream_iterator`是一种输出迭代器。\n\n###### 前向迭代器（forward iterator）\n\n可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法`replace`要求前向迭代器， `forward_list`上的迭代器是前向迭代器。\n\n###### 双向迭代器（bidirectional iterator）\n\n可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（`--`）。算法`reverse`要求双向迭代器，除了`forward_list`之外，其他标准库都提供符合双向迭代器要求的迭代器.\n\n###### 随机访问迭代器（random-access iterator）\n\n提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，还支持以下操作：\n\n* 用于比较两个迭代器相对位置的关系运算符（`<、<=、>`和`>=`) \n* 迭代器和一个整数值的加减运算（`+、+=、-`和`-=`），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置\n* 用于两个迭代器上的减法运算符（`-`），得到两个迭代器的距离\n* 下标运算符`iter[n]`，与`*(iter[n])`等价\n\n算法`sort`要求随机访问迭代器。`array、deque、string、vector`的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。\n\n##### 算法形参模式\n\n大多数算法具有如下4种形式之一：\n\n* ***alg*** ( beg, end, ***other args***)\n* ***alg*** ( beg, end, dest, ***other args***)\n* ***alg*** ( beg, end, beg2, ***other args***)\n* ***alg*** ( beg, end, be2, end2, ***other args***)\n\n##### 算法命名规范\n\n如何提供一个操作代替默认的`<`或`==`运算符，以及算法是将输出数据写入输入序列，还是写入分离的目的位置等问题。\n\n###### 一些算法使用重载形式传递一个谓词\n\n```cpp\nunique(beg, end); // 使用 == 运算符比较元素\nunique(beg, end, comp); // 使用comp比较元素\n```\n\n###### _if版本的算法\n\n接受一个元素值得算法通常有另一个不同名的版本（非重载），该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的`_if`前缀：\n\n```cpp\nfind(beg, end, val); // 查找输入范围种val第一次出现的位置\nfind_if(beg, end, pred);// 查找第一个令pred为真的元素\n```\n\n###### 区分拷贝元素的版本和不拷贝的版本\n\n默认情况下，重排元素的算法将重排后的元素写回给定的输入序列。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个`_copy`：\n\n```cpp\nreverse(beg, end); // 反转输入范围中元素的顺序\nreverse_copy(beg, end ,dest); // 将元素按逆序拷贝到dest\n```\n\n一些算法同时提供`_if`和`_copy`版本。\n\n```cpp\n// 从v1中删除奇数元素\nremove_if(v1.begin(), v1.end(), \n          [](int i) { return i % 2; });\n// 将偶数元素从v1拷贝到v2，v1不变\nremove_copy_if(v1.begin(), v1.end(), back_inserter(v2),\n              [](int i){ return i % 2});\n```\n\n#### 特定容器算法\n\n与其他容器不同，链表类型`list`和`forward_list`定义了几个成员函数形式的算法，它们定义了独有的`sort、merge、remove、reverse、unique`，这些独有的版本比通用版本好得多。\n\n<img src=\"C-泛型算法（二）\\特定容器算法.png\" style=\"zoom:80%;\" />\n\n算法如下：\n\n<img src=\"C-泛型算法（二）\\list.png\" style=\"zoom:80%;\" />\n\n##### splice成员\n\n<img src=\"C-泛型算法（二）\\splice.png\" style=\"zoom:80%;\" />\n\n##### 链表特有的操作会改变容器\n\n链表特有版本会改变底层的容器，例如`remove`会删除指定的元素。`unique`会删除第二个和后继的重复元素。\n\n类似的，通用版本`merge`将合并的序列写到一个给定的目的迭代器，两个输入序列是不变的。而链表版本的`merge`会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用`merge`的链表对象中。在`merge`之后，来自两个链表中的元素依然存在，但它们都已在同一个链表中。","categories":["C++"]},{"title":"C++泛型算法（一）","url":"//www.xingyuzhao.ltd/blog/2020/12/19/C-泛型算法（一）/","content":"\n#### 本次学习要点\n\n1. 概述\n2. 初识泛型算法\n3. 定制操作\n\n<!-- more-->\n\n#### 概述\n\n大多数算法都定义在头文件`algorithm`中。标准库还在头文件`numeric`中定义了一组数值泛型算法。\n\n##### 算法永远不会执行容器的操作\n\n泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。算法永远**不会改变**底层容器的大小。算法可能**改变**容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。\n\n标准库定义了一类特殊的迭代器，称为插入器（inserter）。它们会在底层的容器上执行插入操作。当一个算法操作这样的一个迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身**不会**做这样的操作。\n\n#### 初识泛型算法\n\n标准库算法都对一个范围内的元素进行操作。此范围称为“输入范围”。输入范围使用两个参数：要处理的第一个元素和尾元素之后的位置的迭代器。\n\n##### 只读算法\n\n此类算法只会读取其输入范围内的元素，而从不改变元素。如`find`，`count`。定义在`numeric`中有只读算法`accumulate`，前两个指出需要求和的元素的范围，第三个参数是和的初值。最好用`cbegin()`和`cend()`，除非打算用返回的迭代器来改变元素的值。\n\n```cpp\n// 对vec中的元素求和，和的初值为0\nint sum = accumulate(v.cbegin(), v.cend(), 0);\n```\n\n###### 算法和元素类型\n\n`accumulate`第三个参数为求和起点，包含了一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须和第三个参数匹配。由于`string`定义了`+`操作，所以可以将`vector`中的所有`string`连接起来：\n\n```cpp\nstring sum = accumulate(v.cbegin(), v.cend(), string(\"\"));\n```\n\n将空串当作一个字符串字面值传递给第三个参数是不可以的，会导致编译错误：\n\n```cpp\n// 错误：const char*上没有定义+运算符\nstring sum = accumulate(v.cbegin(), v.cend(), \"\");\n```\n\n###### 操作两个序列的算法\n\n只读算法`equal`用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素和第二个序列中的对应元素逐个比较，如果都相等返回`true`，否则返回`false`。此算法接受三个迭代器：前两个表示第一个序列范围，第三个表示第二个序列的首元素：\n\n```cpp\n// roster2中的元素数目应该至少于roster1一样多\nequal(roster1.cbegin(), roster1.cend(), roster2.cbegin());\n```\n\n`equal`基于假设：第二个序列至少与第一个序列一样长。\n\n***注意！！！****那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。*\n\n##### 写容器元素的算法\n\n一些算法将新值赋予序列中的元素，需要确保序列原大小至少不小于要求算法写入的元素数目。例如`fill`接受一对迭代器表示一个范围，还接受一个值作为第三个参数，将范围内的值置为第三个参数的值：\n\n```cpp\nfill(vec.begin(), vec.end(), 0); // 将每个元素重置为0\n// 将容器的一个子序列设置为10\nfill(vec.begin(), vec.begin() + vec.size() / 2, 0);\n```\n\n###### 算法不检查写操作\n\n一些算法接受一个迭代器来指出一个单独的目的位置，从目的位置开始，将新值赋予一个序列中的元素。例如`fill_n`接受一个单迭代器、一个计数值和一个值：\n\n```cpp\nfill_n(dest, n, val);\n```\n\n`fill_n`假定`dest`指向一个元素，从`dest`开始的序列至少包含n个元素。\n\n```cpp\nvector<int> vec; // 空vector\n// 正确\nfill_n(vec.begin(), vec.size(); 0);\n// 错误,vec并没有10个元素\nfill_n(vec.begin(), 10, 0);\n```\n\n###### 介绍back_inserter\n\n`back_inserter`定义在头文件`iterator`中，其接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中：\n\n```cpp\nvector<int> vec;\nauto it = back_inserter(vec);\n*it = 42;\n```\n\n常常使用`back_inserter`创建一个迭代器，作为算法的目的位置来使用。例如：\n\n```cpp\nvector<int> vec;\nfill_n(back_inserter(vec), 10, 0);\n```\n\n###### 拷贝算法\n\n此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。算法将输入范围中的元素拷贝到目的序列中。**传递给`copy`的目的序列至少要包含与输入序列一样多的元素**。\n\n```cpp\nint a1[] = {0,1,2,3,4,5,6,7,8,9};\nint a2[sizeof(a1) / sizeof(*a1)];\nauto ret = copy(begin(a1), end(a1), a2);\n```\n\n`copy`返回其目的位置迭代器（递增后）的值，即`ret`恰好指向拷贝到`a2`的尾元素之后的位置。\n\n多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放在输入序列的末尾，而是创建一个新序列保存这些结果。\n\n如`replace`，其读入一个序列，并将其中所有等于给定值元素都改为另一个值，此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值：\n\n```cpp\n// 将所有值为0的元素改为42\nreplace(ilist.begin(), ilist.end(), 0, 42);\n```\n\n对于它的“拷贝”版本`replace_copy`，此算法接受额外第三个迭代器参数，指出点整后序列的保存位置：\n\n```cpp\n// 使用back_inserter按需要增长目标序列\nreplace_copy(ilist.cbegin(), ilist.cend(),\n             back_inserter(ivec), 0, 42);\n```\n\n经过此调用，`ilist`并未改变，`ivec`包含`ilist`的一份拷贝，不过原来在`ilist`中值为0的元素在`ivec`中都变为42。\n\n##### 重排容器元素的算法\n\n假定已经有一个`vector`，保存了多个故事的文本，简化这个`vector`，使得每个单词只出现一次。输入如下：\n\n<img src=\"C-泛型算法（一）\\重排_输入.png\" style=\"zoom:80%;\" />\n\n要求得到的结果如下：\n\n<img src=\"C-泛型算法（一）\\重排_输出.png\"  />\n\n为了消除重复单词，先对`vector`排序，使得重复的单词相邻出现，之后可以使用另一个称为`unique`的标准库算法来重排`vector`，使得不重复的元素出现在`vector`的开始部分。由于算法不能执行容器的操作，可以使用`vector`的成员`erase`来完成真正的删除操作：\n\n```cpp\nvoid elimDups(vector<string> &words){\n\tsort(words.begin(), words.end());\n    auto end_unique(words.begin(), words.end());\n    words.erase(end_unique, words.end());\n}\n```\n\n`words`排序完毕后，使用`unique`算法重排输入序列，将相邻的重复项”消除“，并**返回一个指向最后一个不重复元素之后的位置的迭代器**。调用`unique`后，`vector`将变为：\n\n<img src=\"C-泛型算法（一）\\after_unique.png\"  />\n\n如上图所示，`unique`并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列的开始部分。`unique`返回的迭代器位置之后的元素依旧存在，但不知道是什么。\n\n**标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元。素**\n\n最后，使用`erase`删除从`end_unique`开始至`words`末尾的范围内的所有元素。即使`words`中没有重复单词，调用`erase`也是安全的，删除空的范围没什么不良后果。\n\n#### 定制操作\n\n详见[C++11之lambda表达式](http://www.xingyuzhao.ltd/blog/2020/08/02/C-11%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/)。","categories":["C++"]},{"title":"LeetCode48-旋转图像","url":"//www.xingyuzhao.ltd/blog/2020/12/19/LeetCode48-旋转图像/","content":"\n#### 题目描述\n\n给定一个 $n × n$ 的二维矩阵表示一个图像。\n\n将图像顺时针旋转 90 度。\n\n说明：\n\n你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。\n\n<!-- more-->\n\n<img src=\"LeetCode48-旋转图像\\48.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n不好意思，一开始我还是用了新的数组。\n\n从最后一列往前，从第一行往后，每一列都是由相应的行复制过来，如下图（示例二）：\n\n<img src=\"LeetCode48-旋转图像\\48_思路.png\" style=\"zoom:80%;\" />\n\n新建数组保存原始数组的拷贝，然后再根据原始数组拷贝来修改原始数组。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int scale = matrix.size();\n        auto matrixHelper = matrix;\n        int pos = 0; // 表示当前遍历到拷贝数组的第pos行\n        for(int j = scale - 1; j >= 0; --j){\n            for(int i = 0; i < scale; ++i){\n                // 前面的i表示原始数组的行，后面的i表示拷贝数组的列\n                matrix[i][j] = matrixHelper[pos][i];\n            }\n            pos++;\n        }\n    }\n};\n```\n\n时间复杂度和空间复杂度都是$O(N^2)$。\n\n#### 更进一步\n\n##### 思路\n\n仔细观察旋转后的图：\n\n<img src=\"LeetCode48-旋转图像\\48_思路.png\" style=\"zoom:80%;\" />\n\n对于矩阵中第 $i$ 行的第 $j$ 个元素，在旋转后，它出现在倒数第 $i $ 列的第 $j$ 个位置。即：\n$$\nmatrix_{new}[col][n-row-1]=matrix[row][col]\n$$\n这样可以得到以下代码：\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        auto matrixHelper = matrix;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                matrix[j][n - i - 1] = matrixHelper[i][j];\n            }\n        }\n    }\n};\n```\n\n这样也不是原地修改，但是可以得到上面那个重要等式。\n\n如果对矩阵先进行水平轴翻转，再进行主对角线翻转，也可以得到旋转后的矩阵，以示例二为例：\n\n1. 水平翻转：\n\n$$\n\\left[\n\\begin{matrix}\n\t5 & 1 & 9 & 11 \\\\\\\\\n\t2 & 4 & 8 & 10 \\\\\\\\\n    13 & 3 & 6 & 7 \\\\\\\\\n    15 & 14 & 12 & 16\n\t\\end{matrix}\n\t\\right]\\stackrel{\\Large水平翻转}{\\huge\\longrightarrow}\n\\left[\n\\begin{matrix}\n\t15 & 14 & 12 & 16\\\\\\\\\n    13 & 3 & 6 & 7 \\\\\\\\\n    2 & 4 & 8 & 10 \\\\\\\\\n    5 & 1 & 9 & 11\n\t\\end{matrix}\n\t\\right]\n$$\n\n$$\nmatrix[row][col]=matrix[n-row-1][col]\n$$\n\n2. 主对角线翻转：\n\n$$\n\\left[\n\\begin{matrix}\n\t15 & 14 & 12 & 16 \\\\\\\\\n    13 & 3 & 6 & 7 \\\\\\\\\n    2 & 4 & 8 & 10 \\\\\\\\\n    5 & 1 & 9 & 11\n\t\\end{matrix}\n\t\\right]\\stackrel{\\Large主对角线翻转}{\\huge\\longrightarrow}\n\\left[\n\\begin{matrix}\n\t15 & 13 & 2 & 5 \\\\\\\\\n    14 & 3 & 4 & 1 \\\\\\\\\n    12 & 6 & 8 & 9 \\\\\\\\\n    16 & 7 & 10 & 11\n\t\\end{matrix}\n\t\\right]\n$$\n\n$$\nmatrix[row][col]=matrix[col][row]\n$$\n\n综合以上两式，可以得到：\n$$\nmatrix[row][col]\\stackrel{\\large水平翻转}{\\large\\longrightarrow}matrix[n-row-1][col]\n$$\n\n$$\nmatrix[n-row-1][col]\\stackrel{\\large主对角线翻转}{\\large\\longrightarrow}matrix[col][n-row-1]\n$$\n\n即：\n$$\nmatrix[row][col]=matrix_{new}[col][n-row-1]\n$$\n这就与之前得到的重要等式相同了。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        // 水平翻转\n        for (int i = 0; i < n / 2; ++i) {\n            for (int j = 0; j < n; ++j) {\n                swap(matrix[i][j], matrix[n - i - 1][j]);\n            }\n        }\n        // 主对角线翻转\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n    }\n};\n\n```\n\n#### Reference\n\n官方题解：\n\nhttps://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/","tags":["数组"],"categories":["LeetCode"]},{"title":"LeetCode389-找不同","url":"//www.xingyuzhao.ltd/blog/2020/12/18/LeetCode389-找不同/","content":"\n#### 题目描述\n\n给定两个字符串 ***s*** 和 ***t***，它们只包含小写字母。\n\n字符串 ***t*** 由字符串 ***s*** 随机重排，然后在随机位置添加一个字母。\n\n请找出在 ***t*** 中被添加的字母。\n\n<!-- more-->\n\n<img src=\"LeetCode389-找不同\\389.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n用一个长为26的数组记录在 ***t*** 中所有字母的出现次数，然后再去遍历 ***s*** ，对每次遇到的字母对应的次数减一，最后再遍历这个数组，如果有出现次数为1的字母，那么这就是 ***t*** 中被添加的字母。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    char findTheDifference(string s, string t) {\n        int map[26] = {0};\n        for(auto &ch : t){\n            map[ch - 'a']++;\n        }\n        for(auto &ch : s){\n            map[ch - 'a']--;\n        }\n        for(int i = 0; i < 26; ++i){\n            if(map[i] == 1) return char(i + 'a');\n        }\n        return char(' ');\n    }\n};\n```\n\n","tags":["哈希表"],"categories":["LeetCode"]},{"title":"LeetCode714-买卖股票的最佳时机含手续费","url":"//www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-买卖股票的最佳时机含手续费/","content":"\n#### 题目描述\n\n给定一个整数数组 $prices$，其中第$i$个元素代表了第$i$天的股票价格 ；非负整数 $fee$ 代表了交易股票的手续费用。\n\n你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n\n返回获得利润的最大值。\n\n注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n\n<!-- more-->\n\n<img src=\"LeetCode714-买卖股票的最佳时机含手续费\\714.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n##### 定义$dp$数组\n\n使用两个数组$dp1[i]$和$dp2[i]$分别表示当天持有股票or当天不持有股票时的最大收益。\n\n##### 状态转移方程\n\n* $dp1[i]$表示第$i$天未持有的最大收益，由上一天未持有或者上一天持有当天卖出得到：\n\n$$\ndp1[i] = max(dp1[i - 1], dp2[i - 1] + prices[i] - fee)\n$$\n\n* $dp2[i]$表示第$i$天持有的最大收益，由上一天持有或者上一天不持有今天买入得到：\n\n$$\ndp2[i] = max(dp2[i - 1], dp1[i - 1] - prices[i])\n$$\n\n##### 初始化\n\n* 第一天未持有股票时，收益为0，$dp1[0] = 0$。\n* 第一天持有股票时，收益为当天买入所需要的钱，$dp2[0] = -prices[0]$。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        vector<int> dp1(prices.size());\n        vector<int> dp2(prices.size());\n        dp1[0] = 0;\n        dp2[0] = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            dp1[i] = max(dp1[i - 1], dp2[i - 1] + prices[i] - fee);\n            dp2[i] = max(dp2[i - 1], dp1[i - 1] - prices[i]);\n        }\n        return dp1[prices.size() - 1];\n    }\n};\n```\n\n##### 更进一步\n\n注意到$dp1[i]$和$dp2[i]$只会从$dp1[i-1]$和$dp2[i-1]$转移而来，所以用两个变量$sell$以及$buy$分别表示$dp1[i]$和$dp2[i]$，空间复杂度降为$O(1)$。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int sell = 0;\n        int buy = -prices[0];\n        for(int i = 1; i < prices.size(); ++i){\n            int tmp = sell;\n            sell = max(sell, buy + prices[i] - fee);\n            buy = max(buy, sell - prices[i]);\n        }\n        return sell;\n    }\n};\n```\n\n#### Reference\n\n评论区：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/comments/\n\n官方题解：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/\n\n股票问题系列通解（转载翻译）：https://leetcode-cn.com/circle/article/qiAgHn/\n\n#### Appendix\n\n结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？\n\n如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。\n\n[LeetCode121-买卖股票的最佳时机]()\n\n[LeetCode122-买卖股票的最佳时机II]()\n\n[LeetCode122-买卖股票的最佳时机III]()\n\n[LeetCode122-买卖股票的最佳时机 IV]()\n\n[LeetCode309-最佳买卖股票时机含冷冻期]()\n\n[LeetCode714-买卖股票的最佳时机含手续费]()","tags":["动态规划","股票问题"],"categories":["LeetCode"]},{"title":"LeetCode290-单词规律","url":"//www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-单词规律/","content":"\n#### 题目描述\n\n给定一种规律 `pattern` 和一个字符串 `str` ，判断 `str` 是否遵循相同的规律。\n\n这里的 `遵循` 指完全匹配，例如， `pattern` 里的每个字母和字符串 `str` 中的每个非空单词之间存在着双向连接的对应规律。\n\n<!-- more-->\n\n<img src=\"LeetCode290-单词规律\\290.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n字母和单词一一对应时返回true，否则返回false。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        istringstream istr(s);\n        vector<string> str;\n        string word;\n        while(istr >> word){\n            str.push_back(word);\n        }\n        if(pattern.size() != str.size()) return false;\n        unordered_map<char, unordered_set<string>> map1;\n        unordered_map<string, unordered_set<char>> map2;\n        for(int i = 0; i < pattern.size(); ++i){\n            map1[pattern[i]].insert(str[i]);\n            map2[str[i]].insert(pattern[i]);\n            // 如果不是一一对应，返回false\n            if(map1[pattern[i]].size() > 1 || map2[str[i]].size() > 1) return false;\n        }\n        return true;\n    }\n};\n```\n\n","tags":["哈希表"],"categories":["LeetCode"]},{"title":"LeetCode738-单调递增的数字","url":"//www.xingyuzhao.ltd/blog/2020/12/15/LeetCode738-单调递增的数字/","content":"\n#### 题目描述\n\n给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。（当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）\n\n<!-- more-->\n\n<img src=\"LeetCode738-单调递增的数字\\738.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n这种思路太繁琐，不想看的话直接转至**更进一步**。\n\n---\n\n输入是一个非负整数，所以第一步要将其转换成可以遍历的形式，可以先将整数转换为字符串序列。\n\n从**输入序列**的第一个数开始，一个一个数的建立起**答案序列**。\n\n1. **输入序列单调不减**，答案序列的当前值最大可以取到输入序列的当前值。如输入为1234，那么答案序列的第一个位置最大可以取到1，继续遍历，取到当前位置最大值时，一直会大于等于上一个取到的值，所以最终可以得到答案1234：\n\n```cpp\nstring nums; // 输入序列\nstring res; // 答案序列\nint pre = -1; // 初始化为-1，保证第一个值可以取到\nint cur;\nfor(int i = 0; i < nums.size(); ++i){\n    cur = nums[i] - '0';\n    if(cur >= pre){\n        res += to_string(cur);\n        pre = nums[i] - '0';\n    }\n}\n```\n\n2. **输入序列非单调不减**，如果当前值小于上一个可以取到的最大值，就需要回退，直到当前值不小于上一个可以取到的最大值。如输入332。\n   1. 当取到2时小于上一个取到的值3，上一个值减去1作为当前值（得到2），`res`出栈一次，如果出栈后`res`为空，那么存下当前值并退出。否则，上一个值取`res`末尾的值（第一个3）。\n   2. 当前值为2，上一个值为第一个3，由于2小于3，那么再将上一个值减1作为当前值得到2），出栈一次，遍历回退一次，那么当前值变为2，此时`res`为空，记录2并且退出遍历。\n\n* 使用一个`flag`标记是否回退。\n* 如果`res == \"0\"`，说明第一个数为0，此时答案长度为输入序列的长度减去1，全部为9；否则，就在`res`后补充9直到和输入序列长度相同。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int monotoneIncreasingDigits(int N) {\n        string nums = to_string(N);\n        int pre = -1;\n        int cur;\n        int flag = 0;\n        string res;\n        int i;\n        for(i = 0; i < nums.size(); ++i){\n            if(flag == 0){\n                cur = nums[i] - '0';\n                if(cur >= pre){\n                    res += to_string(cur);\n                    pre = nums[i] - '0';\n                }\n                else{\n                    flag = 1;\n                    pre--;\n                    res.pop_back();\n                    if(res.empty()){\n                        res += to_string(pre);\n                        break;\n                    }\n                    cur = pre;\n                    pre = res.back() - '0';\n                    i--;\n                }\n            }\n            else{\n                if(cur >= pre){\n                    res += to_string(cur);\n                    break;\n                }\n                pre--;\n                res.pop_back();\n                if(res.empty()){\n                    res += to_string(pre);\n                    break;\n                }\n                cur = pre;\n                pre = res.back() - '0';\n                i--;\n            }\n        }\n        int resVal;\n        if(res == \"0\"){\n            int n = nums.size() - 1;\n            string buf(n, '9');\n            resVal = stoi(buf, 0, 10);\n        }\n        else{\n            for(int j = res.size(); j < nums.size(); ++j){\n                res += '9';\n            }\n            resVal = stoi(res, 0, 10);\n        }\n        return resVal;\n    }\n};\n```\n\n这种思路实现起来太繁琐了（我是sb）。\n\n#### 更进一步\n\n##### 思路\n\n局部最优：遇到`nums[i - 1] > nums[i]`的情况，让`nums[i - 1]--`，然后`nums[i]`值为9，可以保证这两位变成最大单调不减整数。\n\n全局最优：尽量使`nums[i - 1]--`靠后，这样做可以使整数尽可能的大，因为越后面减去1，对整数的损失越小，所以从后往前遍历。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    int monotoneIncreasingDigits(int N) {\n        string nums = to_string(N);\n        int flag = nums.size();\n        for(int i = nums.size() - 1; i >= 1; --i){\n            if(nums[i - 1] > nums[i]){\n                nums[i - 1]--;\n                flag = i;\n            }\n        }\n        for(flag; flag < nums.size(); ++flag){\n            nums[flag] = '9';\n        }\n        return stoi(nums, 0, 10);\n    }\n};\n```\n\n#### Reference\n\n题解：\n\nhttps://leetcode-cn.com/problems/monotone-increasing-digits/solution/738-dan-diao-di-zeng-de-shu-zi-tan-xin-s-vq4r/","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode49-字母异位词分组","url":"//www.xingyuzhao.ltd/blog/2020/12/14/LeetCode49-字母异位词分组/","content":"\n#### 题目描述\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n<!-- more-->\n\n<img src=\"LeetCode49-字母异位词分组\\49.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n主要是理解哈希表的 $key$ 和 $value$ 表示什么数或者集合。对于字母构造相同的几个`string`，它们进行排序后的结果是一致的，所以可以将排序后的结果作为哈希表的 $key$，而对应的 $value$ 来存储排序后等于此 $key$ 的所有`string`。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> map;\n        vector<vector<string>> res;\n        for(int i = 0; i < strs.size(); ++i){\n            string str = strs[i];\n            sort(str.begin(), str.end());\n            map[str].push_back(strs[i]);\n        }\n        for(auto &m : map)\n            res.push_back(m.second);\n        return res;   \n    }\n};\n```\n\n#### 更进一步\n\n##### 思路\n\n**唯一分解定理**：任何一个大于1的**自然数**N,如果N不为**质数**，那么N可以唯一分解成**有限个质数**的乘积。\n\n用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。并且每个乘积只能是由这几个质数相乘得到。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<double, vector<string>> map;\n        vector<vector<string>> res;\n        double value[26]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};\n        for(int i = 0; i < strs.size(); ++i){\n            double v = 1;\n            for(auto &ch : strs[i]){\n                v *= value[ch - 'a'];\n            }\n            map[v].push_back(strs[i]);\n        }\n        for(auto &m : map)\n            res.push_back(m.second);\n        return res;   \n    }\n};\n```\n\n#### Reference\n\n评论区https://leetcode-cn.com/problems/group-anagrams/comments/","tags":["哈希表"],"categories":["LeetCode"]},{"title":"内存管理（二）","url":"//www.xingyuzhao.ltd/blog/2020/12/12/内存管理（二）/","content":"\n#### 本次学习要点\n\n1. 连续分配管理方式\n2. 动态分区分配算法\n\n <!-- more-->\n\n#### 连续分配管理方式\n\n连续分配：指为用户进程分配的必须是一个**连续的空间**。\n\n<img src=\"内存管理（二）\\连续分配.png\"  />\n\n##### 单一连续分配\n\n单一连续分配方式中，内存被分为**系统区**和**用户区**。\n\n<img src=\"内存管理（二）\\单一连续分配.png\" style=\"zoom:80%;\" />\n\n特点：内存中**只能有一道用户程序**，用户程序独占整个用户区空间。\n\n优点：实现简单，**无外部碎片**；可采用覆盖技术扩充内存；不一定需要采取内存保护\n\n缺点：只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低。\n\n*分配给某进程的内存区域中，如果有些部分没有用上，就是**内部碎片***。\n\n##### 固定分区分配\n\n将**用户空间**划分为**若干个固定大小的分区**，每个分区中**只装入一道作业**。\n\n有两种形式：分区大小相等和分区大小不等\n\n<img src=\"内存管理（二）\\固定分区分配.png\" style=\"zoom:80%;\" />\n\n* 分区大小相等：缺乏灵活性，适用于一台计算机控制多个相同模块的场合。\n* 分区大小不等：增加灵活性，可以满足不同大小进程需求。\n\n###### 分区说明表\n\n操作系统需要建立一个数据结构—分区说明表，每个表包括对应分区的**大小、起始地址、状态**：\n\n<img src=\"内存管理（二）\\固定分区分配-分区说明表.png\"  />\n\n当某用户程序要装入内存时，操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将其分配给该程序，然后修改状态为“已分配”。\n\n优点：实现简单，无外部碎片。\n\n缺点：用户程序太大时，所有分区都不能满足需求，此时得采用覆盖技术，会降低性能；会产生内部碎片，内存利用率低。\n\n##### 动态分区分配\n\n动态分区分配也称可变分区分配，这种方法不会预先划分内存分区，而是**在进程装入内存时，根据进程的大小动态的建立分区**，使分区的大小正好适合进程的需要。\n\n<img src=\"内存管理（二）\\动态分配数据结构.png\" style=\"zoom:80%;\" />\n\n###### 使用什么数据结构？\n\n1. 空闲分区表：每个空闲分区对应一个表项，表项中包含分区号、分区大小、分区起始地址等信息。\n\n<img src=\"内存管理（二）\\动态分配数据结构-空闲分区表.png\"  />\n\n2. 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可以记录分区大小等信息。\n\n<img src=\"内存管理（二）\\动态分配数据结构-空闲分区链.png\"  />\n\n###### 选择哪个分区？\n\n动态分区分配算法，之后会提到。\n\n###### 如何进行分区的分配与回收？\n\n1. 分配\n\n<img src=\"内存管理（二）\\动态分配数据结构-分配1.png\" style=\"zoom:80%;\" />\n\n如果此时一个大小为5MB的进程到来，按照一定的分配算法，将分区1的一部分分配给它运行，分区表更新如下：\n\n![image-20201218113548211](D:\\zxy543040659.github.io\\source\\_posts\\内存管理（二）\\动态分配数据结构-分配2.png)\n\n还有一种情况，如果到来的进程大小为4MB，且将分区3分配给它，那么分区表更新如下：\n\n<img src=\"内存管理（二）\\动态分配数据结构-分配3.png\"  />\n\n2. 回收\n\n   1. 情况一，回收区的后面有一个相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收1.png\" style=\"zoom: 80%;\" />\n\n   此时进程4执行完毕，释放其占用的4MB内存，更新分区表如下（二合一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收2.png\"  />\n\n   \n\n   2. 情况二，回收区的前面有一个相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收3.png\" style=\"zoom:80%;\" />\n\n   此时进程3执行完毕，释放其占用的18MB内存，更新分区表如下（二合一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收4.png\"  />\n\n   3. 情况三，回收区的前、后各有一个相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收5.png\" style=\"zoom:80%;\" />\n\n   此时进程4执行完毕，释放其占用的4MB内存，更新分区表如下（三合一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收6.png\"  />\n\n   4. 情况四，回收区的前、后都没有相邻的空闲分区：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收7.png\" style=\"zoom:85%;\" />\n\n   此时进程2执行完毕，释放其占用的14MB内存，更新分区表如下（新增一）：\n\n   <img src=\"内存管理（二）\\动态分配数据结构-回收8.png\"  />\n\n*各表项的顺序不一定按照地址递增顺序，具体由动态分区分配算法确定。*\n\n###### 小结\n\n动态分区分配**没有内部碎片**，但是有**外部碎片**。\n\n* 内部碎片：分配给某进程的内存区域中，有些部分没有用上。\n* 外部碎片：指内存中某些空闲分区由于太小而难以利用。\n\n如果内存中空闲空间的总和本来可以满足某进程的要求，但是进程需要一整块连续的内存空间，而碎片不连续，可以通过**紧凑（拼凑，Compaction）**技术解决外部碎片。\n\n##### 小结\n\n<img src=\"内存管理（二）\\连续分配小结.png\" style=\"zoom:120%;\" />\n\n#### 动态分区分配算法\n\n在动态分区分配方式中，当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？\n\n<img src=\"内存管理（二）\\动态分配算法.png\" style=\"zoom:80%;\" />\n\n##### 首次适应算法\n\n算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。\n\n如何实现：**空闲分区以地址递增的次序排列**。每次分配内存时顺序查找**空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区。\n\n##### 最佳适应算法\n\n算法思想：尽可能多的留下大片的空闲区，优先使用更小的空闲区。\n\n如何实现：**空闲分区以容量递增次序链接**。每次分配内存时顺序查找**空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区（能够满足但大小最小）。\n\n缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多外部碎片。\n\n##### 最坏适应算法\n\n又称最大适应算法。\n\n算法思想：每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小。\n\n如何实现：**空闲分区以容量递减次序链接**。每次分配内存时顺序查找**空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区。\n\n缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。之后如果有“大进程”到达，就没有内存分区可用了。\n\n##### 邻近适应算法\n\n算法思想：在首次适应算法基础上，每次都从上次查找结束的位置开始检索，减小查找的开销。\n\n如何实现：**空闲分区以地址递增的顺序排列（可排成一个循环链表）**。每次分配内存时**从上次查找结束的位置开始查找空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区。\n\n**首次适应算法**每次都会从头查找，每次都需要检索低地址的小分区。这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来。\n\n**邻近适应算法**的规则可能导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，被划分为小分区，最后导致无大分区可用。\n\n**综合来看，首次适应算法的效果反而最好**。\n\n##### 小结\n\n<img src=\"内存管理（二）\\动态分配算法小结.png\" style=\"zoom:120%;\" />\n\n\n\n","categories":["操作系统"]},{"title":"内存管理（一）","url":"//www.xingyuzhao.ltd/blog/2020/12/12/内存管理（一）/","content":"\n#### 本次学习要点\n\n1. 内存的基础知识\n2. 内存管理的概念\n3. 覆盖与交换\n\n<!-- more-->\n\n#### 内存的基本知识\n\n##### 什么是内存？有何作用？\n\n**内存**是用于存放数据的硬件。程序执行前**需要先放到内存中才能被CPU处理。**\n\n在多道程序环境下，系统中会有多个程序并发执行，会有多个程序的数据需要同时放到内存中。如何区分各个程序的数据在什么地方？——给内存的存储单元编地址。\n\n**内存地址**从0开始，每个地址对应一个存储单元。如果计算机按**字节**编址，则每个存储单元大小为1字节；如果**字长为16位**的计算机按**字**编址，则每个存储单元大小位1个字，也就是16个二进制位。\n\n常用的几个数量单位：\n\n```\n2^10 = 1K\n2^20 = 1M\n2^30 = 1G\n```\n\n##### 逻辑地址与物理地址\n\n编译时产生的指令只关心**相对地址**，实际放入内存中再想办法根据起始位置得到**绝对地址**。\n\neg：编译时只需确定变量x的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程*起始地址+100*即可。\n\n**相对地址**又称**逻辑地址**，**绝对地址**又称**物理地址**。\n\n##### 程序的装入和链接\n\n<img src=\"内存管理（一）\\程序的执行.png\" style=\"zoom:120%;\" />\n\n编译：由编译程序将用户源代码编译成若干个目标模块（高级语言->机器语言）。\n\n链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。\n\n装入（装载）：由装入程序将装入模块装入内存运行。\n\n##### 装入的三种方式\n\n<img src=\"内存管理（一）\\三种装入方式.png\" style=\"zoom:120%;\" />\n\n###### 绝对装入\n\n在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。\n\n绝对装入**只适用于单道程序环境**。\n\n程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。\n\n###### 静态重定位\n\n又称**可重定位装入**。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址仅从**重定位**，将逻辑地址变换为物理地址（地址变换实在装入时一次完成的）。\n\n静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**，也不能再申请内存空间。\n\n###### 动态重定位\n\n又称**动态运行时装入**。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行。**因此装入内存后所有的地址依然是逻辑地址，这种方式需要一个**重定位寄存器支持**。\n\n<img src=\"内存管理（一）\\重定位寄存器.png\" style=\"zoom:120%;\" />\n\n* 采取动态重定位时**允许程序在内存中发生移动**；\n* 可将程序分配到**不连续**的存储区中；\n* 程序运行前只需装入部分代码即可投入运行；\n* 运行期间根据需要动态申请分配内存。\n\n##### 链接的三种方式\n\n###### 静态链接\n\n在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。\n\n<img src=\"内存管理（一）\\静态链接.png\" style=\"zoom: 80%;\" />\n\n###### 装入时动态链接\n\n将各目标模块装入内存时，边装入边链接的链接方式。\n\n<img src=\"内存管理（一）\\装入时动态链接.png\" style=\"zoom:85%;\" />\n\n###### 运行时动态链接\n\n在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。\n\n<img src=\"内存管理（一）\\运行时动态链接.png\" style=\"zoom:90%;\" />\n\n##### 小结\n\n<img src=\"内存管理（一）\\内存的基本知识小节.png\" style=\"zoom:120%;\" />\n\n#### 内存管理的概念\n\n1. 操作系统负责**内存空间的分配与回收**。\n2. 操作系统需要提供某种技术从逻辑上**对内存空间进行扩充**。\n3. 操作系统需要提供**地址转换**功能，负责程序的**逻辑地址**与**物理地址**的转换。\n\n4. 操作系统需要提供**内存保护**功能。保证各进程在各自存储空间内运行，互不干扰。\n\n内存保护的两种方法：\n\n1. 在CPU中设置一对**上、下限寄存器**，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。\n2. 采用**重定位寄存器（基址寄存器）**和**界地址寄存器（限长寄存器）**进行越界检查。重定位寄存器存放进程的**起始物理地址**。界地址寄存器存放进程的**最大逻辑地址**。\n\n<img src=\"内存管理（一）\\内存保护方法二.png\" style=\"zoom:80%;\" />\n\n##### 小结\n\n<img src=\"内存管理（一）\\内存管理的概念.png\" style=\"zoom:100%;\" />\n\n#### 覆盖与交换\n\n##### 覆盖技术\n\n引入**覆盖技术**，解决**程序大小超过物理内存总和**的问题。\n\n覆盖技术的思想：将**程序分为多个段（多个模块）**。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为**一个固定区**和**若干个覆盖区**。\n\n* 需要常驻内存的段放在**固定区**中，**调入后就不再调出（除非运行结束）**。\n* 不常用的段放在**覆盖区**，**需要用到时调入内存，用不到时调出内存**。\n\n<img src=\"内存管理（一）\\覆盖技术.png\" style=\"zoom:80%;\" />\n\n*必须由程序员声明覆盖结构*，操作系统完成自动覆盖。\n\n**缺点**：对用户不透明，增加了用户编程负担，已成为历史。\n\n##### 交换技术\n\n交换技术的思想：内存空间紧张时，系统将内存中某些进程暂时**换出**外存，把外存中某些已具备运行条件的进程**换入**内存（进程在内存与磁盘间动态调度）。进行了中级调度（内存调度）：决定将哪个处于挂起状态的进程重新调入内存。\n\n1. 应该在外存（磁盘）的什么位置保存被换出的进程？\n\n   具有对换功能的操作系统中，通常把磁盘空间分为**文件区**和**对换区**两部分。**文件区**主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用**离散分配**方式；**对换区**空间只占磁盘空间的小部分，**被换出的进程数据就存放在对换区**。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用**连续分配**方式。总之，对换区的`I/O`速度比文件区的更快。\n\n2. 什么时候应该交换？\n\n   交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。\n\n3. 应该换出哪些进程？\n\n   可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。\n\n*PCB会常驻内存*，不会被换成外存。\n\n##### 小结\n\n<img src=\"内存管理（一）\\覆盖与交换小结.png\" style=\"zoom:120%;\" />\n\n","categories":["操作系统"]},{"title":"LeetCode376-摆动序列","url":"//www.xingyuzhao.ltd/blog/2020/12/12/LeetCode376-摆动序列/","content":"\n#### 题目描述\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。\n\n例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n\n给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。\n\n<!-- more-->\n\n<img src=\"LeetCode376-摆动序列\\376.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n可以找每次的拐点进行计数，最后再加上首尾两个点即可，比如序列$[1,7,4,9,2,5]$，有4个拐点，加上首尾一共6个点：\n\n<img src=\"LeetCode376-摆动序列\\1.png\" style=\"zoom:80%;\" />\n\n需要考虑特殊情况：\n\n1. 连续几个相同的数恰好都是拐点，如$[1,12,12,12,1]$：\n\n<img src=\"LeetCode376-摆动序列\\2.png\" style=\"zoom:80%;\" />\n\n2. 输入的序列没有拐点且全部是同一个数，如$[1,1,1]$：\n\n<img src=\"LeetCode376-摆动序列\\3.png\" style=\"zoom:80%;\" />\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        int guaidian = 0;\n        for(int i = 1; i < nums.size() - 1; ++i){\n            if(nums[i - 1] > nums[i] && nums[i + 1] > nums[i]){\n                guaidian++;\n            }\n            else if(nums[i - 1] < nums[i] && nums[i + 1] < nums[i]){\n                guaidian++;\n            }\n            // 这一步是为了去除相同的点，如果nums[i]与nums[i + 1]相同，\n            // 那么就让nums[i]等于nums[i - 1]，\n            // 可以保证nums[i + 1]与改变之后的nums[i]不同。\n            else if(i + 1 < nums.size() - 1 && nums[i] == nums[i + 1]){\n                nums[i] = nums[i - 1];\n            }\n        }\n        if(guaidian == 0){\n            auto f = unique(nums.begin(), nums.end());\n            // 输入的序列全部都是同一个数\n            if(f - 1 == nums.begin()){\n                return 1;\n            }\n        }\n        return guaidian + 2;\n    }\n};\n```\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode649-Dota2参议院","url":"//www.xingyuzhao.ltd/blog/2020/12/11/LeetCode649-Dota2参议院/","content":"\n#### 题目描述\n\nDota2 的世界里有两个阵营：`Radiant`(天辉)和 `Dire`(夜魇)\n\nDota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：\n\n1. `禁止一名参议员的权利`：\n\n参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。\n\n2. `宣布胜利`：\n\n如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。\n\n<!-- more-->\n\n给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。\n\n以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。\n\n假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `Radiant` 或 `Dire`。\n\n<img src=\"LeetCode649-Dota2参议院\\649.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n只想到了暴力法解决。首先记录$senate$中R和D出现次数，再用一个长与$senate$相同的$bool$数组来记录当前字母是否被**消灭**了，初始化都为0，代表没有被**消灭**。遍历$senate$，如果遇到了R，就从R开始找第一个D的位置，直到下一轮循环到它之前的位置；对于D也是一样。这样保证它们能行使自己的权力，除非自己的阵营已经获胜了。\n\n**消灭的策略是：尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴。**\n\n这样做的时间复杂度会很高，用时1452ms。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    string predictPartyVictory(string senate) {\n        int R_cnt = 0;\n        int D_cnt = 0;\n        int len = senate.size();\n        vector<bool> isUsed(senate.size(), 0);\n        for(auto &ch : senate){\n            if(ch == 'R') R_cnt++;\n            else D_cnt++;\n        }\n        while(R_cnt != 0 && D_cnt != 0){\n            for(int i = 0; i < senate.size(); ++i){\n                if(isUsed[i]) continue;\n                if(senate[i] == 'R'){\n                    for(int m = i + 1; m < i + len; ++m){\n                        int j = m % len;\n                        if(senate[j] == 'D' && isUsed[j] == false){\n                            isUsed[j] = true;\n                            D_cnt--;\n                            break;\n                        }\n                    }\n                }\n                else{\n                    for(int m = i + 1; m < i + len; ++m){\n                        int j = m % len;\n                        if(senate[j] == 'R' && isUsed[j] == false){\n                            isUsed[j] = true;\n                            R_cnt--;\n                            break;\n                        }\n                    }\n                }\n                if(R_cnt == 0 || D_cnt == 0) break;\n            }\n        }\n        return R_cnt != 0 ? \"Radiant\" : \"Dire\";\n    }\n};\n```\n\n#### 更进一步\n\n##### 思路\n\n使用一个变量来记录当前参议员之前有几个对手，从而判断自己是否被消灭了。\n\n这里使用$count>0$表示**R在D前面，R可以消灭D**，用$count<0$表示**D在R前面，D可以消灭R**。\n\n执行用时：4ms。\n\n##### 代码\n\n```cpp\nclass Solution {\npublic:\n    string predictPartyVictory(string senate) {\n        int count = 0;\n        bool R = true, D = true;\n        while(R && D){\n            R = false;\n            D = false;\n            for(int i = 0; i < senate.size(); ++i){\n                // 如果没被完全消灭，本轮循环结束R和D都为true\n                if(senate[i] == 'R'){\n                    if(count < 0) senate[i] = '0';\n                    else R = true;\n                    // 如果被消灭了计数加一，代表抵挡了一次攻击\n                    // 如果没有被消灭，代表有多了一次消灭敌方机会\n                    // 无论如何都是需要++的，下面的--同\n                    count++;\n                }\n                else if(senate[i] == 'D'){\n                    if(count > 0) senate[i] = '0';\n                    else D = true;\n                    count--;\n                }\n            }\n        }\n        return R != 0 ? \"Radiant\" : \"Dire\";\n    }\n};\n```\n\n#### Reference\n\nhttps://leetcode-cn.com/problems/dota2-senate/solution/649-dota2-can-yi-yuan-tan-xin-suan-fa-ji-siha/","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode860-柠檬水找零","url":"//www.xingyuzhao.ltd/blog/2020/12/10/LeetCode860-柠檬水找零/","content":"\n#### 题目描述\n\n在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。\n\n顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。\n\n每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。\n\n注意，一开始你手头没有任何零钱。\n\n如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。\n\n<!-- more-->\n\n<img src=\"LeetCode860-柠檬水找零\\860.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n每位顾客付款只有5、10、20美元的选项：\n\n* 收到5元时记录5元零钱的个数；\n\n* 收到10元时需要找零5元并记录10元的个数；\n* 收到20元需要找零15元，但不用记录20元个数，因为不会发生找零20元的情况。\n\n*收到20元找零时应首先选10元零钱，10元用完后再选5元的。比如找零15元，如果只剩下两张5元，一张10元，先从5元开始无法刚好找零15（5+5+10）。*\n\n*需要找零的总数必须大于等于当前用到的零钱的面值，详见代码。*\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool lemonadeChange(vector<int>& bills) {\n        int map[11] = {0};\n        for(int i = 0; i < bills.size(); ++i){\n            if(bills[i] == 5){\n                map[5]++;\n            }\n            else{   \n                int val = bills[i] - 5;\n                for(int j = 10; j >= 5; j /= 2){\n                    // 需要找零的总数必须大于等于当前用到的零钱的面值，val >= j\n                    while(map[j] != 0 && val > 0 && val >= j){\n                        val -= j;\n                        map[j]--;\n                    }\n                    if(val == 0) break;\n                }\n                if(bills[i] <= 10) map[bills[i]]++;\n                if(val != 0) return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n","tags":["贪心算法"],"categories":["LeetCode"]},{"title":"LeetCode62-不同路径","url":"//www.xingyuzhao.ltd/blog/2020/12/09/LeetCode62-不同路径/","content":"\n#### 题目描述\n\n一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n与此类似：[LeetCode-不同路径Ⅱ](http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/)，[LeetCode97-交错字符串](http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more)，[LeetCode174-地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)。\n\n<!-- more-->\n\n<img src=\"LeetCode62-不同路径\\62.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n机器人只能往右或者往下，考虑动态规划（如果四个方向都可以走就不可以用动态规划了，得用DFS或者BFS），对于机器人所在的行和列，都只有一条路径可以到达，初始化为1。而除此之外的位置都是可以由其上边和其左边到达，以此类推得到可以到达最终位置的路径总数。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 1));\n        for(int i = 1; i < m; ++i){\n            for(int j = 1; j < n; ++j){\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n```\n\n\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode842-将数组拆分成斐波那契序列","url":"//www.xingyuzhao.ltd/blog/2020/12/08/LeetCode842-将数组拆分成斐波那契序列/","content":"\n#### 题目描述\n\n给定一个数字字符串 `S`，比如 `S = \"123456579\"`，我们可以将它分成斐波那契式的序列 `[123, 456, 579]​`。\n\n形式上，斐波那契式序列是一个非负整数列表 `F​`，且满足：\n\n* `0 <= F[i] <= 2^31 - 1​`，（也就是说，每个整数都符合 32 位有符号整数类型）\n* `F.length >= 3​`；\n* 对于所有的 `0 <= i < F.length - 2​`，都有 ​`F[i] + F[i+1] = F[i+2]​`成立。\n\n**另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。**\n\n返回从 `S` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]`。\n\n<!-- more-->\n\n<img src=\"LeetCode842-将数组拆分成斐波那契序列\\842.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n不断地截取字符串，看当前字符串对应的数能不能和之前的两个数构成斐波那契序列，如果可以就继续找下一个，不行的话就进行回退。截取完最后一个字符后，如果截取到的数字的个数大于等于3，则说明此数组可以拆分成斐波那契序列。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> splitIntoFibonacci(string S) {\n        if(S.empty()) return {};\n        vector<int> buf;\n        backTrack(S, buf, 0);\n        return buf;\n    }\n    bool backTrack(string &S, vector<int> &buf, int index){\n        if(buf.size() >= 3 && index == S.size())\n            return true;\n        for(int i = index; i < S.size(); ++i){\n            // 不能以0开头\n            if(S[index] == '0' && i > index)\n                break;\n            // 取从index开始到i的字符串并转换为数字\n            string s = S.substr(index, i - index + 1);\n            long num = stol(s, 0, 10);\n            // 如果取出的数大于INT_MAX直接终止\n            if(num > INT_MAX) break;\n            int len = buf.size();\n            // 如果截取的数字大于前两个数字之后，直接终止，因为后面只会越取越大\n            if(len >= 2 && num > (long)buf[len - 1] + (long)buf[len - 2]) break;\n            // 刚开始时buf里不到2个数时，将num加入buf中\n            // 或者buf已经有2个及以上的数了，如果num等于buf的后两个数之和，加入buf中\n            if(len <= 1 || num == (long)buf[len - 1] + (long)buf[len - 2]){\n                buf.push_back(num);\n                if(backTrack(S, buf, i + 1))\n                    return true;\n                // 如果没找到，就将当前的num移除掉\n                buf.pop_back();\n            }\n        }\n        return false;\n    }\n};\n```\n\n#### Reference\n\nhttps://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/","tags":["贪心算法","回溯算法"],"categories":["LeetCode"]},{"title":"进程管理（四）-死锁","url":"//www.xingyuzhao.ltd/blog/2020/12/07/进程管理（四）-死锁/","content":"\n#### 本次学习要点\n\n1. 死锁的概念\n2. 预防死锁\n3. 避免死锁\n4. 死锁的检测和解除\n\n<!-- more-->\n\n#### 死锁的概念\n\n##### 什么是死锁？\n\n在并发的环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法推进的现象，就是**死锁**。发生死锁后若无外力干涉，这些进程都将无法向前推进。\n\n##### 死锁、饥饿、死循环区别\n\n<img src=\"进程管理（四）-死锁\\死锁、饥饿、死循环区别.png\" style=\"zoom:120%;\" />\n\n##### 死锁产生的必要条件\n\n产生死锁必须同时满足以下四个条件：\n\n* 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的。\n* 不剥夺条件：进程所获得的资源在未使用完之前，**不能由其他进程强行夺走**，只能主动释放。\n* 请求和保持条件：进程**已经保持了至少一个资源**，但又提出了新的资源要求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源**保持**不放。\n* 循环等待条件：存在一种进程**资源的循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。\n\n*注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁。*\n\n##### 什么时候会发生死锁？\n\n1. 对系统资源的竞争。\n2. 进程推进顺序非法。\n3. 信号量的使用不当。\n\n总之，对不可剥夺资源的不合理分配，可能导致死锁。\n\n##### 死锁的处理策略\n\n1. 预防死锁：破坏死锁产生的四个必要条件中的一个。\n2. 避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。\n3. 死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。\n\n<img src=\"进程管理（四）-死锁\\死锁的概念.png\" style=\"zoom:120%;\" />\n\n#### 预防死锁\n\n##### 破坏互斥条件\n\n如果把只能互斥使用的资源改造成允许共享使用，则系统不会进入死锁状态。如：`SPOOLing`技术。\n\n缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，**很多时候都无法破坏互斥条件**。\n\n##### 破坏不剥夺条件\n\n方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。\n\n方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。\n\n缺点：\n\n1. 实现复杂。\n2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法只适合已保存和恢复状态的资源，如CPU。\n3. 反复的申请和释放资源会增加系统开销，降低系统吞吐量。\n4. 若采用方案一，只要暂时得不到某个资源，之前获得的资源都要放弃，以后再重新申请。如果持续发生这种情况，会导致进程饥饿。\n\n##### 破坏请求和保持条件\n\n可以采用**静态分配方法**，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行后，资源归其所有，该进程就不会再请求别的资源了。\n\n缺点：有些资源可能使用很短的时间，如果进程执行期间一直保持所有资源，就会造成严重的资源浪费，资源利用率极低。另外也可能导致某些进程饥饿。\n\n##### 破坏循环等待条件\n\n可采用**顺序资源分配法**，给系统中的资源编号，规定每个进程**必须按编号递增的顺序请求资源**，同类资源（即编号相同的资源）一次申请完。\n\n原理：一个进程只有占有小编号的资源时才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。\n\n缺点：\n\n1. 不方便增加新的设备，因为可能需要重新分配所有的编号。\n2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源的浪费。\n3. 必须按规定的次序申请资源，用户编程麻烦。\n\n<img src=\"进程管理（四）-死锁\\预防死锁.png\" style=\"zoom:120%;\" />\n\n#### 避免死锁\n\n不破坏死锁的必要条件，而是在在资源动态分配的过程中，防止系统进入不安全状态。\n\n##### 系统安全状态\n\n指系统能按某种推进顺序（P1,P2,...,Pn）为每个进程Pi分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称P1,P2,...,Pn为安全序列，若系统无法找到一个安全序列，则称系统处于不安全状态。\n\n并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。\n\n##### 银行家算法\n\n数据结构：\n\n* 长度为m的一维数组Avaliable表示还有多少可用资源。\n* n*m矩阵Max表示各进程对资源的最大需求数。\n* n*m矩阵Allocation表示已经给各进程分配了多少资源。\n* Max - Alllcation = Need 矩阵表示各进程最多还需要多少资源。\n* 长度为m的一维数组Request表示进程此次申请的各种资源数。\n\n银行家算法步骤：\n\n1. 检查此次申请是否超过了之前声明的最大需求数。\n2. 检查此时系统剩余的可用资源是否还能满足这次请求。\n3. 试探着分配，更改各数据结构。\n4. 用安全性算法检查此次分配是否会导致系统进入不安全状态。\n\n安全性算法步骤：\n\n检查当前的剩余可用资源能否满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程只有的资源全部回收。\n\n不断重复上述过程，看最终是否能让所有进程都加入安全序列。\n\n*系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。*\n\n**举例（后面更新）：**\n\n#### 死锁的检测和解除\n\n当可能发生死锁时，系统应当提供两个算法：\n\n1. 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。\n2. 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。\n\n##### 死锁的检测\n\n为了能对系统是否已发生了死锁进行检测，必须：\n\n1. 用**某种数据结构**来保存资源的请求和分配信息。\n2. 提供**一种算法**，利用上述信息来检测系统是否已进入死锁状态。\n\n<img src=\"进程管理（四）-死锁\\死锁的检测.png\" style=\"zoom:120%;\" />\n\n<img src=\"进程管理（四）-死锁\\死锁的检测1.png\" style=\"zoom:80%;\" />\n\n检测死锁的算法：\n\n1. 在资源分配图中，找出既不阻塞又不是孤点的进程Pi (即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中己有空闲资源数景。如下图中，R1没有空闲资源，R2有 —个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中P1是满足这一条件的进程结点，于是将P1的所有边消去。\n2. 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。\n\n<img src=\"进程管理（四）-死锁\\死锁的检测2.png\" style=\"zoom:80%;\" />\n\n**死锁定理**：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统死锁。\n\n##### 死锁的解除\n\n—旦检测出死锁的发生，就应该立即解除死锁。\n补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程 。\n解除死锁的主要方法有：\n\n1. 资源剥夺法。挂起（哲时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。\n\n2. 撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能己经运行了很长时间，己经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。\n3. 进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程历史信息，设罝还原点。\n\n如何决定”对谁动手“？\n\n1. 进程优先级：牺牲优先级低的。\n2. 已执行多长时间：牺牲执行时间短的。\n3. 还要多久完成：让快结束的优先获得资源。\n4. 进程已经使用了多少资源：拥有更多资源的先牺牲。\n5. 进程是交互式的还是批处理式的？：先牺牲批处理式的。\n\n<img src=\"进程管理（四）-死锁\\总结.png\" style=\"zoom:120%;\" />","tags":["死锁"],"categories":["操作系统"]},{"title":"进程管理（三）","url":"//www.xingyuzhao.ltd/blog/2020/12/04/进程管理（三）/","content":"\n#### 本次学习要点\n\n1. 进程同步、进程互斥\n2. 进程互斥软件/硬件实现方法\n3. 信号量机制及用其实现进程同步等\n4. 管程\n\n<!-- more-->\n\n#### 进程同步、进程互斥\n\n##### 进程同步\n\n进程异步性：指各并发执行的进程以各自独立的、不可预知的速度向前推进。\n\n进程同步：指为完成某种任务而建立的两个或多个进程，这些进程因为需要再某些位置上协调它们的工作次序而产生制约关系。\n\n##### 进程互斥\n\n临界资源：一个时间段内只允许一个进程使用的资源。如摄像头、打印机等。对临界资源的访问必须**互斥**的进行。\n\n进程互斥：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。\n\n对临界资源的互斥访问，可以在逻辑上分为如下四个部分：\n\n```c\ndo{\n\tentry section; // 进入区\n    critical section; // 临界区\n    exit section; // 退出区\n    remainder section;// 剩余区\n}while(true)\n```\n\n1. 进入区：检查是否可以进入临界区，若可以进入，则设置正在访问临界资源的标志（上锁），防止其他进程同时进入临界区。\n2. 临界区：访问临界资源的代码。\n3. 退出区：解除正在访问临界资源的标志（解锁）。\n4. 剩余区：做其他处理。\n\n*临界区时进程中访问临界资源的代码段。*\n\n*进入区和退出区是负责实现互斥的代码段。*\n\n实现对临界资源的互斥访问需要遵循以下四项原则：\n\n1. 空闲让进。\n2. 忙则等待。\n3. 有限等待，请求访问的进程在有限时间内进入临界区（保证不会饥饿）。\n4. 让权等待，进程不能进入临界区时，应立即释放处理机，防止进程忙等待。\n\n<img src=\"进程管理（三）\\同步与互斥.png\" style=\"zoom:120%;\" />\n\n#### 进程互斥软件/硬件实现方法\n\n##### 软件实现方法\n\n###### 单标志法\n\n实现思想：两个进程在**访问完临界区后**会把临界区的使用权转交给另一个进程，**每个进程进入临界区的权限只能被另一个进程赋予**。\n\n主要问题：违背**空闲让进**原则。\n\n###### 双标志先检查\n\n实现思想：**设置**一个布尔型数组`flag[]`，数组中各个元素用来**标记各进程想要进入临界区的意愿**，比如`flag[0]=true`表示着0号进程P0想要进入临界区。每个进程在进入临界区之前先看有没有别的进程想要进入临界区，没有就将自身的`flag[i]`置为`true`，之后开始访问临界区。\n\n主要问题：违反**忙则等待**原则。原因在于进入区的检查和上锁不是一气呵成的，在**检查后，上锁前**可能发生进程切换。\n\n###### 双标志后检查\n\n实现思想：对比双标志先检查法，先进行上锁再进行检查。\n\n主要问题：虽然解决了**忙则等待**，但是违背了**空闲让进**和**有限等待**原则，会因各进程都长期无法访问临界资源而产生**饥饿**现象。\n\n###### Peterson算法\n\n实现思想：对比双标志后检查法，如果双方都争着想进入临界区，可以让进程主动让对方先使用临界区。\n\n主要问题：违背了**让权等待**原则。\n\n<img src=\"进程管理（三）\\进程互斥的软件实现方法.png\" style=\"zoom:120%;\" />\n\n##### 硬件实现方法\n\n###### 中断屏蔽方法\n\n实现思想：利用”开/关中断指令“实现。\n\n```\n>>>\n关中断；// 关中断后不允许当前进程被中断，也必然不会发生进程切换\n临界区；\n开中断；// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区\n>>>\n```\n\n* 优点：简单、高效。\n* 缺点：不适用于对处理机；只适用于操作系统内核进程，不适用于用户进程。\n\n###### TestAndSet(TS指令/TSL指令)\n\n简称TS指令，也称TestAndSetLock指令，或TSL指令。\n\n主要思想：使用硬件实现，将上锁和检查操作变为原子操作，执行过程中不允许被中断。\n\n* 优点：实现简单，适用于多处理机环境。\n* 缺点：不满足**让权等待**原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。\n\n###### Swap指令(XCHG指令)\n\n也叫Exchange指令，或者XCHG指令。\n\n逻辑上与TS指令相同。\n\n<img src=\"进程管理（三）\\进程互斥的硬件实现方法.png\" style=\"zoom:120%;\" />\n\n#### 信号量机制\n\n信号量机制时一种功能较强的机制，可以用来解决互斥和同步问题，它只能被两个标准的原语`wait(S)`和`signal(S)`访问，简称**P操作**和**V操作**。\n\n信号量其实就是一个变量，可以是一个整数，也可以是更复杂的记录型变量，可以用一个信号量来**表示系统中某种资源的数量**。\n\n##### 整型信号量\n\n用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。\n\n```c\nint S = 1; // 表示当前系统中可用的打印机数\nvoid wait(int S){ // wait原语，相当于进入区\n    while(S <= 0); // 资源不够，等待\n    S = S - 1; // 资源够，占用一个资源\n}\nvoid signal(int S){ // signal原语，相当于退出区 \n    S = S + 1; // 使用完资源后，在退出区释放资源\n}\n```\n\n1. 与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。\n2. **检查**和**上锁**一气呵成，避免并发、异步导致的问题。\n3. 存在问题：不满足**让权等待**原则，会发生**忙等**。\n\n##### 记录型信号量\n\n用记录型数据结构表示的信号量。\n\n```c\n/*记录型信号量的定义*/\ntypedef struct{\n    int value; // 剩余资源数\n    struct process *L;// 等待队列\n} semaphore;\n\n```\n\n```c\n/*某进程需要资源时，通过wait原语申请*/\nvoid wait(semaphore S){\n    S.value--;\n    // 如果剩余资源不够，使用block原语使进程由运行态进入阻塞态\n    // 并将其挂到信号量S的等待队列（即阻塞队列）中\n    // 遵循了让权等待原则，不会出现忙等\n    if(S.value < 0){\n\t\tblock(S.L);\n    }\n}\n```\n\n```c\n/*进程使用完资源后，通过signal原语释放*/\nvoid signal(semaphore S){\n    S.value++;\n    // 释放完资源后，若还有别的进程在等待这种资源\n    // 则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态\n    if(S.value <= 0){\n\t\twakeup(S.L);\n    }\n}\n```\n\n#####  用信号量机制实现进程互斥、同步、前驱关系\n\n###### 进程互斥\n\n1. 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）。\n2. 设置**互斥信号量**mutex，**初始值为1**。\n3. 在临界区之前执行P(mutex)。\n4. 在临界区之后执行V(mutex)。\n\n*注意：对不同的临界资源需要设置不同的互斥信号量，P、V操作必须成对出现*。\n\n###### 进程同步\n\n1. 分析什么地方需要实现”同步关系“，即必须保证”一前一后“执行的两个操作（或两句代码）。\n2. 设置**同步信号量**S，**初始值为0**。\n3. 在\"前操作\"之后执行V(S)。\n4. 在”后操作“之前执行P(S)。\n\n###### 信号量机制实现前驱关系\n\n其实每一对前驱关系都是一个进程同步问题（需要保证一前一后操作）。\n\n1. 要为每一对前驱关系各设置一个同步变量。\n2. 在”前操作“之后对相应的同步变量执行V操作。\n3. 在”后操作“之前对相应的同步变量执行P操作。\n\n<img src=\"进程管理（三）\\信号量实现同步与互斥.png\" style=\"zoom:120%;\" />\n\n常见的使用场景\n\n* 生产者消费者问题\n* 多生产者—多消费者模型\n* 吸烟者问题\n* 读者—写者问题\n* 哲学家进餐问题\n\n#### 管程\n\n引入管程的原因：信号量机制编写程序困难，易出错而导致死锁。\n\n管程是一种特殊的软件模块，由这些部分组成：\n\n1. 局部于管程的共享数据结构说明。\n2. 对该数据结构进行操作的一组过程（或函数）。\n3. 对局部于管程的共享数据设置的一组过程。\n4. 管程的名称。\n\n基本特征：\n\n1. 局部于管程的数据只能被局部于管程的过程所访问。\n2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。\n3. **每次仅允许一个进程在管程内执行某个内部过程，即同一时刻只有一个进程在管程内执行某个函数。**\n\n<img src=\"进程管理（三）\\管程.png\" style=\"zoom:120%;\" />\n\n","categories":["操作系统"]},{"title":"C++顺序容器","url":"//www.xingyuzhao.ltd/blog/2020/11/25/C-顺序容器/","content":"\n#### 本次学习要点\n\n1. 顺序容器概述\n2. 容器库概览\n3. 顺序容器操作\n4. `vector`对象是如何增长的\n5. 额外的`string`操作\n6. 容器适配器\n\n<!-- more-->\n\n#### 顺序容器概述\n\n<img src=\"C-顺序容器\\概述.png\" style=\"zoom:120%;\" />\n\n选择容器的基本原则：\n\n* 尽量使用`vector`。\n* 要求随机访问元素，使用`vector`或者`deque`。\n* 要求在中间插入或删除元素，使用`list`或者`forward_list`。\n* 要求在首尾插入或删除元素且不会在中间插入或者删除，使用`deque`。\n* 如果程序要读取输入，且必须在中间插入，使用`list`，随后拷贝到`vector`。\n\n#### 容器库概览\n\n<img src=\"C-顺序容器\\容器操作.png\" style=\"zoom:120%;\" />\n\n<img src=\"C-顺序容器\\容器操作1.png\" style=\"zoom:120%;\" />\n\n##### 迭代器\n\n`forward_list`迭代器不支持递减运算符。\n\n###### 迭代器范围\n\n**左闭合区间**：`[begin, end)`，表示范围自`begin`开始，于`end`之前结束。\n\n* 如果`begin`与`end`相等，则范围为空。\n* 如果`begin`与`end`不等，则范围至少包含一个元素，且`begin`指向该范围中的第一个元素。\n* 可以对`begin`递增若干次，使得`begin==end`。\n\n##### 容器类型成员\n\n```cpp\nlist<string>::iterator iter;\nvector<int>::difference_type count\n```\n\n##### begin与end成员\n\n```cpp\nlist<string> a = {\"abc\", \"bcd\", \"cde\"};\nauto it1 = a.begin(); // list<string>::iterator\nauto it2 = a.rbegin(); // list<string>::reverse_iterator\nauto it3 = a.cbegin(); // list<string>::const_iterator\nauto it4 = a.crbegin(); // list<string>::const_reverse_iterator\n```\n\n##### 容器定义及初始化\n\n<img src=\"C-顺序容器\\初始化.png\" style=\"zoom:120%;\" />\n\n**array的使用**\n\n```cpp\narray<int, 10> ia1; // 10个默认初始化的int\narray<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9};\narray<int, 10> ia3 = {42}; // ia3[0]为42， 其余为0\narray<int, 10> ia4 = {}; // 初始化为0\n```\n\n##### 赋值和swap\n\n<img src=\"C-顺序容器\\assign.png\" style=\"zoom:120%;\" />\n\n```cpp\n// assign第一种用法\nlist<string> names;\nvector<const char*> oldstyle;\nnames = oldstyle; // 错误，容器类型不匹配\n// 正确，可以将const char*转为string\nnames.assign(oldstyle.cbegin(), oldstyle.cend()); \n// assign的第二种用法\nlist<string> slist1(1); // 1个元素，为空string\nslist1.assign(10, \"Hiya!\"); // 10个元素，每个都是\"Hiya\"\n```\n\n###### 使用swap\n\nswap操作交换两个相同类型容器的内容\n\n```cpp\nvector<string> svec1(10);\nvector<string> svec2(24);\nswap(svec1, svec2);\n// 元素本身并未交换，swap只是交换了两个容器的内部数据结构\n```\n\n**除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间完成**。**对array会真正交换它们的元素**。\n\n##### 容器大小操作\n\n`size`：返回容器中元素数目。\n\n`empty`：容器是否为空。\n\n`max_size`：返回一个大于或等于该类型容器所能容纳的最大元素数的值。\n\n注：`forward_list`不支持`size`。\n\n##### 关系运算符\n\n```cpp\nvector<int> v1 = {1,3,5,7,9,12};\nvector<int> v2 = {1,3,9};\nvector<int> v3 = {1,3,5,7};\nvector<int> v4 = {1,3,5,7,9,12};\n// v1 < v2 true，在v1[2] < v2[2]\n// v1 < v3 false，所有元素相等，但是v3元素更少\n// v1 == v4 true，元素对应相等且长度相同\n// v1 == v2 false，v2元素比v1少\n```\n\n#### 顺序容器操作\n\n<img src=\"C-顺序容器\\添加元素.png\" style=\"zoom:120%;\" />\n\n##### 使用emplace操作\n\n当调用一个`emplace`成员函数时，将参数传递给元素类型的构造函数。`emplace`成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：\n\n```cpp\nc.emplace_back(\"978-0590353403\", 24, 15.99);\nc.push_back(Sales_data(\"978-0590353403\", 24, 15.99));\n// 错误\nc.push_back(\"978-0590353403\", 24, 15.99);\n```\n\n##### 访问元素\n\n<img src=\"C-顺序容器\\访问元素.png\" style=\"zoom:120%;\" />\n\n##### 删除元素\n\n<img src =\"C-顺序容器\\删除元素.png\" style=\"zoom:120%;\" />\n\n##### 改变容器大小\n\n<img src =\"C-顺序容器\\改变容器大小.png\" style=\"zoom:120%;\" />\n\n##### 容器操作可能使迭代器失效\n\n向容器中添加/删除元素可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。\n\n在向容器添加元素后：\n\n* 容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但插入位置之后的迭代器、指针和引用将会失效。\n* 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，指向存在元素的引用和指针不会失效。\n* 对于`list`和`forward_list`，指向容器的迭代器、指针和引用仍有效。\n\n删除元素时，指向被删除元素的迭代器、指针和引用都会失效。\n\n* 对于`list`和`forward_list`，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针都有效。\n* 对于`deque`，在首尾之外的任何位置删除元素，指向被删除元素外其他元素的迭代器、指针或引用也会失效。删除尾，尾后迭代器会失效，但其他迭代器、引用和指针不受影响；删除首，也不受影响。\n* 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍有效。\n\n*注意：当我们删除元素时，尾后迭代器总会失效*。\n\n#### vector对象是如何增长的\n\n`vector`会分配比新的空间需求更大的内存空间，作为备用。\n\n##### 管理容量的成员函数\n\n<img src=\"C-顺序容器\\管理vector.png\" style=\"zoom:120%;\" />\n\n*`reserve`不改变容器中元素的数量，只影响`vector`预先分配多大的内存空间。*\n\n#### 额外的string操作\n\n<img src=\"C-顺序容器\\额外string.png\" style=\"zoom:120%;\" />\n\n这些构造函数接受一个`string`或一个`const char*`参数，还接受（可选的）指定拷贝多少个字符的参数。\n\n从`const char*`创建`string`时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。且：\n\n* 如果同时传一个计数值，就不必以空字符结尾。\n* 如果未传递计数值且数组未以空字符结尾，或者计数值大于数组大小，则构造函数未定义。\n\n从`string`拷贝时，可选开始位置和计数值。位置大于`size`，构造函数抛出一个*out of range*异常。计数值代表从当前位置拷贝这么多个字符，最多拷贝到`string`结尾。\n\n##### sbustr\n\n<img src=\"C-顺序容器\\substr.png\" style=\"zoom:120%;\" />\n\n##### aapend和replace\n\n1. `append`操作是在`string`末尾进行插入操作的一种简写形式。\n\n```cpp\ns.append(\"123abc\"); // 将\"123abc\"追加在s之后\n```\n\n2. `replace`操作是调用`erase`和`insert`的一种简写形式。\n\n```cpp\ns.erase(11, 3);\ns.insert(11, \"5th\");\n// 等价于\ns.replace(11, 3, \"5th\");\n```\n\n还有`assign`：\n\n```cpp\ns.assign(arg); // 将s中字符替换未arg，返回指向s的引用\n```\n\n`assign`总是替换`string`中所有内容。\n\n##### string的搜索操作\n\n<img src=\"C-顺序容器\\string_find.png\" style=\"zoom:120%;\" />\n\n<img src=\"C-顺序容器\\string_find_form.png\" style=\"zoom:120%;\" />\n\n*`string`搜索返回`string::size_type`类型，是无符号的，因此用`int`表示不是很好的选择。*\n\n##### compare函数\n\n<img src=\"C-顺序容器\\compare.png\" style=\"zoom:120%;\" />\n\n##### 数值转换\n\n```cpp\nstring s = \"pi = 3.14\";\n// 转换s中以数字开始的第一个字串，d=3.14\nd = stod(s.substr(s.find_first_of(\"+-.0123456789\")));\n```\n\n*如果`string`不能转换为数值，抛出`invalid_argument`异常。如果转换的数值无法用任何类型表示，则抛出一个`out_of_range`异常*。\n\n#### 容器适配器\n\n**适配器**是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。比如：`stack`、`queue`、`priority_queue`。\n\n<img src=\"C-顺序容器\\容器适配器.png\" style=\"zoom:120%;\" />\n\n每个适配器都定义了两个构造函数：\n\n1. 默认构造函数创建一个空对象，接受一个容器的构造函数拷贝来初始化适配器。\n\n```cpp\n// 假定dep使一个deque<int>\nstack<int> stk(dep); // 从deq拷贝元素到stk\n```\n\n2. 默认情况下，`stack`和`queue`基于`deque`实现，`priority_deque`基于`vector`。创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。\n\n```cpp\n// 基于vector实现空栈\nstack<string, vector<string>> str_stk;\n// str_stk2在vector上实现，初始化时保存svec的拷贝\nstack<string, vector<string>> str_stk2(svec);\n```\n\n##### 栈适配器\n\n`stack`类型定义在`stack`头文件中。\n\n<img src=\"C-顺序容器\\stack.png\" style=\"zoom:120%;\" />\n\n##### 队列适配器\n\n`queue`和`priority_queue`适配器定义在`queue`头文件中。\n\n<img src=\"C-顺序容器\\queue.png\" style=\"zoom:120%;\" />\n\n<img src=\"C-顺序容器\\queue1.png\" style=\"zoom:120%;\" />\n\n","categories":["C++"]},{"title":"LeetCode148-排序链表","url":"//www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-排序链表/","content":"\n#### 题目描述\n\n给你链表的头结点 `head` ，请将其按 升序 排列并返回 排序后的链表 。\n\n**进阶**：\n\n你可以在`O(nlogn)`时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n\n本题可与[LeetCode147-对链表进行插入排序](http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more)，[LeetCode143-重排链表](http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/)共同学习。\n\n<!-- more-->\n\n<img src=\"LeetCode148-排序链表\\示例.png\" style=\"zoom:80%;\" />\n\n#### 思路\n\n题目要求用`O(nlogn)`的时间复杂度来进行排序，所以不能用[LeetCode147-对链表进行插入排序](http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more)的方法来进行解，所以采用归并排序的思想对链表进行排序。\n\n使用归并排序首先得找到链表的中间节点，找到中间节点，根据中间节点的位置将链表分为两个部分，再进行归并排序。**中间节点在链表前半部分的末尾，将链表拆开后，要让中间节点的下一个指向空**，再分别对两个链表进行归并排序，最后再合并两个排序好的链表，如下：\n\n```cpp\nListNode* __mergeSort(ListNode *node){\n    // 如果节点为空或只有一个节点，返回当前节点即可\n    if(!node || !node->next)\n        return node;\n    ListNode *fast = node;\n    ListNode *slow = node;\n    while(fast->next && fast->next->next){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    ListNode *l2 = slow->next;\n    slow->next = nullptr;\n\n    ListNode* left = __mergeSort(node);\n    ListNode* right = __mergeSort(l2);\n    return __merge(left, right);\n}\n```\n\n合并的操作需要创建一个新的链表，新的链表根据两个链表的值建立。如果$l1$的值小于$l2$，那么将插入$l1$新的链表中，同时$l1$移动到它的下一个节点；否则将$l2$插入新的链表中，同时$l2$移动到它的下一个节点。插入操作结束后，再将新链表向后移动一个节点（也就是新插入的节点）。**如果两个链表长度不一样（两个链表长度最多差一个），还要判断插入操作结束后哪个链表不为空，如果不为空，它就是新链表的最后一个节点**。\n\n```cpp\nListNode* __merge(ListNode *l1, ListNode *l2){\n    ListNode *dummyNode = new ListNode(-1);\n    ListNode *cur = dummyNode;\n\n    while(l1 && l2){\n        if(l1->val < l2->val){\n            cur->next = l1;\n            l1 = l1->next;\n        }\n        else{\n            cur->next = l2;\n            // cout << l2->val;\n            l2 = l2->next;\n        }\n        cur = cur->next;\n    }\n    cur->next = l1 != nullptr ? l1 : l2;\n    return dummyNode->next;\n}\n```\n\n#### 代码\n\n```cpp\n// 主函数\nListNode* sortList(ListNode* head) {\n    return __mergeSort(head);\n}\n// 其余两个函数\nListNode* __mergeSort(ListNode *node);\nListNode* __merge(ListNode *l1, ListNode *l2);\n```\n\n\n\n","tags":["链表","归并排序"],"categories":["LeetCode"]},{"title":"LeetCode147-对链表进行插入排序","url":"//www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-对链表进行插入排序/","content":"\n#### 题目描述\n\n插入排序算法：\n\n1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。\n2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。\n3. 重复直到所有输入数据插入完为止。\n\n本题可与[LeetCode143-重排链表](http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/)，[LeetCode148-排序链表](http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/)共同学习。\n\n<!-- more-->\n\n<img src=\"LeetCode147-对链表进行插入排序\\description.png\" style=\"zoom:80%;\" />\n\n\n\n<img src=\"LeetCode147-对链表进行插入排序\\示例.png\" style=\"zoom:100%;\" />\n\n#### 思路\n\n首先，使用一个指针记录下一个要进行排序的节点；对于当前节点，从头开始寻找插入位置，然后将当前节点插入。\n\n那么需要保存插入位置的前一个节点和后一个节点，从头开始，如果当前节点的值大于后一个节点，那么同时将两个节点后移，否则直接进行插入即可。\n\n最后再将当前节点更新为下一个要进行排序的节点。\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        if(!head || !head->next) return head;\n        ListNode *dummyNode = new ListNode(0);\n        ListNode *node = head;\n        while(node){\n            ListNode *next = node->next;\n            // 对排好序的链表进行插入\n            ListNode *pre = dummyNode;\n            ListNode *sorted = dummyNode->next;\n            while(sorted){\n                // 当前点大于后一个点\n                if(node->val > sorted->val){\n                    pre = sorted;\n                    sorted = sorted->next;\n                }\n                else break;\n            }\n            // 此时当前点小于等于最后一个点，可以进行插入\n            // 此时sorted之前的点都已经排好序了\n            pre->next = node;\n            node->next = sorted;\n\n            node = next;\n        }\n        return dummyNode->next;\n    }\n};\n```\n\n","tags":["链表","插入排序"],"categories":["LeetCode"]},{"title":"C++标准库-I/O库","url":"//www.xingyuzhao.ltd/blog/2020/11/21/C-标准库-I-O库/","content":"\n#### 本次学习要点\n\n1. I/O类\n2. 文件输入输出\n3. string流\n\n<!-- more-->\n\n#### I/O类\n\n`iostream`定义了用于读写流的基本类型。\n\n`fstream`定义了用于读写命名文件的类型。\n\n`sstream`定义了用于读写内存`string`对象的类型。\n\n<img src=\"C-标准库-I-O库\\io类.png\" style=\"zoom:120%;\" />\n\n`I/O`对象无拷贝或赋值，传递和引用不能是`const`的。\n\n##### 条件状态\n\n<img src=\"C-标准库-I-O库\\条件状态.png\" style=\"zoom:120%;\" />\n\n上表是`I/O`类所定义的一些函数和标志，可以访问和操作流的**条件状态**。\n\n由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态最简单的方法是将它当作一个条件使用：\n\n```cpp\nwhile(cin >> word)\n\t// ok：读操作成功\n```\n\n##### 刷新输出缓冲区\n\n```cpp\ncout << \"hi!\" << endl;  // 输出hi和换行，然后刷新缓冲区\ncout << \"hi!\" << flush; // 输出hi后直接刷新缓冲区\ncout << \"hi!\" << ends;  // 输出hi和一个空字符再刷新缓冲区\n```\n\n#### 文件输入输出\n\n头文件`fstream`定义了三个类型来支持文件IO：\n\n1. **ifstream**从一个给定文件读取数据。\n2. **ofstream**向一个给定文件写入数据。\n3. **fstream**可以读写给定文件。\n\n<img src=\"C-标准库-I-O库\\fstream.png\" style=\"zoom:120%;\" />\n\n##### 使用文件流对象\n\n创建文件流对象时，可以提供文件名（可选）。\n\n```cpp\nifstream in(ifile); // 构造一个ifstream并打开给定文件\nofstream out; // 输出文件流未关联到任何文件\n```\n\n##### 成员函数open和close\n\nopen用来判断文件是否打开成功，一旦打开成功，它就保持与对应文件的关联，对于一个已经打开的文件流调用open会失败，直到使用close关闭文件，成功关闭后可以打开新的文件。\n\n```cpp\nifstream in(ifile);\nin.close();\nin.open(ifile + \"2\");\n```\n\n当一个`fstream`对象离开其作用域时，与之关联的文件会自动关闭。\n\n##### 文件模式\n\n<img src=\"C-标准库-I-O库\\文件模式.png\" style=\"zoom:120%;\" />\n\n指定文件模式有如下限制（部分）：\n\n* 只可以对`ofstream/fstream`对象设定out模式。\n* 只可以对`ifstream/fstream`对象设定in模式。\n\n在未指定文件模式时，与`ifstream`关联的文件默认以in模式打开；与`ofstream`关联的文件默认以out模式打开；与`fstream`关联的文件默认以in和out模式打开。\n\n默认情况下，**以out模式打开文件会丢去已有数据**。阻止一个`ofstream`清空给定文件内容的方法是同时指定app模式：\n\n```cpp\n// 在这几条语句中，file1都被截断\n// 隐含以输出模式打开文件并截断文件\nofstream out(\"file1\");\n// 隐含地截断文件\nofstream out1(\"file1\", ofstream::out);\nofstream out2(\"flie2\", ofstream::out | ofstream::trunc);\n// 为了保留文本内容，必须显示指定app模式\n// 隐含为输出模式\nofstream app(\"file1\", ofstream::app);\nofstream app1(\"file2\", ofstream::out | ofstream::app);\n```\n\n*保留被`ofstream`打开地文件中已有数据地唯一方法是显示指定app或in模式（17.5.3节，676页）*。每次调用`open`时都会确定文件模式。\n\n#### string流\n\n`istringstream`从`string`中读取数据。\n\n`ostringstream`向`string`中写入数据。\n\n`stringstream`既可从`string`中读数据也可以向`string`中写数据。\n\n<img src=\"C-标准库-I-O库\\stringstream.png\" style=\"zoom:120%;\" />\n\n##### 使用istringstream\n\n当我们的工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词，通常可以用`istringstream`。\n\n假如一个文件，列出了一些人和他们所拥有的电话号码（一个或多个），输入文件可能如下：\n\n<img src=\"C-标准库-I-O库\\输入文件.png\"  />\n\n定义一个类描述输入数据：\n\n```cpp\nstruct PersonInfo{\n\tstring name;\n\tvector<string> phones;\n};\n```\n\n使用程序读取数据文件如下：\n\n```cpp\nstring line, word; // 分别保存来自输入的一行和单词\nvector<PersonInfo> people;\n// 逐行从输入读取数据，直到cin遇到文件尾（或其他错误）\nwhile(getline(cin, line)){\n\tPersonInfo info;\n    // 将记录绑定到刚输入的行\n    istringstream record(line);\n    record >> info.name;\n    while(record >> word)\n        info.phones.push_back(word);\n    people.push_back(info);\n}\n```\n\n##### 使用ostringstream\n\n当我们逐步构造输出，最后一起进行打印时，可以使用ostringstream。对上一节的例子，逐个验证电话号码并将其格式化。将有效的号码输出到一个新文件中；对于无效的号码不输出到文件中，并打印一条包含人名和无效号码的错误信息。\n\n```cpp\nfor(const auto &entry : people){\n    ostringstream formatted, badNums;\n    for(const auto &nums : entry.phones){\n        // 如果号码无效，将数的字符串写入badNums\n        if(!valid(nums)){\n            badnums << \" \" << nums;\n        }\n        // 号码有效，将格式化的字符串写入formatted\n        else{\n            formatted << \" \" format(nums);\n        }  \n    }\n    // 没有错误的数，打印名字和格式化的数\n    if(badNums.str().empty())\n        os << entry.name << \" \" << formatted.str() << endl;\n    // 否则，打印名字和错误的数\n    else\n        cerr << \"input error:\" << entry.name  \n        << \"invalid number(s)\" << badNums.str() << endl;\n}\n```\n\n假设两个函数`valid`和`format`已知，分别完成电话号码的验证和格式化功能。","categories":["C++"]},{"title":"进程管理（二）","url":"//www.xingyuzhao.ltd/blog/2020/11/17/进程管理（二）/","content":"\n#### 本次学习要点\n\n1. 处理机调度概念、层次\n2. 进程调度的时机/切换与过程/方式\n3. 调度算法的评价指标\n4. 非交互性调度算法\n5. 交互性调度算法\n\n<!-- more-->\n\n#### 处理机调度概念、层次\n\n**处理机调度**是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理及分配给它运行，以实现进程并发的执行。\n\n**调度的三个层次**\n\n1. 高级调度（作业调度）\n   * 按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使他（们）获得竞争处理机的权利。\n   * **作业调入一次（建立PCB），调出一次（撤销PCB）。**\n   * 高级调度主要是指调入的问题，只有调入的时机需要操作系统来确定，调出必然是作业结束时刻。\n   * 执行频率低。\n\n2. 中级调度（内存调度）\n\n   * 引入虚拟存储技术后，可将在暂时不能运行的进程调至外存等待，此时状态称为**挂起态。**\n   * PCB不会调到外存，而是常驻内存，被挂起的进程PCB会被放到挂起队列中。\n   * 中级调度就是决定将哪个处于挂起态的进程重新调入内存。\n   * 一个进程可能会被多次调出、调入内存，中级调度频率高于高级调度。\n\n   * 进程的挂起态与七状态模型。\n\n   <img src=\"进程管理（二）\\7states.png\"  />\n\n3. 低级调度（进程调度）\n\n   * 按照某种方法从就绪队列中选取一个进程，将处理机分配给他。\n   * 是**最基本的一种调度。**\n   * 频率很高，一般几十毫秒一次。\n\n **三层调度的联系、对比**\n\n<img src=\"进程管理（二）\\三层调度的联系及对比.png\"  />\n\n*调度算法要研究的问题*：**高级调度、进程调度**\n\n#### 进程调度的时机/切换与过程/方式\n\n##### 进程调度的时机\n\n<img src=\"进程管理（二）\\进程调度的时机.png\"  />\n\n需要注意：\n\n1. 进程在**操作系统内核程序临界区**中*不能*进行调度与切换\n   * 内核程序临界区时用来访问某种内核数据结构的（如进程的就绪队列，由各就绪进程的PCB组成）。\n   * 内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。\n2. 进程处于**临界区**时*可以*进行处理机调度\n   * 如打印机在打印完成之前，进程一直处于临界区内并将临界资源上锁，但打印机是慢速设备，如果此时不允许进程调度会导致CPU一直空闲。\n   * 普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，因此普通临界区可以进行调度和切换。\n\n##### 进程调度的切换与过程\n\n*狭义的进程调度*指的是从就绪队列中选中一个要运行的进程，可以是刚刚被暂停的进程，也可能是另外一个进程，后者需要进程切换。\n\n*广义的进程调度*指包含了选择一个进程和进程切换两个步骤。\n\n*进程切换*是指一个进程让出处理机，由另一个进程占用处理机的过程。进程切换的过程主要完成了：\n\n1. 对原来运行进程各种数据的保存。\n2. 对新的进程各种数据的恢复。\n\n**注意**：进程切换时由代价的，过于频繁的进行进程调度、切换，会使整个系统的效率降低。\n\n##### 进程调度的方式\n\n1. 非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。\n2. 剥夺调度方式，又称抢占方式。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合与分时操作系统、实时操作系统。\n\n#### 调度算法的评价指标\n\n<img src=\"进程管理（二）\\调度算法的评价指标.png\"  />\n\n##### CPU利用率\n\n$$\n利用率=\\frac{忙碌的时间}{总时间}\n$$\n\n##### 系统吞吐量\n\n单位时间内完成作业的数量。\n$$\n系统吞吐量=\\frac{总共完成了多少道作业}{总共花了多少时间}、\n$$\n\n#####  周转时间\n\n从**作业被提交给系统开始**，到**作业完成为止**的这段时间间隔，它包括4个部分：\n\n1. 作业在外存后备队列上等待作业调度（高级调度）的时间。\n2. 进程在就绪队列上等待进程调度（低级调度）的时间。\n3. 进程在CPU上执行的时间。\n4. 进程等待I/O操作完成的时间。\n\n后三项可能发生多次。\n$$\n周转时间=作业完成时间-作业提交时间\n$$\n\n$$\n平均周转时间=\\frac{各作业周转时间之和}{作业数}\n$$\n\n$$\n带权周转时间=\\frac{作业周转时间}{作业实际运行的时间}=\\frac{作业完成时间-作业提交时间}{作业实际运行的时间}\n$$\n\n$$\n平均带权周转时间=\\frac{各作业带权周转时间之和}{作业数}\n$$\n\n后两个比较重要，带权周转时间和周转时间都是越短越好。\n\n##### 等待时间\n\n进程/作业处于等待处理机状态时间之和。\n\n对于**进程**来说，等待时间就是指建立进程后等待被服务的时间之和，在等待I/O完成的期间其实进程也是被服务的，不计入等待时间内。\n\n对于**作业**来说，不仅考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。\n\n##### 响应时间\n\n从用户**提交请求**到**首次产生响应**所用的时间。\n\n#### 非交互性调度算法\n\n##### 先来先服务（FCFS, First Come First Serve）\n\n<img src=\"进程管理（二）\\先来先服务.png\"  />\n\n##### 最短作业优先（SJF, Shortest Job First）\n\n最短作业/进程优先得到服务；既可用于作业调度，也可用于进程调度，用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”；SJF和SPF是**非抢占式的算法**，也有**抢占式的版本**—**最短剩余时间优先**算法（SRTN, Shortest Remaining Time Next）。\n\n短作业/进程优先调度算法：每次调度时选择**当前已到达**且**运行时间最短**的作业/进程，对比FCFS，SPF的平均等待/周转/带权周转的时间都要低。\n\n最短剩余时间优先算法：每当有进程加入，就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间**更短**，则由新进程**抢占**处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。对比非抢占式的算法，其平均等待/周转/带权周转的时间都要低。\n\n<img src=\"进程管理（二）\\SJF.png\"  />\n\n##### 最高响应比优先（HRRN, Highest Response Ratio Next）\n\n非抢占式的调度算法，只有当前运行的进程**主动放弃CPU时**，才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。\n$$\n响应比=\\frac{等待时间+要求服务时间}{要求服务时间}\n$$\n<img src=\"进程管理（二）\\HRRN.png\"  />\n\n #### 交互性调度算法\n\n ##### 时间片轮转（RR, Round-Robin）\n\n轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列头的进程），常用于分时操作系统。\n\n如果**时间片过大**，使得每个进程可以在一个时间片内完成，则时间片轮转调度算法退化为**先来先服务**算法，且会增加进程响应时间。\n\n如果**时间片过小**，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比列减少。\n\n一般来说，设计时间片时要让切换进程的开销占比不超过1%。\n\n<img src=\"进程管理（二）\\RR.png\"  />\n\n##### 优先级调度算法\n\n*非抢占式的优先级调度算法*：每次调度时选择当前已到达且优先级最高的进程。当前进程**主动**放弃处理机时发生调度。\n\n*抢占式的优先级调度算法*：每次调度时选择当前已到达且优先级最高的进程。当前进程**主动**放弃处理机时发生调度。另外，当**就绪队列发生改变时**也需要检查是否会发生抢占。\n\n1. *静态优先级*：创建进程时确定，之后一直不变。\n2. *动态优先级*：创建进程时有一个初始值，之后会根据情况动态的调整优先级。\n\n如何合理设置优先级，通常情况下：\n\n* 系统进程优先级**高于**用户进程\n* 前台进程优先级**高于**后台进程\n* 操作系统**更偏好I/O型进程（I/O繁忙型进程）**\n  * I/O设备和CPU可以并行工作，最好让其尽早投入工作\n\n采取动态优先级，何时调整：\n\n* 某进程在就绪队列中等待很长时间，可适当提高其优先级\n* 某进程占用处理机运行了很长时间，可适当降低其优先级\n* 某进程频繁进行I/O操作，可适当提升其优先级\n\n<img src=\"进程管理（二）\\优先级调度算法.png\"  />\n\n##### 多级反馈队列调度算法\n\n<img src=\"进程管理（二）\\多级反馈队列调度算法.png\"  />\n\n**总结**：\n\n<img src=\"进程管理（二）\\总结.png\"  />\n\n","categories":["操作系统"]},{"title":"进程管理（一）","url":"//www.xingyuzhao.ltd/blog/2020/11/11/进程管理（一）/","content":"\n#### 本次学习要点\n\n1. 进程的定义、组成、组织方式、特征\n2. 线程\n\n<!-- more-->\n\n#### 进程\n\n##### 一、进程的概念 \n\n多道程序环境下引入*进程*的概念，为了更好地描述和控制程序的并发执行，实现操作系统的并发行和共享性。\n\n1. 进程控制块(Process Control Block, PCB)：描述进程的基本情况和运行状态，进而控制和管理进程，**PCB是进程存在的唯一标志**。\n\n2. **进程映像（进程实体）**由程序段、相关数据段和PCB构成，进程映像是静态的，进程是动态的。\n\n3. **进程**是**进程实体**的运行过程，是系统进行资源分配和调度的一个独立单位。\n\n4. **进程的典型定义**：\n   1. 进程是程序的一次执行过程\n   2. 进程是一个程序及其数据在处理及上顺序执行时所发生的活动\n   3. 进程时具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n\n##### 二、进程的组成\n\n<img src=\"进程管理\\进程的组成.png\"  />\n\n##### 三、进程的特征\n\n1. 动态性：进程是程序的一次执行过程，是动态地产生、变化和消失的，**最基本特征**\n2. 并发性：内存中有多个进程实体，各进程可并发执行\n3. 独立性：进程是能独立运行、独立获得资源、独立接受调度的**基本单位**\n4. 异步性：各进程按照独立的、**不可预知**的速度向前推进，操作系统要提供**进程同步机制**来解决异步问题\n5. 结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成\n\n##### 四、进程的状态与转换\n\n<img src=\"进程管理\\进程的状态.png\"  />\n\n创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB\n\n终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB\n\n###### 进程的三种基本状态\n\n1. 运行态：占有CPU，并在CPU上运行（单核处理器下，每个时刻最多一个进程处于运行态）\n2. 就绪态：已经具备运行条件，但由于没有空闲CPU，暂时不能运行（万事俱备，只欠CPU）\n3. 阻塞态：又称等待态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机），或等待输入/输出完成。即使处理机空闲，该进程也不能运行\n\n###### 进程状态的转换\n\n<img src=\"进程管理\\进程的状态转换.png\"  />\n\n就绪态->运行态：进程被调度\n\n运行态->就绪态：时间片到，或CPU被其他高优先级的进程抢占\n\n运行态->阻塞态：等待系统分配资源，或等到某事件发生（*主动行为*）\n\n阻塞态->就绪态：资源分配到位，等待的事件发生（*被动行为*）\n\n##### 五、进程控制\n\n进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为**原语**，**原语**的特点是在**执行期间不允许中断**，它是一个不可分割的基本单位，**原语采用关中断指令和开中断指令实现**。\n\n###### 进程的创建\n\n<img src=\"进程管理\\进程的创建.png\"  />\n\n###### 进程的终止\n\n<img src=\"进程管理\\进程的终止.png\"  />\n\n###### 进程的阻塞和唤醒\n\n进程的阻塞和唤醒要成对出现\n\n<img src=\"进程管理\\进程的阻塞和唤醒.png\"  />\n\n###### 进程切换\n\n<img src=\"进程管理\\进程的切换.png\"  />\n\n##### 六、进程通信\n\n<img src=\"进程管理\\进程通信.png\"  />\n\n ###### 共享存储\n\n两个进程对共享空间的访问必须是互斥的，通过操作系统提供的工具实现。操作系统只负责提供共享空间和同步互斥工具（如P、V操作）。\n\n方法：\n\n1. 基于数据结构的共享，低级通信方式\n\n2. 基于存储区的共享，高级通信方式\n\n###### 消息传递\n\n进程间数据交换以**格式化的消息**为单位，包括消息头和消息体。进程通过操作系统提供的“发送信息/接受信息”两个原语进行数据交换。\n\n方法：\n\n1. 直接通信方式，发送进程将消息直接发送给接收进程，挂在接收进程的消息缓冲队列上\n2. 间接通信方式，消息要先发送到中间实体（信箱）中，也称“信箱通信方式”\n\n###### 管道通信\n\n1. 管道通信采用半双工，若要实现双向同时通信，需要设置两个管道\n2. 各进程要互斥地访问管道\n3. 管道满时，写进程write()系统调用被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程read()被阻塞\n4. 如果**没写满就不允许读**，如果**没读空就不允许写**\n5. 数据一旦被读出，就从管道中被抛弃，意味着读进程最多只能有一个\n\n#### 线程\n\n有的进程可能需要“同时”做很多事，而传统的进程只能串行的执行一系列程序。为此，引入了“线程”来增加并发度，**引入线程后，线程成为了程序执行流的最小单位**。\n\n引入线程后，进程只作为除CPU之外的系统资源的分配单位，线程则作为处理机的分配单元。\n\n<img src=\"进程管理\\线程.png\"  />\n\n##### 一、线程的实现方式\n\n1. 用户级线程\n\n<img src=\"进程管理\\用户级线程.png\" style=\"zoom:80%;\" />\n\n2. 内核级线程\n\n<img src=\"进程管理\\内核级线程.png\" style=\"zoom:80%;\" />\n\n3. 二者组合方式，将n个用户级线程映射到m个内核级线程上（n>=m）\n\n<img src=\"进程管理\\组合线程实现.png\" style=\"zoom:80%;\" />\n\n操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。\n\n##### 二、多线程模型\n\n有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。\n\n1. 多对一模型：多个用户级线程映射到一个内核级线程\n\n<img src=\"进程管理\\多线程1.png\" style=\"zoom:80%;\" />\n\n优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。\n\n缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。\n\n2. 一对一模型：一个用户级线程映射到一个内核级线程\n\n<img src=\"进程管理\\多线程2.png\" style=\"zoom:80%;\" />\n\n优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行。\n\n缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，线程管理成本高，开销大。\n\n3. 多对多模型：n个用户级线程映射到m个内核级线程（n>=m）\n\n<img src=\"进程管理\\多线程3.png\" style=\"zoom:80%;\" />\n\n克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。","categories":["操作系统"]},{"title":"图论（二）","url":"//www.xingyuzhao.ltd/blog/2020/11/03/图论2/","content":"\n#### 本次学习要点\n\n1. 读取一个图\n2. 深度优先搜索DFS\n3. 广度优先搜索BFS\n\n<!-- more-->\n\n#### 从文件中读取一个图\n\n如果要从已有的文件中读取并构建一张图，需要使用到C++的IO库，使用头文件`fstream`和`sstream`，类型如下:\n\n**fstream:**\n\n* `ifstream, wifstream`从文件中读取数据\n* `ofstream, wofstram`向文件中写入数据\n* `fstream, wfstream`读写文件\n\n**sstream:**\n\n* `istringstream, wistringfstream`从`string`中读取数据\n* `ostringstream, wosringstream`向`string`中写入数据\n* `stringstream, wstringstream`读写`string`\n\n##### 读文件—类的实现\n\n```cpp\ntemplate <typename Graph>\nclass ReadGraph {\npublic:\n    ReadGraph(Graph &graph, const string &filename){\n        ifstream file(filename);\n        string line;\n        int V, E;\n\n        assert(file.is_open());\n        assert(getline(file, line));\n        // 首先读入顶点数和边数\n        stringstream ss(line);\n        ss >> V >> E;\n        assert(V == graph.V());\n        // 读入每一条边\n        for(int i = 0; i < E; ++i){\n            assert(getline(file, line));\n            stringstream ss(line);\n            int a, b;\n            ss >> a >> b;\n            assert(a >= 0 && a < V);\n            assert(b >= 0 && b < V);\n            graph.addEdge(a, b);\n        }\n    }\n};\n```\n\n###### 测试主函数\n\n```cpp\nint main(){\n    string filename = \"testG2.txt\";\n    // G2是有6个顶点的无向图\n    SparseGraph g1(6, false);\n    ReadGraph<SparseGraph> readGraph1(g1, filename);\n    // 在两种头文件中新加show函数打印结果\n    g1.show();\n\n    cout << endl;\n\n    DenseGraph g2(6, false);\n    ReadGraph<DenseGraph> readGraph2(g2, filename);\n    g2.show();\n\n    return 0;\n}\n// 输出\nvertex 0:       1 2 5\nvertex 1:       0 2 3 4\nvertex 2:       0 1\nvertex 3:       1 4 5\nvertex 4:       1 3\nvertex 5:       0 3\n\nvertex 0:       0 1 1 0 0 1\nvertex 1:       1 0 1 1 1 0\nvertex 2:       1 1 0 0 0 0\nvertex 3:       0 1 0 0 1 1\nvertex 4:       0 1 0 1 0 0\nvertex 5:       1 0 0 1 0 0\n```\n\n#### 深度优先搜索（DFS）\n\n与二叉树的深度优先搜索遍历不同，二叉树总会遇到空，但是图可能成环，或者无向图，所以遍历时应记录每个节点是否被遍历了。\n\n##### 连通分量\n\n无向图Graph的极大连通子图称为G的**连通分量**( Connected Component)。任何**连通图**的连通分量只有一个，即是其自身，**非连通的无向图**有多个连通分量。如图所示，无向图共有4个连通分量：\n\n<img src=\"图论2\\dfs1.png\"  />\n\n对于一个非连通的无向图来说，可以用DFS得到Graph共有几个连通分量。\n\n```cpp\ntemplate <typename Graph>\nclass Components {\nprivate:\n    Graph &G;\n    bool *visited; // 当前节点是否被遍历过\n    int ccount;\t// 记录连通分量总数\n    int *id;\n\n\tvoid dfs(int v){\n    \tvisited[v] = true;\n    \t// 相当于并查集，让同一个联通分量中的节点指向同一个数\n    \tid[v] = ccount;\n    \t// 编译器无法判断是Graph的一个类型还是一个成员变量，需加关键字typename\n    \ttypename Graph::adjIterator adj(G, v);\n    \tfor(int i = adj.begin(); !adj.end(); i = adj.next()){\n        \tif(!visited[i])\n            \tdfs(i);\n    \t}\n\t}\npublic:\n    Components(Graph &graph): G(graph){\n        visited = new bool[G.V()];\n        id = new int[G.v()];\n        ccount = 0;\n        // 初始化\n        for(int i = 0; i < G.V(); ++i){\n            visited[i] = false;\n            id[i] = -1;\n        }\n        for(int i = 0; i < G.V(); ++i){\n            if(!visited[i]){\n                dfs(i);\n                ccount++;\n            }\n        }\n    }\n    ~Components(){\n        delete[] visited;\n        delete[] id;\n    }\n    int count(){\n        return ccount;\n    }\n    // 查询两个节点是否相连\n    bool isConnected(int v, int w){\n        assert(v >= 0 && v < G.V());\n        assert(w >= 0 && w < G.V());\n        return id[v] == id[w];\n    }\n};\n```\n\n###### 测试主函数\n\n对于图`testG1.txt`和`testG2.txt`，先从文件中读取到稀疏图中，再对此图进行DFS得到连通分量的个数，两个文件内容分别为：\n\n* testG1:\n\n<img src=\"图论2\\testG1.png\"  />\n\n* testG2:\n\n<img src=\"图论2\\testG2.png\"  />\n\n```cpp\nint main(){\n    string filename1 = \"testG1.txt\";\n\n    SparseGraph g1(13, false);\n    ReadGraph<SparseGraph> readGraph1(g1, filename1);\n    Components<SparseGraph> component1(g1);\n    cout << \"TestG1.txt, Component Count: \"<< component1.count() << endl;\n\n    string filename2 = \"testG2.txt\";\n    SparseGraph g2(6, false);\n    ReadGraph<SparseGraph> readGraph2(g2, filename2);\n    Components<SparseGraph> component2(g2);\n    cout << \"TestG2.txt, Component Count: \" << component2.count() << endl;\n\n    return 0;\n}\n// 输出\nTestG1.txt, Component Count: 3\nTestG2.txt, Component Count: 1\n```\n\n##### 获得两点之间的一条路径\n\n使用DFS可以找连通图两点之间的一条路径，但不一定是最短路径。对于稀疏图，复杂度为O(V+E)，对于稠密图，复杂度为O(V^2)。对于下图，寻找节点0到节点6的一条路径。\n\n<img src=\"图论2\\dfs2.png\"  />\n\n在遍历每个节点时，可以存储当前节点是由哪个节点遍历到的，以此可以反推出原始节点到当前节点的一条路径。\n\n```cpp\ntemplate <typename Graph>\nclass Path {\nprivate:\n    Graph &G;\n    int s; // 源节点\n    bool *visited;\n    int *from; // 当前节点是由哪个节点遍历到的\n    void dfs(int v){\n        visited[v] = true;\n        typename Graph::adjIterator adj(G, v);\n        for(int i = adj.begin(); !adj.end(); i = adj.next()){\n            if(!visited[i]){\n                // 节点i是由节点v遍历到的\n                from[i] = v;\n                dfs(i);\n            }\n        }\n    }\npublic:\n    Path(Graph &graph, int s): G(graph){\n        // 算法初始化\n        assert(s >= 0 && s < G.V());\n\n        visited = new bool[G.V()];\n        from = new int[G.V()];\n        for(int i = 0; i < G.V(); ++i){\n            visited[i] = false;\n            from[i] = -1;\n        }\n        this->s = s;\n        // 寻路\n        dfs(s);\n    }\n    ~Path(){\n        delete [] visited;\n        delete [] from;\n    }\n    bool hasPath(int w){\n        assert( w >= 0 && w < G.V() );\n        return visited[w];\n    }\n    void path(int w, vector<int> &vec){\n        stack<int> s;\n        int p = w;\n        // 找到从源节点到目标节点所经过的每一个节点入栈\n        while(p != -1){\n            s.push(p);\n            // 将p更新为可以到达p的一个节点\n            p = from[p];\n        }\n        vec.clear();\n        while(!s.empty()){\n            // 出栈是正向路径\n            vec.push_back(s.top());\n            s.pop();\n        }\n    }\n    void showPath(int w){\n        vector<int> vec;\n        path(w, vec);\n        for(int i = 0; i < vec.size(); ++i) {\n            cout << vec[i];\n            if (i == vec.size() - 1)\n                cout << endl;\n            else\n                cout << \" -> \";\n        }\n    }\n};\n```\n\n###### 测试主函数\n\n```cpp\nint main() {\n    string filename = \"testG2.txt\";\n    SparseGraph g = SparseGraph(7, false);\n    ReadGraph<SparseGraph> readGraph(g, filename);\n    g.show();\n    cout << endl;\n\n    Path<SparseGraph> dfs(g, 0);\n    cout << \"DFS : \";\n    dfs.showPath(6);\n\n    return 0;\n}\n// 输出\nvertex 0:       1       2       5       6\nvertex 1:       0\nvertex 2:       0\nvertex 3:       4       5\nvertex 4:       3       5       6\nvertex 5:       0       3       4\nvertex 6:       0       4\n\nDFS : 0 -> 5 -> 3 -> 4 -> 6\n```\n\n#### 广度优先搜索（BFS）\n\n使用深度优先搜索可以找到无权图两个节点之间的最短路径，复杂度与DFS相同。\n\n##### 最短路径—类的实现\n\n```cpp\ntemplate <typename Graph>\nclass ShortestPath {\nprivate:\n    Graph &G;\n    int s;\n    bool *visited;\n    int *from;\n    int *ord; // 当前点到源节点的最短距离\npublic:\n    ShortestPath(Graph &graph, int s): G(graph){\n        // 算法初始化\n        assert(s >= 0 && s < G.V());\n\n        visited = new bool[graph.V()];\n        from = new int[graph.V()];\n        ord = new int[graph.V()];\n        for( int i = 0 ; i < graph.V() ; i ++ ){\n            visited[i] = false;\n            from[i] = -1;\n            ord[i] = -1;\n        }\n        this->s = s;\n\n        queue<int> q;\n        // 无向图最短路径算法\n        q.push(s);\n        visited[s] = true;\n        ord[s] = 0;\n        while(!q.empty()){\n            int v = q.front();\n            q.pop();\n            typename Graph::adjIterator adj(G, v);\n            for(int i = adj.begin(); !adj.end(); i = adj.next()){\n                if(!visited[i]){\n                    q.push(i);\n                    visited[i] = true;\n                    from[i] = v;\n                    ord[i] = ord[v] + 1;\n                }\n            }\n        }\n    }\n    ~ShortestPath(){\n        delete [] visited;\n        delete [] from;\n        delete [] ord;\n    }\n    bool hasPath(int w){\n        assert( w >= 0 && w < G.V() );\n        return visited[w];\n    }\n\n    void path(int w, vector<int> &vec){\n        assert( w >= 0 && w < G.V() );\n        stack<int> s;\n        int p = w;\n        while( p != -1 ){\n            s.push(p);\n            p = from[p];\n        }\n        vec.clear();\n        while( !s.empty() ){\n            vec.push_back( s.top() );\n            s.pop();\n        }\n    }\n    void showPath(int w){\n        assert( w >= 0 && w < G.V() );\n        vector<int> vec;\n        path(w, vec);\n        for( int i = 0 ; i < vec.size() ; i ++ ){\n            cout<<vec[i];\n            if( i == vec.size()-1 )\n                cout<<endl;\n            else\n                cout<<\" -> \";\n        }\n    }\n    int length(int w){\n        assert( w >= 0 && w < G.V() );\n        return ord[w];\n    }\n};\n```\n\n###### 测试主函数\n\n```cpp\nint main() {\n    string filename = \"testG2.txt\";\n    SparseGraph g = SparseGraph(7, false);\n    ReadGraph<SparseGraph> readGraph(g, filename);\n    g.show();\n    cout<<endl;\n\n    Path<SparseGraph> dfs(g,0);\n    cout<<\"DFS : \";\n    dfs.showPath(4);\n\n    ShortestPath<SparseGraph> bfs(g,0);\n    cout<<\"BFS : \";\n    bfs.showPath(4);\n    cout<< \"Shortest length : \" << bfs.length(4);\n    return 0;\n}\n// 输出\nvertex 0:       1 2 5 6\nvertex 1:       0\nvertex 2:       0\nvertex 3:       4 5\nvertex 4:       3 5 6\nvertex 5:       0 3 4\nvertex 6:       0 4\n\nDFS : 0 -> 5 -> 3 -> 4\nBFS : 0 -> 5 -> 4\nShortest Length : 2\n```\n\n#### 完整工程：\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git\n\n","categories":["算法与数据结构"]},{"title":"图论（一）","url":"//www.xingyuzhao.ltd/blog/2020/10/27/图论1/","content":"\n#### 本次学习要点\n\n1. 图的基本概念\n2. 图的两种表示方法及实现\n3. 对图进行遍历\n\n<!-- more-->\n\n#### 图的基本概念\n\n##### 基本组成\n\n* 节点（Vertex）\n* 边（Edge）\n\n使用场景：交通运输，社交网络，互联网，工作安排，脑区活动，程序状态执行（自动机）等。\n\n##### 图的分类\n\n* 无向图（Undirected Graph）\n* 有向图（Directed Graph）\n\n无向图是一种特殊的有向图，比如A指向B，同时B指向A\n\n* 无权图（Unweighted Graph）\n* 有权图（Weighted Graph）\n\n其他概念：图的连通性，简单图（无自环边与平行边）\n\n<img src=\"图论1/7-1-1.png\" style=\"zoom:80%;\" />\n\n#### 图的两种表示方法及实现（邻接矩阵与邻接表）\n\n##### 邻接矩阵（适合表示稠密图Dense Graph）\n\n<img src=\"图论1\\7-2-1.png\" style=\"zoom:80%;\" />\n\n**实现：**\n\n```cpp\nclass DenseGraph{\nprivate:\n    int n, m;      // 节点数和边数\n    bool directed; // 是否是有向图\n    vector<vector<bool>> g;\npublic:\n    DenseGraph(int n, bool directed){\n        this->n = n;\n        this->m = 0;\n        this->directed = directed;\n        for(int i = 0; i < n; i++){\n            g.push_back(vector<bool>(n, false));\n        }\n    }\n    ~DenseGraph(){};\n    int V(){ return n;} // 图的节点总数\n    int E(){ return m;} // 图的边总数\n    // 增加节点v与节点w之间的一条边\n    void addEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n        if(hasEdge(v, w)) return; // 处理了平行边，并且防止边数m多加一次\n        g[v][w] = true;\n        if(!directed) // 如果是无向图\n            g[w][v] = true;\n        m++;\n    }\n    bool hasEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n        return g[v][w];\n    }\n};\n```\n\n##### 邻接表（适合表示稀疏图Sparse Graph）\n\n<img src=\"图论1\\7-2-2.png\" style=\"zoom:80%;\" />\n\n**实现：**\n\n```cpp\nclass SparseGraph{\nprivate:\n    int n, m;\n    bool directed;\n    vector<vector<int>> g;\npublic:\n    SparseGraph(int n, bool directed){\n        this->n = n;\n        this->m = 0;\n        this->directed = directed;\n        for(int i = 0; i < n; ++i){\n            g.push_back(vector<int>());\n        }\n    }\n    ~SparseGraph(){}\n    int V(){ return n;} // 图的节点总数\n    int E(){ return m;} // 图的边总数\n    void addEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n\n        g[v].push_back(w);\n        if(v != w && !directed) // 处理了自环边，并且防止边数m多加一次\n            g[w].push_back(v);\n        m++;\n    }\n    bool hasEdge(int v, int w){\n        assert(v >= 0 && v < n);\n        assert(w >= 0 && w < n);\n\n        for(int i = 0; i < g[v].size(); ++i){\n            if(g[v][i] == w) // 节点v与w相连\n                return true;\n            return false;\n        }\n    }\n};\n```\n\n#### 对图进行遍历——迭代器的实现\n\n```mermaid\ngraph LR\n\t0-->3;\n\t0-->5;\n\t0-->8;\n```\n\n在邻接矩阵中如下：\n\n| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 0    | 0    | 0    | 1    | 0    | 1    | 0    | 0    | 1    |\n\n在邻接表中如下：\n\n| 0    | 1    | 2    | 3    |\n| ---- | ---- | ---- | ---- |\n| 0    | 3    | 5    | 8    |\n\n如果要遍历某个节点的所有邻边，可以借鉴迭代器的思想。\n\n##### 稠密图（邻接矩阵中）\n\n在`DenseGraph`类中实现：\n\n```cpp\n// 迭代器实现\n// 顶点的邻边按顺序输出\nclass adjIterator {\nprivate:\n    DenseGraph &G;\n    int index; // 遍历到的节点坐标\n    int v;\npublic:\n    adjIterator(DenseGraph &graph, int v) : G(graph) {\n        this->v = v;\n        this->index = -1;\n    }\n    int begin() {\n        index = -1;\n        return next();\n    }\n    int next() {\n        index += 1;\n        for (index; index < G.V(); index++) {\n            if (G.g[v][index]) // 如果v与index相连\n                return index;\n        }\n        return -1; // 没有邻边\n    }\n    bool end() {\n        return index >= G.V();\n    }\n};\n```\n\n##### 稀疏图（邻接表中）\n\n在`SparseGraph`类中实现：\n\n```cpp\nclass adjIterator{\nprivate:\n    SparseGraph &G;\n    int index;\n    int v;\npublic:\n    adjIterator(SparseGraph &graph, int v):G(graph){\n        this->v = v;\n        // 与稠密图不同的是，这里的index表示遍历到v的第index个节点，不表示节点index\n        this->index = index; \n    }\n    int begin(){\n        index = 0;\n        if(G.g[v].size())\n            return G.g[v].size();\n        return -1;\n    }\n    int next(){\n        index += 1;\n        if(index < G.g[v].size())\n            return G.g[v][index];\n        return -1; // 返回-1说明已经遍历结束，此时index = G.g[v].size()\n    }\n    bool end(){\n        return index >= G.g[v].size();\n    }\n};\n```\n\n**测试用主函数：**\n\n```cpp\nint main() {\n    int N = 10;\n    int M = 30;\n\n    srand(time(NULL));\n\n    // Sparse Graph\n    // 存在平行边\n    SparseGraph g1(N, false);\n    for(int i = 0; i < M; ++i){\n        int a = rand() % N;\n        int b = rand() % N;\n        g1.addEdge(a, b);\n    }\n    // O(E)\n    for(int v = 0; v < N; ++v){\n        cout << v << \" : \";\n        SparseGraph::adjIterator adj(g1, v);\n        for(int w = adj.begin(); !adj.end(); w = adj.next()){\n            cout << w << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n    // Dense Graph\n    // 存在自环边\n    DenseGraph g2(N, false);\n    for(int i = 0; i < M; ++i){\n        int a = rand() % N;\n        int b = rand() % N;\n        g2.addEdge(a, b);\n    }\n    // O(V^2)\n    for(int v = 0; v < N; ++v){\n        cout << v << \" : \";\n        DenseGraph::adjIterator adj(g2, v);\n        for(int w = adj.begin(); !adj.end(); w = adj.next()){\n            cout << w << \" \";\n        }\n        cout << endl;\n    }\n}\n```\n\n**测试结果**\n\n```\n// Sparse Graph\n// 可以看出存在平行边\n0 : 3 6 6 7 6\n1 : 9 2\n2 : 7 9 5 1 9\n3 : 5 0 5 6 4 9 5\n4 : 6 3 8 6 8\n5 : 9 7 3 2 3 3 9\n6 : 9 4 0 3 9 0 4 0\n7 : 5 2 8 9 0\n8 : 7 8 9 4 4\n9 : 5 2 6 1 7 3 6 8 5 2\n\n// Sparse Graph\n// 可以看出存在自环边\n0 : 0 2 4\n1 : 4 5 7 9\n2 : 0 4 8\n3 : 3 4 5 6\n4 : 0 1 2 3 6 7 9\n5 : 1 3 6\n6 : 3 4 5 7 8 9\n7 : 1 4 6 7\n8 : 2 6 8\n9 : 1 4 6\n```\n\n#### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git\n","categories":["算法与数据结构"]},{"title":"LeetCode143-重排链表","url":"//www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-重排链表/","content":"\n本题同时解决**LeetCode206-反转链表**和**LeetCode876-链表的中间结点**\n\n#### 题目描述\n\n给定一个单链表 $L$：$L0→L1→…→Ln-1→Ln$ ，\n将其重新排列后变为： $L0→Ln→L1→Ln-1→L2→Ln-2→…$\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n本题可与[LeetCode147-对链表进行插入排序](http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more)，[LeetCode148-排序链表](http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/)共同学习。\n\n<!-- more-->\n\n<img src=\"LeetCode143-重排链表\\示例.png\"  />\n\n#### 思路\n\n观察链表，对于长度为偶数的链表，如示例1，可以将2之后的子链表进行反转得到$4->3$，然后再与剩下的链表$1->2$交叉合并，得到$1->4->2->3$；\n\n长度为奇数的链表同理，找到中间结点3，将3之后的子链表反转得到$5->4$，再与剩下的链表$1->2->3$进行合并，得到$1->5->2->4->3$。\n\n#### 链表的中间结点\n\n```cpp\n// 对于偶数长度链表，找到的是中间靠后的一个\nListNode* midNode(ListNode *root){\n    if(!root || !root->next) \n        return root;\n    ListNode *fast = root;\n    ListNode *slow = root;\n    while(fast && fast->next){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    return slow;\n}\n// 对于偶数长度链表，找到的是中间靠前的一个\nListNode* midNode(ListNode *root){\n    if(!root || !root->next) \n        return root;\n    ListNode *fast = root;\n    ListNode *slow = root;\n    while(fast->next && fast->next->next){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    return slow;\n}\n```\n\n#### 反转链表\n\n```cpp\nListNode* reverseList(ListNode *root){\n    ListNode *pre = nullptr;\n    ListNode *cur = root;\n    while(cur){\n        ListNode *tmp = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = tmp;\n    }\n    return pre;\n}\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if(!head) return;\n        ListNode *mid = midNode(head);\n        ListNode *l2 = mid->next;\n        mid->next = nullptr; \n        l2 = reverseList(l2);\n        mergeList(head, l2);\n    }\n    ListNode* midNode(ListNode *root){\n        ListNode *fast = root;\n        ListNode *slow = root;\n        while(fast && fast->next){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n    ListNode* reverseList(ListNode *root){\n        ListNode *pre = nullptr;\n        ListNode *cur = root;\n        while(cur){\n            ListNode *tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp;\n        }\n        return pre;\n    }\n    void mergeList(ListNode *l1, ListNode* l2){\n        ListNode *tmp1;\n        ListNode *tmp2;\n        while(l1 && l2){\n            tmp1 = l1->next;\n            l1->next = l2;\n            tmp2 = l2->next;\n            l2->next = tmp1;\n            l1 = tmp1;\n            l2 = tmp2;\n        }\n    }\n};\n```\n\n","tags":["链表"],"categories":["LeetCode"]},{"title":"二叉树的三种遍历方法（迭代）","url":"//www.xingyuzhao.ltd/blog/2020/10/19/二叉树的三种遍历方法（迭代）/","content":"\n**概要**\n\n1. 二叉树的前序遍历\n2. 二叉树的中序遍历\n3. 二叉树的后序遍历\n\n<!-- more-->\n\n递归进行二叉树的遍历比较简单，学习使用迭代法进行二叉树的遍历，主要是使用栈这种数据结构。\n\n#### 二叉树的前序遍历\n\n前序遍历的顺序为：中—左—右\n\n```cpp\nvector<int> preorderTraversal(TreeNode* root) {\n    vector<int> preOrder;\n    stack<TreeNode*> st;\n    st.push(root);\n    while(!st.empty()){\n        TreeNode *node = st.top();\n        st.pop();\n        if(node){\n            preOrder.push_back(node->val);\n            // 这里需要注意，前序遍历第二次遍历的是左节点\n            // 所以先将右节点入栈，再将左节点入栈，保证左节点先出栈\n            st.push(node->right);\n            st.push(node->left);\n        }\n    }\n    return preOrder;\n}\n```\n\n#### 二叉树的中序遍历\n\n中序遍历的顺序为：左—中—右\n\n```cpp\nvector<int> inorderTraversal(TreeNode* root) {\n    vector<int> res;\n    stack<TreeNode*> st;\n    TreeNode *node = root;\n    // 先判断根节点不为空，进入迭代，后面再根据栈是否为空进行迭代\n    while(!st.empty() || node){\n        // 当前节点存在，查看其左节点情况，如果其左节点不存在，那就弹出当前节点\n        // 再查看其右节点情况，如果右节点也不存在，就弹出当前栈顶（也就是上一个左节点）\n        if(node){\n            st.push(node);\n            node = node->left;\n        }\n        else{\n            node = st.top();\n            st.pop();\n            res.push_back(node->val);\n            node = node->right;\n        }\n    }\n    return res;\n}\n```\n\n#### 二叉树的后序遍历\n\n后序遍历的顺序为：左—右—中\n\n##### 根据二叉树结构遍历\n\n```cpp\nvector<int> postorderTraversal(TreeNode* root) {\n    stack<TreeNode *> st;\n    vector<int> res;\n    TreeNode *cur = root;\n    TreeNode *pre;\n    while(cur || !st.empty()){\n        // 首先当前节点的左子树入栈\n        while(cur != nullptr){\n            st.push(cur);\n            cur = cur->left;\n        }\n        // 取出最后一个左节点\n        cur = st.top();\n        // 如果当前节点的右节点为空或者已经遍历过了，那么就记录当前节点\n        if(!cur->right || cur->right == pre){\n            res.push_back(cur->val);\n            pre = cur;\n            // 如果记录了当前节点，那么当前节点必须置为空，否则会陷入第一个while中死循环\n            cur = nullptr;\n            st.pop();\n        }\n        // 否则查看当前节点的右节点\n        else{\n            cur = cur->right;\n        }\n    }\n    return res;\n}\n```\n\n动画演示：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/di-gui-die-dai-qu-qiao-san-chong-fang-fa-quan-jie-/\n\n##### 破坏结构遍历\n\n```cpp\nvector<int> postorderTraversal(TreeNode* root) {\n    if(!root) return {};\n    stack<TreeNode*> st;\n    vector<int> res;\n    st.push(root);\n    while(!st.empty()){\n        TreeNode *node = st.top();\n        st.pop();\n        if(node){\n            res.push_back(node->val);\n            st.push(node->left);\n            st.push(node->right);\n        }\n    }\n    // 得到的结果是中—右—左，需要反转一下得到左—右—中\n    reverse(res.begin(), res.end());\n    return res;\n}\n```\n\n","tags":["二叉树"],"categories":["算法与数据结构"]},{"title":"C++类的一些知识点","url":"//www.xingyuzhao.ltd/blog/2020/10/18/C-类的一些知识点/","content":"\n《C++ Primer》第七章内容——类\n\n**部分总结**\n\n<!-- more-->\n\n#### 第七章：类\n\n1. ##### 友元\n\n* 类可以允许其他类或者函数访问它的非共有成员，方法是令其他类或者函数（可以是成员函数也可以是非成员函数）成为它的友元。一般来说，在类的开始或者结束前位置集中声明友元。如果希望类的用户能够调用某个友元函数，那么就需要在类中友元声明之外再进行一次声明。\n\n  ```cpp\n  class Sales_data{\n  friend Sales_data add(const Sale_data&, const Sale_data&);\n  public:\n      /.../\n  private:\n      /.../\n  };\n  // 非成员函数声明\n  Sales_data add(const Sale_data&, const Sale_data&);\n  ```\n\n* 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元的关系不具有传递性。\n\n  ```cpp\n  class Screen{\n      // Window_mgr的成员可以访问Screen类的私有部分\n      friend class Window_mgr;\n      /.../\n  }\n  // 也可以只为某个成员函数提供访问权限\n  class Screen{\n      // Window_mgr::clear必须再Screen类之前声明\n      friend void Window_mgr::clear(ScreenIndex);\n      /.../\n  }\n  ```\n\n2. **构造函数**\n\n* 使用构造函数初始值列表来初始化成员。\n\n* 如果成员是引用或者const时，必须通过函数初始值列标将其初始化：\n\n  ```cpp\n  class ConstRef{\n  public:\n  \tConstRef(int ii);\n  private:\n  \tint i;\n  \tconst int ci;\n  \tint &ri;\n  }\n  ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(ii);\n  ```\n\n3. **类的静态成员**\n\n* 适用于类的成员直接与类相关，而不是与类的各个对象关联，比如说：银行的利率\n\n* 静态成员可以是public或者private，使用关键字static，成员函数不用通过作用域运算符就能直接使用静态成员。静态成员不是由类的构造函数初始化的，一般在类的外部定义和初始化每个静态成员，只能定义一次：\n\n  ```cpp\n  class Account{\n  public:\n      void calculate() { amount += amount * interestRate; };\n      static double rate() { return interestRate; };\n      static void rate(double);\n  private:\n      string owner;\n      double amount;\n      static double interestRate;\n      static double initRate(){\n  \t\treturn 1.0;\n      };  \n  };\n  void Account::rate(double newRate){\n      interestRate = newRate;\n  }\n  // 定义并初始化一个静态成员\n  double Account::interestRate = initRate();\n  // test\n  int main() {\n      Account c1;\n      double r;\n      r = c1.rate();\n      // 输出1\n      cout << r << \" \";\n      \n      Account::rate(0.8);\n      r = c1.rate();\n      // 输出0.8\n      cout << r << \" \";\n      return 0;\n  }\n  ```\n","tags":["类(class)"],"categories":["C++"]},{"title":"LCP19-秋叶收藏集","url":"//www.xingyuzhao.ltd/blog/2020/10/11/LCP19-秋叶收藏集/","content":"\n### 题目描述\n\n小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。\n出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。\n\n<!-- more-->\n\n<img src=\"LCP19-秋叶收藏集\\image-20201011112801516.png\" style=\"zoom:80%;\" />\n\n### 思路\n\n用三个状态来标记其中的每一个部分，0和2表示前面和后面的红色，1表示中间的黄色，于是三部分结构为「0、1、2」。\n\n定义`dp[i][j]`表示：对**[0..i]**片叶子进行调整，并且第**i**片叶子处于**j**状态的最小操作数，所以有下面三种情况：\n\n1. 当**j = 0**时，第**i**片叶子应为红色，并且第**i - 1**片叶子也应该处于**j = 0**的状态：\n\n$$\ndp[i][0] = dp[i-1][0] + isYellow(i)\n$$\n\n$$\nisYellow(i)=\n\\begin{cases}\n1& \\text{leaves[i] = 'y'}\\\\\\\\\n0& \\text{leaves[i] = 'r'}\n\\end{cases}\n$$\n\n如果是黄色，那么需要进行一次操作修改颜色：\n\n2. 当**j = 1**时，第**i**片叶子应为黄色，第**i - 1**片叶子可以处于**j = 0**或**j = 1**的状态，所以取其中的较小值：\n\n$$\ndp[i][1] = min(dp[i-1][1], dp[i-1][0]) + isRed(i)\n$$\n\n$$\nisRed(i)=\n\\begin{cases}\n1& \\text{leaves[i] = 'r'}\\\\\\\\\n0& \\text{leaves[i] = 'y'}\n\\end{cases}\n$$\n\n​\t\t如果是红色，那么需要进行一次操作修改颜色：\n\n3. 当**j = 2**时，第**i**片叶子应为红色，第**i - 1**片叶子可以处于**j = 2**或**j = 1**的状态（不能取**j = 0**的状态，因为每种状态至少含有一片叶子，中间必须存在有黄色叶子），再取其中的较小值：\n\n$$\ndp[i][2] = min(dp[i-1][2], dp[i-1][1]) + isYellow(i)\n$$\n\n如果是黄色，那么需要进行一次操作修改颜色，公式同1\n\n最终答案为`dp[n-1][2]`。\n\n***初始化条件：***\n\n1. 要保证每种状态都有叶子，则叶子数量应大于等于状态数量，对于`dp[i][j]`，有**i >= j**；如果**i < j**，那么可以令`dp[i][j] = INT_MAX`；\n2. 对于**i = 0**，**j**也必须为0，于是有`dp[0][0] = isYellow(0)`。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minimumOperations(string leaves) {\n        vector<vector<int>> dp(leaves.size(), vector<int>(3));\n        dp[0][0] = leaves[0] == 'y';\n        // 不合要求的,实际上也不会遇到dp[0][2]这种情况\n        dp[0][1] = dp[0][2] = dp[1][2] = INT_MAX;\n        for(int i = 1; i < leaves.size(); ++i){\n            int isYellow = leaves[i] == 'y';\n            int isRed = leaves[i] == 'r';\n            dp[i][0] = dp[i - 1][0] + isYellow;\n            dp[i][1] = min(dp[i - 1][1], dp[i - 1][0]) + isRed;\n            if(i >= 2) dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + isYellow;\n        }\n        return dp[leaves.size() - 1][2];\n    }\n}\n```\n\n也可以优化空间，使用3个变量来代替状态转移数组：\n\n```cpp\nclass Solution {\npublic:\n    int minimumOperations(string leaves) {\n        int n = leaves.size();\n        // dp[0][0]\n        int start = leaves[0] == 'y';\n        // dp[0][1]\n        int mid = INT_MAX;\n        // dp[1][2]\n        int last = INT_MAX;\n        // 初始化转移变量\n        int start2, mid2, last2 = INT_MAX, red = 0, yellow = 0;\n        for(int i = 1; i < n; ++i){\n            red = leaves[i] == 'r';\n            yellow = leaves[i] == 'y';\n            start2 = start + yellow;\n            mid2 = min(start, mid) + red;\n            if(i >= 2) last2 = min(mid, last) + yellow;\n\n            start = start2;\n            mid = mid2;\n            last = last2;\n        }\n        return last;\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/UlBDOe/solution/qiu-xie-shou-cang-ji-by-leetcode-solution/","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode701-二叉搜索树中的插入操作","url":"//www.xingyuzhao.ltd/blog/2020/10/09/LeetCode701-二叉搜索树中的插入操作/","content":"\n### 题目描述\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。\n\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。\n\n<!-- more-->\n\n<img src=\"LeetCode701-二叉搜索树中的插入操作\\示例.png\" style=\"zoom:80%;\" />\n\n* 给定的树上的节点数介于 0 和 10^4 之间\n* 每个节点都有一个唯一整数值，取值范围从 0 到 10^8\n* -10^8 <= val <= 10^8\n* 新值和原始二叉搜索树中的任意节点值都不同\n\n### 思路\n\n二叉搜索树满足父节点值大于其左孩子的值小于其右孩子的值，即当前节点大于以它为根节点的左子树的所有值，并且小于其右子树的所有值。根据这个性质，只需要判断`val`与当前节点的值的大小关系来寻找插入位置。\n\n### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if(!root) return new TreeNode(val);\n        if(val < root->val)\n            root->left = insertIntoBST(root->left, val);\n        if(val > root->val)\n            root->right = insertIntoBST(root->right, val);\n        return root;\n    }\n};\n```\n\n","tags":["二叉搜索树"],"categories":["LeetCode"]},{"title":"LeetCode106-从中序与后序遍历序列构造二叉树","url":"//www.xingyuzhao.ltd/blog/2020/09/27/LeetCode106-从中序与后序遍历序列构造二叉树/","content":"\n### 题目描述\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n**注意:**\n你可以假设树中没有重复的元素。\n\n<!--more -->\n\n<img src=\"LeetCode106-从中序与后序遍历序列构造二叉树\\示例.png\"  />\n\n\n\n### 思路\n\n对于二叉树的题，大部分都是通过递归来解决的，此题也不例外，需要注意的是，要充分利用二叉树中序遍历和后序遍历的性质。\n\n* 中序遍历二叉树(左子树—根节点—右子树)，根节点的左边是左子树，右边是右子树；\n* 后序遍历二叉树(左子树—右子树—根节点)，根节点是最后输出的。\n\n在后序遍历数组中找到根节点之后，再从中序遍历数组中搜索根节点的左边，由此坐标将数组分开，分别就是当前根节点下的左子树和右子树：\n\n<img src=\"LeetCode106-从中序与后序遍历序列构造二叉树\\pic1.png\"  />\n\n上图中`inorder`数组中，3是在`postorder`找到的根节点，由此节点分开，`inorder`数组中绿色部分是左子树，黄色部分是右子树，在`posorder`数组中也是一样的。\n\n* 定义`inorder`数组中3的位置为**rootIn**，数组起始位置为**iStart**，结束位置为**iEnd**；\n* 定义`postorder`数组数组起始位置为**pStart**，结束位置为**pEnd**；\n\n根据以上定义，`inorder`数组中左子树起止位置为`iStart->rootIn-1`，右子树起止位置为`rootIn+1->iEnd`；`postorder`数组中左子树起止位置为`pStart->pStart+rootIn-iStart-1`，右子树起止位置为`pStart+rootIn-iStart->pEnd-1`，图来自leetcode题解(https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/)：\n\n<img src=\"LeetCode106-从中序与后序遍历序列构造二叉树\\pic2.png\"  />\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    unordered_map<int, int> map;\n    vector<int> post;\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int cnt = 0;\n        // 使用一个map记录中序遍历数值的位置\n        for(auto &num : inorder){\n            map[num] = cnt++;\n        }\n        post = postorder;\n        TreeNode *node = dfs(0, inorder.size() - 1, 0, postorder.size() - 1);\n        return node;\n    }\n    TreeNode* dfs(int iStart, int iEnd, int pStart, int pEnd){\n        if(iStart > iEnd || pStart > pEnd) return nullptr;\n        int root = post[pEnd];\n        int rootIn = map[root];\n        TreeNode *node = new TreeNode(root);\n        node->left = dfs(iStart, rootIn - 1, pStart, pStart + rootIn - iStart - 1);\n        node->right = dfs(rootIn + 1, iEnd, pStart + rootIn - iStart, pEnd - 1);\n        return node;\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/","tags":["二叉树","递归"],"categories":["LeetCode"]},{"title":"LeetCode200-岛屿数量","url":"//www.xingyuzhao.ltd/blog/2020/09/20/LeetCode200-岛屿数量/","content":"\n### 题目描述\n\n给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n**使用并查集解决此问题**\n\n<!-- more-->\n\n<img src=\"LeetCode200-岛屿数量\\示例.png\" style=\"zoom:80%;\" />\n\n### 思路\n\n在`grid`中遇到`'1'`时，搜索其四周（上下左右），如果发现值也为`'1'`，那么将他们合并，同时将当前位置值置为`'0'`，直到遍历到最后一个元素。\n\n并查集进行初始化时，遇到`'1'`则增加计数值`count`，在后续的合并操作中，如果两者根节点不同，要进行合并时，计数值`count`要减1，说明两个节点进行了连接。\n\n### 代码\n\n```cpp\nclass unionFind{\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\npublic:\n    unionFind(vector<vector<char>> &grid){\n        count = 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(grid[i][j] == '1'){\n                    parent.push_back(n * i + j);\n                    count++;\n                }\n                else parent.push_back(-1);\n                rank.push_back(0);\n            }\n        }\n    }\n    int find(int p){\n        return p == parent[p] ? p : parent[p] = find(parent[p]);\n    }\n    void unionElem(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 对于根不同的情况，将其相连，计数减1\n        if(rank[pRoot] < rank[qRoot]){\n            parent[pRoot] = qRoot;\n        }\n        else if(rank[pRoot] > rank[qRoot]){\n            parent[qRoot] = pRoot;\n        }\n        else{\n            // 随便指一个\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n        count--;\n    }\n    int getCount() const{\n        return count;\n    }\n};\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.empty()) return 0;\n        unionFind uf(grid);\n        int m = grid.size();\n        int n = grid[0].size();\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(grid[i][j] == '1'){\n                    grid[i][j] = '0';\n                    if(i - 1 >= 0 && grid[i - 1][j] == '1') uf.unionElem(n * i + j, n * (i - 1) + j);\n                    if(i + 1 < m && grid[i + 1][j] == '1') uf.unionElem(n * i + j, n * (i + 1) + j);\n                    if(j - 1 >= 0 && grid[i][j - 1] == '1') uf.unionElem(n * i + j, n * i + j - 1);\n                    if(j + 1 < n && grid[i][j + 1] == '1') uf.unionElem(n * i + j, n * i + j + 1);\n                }\n            }\n        }\n        return uf.getCount();\n    }\n};\n```\n\n","tags":["并查集"],"categories":["LeetCode"]},{"title":"并查集(Union Find)","url":"//www.xingyuzhao.ltd/blog/2020/09/06/并查集-Union-Find/","content":"\n### 本次学习要点\n\n1. 并查集的基本概念及实现(Quick_Find/Quick_Union)\n2. 基于size优化与基于rank优化\n3. 路径压缩\n\n<!-- more-->\n\n### 并查集的基本概念及实现\n\n#### 基本概念\n\n并查集是一种特殊的图，较图论而言要简单一些。对于图论来说，主要解决的问题是**连接问题和路径问题**，而并查集只是回答前者——连接问题。比如网络节点间的连接状态，数学中集合类的实现等。\n\n并查集支持两个动作（合并两个节点，查询某个节点）：\n\n* union(p, q)\n* find(p)\n\n用来回答一个问题（两个节点是否相连接）：\n\n* isConnected(p, q)\n\n并查集可以用数组来表示，基本数据表示如下（0~4，5~9互相连接）：\n\n|      |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  id  |  0   |  0   |  0   |  0   |  0   |  1   |  1   |  1   |  1   |  1   |\n\n#### 基本实现(Quick_Find)\n\n```cpp\nclass UnionFind1 {\nprivate:\n    int *id;\n    int count;\npublic:\n    UnionFind1(int n){\n        count = n;\n        id = new int[n];\n        for(int i = 0; i < n; i++)\n            id[i] = i;\n    }\n    ~UnionFind1(){\n        delete [] id;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        return id[p];\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pID = find(p);\n        int qID = find(q);\n        if(pID == qID) return;\n        // 让p指向q，复杂度O(n)\n        for(int i = 0; i < count; i++){\n            if(id[i] == pID)\n                id[i] = qID;\n        }\n    }\n};\n```\n\n#### 基本实现(Quick_Union)\n\n将每一个元素，看作是一个节点：\n\n<img src=\"并查集-Union-Find\\quickUnion.png\" style=\"zoom:67%;\" />\n\n对于上图，将7和3连接，只需要把7的根节点指向3的根节点（反过来也行）。\n\n|   i    |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| parent |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n\n`parent[i]`表示`i`指向的父亲元素是谁。\n\n```cpp\nclass UnionFind2 {\nprivate:\n    int *parent;\n    int count;\npublic:\n    UnionFind2(int count){\n        this->count = count;\n        parent = new int[count];\n        for(int i = 0; i < count; i++)\n            parent[i] = i;\n    }\n    ~UnionFind2(){\n        delete [] parent;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        // 寻找根节点，复杂度O(n)\n        while(p != parent[p])\n            p = parent[p];\n        return p;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 让p指向q，复杂度O(1)\n        parent[pRoot] = qRoot;\n    }\n};\n```\n\n### 并查集的优化\n\n#### 基于size的优化\n\n之前实现的并查集中`Union(p, q)`操作都是让p的根节点指向q，如下图：\n\n<img src=\"并查集-Union-Find\\size1.png\" style=\"zoom: 80%;\" />\n\n如果实现`union(9, 4)`，那么9的根节点9将指向4的根节点8；相应的如果实现`union(4, 9)`则会出现将4的根节点8指向了9，如此一来，查找4的根节点需要的时间就更多了，我们完全可以在`union`操作之前进行判断，将元素少的集合的根节点指向元素多的集合的根节点，用一个数组`sz[i]`来表示以i为根集合中元素的个数。\n\n```cpp\nclass UnionFind3 {\nprivate:\n    int *parent;\n    int *sz;\n    int count;\npublic:\n    UnionFind3(int count){\n        this->count = count;\n        parent = new int[count];\n        sz = new int[count];\n        for(int i = 0; i < count; i++) {\n            parent[i] = i;\n            sz[i] = 1;\n        }\n    }\n    ~UnionFind3(){\n        delete [] parent;\n        delete [] sz;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        // 寻找根节点，复杂度O(n)\n        while(p != parent[p])\n            p = parent[p];\n        return p;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 基于size优化\n        if(sz[pRoot] < sz[qRoot]){\n            parent[pRoot] = qRoot;\n            sz[qRoot] += sz[pRoot];\n        }\n        else{\n            parent[qRoot] = pRoot;\n            sz[pRoot] += sz[qRoot];\n        }\n    }\n};\n```\n\n#### 基于rank的优化\n\n基于size的优化会出现下面一个问题：\n\n<img src=\"并查集-Union-Find\\rank1\" style=\"zoom:80%;\" />\n\n根节点为7的size是大于根节点为8的size的，所以基于size的优化会使8指向7，如下图：\n\n<img src=\"并查集-Union-Find\\rank2\" style=\"zoom:80%;\" />\n\n这样一来，这棵树的层数变成了4，一种更合理的方式是根据当前根节点的树的高度来进行优化，如下图，这样树的层数为3：\n\n<img src=\"并查集-Union-Find\\rank3\" style=\"zoom:80%;\" />\n\n我们可以用一个数组`rang[i]`表示根节点为i的树的高度。\n\n```cpp\nclass UnionFind4 {\nprivate:\n    int *parent;\n    int *rank;\n    int count;\npublic:\n    UnionFind4(int count){\n        this->count = count;\n        parent = new int[count];\n        rank = new int[count];\n        for(int i = 0; i < count; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n    }\n    ~UnionFind4(){\n        delete [] parent;\n        delete [] rank;\n    }\n    int find(int p){\n        assert(p >= 0 && p < count);\n        // 寻找根节点，复杂度O(n)\n        while(p != parent[p])\n            p = parent[p];\n        return p;\n    }\n    bool isConnected(int p, int q){\n        return find(p) == find(q);\n    }\n    void uoionElement(int p, int q){\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if(pRoot == qRoot) return;\n        // 基于size优化\n        if(rank[pRoot] < rank[qRoot]){\n            // 不用维护层数\n            parent[pRoot] = qRoot;\n        }\n        else if (rank[pRoot] > rank[qRoot]){\n            // 不用维护层数\n            parent[qRoot] = pRoot;\n        }\n        else{ \n            // rank[pRoot] == rank[qRoot]\n            // 层数加1\n            parent[pRoot] = qRoot;\n            rank[qRoot]++;\n        }\n    }\n};\n```\n\n### 路径压缩(Path Compression)\n\n之前我们的`find(p)`操作中，递归查找的复杂度为`O(1)`，如下图，要查找4的根节点需要4次递归：\n\n<img src=\"并查集-Union-Find\\pathcompression1\" style=\"zoom:80%;\" />\n\n|        |  0   |  1   |  2   |  3   |  4   |\n| :----: | :--: | :--: | :--: | :--: | :--: |\n| parent |  0   |  0   |  1   |  2   |  3   |\n\n如果将4指向3的父节点2（指向其父节点的父节点），会得到下图：\n\n<img src=\"并查集-Union-Find\\pathcompression2\"  />\n\n由于根节点指向自己，所以不会出现无效的情况，继续将p更新为`parent[p]`，得到下图：\n\n<img src=\"并查集-Union-Find\\pathcompression3\"  />\n\n这样一来，所有节点的路径都进行了压缩，查找的时间复杂度近乎是`O(1)`的。\n\n```cpp\n// 循环\nint find(int p){\n    assert(p >= 0 && p < count);\n    // 路径压缩\n    while(p != parent[p]){\n        parent[p] = parent[parent[p]];\n        p = parent[p];\n    }\n    return p;\n}\n// 递归\nint find(int p){\n    assert(p >= 0 && p < count);\n    if(p != parent[p])\n        parent[p] = find(parent[p]);\n    return parent[p];\n}\n```\n\n### 测试\n\n对每种并查集的工程执行100w次`union`操作和100w次`find`操作：\n\n<img src=\"并查集-Union-Find\\test\" style=\"zoom:80%;\" />\n\n区别还是很明显的。\n\n### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git","categories":["算法与数据结构"]},{"title":"快速排序(Quick sort)","url":"//www.xingyuzhao.ltd/blog/2020/08/15/快速排序-quick-sort/","content":"\n### 本次学习要点\n\n1. 快速排序基本实现及优化\n2. 双路快速排序\n3. 三路快速排序\n\n<!-- more-->\n\n### 快速排序\n\n#### 基本实现\n\n快速排序的基本思想很简单，对于`l`处的数`val`，与`j`处的数进行交换，使得坐标小于`j`的所有数都小于`val`，而位于`j`之后的数都应该大于`val`，如下图所示：\n\n<img src=\"快速排序-quick-sort\\1-1\" style=\"zoom:80%;\" />\n\n而实现这一操作的过程称为`partition`，具体过程如下：\n\n<img src=\"快速排序-quick-sort\\1-2\"  />\n\n1. 对于上图，`arr[l+1...j] < v`，`arr[j+1...i-1] > v`，当前位置`i`的值为`e`；\n\n* 如果`e > v`，将`e`放在`> v`后面，同时`i++`；\n\n* 如果`e < v`，将`i`处的值`e`与`j`下一个位置的值进行交换，然后`j++,i++`；\n\n  <img src=\"快速排序-quick-sort\\1-3\"  />\n\n  <img src=\"快速排序-quick-sort\\1-4\"  />\n\n2. 继续步骤1，会得到以下结果：\n\n<img src=\"快速排序-quick-sort\\1-5\"  />\n\n3. 此时满足`arr[l+1...j] < v`，`arr[j+1...i-1] > v`，再将`l`和`j`位置进行交换：\n\n<img src=\"快速排序-quick-sort\\1-6\"  />\n\n4. 重复步骤1-3，直到递归结束。\n\n代码如下：\n\n```cpp\n//\n// Created by Zxy on 2020/8/16.\n//\n#include <iostream>\n#include <cassert>\n#include <ctime>\n#include \"sortHelper.h\"\nusing namespace std;\n\n// 对arr[l...r]部分进行partition操作\n// 返回p，使arr[l...p-1] < arr[p]; arr[p+1...r] > arr[p]\ntemplate <typename T>\nint partition(T arr[], int l, int r){\n    T v = arr[l];\n    // arr[l+1...j] < v; arr[j+1...i) > v\n    // 初始状态时两个区间都为空\n    int j = l;\n    for(int i = l + 1; i <= r; ++i){\n        // 实际上当前值大于等于v时，将e都直接放在<v后面\n        if(arr[i] < v){\n            swap(arr[j + 1], arr[i]);\n            j++;\n        }\n    }\n    swap(arr[l], arr[j]);\n    return j;\n}\n\n// 对arr[l...r]部分进行快速排序\ntemplate <typename T>\nvoid __quickSort(T arr[], int l, int r){\n    if(l >= r) return;\n    int p = partition(arr, l, r);\n    __quickSort(arr, l, p - 1);\n    __quickSort(arr, p + 1, r);\n}\n\ntemplate <typename T>\nvoid quickSort(T arr[], int n){\n    __quickSort(arr, 0, n - 1);\n}\n\nint main(){\n    int *arr = generateRandomArray(10, 1, 50); // 产生10个1到50间的随机数\n    cout << \"排序前数组为：\" << endl;\n    printArray(arr, 10); // 打印数组\n    cout << endl;\n    quickSort(arr, 10);\n    cout << \"排序后数组为：\" << endl;\n    printArray(arr, 10);\n    cout << endl;\n    return 0;\n}\n```\n\n输出结果为：\n\n<img src=\"快速排序-quick-sort\\1-7\"  />\n\n#### 优化\n\n对于上述的快速排序算法有一个很大的缺点，如果数组近乎有序，复杂度可能退化至O(n^2)，大于`v`或者小于`v`的部分分配不均匀。比如对于数组`[3,1,1,2,2,2]`，经过第一次`partition`时，3放在了数组的末尾，左边5个数全部小于3，而右边没有大于3的数。\n\n对于这种情况，我们可以不取数组`l`处的值作为`v`，而是在数组中随机取一个值作为分界点`v`，然后再进行`partition`操作，此时快速排序复杂度的数学期望为O(nlogn)，具体的推导百度一下。修改如下：\n\n```cpp\ntemplate <typename T>\nint partition(T arr[], int l, int r){\n\t// 修改\n    swap(arr[rand() % (r - l + 1) + l], arr[l]);\n    T v = arr[l];\n    // arr[l+1...j] < v; arr[j+1...i) > v\n    // 初始状态时两个区间都为空\n    int j = l;\n    for(int i = l + 1; i <= r; ++i){\n        if(arr[i] < v){\n            swap(arr[j + 1], arr[i]);\n            j++;\n        }\n    }\n    swap(arr[l], arr[j]);\n    return j;\n}\n\ntemplate <typename T>\nvoid quickSort(T arr[], int n){\n\t// 修改\n    srand(time(NULL));\n    __quickSort(arr, 0, n - 1);\n}\n```\n\n直观的对比一下两种思路对完全随机数组和近乎有序数组的排序速度（其中`swap time`表示对于产生一个有序数组，随机取两个数进行交换，一共交换的次数）：\n\n<img src=\"快速排序-quick-sort\\1-8\"  />\n\n### 双路快速排序\n\n虽然解决了近乎有序数组的排序问题，但是对于数组中存在大量重复键值时，复杂度也可能退化为O(n^2)，如下图所示：\n\n<img src=\"快速排序-quick-sort\\2-1\"  />\n\n我们之前的`partition`操作中，当前值大于等于v时，将e都直接放在小于v最后一个的后面，所以可能出现上述情况。现在我们对于等于v时两边都可以进行收缩，使得`partition`操作更加均匀：\n\n<img src=\"快速排序-quick-sort\\2-2\"  />\n\n话不多说，看代码更容易理解：\n\n```cpp\ntemplate <typename T>\nint partition2(T arr[], int l, int r){\n    swap(arr[rand() % (r - l + 1) + l], arr[l]);\n    T v = arr[l];\n    // arr[l+1...i) <= v; arr(j...r] => v\n    // 初始状态时两个区间都为空\n    int i = l + 1, j = r;\n    while(1){\n        while(i <= r && arr[i] < v) i++;\n        while(j >= l + 1 && arr[j] > v) j--;\n        // 此时i指向第一个大于等于v的位置，j指向最后一个小于等于v的位置\n        if(i > j) break;\n        swap(arr[i], arr[j]);\n        i++;\n        j--;\n    }\n    swap(arr[l], arr[j]);\n    return j;\n}\ntemplate <typename T>\nvoid __quickSort2(T arr[], int l, int r){\n    if(l >= r) return;\n    int p = partition2(arr, l, r);\n    __quickSort2(arr, l, p - 1);\n    __quickSort2(arr, p + 1, r);\n}\ntemplate <typename T>\nvoid quickSort2(T arr[], int n){\n    __quickSort2(arr, 0, n - 1);\n}\n```\n\n<img src=\"快速排序-quick-sort\\2-3\"  />\n\n### 三路快速排序\n\n要给含有大量重复键值的数组排序同时避免对等于v的值进行交换，还可以进行三路的快速排序：\n\n<img src=\"快速排序-quick-sort\\3-1\"  />\n\n现在根据v将数组分为三个部分，分别是：`arr[l+1...lt] < v`，`arr[lt+1...i-1] == v`，`arr[gt...r] > v`。\n\n* 如果`e == v`，`i++`；\n* 如果`e < v`，将e和`lt+1`位置交换，同时`lt++，i++`；\n* 如果`e > v`，将e和`gt-1`位置交换，成为大于v的第一个位置，`gt--`；\n* 最后将`l`和`lt`位置交换，再对小于v部分和大于v部分继续排序。\n\n<img src=\"快速排序-quick-sort\\3-2\"  />\n\n<img src=\"快速排序-quick-sort\\3-3\"  />\n\n数组中`arr[l...lt-1] < v`，`arr[lt...gt-1] == v`，`arr[gt...r] > v`。\n\n代码如下：\n\n```cpp\ntemplate <typename T>\nvoid __quickSort3(T arr[], int l, int r){\n    if(l >= r) return;\n    swap(arr[l], arr[rand() % (r - l +1 ) + l]);\n    T v = arr[l];\n    int lt = l;     // arr[l+1...lt] < v\n    int gt = r + 1; // arr[gt...r] > v\n    int i = l + 1;    // arr[lt+1...i) == v\n    while(i < gt){\n        if(arr[i] < v){\n            swap(arr[i], arr[lt+1]);\n            i++;\n            lt++;\n        }\n        else if(arr[i] > v){\n            swap(arr[i], arr[gt-1]);\n            gt--;\n        }\n        else i++; // arr[i] == v\n    }\n    swap( arr[l] , arr[lt] );\n    __quickSort3(arr, l, lt-1);\n    __quickSort3(arr, gt, r);\n}\ntemplate <typename T>\nvoid quickSort3(T arr[], int n){\n    srand(time(NULL));\n    __quickSort3( arr, 0, n-1);\n}\n```\n\n<img src=\"快速排序-quick-sort\\3-4\"  />\n\n双路快速排序和三路快速排序都是在对近乎有序数组优化的基础上，对数组存在大量重复键值时进行优化，所以时间复杂度都是O(nlogn)。\n\n### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git","categories":["算法与数据结构"]},{"title":"C++11之lambda表达式","url":"//www.xingyuzhao.ltd/blog/2020/08/02/C-11之lambda表达式/","content":"\n学习C++11标准中的新特性——lambda表达式\n\n<!-- more-->\n\n### 向算法传递函数\n\n***\n\n如果需要sort按照自己定义的方式进行排序，需要使用其第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个**谓词**。\n\n***\n\n#### 谓词\n\n1. 定义：谓词是一个**可以调用的表达式**，返回的结果可以被调用\n2. 分类：一元谓词和二元谓词\n   1. 一元谓词：只接受单一的参数\n   2. 二元谓词：接受两个参数\n3. 接受谓词的算法对输入序列中的**元素**调用谓词，因此**元素**必须能转换为谓词的参数类型\n\n`sort`函数接受一个**二元谓词**，假如我们要按字符串的长度升序排序，可以定义一个比较函数`isShorter`：\n\n```cpp\n// 比较函数，用来按长度排序单词\n// 必须是引用类型！！！\nbool isShorter(const string &s1, const string &s2){\n    return s1.size() < s2.size();\n}\n// 按长度由短至长排序words\nsort(words.begin(), words.end(), isShorter);\n\n# words = {\"foxs\", \"jumps\", \"end\", \"kid\"}\n# 输出结果为end kid foxs jumps\n```\n\n***注：针对同一长度的单词，`sort`是不稳定的，如果要保持对应的字典序，可以调用`stable_sort`***\n\n### lambda表达式\n\n对于一个对象或者表达式，如果对其可以使用调用运算符`()`，则称它为可调用的，可以将其传入算法。一个`lambda`表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。\n\n---\n\n**与任何函数相似，一个`lambda`具有一个返回类型，一个参数列表和一个函数体**\n\n**不同的是，`lambda`可以定义在函数内部**\n\n---\n\n一个`lambda`表达式具有如下形式：\n\n```cpp\n[capture list] (parameter list) -> return type { function body }\n```\n\n* `[capture list]`（捕获列表）是一个`lambda`**所在函数中**定义的局部变量的列表（通常为空）\n* `return type`、`parameter list`和`function body`与普通函数一样，分别为返回类型，参数列表和函数体，但是`lambda`必须使用尾置返回\n\n我们可以忽略参数列表和返回类型，但必须永远包括捕获列表和函数体：\n\n```cpp\n// 我们定义了一个可调用对象f，它不接受参数，返回42\nauto f = [] { return 42; };\n```\n\n`lambda`的调用方式与普通函数相同，使用调用运算符：\n\n```cpp\n// 输出42\ncout << f() << endl;\n```\n\n在此例中，当调用`f`时，参数列表为空并且忽略了返回类型，`lambda`根据函数体代码确定返回类型，如果函数体只有一个`return`语句，则返回类型从返回表达式的类型推断而来，否则返回`void`。\n\n***注：如果函数体中包含任何单一`return`语句之外的内容，且未指定返回类型，返回`void`***\n\n#### 向lambda传递参数\n\n与一个普通函数调用类似，调用一个`lambda`给定实参被用来初始化`lambda`形参，类型需要匹配。但是`lambda`不能有默认参数（比如：`int fun(int a = 1, int b = 1) { return a + b; }`）。因此，一个`lambda`调用的实参数目永远和形参数目相等，一旦形参初始化完毕，就可以执行函数体了。\n\n我们可以写出来一个与`isShorter`功能完全一样的`lambda`函数：\n\n```cpp\n[] (const string &s1, const string &s2)\n\t{ return s1.size() < s2.size(); }\n```\n\n空捕获列表表示不使用函数中的局部变量，如下所示，之前的`sort`函数可以改写如下：\n\n```cpp\nsort(words.begin(), words.end(), \n\t[] (const string &s1, const string &s2)\n\t{ return s1.size() < s2.size(); });\n```\n\n#### 使用捕获列表\n\n假如我们现在要找到`words`中第一个长度大于`sz`的单词的位置，可以编写一个可以传递给`find_if`的可调用表达式。一个`lambda`表达式**只能使用明确指明的变量**，在下面的例子中，`lambda`会捕获`sz`，，并只有单一的`string`参数（因为`find_if`只支持一元谓词），其函数体会将`string`的大小与捕获的`sz`进行比较：\n\n```cpp\n[sz] (const string &s)\n{ return s.size() >= sz; };\n```\n\n##### 调用`find_if`函数\n\n使用此`lambda`，查到第一个长度大于等于给定`sz`元素\n\n```cpp\nauto wc = find_if(words.begin(), words.end(),\n     [sz] (const string &s)\n     { return s.size() >= sz; });\n// 输出满足size >= sz第一个元素的值和位置\n// 如果没有找到，返回words.end()的一个拷贝\n// 取sz = 4\ncout << \"value:\" << *wc << \"position:\" << wc - words.begin();\n# value:foxs    position:2\n```\n\n##### `for_each`算法\n\n打印出长度大于等于`sz`的所有单词：\n\n```cpp\nfor_each(wc, words.end(), [] (const string &s) { cout << s << \" \";});\n# foxs jumps\n```\n\n### lambda捕获和返回\n\n我们可以认为，当向一个函数传递一个`lambda`时，同时定义了一个新类型和该类型的对象，传递的参数就是此编译器生成的**类的类型**的**未命名对象**。\n\n**默认情况下，由`lambda`生成的类，数据成员包含捕获列表中的变量，在`lambda`对象创建时被初始化。**\n\n#### 值捕获（后面更改不会影响值）\n\n与参数传递不同之处在于，被捕获的变量的值在`lambda`创建时拷贝，而不是调用时拷贝\n\n```cpp\nsize_t v1 = 42; // 局部变量\nauto f = [v1] { return v1; };\nv1 = 0;\nauto j = f();\n# j为42；f保存我们创建它时的拷贝，因此修改v1不会影响lambda内对应的值\n```\n\n#### 引用捕获（后面更改会影响变量值）\n\n```cpp\nsize_t v2 = 42; // 局部变量\nauto f2 = [&v2] { return v2; };\nv2 = 0;\nauto jj = f2();\n# jj为0；f2保存v1的引用\n# 需要注意的是必须确保被引用的对象在lambda执行的时候是存在的\n# 如果可能的话，避免捕获指针或引用（C++ Primer 351页）\n```\n\n#### 隐式捕获\n\n我们可以让编译器根据`lambda`函数体中的代码来推断我们要使用哪些变量，在捕获列表中写一个`&`表示捕获引用，`=`表示采用值捕获方式，我们可以重写`find_if`函数\n\n```cpp\n// sz为隐式值捕获\nauto wc = find_if(words.begin(), words.end(),\n     [=] (const string &s)\n     { return s.size() >= sz; });\n```\n\n如果想对一部分变量使用值捕获，一部分使用引用捕获，可以混合使用隐式捕获和显示捕获：\n\n```cpp\nostream &os = cout;\nchar c = ' ';\n// os隐式引用捕获，c显示值捕获\nfor_each(wc, words.end(), [&, c] (const string &s) { os << s << c;});\n// os显示引用捕获，c隐式值捕获\nfor_each(wc, words.end(), [=, &os] (const string &s) { os << s << c;});\n```\n\n1. **当我们使用混合捕获时，捕获列表第一个变量必须是一个&或者=，定义了默认捕获方式为引用或值。**\n2. **混合捕获时，显示捕获的变量必须使用与隐式捕获不同的方式，即：显示引用捕获，隐式值捕获或者显示值捕获，隐式引用捕获。**\n\n#### 指定lambda返回类型\n\n标准库函数`transform`：接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中的每个元素调用可调用对象，并将结果写到目的位置：\n\n```cpp\n// 取绝对值\nvector<int> vv1{-1, 1, 3, -20, 7};\ntransform(vv1.begin(), vv1.end(), vv1.begin(),\n          [] (int i) { return i < 0 ? -i : i; });\n# 1,1,3,20,7\n```\n\n如果写成以下形式就会产生编译错误：\n\n```cpp\ntransform(vv1.begin(), vv1.end(), vv1.begin(),\n          [] (int i) { if (i < 0) return -i; else return i; });\n```\n\n这是因为函数体中不止一个`return`语句，`lambda`无法判断返回类型。如果我们需要为其定义返回类型，必须用尾置的方式：\n\n```cpp\ntransform(vv1.begin(), vv1.end(), vv1.begin(),\n          [] (int i) -> int { if (i < 0) return -i; else return i; });\n```\n\n### 参数绑定\n\n---\n\n对于只在一两个地方使用的函数，使用`lambda`是很方便的，多次使用或者函数体比较长的话定义一个函数来实现更好。但是对于捕获局部变量的`lambda`表达式来说，用函数代替就不太容易了。\n\n---\n\n在之前的`find_if`函数中，我们可以容易写出来一个相同功能的函数：\n\n```cpp\nbool check_size(const string &s, string::size_type sz){\n\treturn s.size() >= sz;\n}\n```\n\n但是`find_if`函数只支持一元谓词，直接使用肯定是不可以的。\n\n#### 标准库bind函数\n\n使用`bind`函数可以解决上述问题，此函数定义在头文件`functional`中，可以将`bind`函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。\n\n调用形式为：\n\n```cpp\nauto newCallable = bind(callable, arg_list)\n```\n\n* `newCallable`本身是一个可调用对象\n* `arg_list`是一个逗号分隔的参数列表，对应给定`callable`的参数\n\n当我们调用`newCallable`时，`newCallable`会调用`callable`，并传递给它`arg_list`中的参数。\n\n`arg_list`中的参数可能包含形如`_n`的名字，其中`n`是一个整数，称为**占位符**，表示占据了传递给`newCallable`参数的位置。\n\n##### 绑定`check_size`的`sz`参数\n\n一个简单的例子，使用`bind`生成一个调用`check_size`的对象：\n\n```cpp\n// check4是一个可调用对象，接受一个string类型的参数\n// 使用此string和值4调用check_size\n// 注意要使用using std::placeholder::_1或using namespace std::placeholders\nauto check4 = bind(check_size, _1, 4);\n# 此bind调用只有一个占位符，表示check4只接受单一参数\n# 占位符在arg_list的第一个位置，表示check4的此参数对应check_size的第一个参数，是const string&\n# 因此调用check4必须传递给它一个string类型的参数，check4将其传给check_size\n```\n\n```cpp\nstring s = \"hello\";\nbool b1 = check4(s);\ncout << b1 << endl;\n# 1\n```\n\n此时我们可以改写`find_if`函数：\n\n```cpp\nauto wcc = find_if(words.begin(), words.end(),\n     \tbind(check_size, _1, sz));\nfor_each(wcc, words.end(), [] (const string &s) { cout << s << \" \";});\n# foxs jumps\n// 对比之前的find_if\nauto wc = find_if(words.begin(), words.end(),\n     [sz] (const string &s)\n     { return s.size() >= sz; });\n```\n\n### Reference\n\n《C++ Primer》370-383","tags":["lambda"],"categories":["C++"]},{"title":"LeetCode63-不同路径Ⅱ","url":"//www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-不同路径Ⅱ/","content":"\n本题与[**97交错字符串**](http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more)，[**174-地下城游戏**](https://leetcode-cn.com/problems/dungeon-game/)分析与解法相似\n\n### 题目描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n<!-- more-->\n\n<img src=\"LeetCode63-不同路径Ⅱ\\question\" style=\"zoom:80%;\" />\n\n<img src=\"LeetCode63-不同路径Ⅱ\\question1\" style=\"zoom:;\" />\n\n### 分析\n\n对于输入为二维数组的题目中出现了只能向下或者向右移动的字眼，一般来说考虑动态规划。这道题的不同之处是设置了障碍物，如果遇到了1则表示**不可达**，假如`m = 2, n = 2`，并且无障碍物，我们可以得到下图：\n\n<img src=\"LeetCode63-不同路径Ⅱ\\solution1\" style=\"zoom:80%;\" />\n\n那么对于`(0,1)`和`(1,0)`位置，都只有一条通路可达：\n\n<img src=\"LeetCode63-不同路径Ⅱ\\solution2\" style=\"zoom:80%;\" />\n\n最后对于末尾处`(1,1)`，它的上边和左边可以到达，所以到达它的路径为`1 + 1 = 2`条：\n\n<img src=\"LeetCode63-不同路径Ⅱ\\solution3\" style=\"zoom:80%;\" />\n\n通过观察我们发现，在不遮挡的情况下，可以到达当前位置的路径数就是当前位置的上边和左边路径数的总和。\n\n对于存在障碍物的情况，我们直接令到达它的路径数为0，这样也就满足的题目的要求。\n\n#### 定义dp数组\n\n根据上述分析，`dp[i][j]`表示有多少条路径可以到达`(i,j)`，如果网格中此处值为1，也就是有障碍的情况下，`dp[i][j] = 0`。表示无法到达，路径数为0。\n\n#### 初始化\n\n在**交错字符串**中使用的是从前往后遍历的思想，这里换一种思路，从后往前进行遍历。对于最后一个位置`dp[m-1][n-1]`，如果第`m - 1`行或者`n - 1`列其他位置可以到达最后位置，则为1，否则为0，只要在网格中往回走遇到了1，在那之后`dp`数组的值都为0。\n\n```cpp\nlong long dp[m][n];\nfor(int i = 0; i < m; ++i){\n\tfor(int j = 0; j < n; ++j)\n\t\tdp[i][j] = 0;\n}\n// 最后一行到end初始化为1\n// 注意有有一个为1，后面都被阻挡\nfor(int j = n - 1; j >= 0 && obstacleGrid[m - 1][j] == 0; --j){\n\tdp[m - 1][j] = 1; \n}\n// 最后一列到end初始化为1\nfor(int i = m - 1; i >= 0 && obstacleGrid[i][n - 1] == 0; --i){\n\tdp[i][n - 1] = 1;\n}\n```\n\n#### 状态转移方程\n\n```cpp\nif(obstacleGrid[i][j] == 0)\n    dp[i][j] = dp[i+1][j] + dp[i][j+1];\n```\n\n#### 代码\n\n```cpp\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        // 从后往前必须long long\n        long long dp[m][n];\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j)\n                dp[i][j] = 0;\n        }\n        // 最后一行到end初始化为1\n        // 注意有有一个为1，后面都被阻挡\n        for(int j = n - 1; j >= 0 && obstacleGrid[m - 1][j] == 0; --j){\n                dp[m - 1][j] = 1; \n        }\n        // 最后一列到end初始化为1\n        for(int i = m - 1; i >= 0 && obstacleGrid[i][n - 1] == 0; --i){\n                dp[i][n - 1] = 1;\n        }\n        for(int i = m - 2; i >= 0; --i){\n            for(int j = n - 2; j >= 0; --j){\n                if(obstacleGrid[i][j] == 0)\n                {\n                    dp[i][j] = dp[i + 1][j] + dp[i][j + 1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/unique-paths-ii/solution/jian-dan-dpbi-xu-miao-dong-by-sweetiee/","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode97-交错字符串","url":"//www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-交错字符串/","content":"\n在看了题解之后才慢慢意识到，这道题和[**63-不同路径Ⅱ**](https://leetcode-cn.com/problems/unique-paths-ii/)，[**174-地下城游戏**](https://leetcode-cn.com/problems/dungeon-game/)是非常相似的，题目虽然具有一定难度，但都是有迹可循。它们都可以抽象为在二维数组中，从起始到末尾找路径的问题。上面两个问题还未更新，跳转位置是题目链接。\n\n### 题目描述\n\n给定三个字符串 *s1*, *s2*, *s3*, 验证 *s3* 是否是由 *s1* 和 *s2* 交错组成的。\n\n<!-- more-->\n\n<img src=\"LeetCode97-交错字符串\\question1\"  />\n\n### 分析\n\n交错的意思是：如果第一次取了`s1`，那么第二次必须取`s2`，反之亦然。取多少和哪一个先取都是不一定的，只是要求交错即可。\n\n对于`s1 = \"bacc\", s2 = \"aabcce\", s3 = \"abaacbccec\"`，这个示例是可以匹配的，按照**可以匹配**的过程分析如下：\n\n1. 首先只能取`s2`中的`a`，再继续往下取`a`时，与`s3`已经无法匹配了；\n2. **再取`s1`中的`b`或者`ba`都是可以的**，这里取`b`\n3. 再取`s2`中的`a`，此时匹配到`aba`\n4. 再取`s1`中的`ac`，此时匹配到`abaac`\n5. 再取`s2`中的`bcce`，此时匹配到`abaacbbe`\n6. 再取`s1`中的`c`，此时完全匹配\n\n#### 定义dp数组\n\n`dp[i][j]`表示`s1`的前`i`个字符和`s2`的前`j`个字符是否匹配，我们可以将刚才的分析表示为下图：\n\n<img src=\"LeetCode97-交错字符串\\question1_dp\" style=\"zoom:80%;\" />\n\n上图是不是很像一个路径问题，而且只能向右或者向下移动，进一步说明是用动态规划来解决，如果还可以往上或者左，那就不能用动态规划来做了，得考虑`dfs`之类的算法。\n\n分析中的第二步，也就是图中`true`的其他可能。\n\n#### 初始化\n\n```cpp\n// 都为空时匹配\ndp[0][0] = 1\n// 对于第一行和第一列，当前值若无法匹配，则当前值和之后的都无法匹配\nif(i == 0) dp[0][j] = s2[0,j) == s3[0,j)\nif(j == 0) dp[i][0] = s2[0,i) == s3[0,i)\n```\n\n#### 状态转移方程\n\n```cpp\ndp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1])\n\t|| (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1])\n```\n\n### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        int m = s1.size(), n = s2.size();\n        if(m + n != s3.size()) return false;\n        // bool dp[m + 1][n + 1] = {false};\n        bool **dp = new bool*[m + 1];\n        for(int i = 0; i <= m; ++i){\n            dp[i] = new bool[n + 1];\n        }\n        for(int i = 0; i <= m; ++i){\n            for(int j = 0; j <= n; ++j){\n                dp[i][j] = 0;\n            }\n        }\n        // 初始化\n        dp[0][0] = true;\n        for(int j = 1; j <= n && (s2.substr(0, j) == s3.substr(0, j)); ++j) \n            dp[0][j] = true;\n        for(int i = 1; i <= m && (s1.substr(0, i) == s3.substr(0, i)); ++i) \n            dp[i][0] = true;\n        \n        for(int i = 1; i <= m; ++i){\n            for(int j = 1; j <= n; ++j){\n                dp[i][j] = (dp[i - 1][j] && (s1[i - 1] == s3[i + j - 1])) ||\n                            (dp[i][j - 1] && (s2[j - 1] == s3[i + j - 1]));\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n\n### Reference\n\nhttps://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/","tags":["动态规划"],"categories":["LeetCode"]},{"title":"Verilog基础2","url":"//www.xingyuzhao.ltd/blog/2020/07/14/Verilog基础2/","content":"\n## Verilog基础\n\n学习verilog基础语法2\n\n<!-- more-->\n\n### 第五章 FPGA基本实践\n\n#### 流水灯实践\n\n```verilog\nmodule v1(\n    input clk,\t\t\t// 时钟输入\n    input rst,\t\t\t// 复位信号\n    output [7:0] led\t// LED输出\n    );\nreg [7:0] ledtemp = 8'b0000_0001;\t// led初始值\nreg [23:0] divclk_cnt = 0;\t\t\t// 24位计数值\nreg divclk = 0;\t\t\t\t\t\t// 低频时钟\nassign led = ledtemp;\t// 实现将寄存器变量值赋给LED输出\n\tparameter halfduty_cntvalue = 12500000;\nalways @ ( posedge clk )\t\t\t// 把系统时钟分频50Mhz/25000000 = 2Hz\nbegin\n\tif( divclk_cnt == halfduty_cntvalue)\t// 计数满后翻转\n\t\tbegin\n\t\t\tdivclk = ~divclk;\n\t\t\tdivclk_cnt = 0;\n\t\tend\n\t\telse begin\n\t\t\tdivclk_cnt = divclk_cnt + 1'b1;\n\t\tend\n\tend\nalways @ ( posedge divclk )\nbegin\n\tif( !rst )\n\t\tbegin\n\t\t\tledtemp = 8'b0000_0001;\n\t\tend\n\telse if ( ledtemp[7] == 1 )\n\t\tledtemp = 8'b0000_0001;\t\t// 瀹炵幇寰幆绉讳綅\n\telse\n\t\tledtemp = ledtemp << 1;\nend\n\nendmodule\n```\n\n仿真代码：\n\n```verilog\nmodule sim3;\nreg clk;\nreg rst;\nwire led;\n\nv1 uut( clk, rst, led );\ninitial begin\n    clk = 0;\n    rst = 1;\nend\nalways #10 clk = ~clk; // 每隔10ns反转，周期是20ns，频率也就是50MHz\nendmodule\n```\n\n仿真图如下：\n\n<img src=\"Verilog基础2\\image1\"  />\n\n从**ledtemp**可以看出进行了左移的操作\n\n<img src=\"Verilog基础2\\image2\"  />\n\n完成一次循环之后回到**00000001**","categories":["FPGA"]},{"title":"Verilog基础1","url":"//www.xingyuzhao.ltd/blog/2020/07/14/Verilog基础1/","content":"\n## Verilog基础\n\n学习verilog基础语法1\n\n<!-- more-->\n\n## 第二章 基本语法\n\n#### 数据类型及变量\n\n查找表**LUT**\n\n1. 线网型变量wire\n   1. 信号间连接作用，只能将其连接到某处而不能进行赋值\n   2. 没有时序限定，与其它块语句并行执行\n   3. 不保存状态，值随时可以改变，不受时钟信号限制\n   4. input和output默认位wire\n   5. wire是组合逻辑的赋值，在时序控制always**块外**并使用**assign**进行赋值\n2. 寄存器类型reg\n   1. 值可以改变\n   2. 常用来表示时序控制always块内的指定信号\n3. 符号常量parameter\n\n#### 语句\n\n1. 连续赋值语句**assign**\n\n   assign语句用于对wire型变量赋值，例如`assign c = a & b`，a，b是wire型变量或寄存器变量，c必须是wire型变量或其他线网型变量。\n\n2. 过程赋值语句**`=`和`<=`**\n\n   1. 用于对reg型变量赋值，在过程块中使用过程赋值语句\n   2. 非阻塞(`<=`)：多条非阻塞赋值在过程块中同时完成赋值操作，多条语句相当于同时执行\n   3. 阻塞(`=`)：在一个块语句中，如果有多条阻塞赋值语句，在前面的赋值语句没有完成之前，后面的语句就不能执行`=`\n   4. 对于阻塞，在当前时钟就赋值了，而非阻塞是在下一个时钟进行赋值\n\n3. 过程说明语句**always**\n\n   1. always块包含一个或一个以上的语句（如：过程赋值语句、条件语句和循环语句等），在运行的过程中，在时钟控制下被反复执行，也就是说，时钟有效边沿来了就执行\n   2. 在always块中被赋值的只能是寄存器reg型变量\n   3. 书写方法：`always @ (敏感信号表达式)`\n\n   ```verilog\n   always @ (clk) // 只要clk发生变化就触发\n   always @ (posedge clk) // clk上升沿触发\n   always @ (negedge clk) // clk下降沿触发\n   always @ (negedge clk1 or posedge clk2) // clk1下降沿或者clk2上升沿触发\n   always @ (*) // 任何输入信号变化了都触发\n   ```\n\n\n4. 结构说明语句initial\n\ninitial语句用于对寄存器变量赋予初值\n\n5. 条件语句**if-else**\n\n6. 条件语句**case**\n\n   ```\n   case(表达式)\t<case分支项>\tendcase\n   case 分支项的一般格式：\n   分支表达式：语句；\n   默认项(default)  语句；\n   ```\n\n7. 循环语句\n\n   1. **forever**语句：连续执行的语句\n\n   ```\n   格式: forever begin 语句块 end\n   forever常用于仿真代码中\n   ```\n\n   2. **repeat**\n   3. **while**\n   4. **for** 尽量少用，循环次数固定\n\n## 第三章 组合逻辑电路\n\n#### 多数表决器的实现\n\n1. **逻辑表达式**：`f = a&b|a&c|b&C`\n2. **RTL分析**：在左侧的流程导航器`Flow Navigator`中的详细设计`Elaborated Design` 部分按右键，在弹出的菜单中选`New Elaborated Design`之后得到RTL电路图（RTL意思是寄存器传输级，生成寄存器传输级别的电路，并非综合后的电路），在开发过程中RTL分析不是必须的，但是能帮助我们检测错误。\n3. **综合**：将RTL级别的设计描述转换成逻辑门级的逻辑描述。单击流程导航窗口综合`Synthesis`项下的`Run Synthesis`进入综合，综合完毕后点击`Schematic`打开原理图。\n\n4. **仿真**：新建仿真文件，然后编辑内容，再点击`Run Simulation`\n5. **编程和调试**：首先生成比特流，然后再进行硬件调试\n\n#### **3-8译码器设计和IP核**\n\n1. 译码器设计步骤与多数表决器相同，也是组合逻辑电路\n2. **IP核**：点击顶部的**Tools**，然后点击**Create and Package IP**项，之后一直**Next**，进入以下页面：\n\n<img src=\"Verilog基础1\\image1\" style=\"zoom:80%;\" />\n\n没什么问题后点击**Review and Package**中的**Package IP**\n\n#### 调用IP核实现多数表决器\n\n## 第四章 时序逻辑电路\n\n时钟同步状态机：时序电路的状态变化发生的时间有一个统一的时钟信号的指定边沿来激励。\n\n#### 实现11001序列发生器\n\n1. 画出状态转移图\n\n<img src=\"Verilog基础1\\image2\"  />\n\n2. 画出状态转移表\n\n| Q0 Q1 Q2 | Q0* Q1* Q2* |  Z   |\n| :------: | :---------: | :--: |\n|   000    |     001     |  1   |\n|   001    |     010     |  1   |\n|   010    |     011     |  0   |\n|   011    |     100     |  0   |\n|   100    |     000     |  1   |\n\n3. 根据状态转移表画卡诺图求解。（未使用的状态用无关项表示）\n\n| Q2/Q0Q1 |  00   |  01   |  11   |  10   |\n| :-----: | :---: | :---: | :---: | :---: |\n|    0    | 001/1 | 011/0 | ddd/d | 000/1 |\n|    1    | 010/1 | 100/0 | ddd/d | ddd/d |\n\n4. 得到转移方程和输出方程\n\n   1. 转移方程：\n      $$\n      Q0* = Q1Q2\\\\\n      Q1* = Q1'Q2 + Q1Q2'\\\\\n      Q2* = Q0'Q2'\n      $$\n\n   2. 输出方程\n\n   $$\n   Z = Q1'\n   $$\n\n5. 判断自启动，FPGA设计可以给出初始态，所以可以忽略\n\n6. 使用D触发器，写出激励方程\n   $$\n   D0 = Q0* = Q1Q2\\\\\n   D1 = Q1* = Q1'Q2 + Q1Q2'\\\\\n   D2 = Q2* = Q0'Q2'\n   $$\n\n7. 建立工程编写程序\n\n```verilog\nmodule seq_11001_1(\n\tinput  clk,\n\toutput led\n    );\nreg [5:0] divclk_cnt = 0;\nreg divclk = 0;\nreg q0 = 0;\nreg q1 = 0;\nreg q2 = 0;\nalways @ ( posedge clk )\nbegin\n\tif(divclk_cnt == 25) // 50分频 25低25高 默认32位宽\n\tbegin\n\t\tdivclk = ~divclk;\n\t\tdivclk_cnt = 0;\t\t\n\tend\n\telse begin\n\t\tdivclk_cnt = divclk_cnt + 1'b1;\n\tend\nend\n\nassign led = ~q1;\nalways @ (posedge divclk)\nbegin\n\tq0 <= q1&q2;\n\tq1 <= ~q1&q2|q1&~q2;\n\tq2 <= ~q0&~q2;\nend\t\nendmodule\n```\n\n仿真文件：\n\n```verilog\nmodule sim1;\nreg clk;\nwire led;\nseq_11001_1 uut( clk, led );\ninitial begin\n    clk = 0;\nend\nalways #10 clk = ~clk;\nendmodule\n```\n\n8. 仿真\n\n<img src=\"Verilog基础1\\image3\"  />\n\n从图可知，和状态转移表一致\n\n#### 状态图直接描述法实现序列发生器\n\n根据上部分**1**中的状态转移图可以直接实现**11001**序列发生器，实现代码如下：\n\n```verilog\nmodule seq_11001_2(\n    input clk,\n    output led\n    );\nreg led;\nreg [31:0] divclk_cnt = 0;\nreg divclk = 0;\nreg [2:0] state = state_A;\nparameter // 符号常量\nstate_A = 3'b000,state_B = 3'b001,state_C = 3'b010,state_D = 3'b011,state_E = 3'b100;\nalways @ ( posedge clk )\nbegin\n\tif(divclk_cnt == 25)\n\tbegin\n\t\tdivclk = ~divclk;\n\t\tdivclk_cnt = 0;\n\tend\n\telse begin\n\t\tdivclk_cnt = divclk_cnt + 1;\n\tend\nend\nalways @ ( posedge divclk )\nbegin\n\tcase( state )\n\t\tstate_A:begin\n\t\t\tstate <= state_B;\n\t\t\tled <= 1;\n\t\tend\n\t\tstate_B:begin\n\t\t\tstate <= state_C;\n\t\t\tled <= 1;\n\t\tend\n\t\tstate_C:begin\n\t\t\tstate <= state_D;\n\t\t\tled <= 0;\n\t\tend\n\t\tstate_D:begin\n\t\t\tstate <= state_E;\n\t\t\tled <= 0;\n\t\tend\n\t\tstate_E:begin\n\t\t\tstate <= state_A;\n\t\t\tled <= 1;\n\t\tend\n        // 表示当前状态不属于以上状态，让状态回到state_A\n\t\tdefault:begin\n\t\t\tstate <= state_A;\n\t\t\tled <= 1;\n\t\tend\n\tendcase\nend\n\nendmodule\n```\n\n仿真图如下：\n\n<img src=\"Verilog基础1\\image4\"  />\n\n当`state = 000`时，在`divclk`的下一个上升沿时`led = 1`，以此类推\n\n","categories":["FPGA"]},{"title":"LeetCode718-最长重复子数组","url":"//www.xingyuzhao.ltd/blog/2020/07/03/LeetCode718-最长重复子数组/","content":"\n### 题目描述\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n<!-- more-->\n\n<img src=\"LeetCode718-最长重复子数组\\示例.png\" style=\"zoom: 80%;\" />\n\n### 分析\n\n题目的意思很好理解，如示例所示，公共的子数组除了单一的数值`[1],[2],[3]`，也有`[2,1],[3,2,1]`这些数组，其中最长的就是`[3,2,1]`这个数组，长度为3。像题目出现**最长，最短**之类的字都可以考虑用动态规划去解决。\n\n#### 一、定义dp数组的含义\n\n数组A长5，数组B长5，我们假设存在一个`6×6`的`dp`矩阵，使得矩阵坐标从1开始，同时保证边界位置上的计算，并初始化所有值为0。**矩阵表示固定A的值时，到B数组的当前值与到A固定值的公共数组长度**：\n\n<img src=\"LeetCode718-最长重复子数组\\index.png\"  />\n\n我们固定A数组，然后去遍历B数组。假如`A[i]=B[j]`时，公共数组的长度在上一次长度的基础上+1，否则不变，在后续分析中可以看到。\n\n比如说`A[0]=1`，此时遍历B数组，`B[0]=3`，两个值不等。因为我们建立数组时候起始坐标是从1开始的，所以`dp[1][1] = 0`。继续遍历B数组，可以得到以下结果：\n\n```\ndp[1][2] = 0\ndp[1][3] = 1\ndp[1][4] = 0\ndp[1][5] = 0\n```\n\n<img src=\"LeetCode718-最长重复子数组\\index1.png\"  />\n\n接下来改变A值，`A[1]=2`，可以得到：\n\n```\ndp[2][1] = 0\ndp[2][2] = 1\ndp[2][3] = 0\ndp[2][4] = 0\ndp[2][5] = 0\n```\n\n<img src=\"LeetCode718-最长重复子数组\\index2.png\"  />\n\n同理`A[2]=3`：\n\n<img src=\"LeetCode718-最长重复子数组\\index3.png\"  />\n\n当`A[3]=2,B[1]=2`时，此时满足`value(A)==value(B)`，所以`dp[4][2] = dp[3][1] + 1 = 2 `，如图：\n\n<img src=\"LeetCode718-最长重复子数组\\index4.png\"  />\n\n当`A[4]=1,B[2]=1`时，此时满足`value(A)==value(B)`，所以`dp[5][3] = dp[4][2] + 1 = 3`，如图：\n\n<img src=\"LeetCode718-最长重复子数组\\index5.png\"  />\n\n遍历完一次B数组后更新最大长度，所以最后最大的公共数组长度就是3。\n\n#### 二、状态转移方程\n\n根据上述分析，可以得到：\n\n```cpp\nif(A[i-1] == B[j-1])\n    dp[i][j] = dp[i-1][j-1] + 1;\n```\n\n#### 三、代码实现\n\n```cpp\nclass Solution {\npublic:\n    int findLength(vector<int>& A, vector<int>& B) {\n        int res = 0;\n        int **dp = new int*[A.size()+1];\n        for(int i = 0; i < A.size() + 1; i++){\n            dp[i] = new int[B.size()+1];\n        }\n        for(int i = 0; i < A.size() + 1; i++){\n            for(int j = 0; j < B.size() + 1; j++){\n                dp[i][j] = 0;\n            }\n        }\n        // 从前往后\n        for(int i = 1; i <= A.size(); i++){\n            for(int j = 1; j <= B.size(); j++){\n                if(A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\n                res = max(res, dp[i][j]);\n            }\n        }\n        return res;\n    }\n};\n```\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"堆排序(heap sort)","url":"//www.xingyuzhao.ltd/blog/2020/06/27/堆排序-heap-sort/","content":"\n堆排序是一种特殊的排序算法，涉及到了优先级的概念\n\n更新于2020/7/12\n\n### 本次学习要点\n\n1. 了解优先队列的一些概念\n2. 堆排序概念及实现\n\n<!-- more-->\n\n### 优先队列\n\n* 普通队列：FIFO\n* 优先队列：出队顺序与入队无关，与优先级有关\n\n为什么选择优先队列？\n\n比如：在10000000个元素中选择前100名？(在N个元素中选择前M个)\n\n* 排序算法复杂度 O(NlogN)\n* 优先队列 O(NlogM)\n\n优先队列的实现方法：\n\n<img src=\"D:堆排序-heap-sort\\实现方式.png\" style=\"zoom:80%;\" />\n\n使用普通数组在出队时需要遍历一次找到优先级最高的元素；顺序数组在每次插入的时候也要遍历一次找到相应的位置；使用堆这种结构可以让入队出队复杂度都为O(logN)。\n\n### 堆的基本实现\n\n#### 二叉堆(Binary Heap)\n\n二叉堆类似于二叉树，是一种树状结构，可以用数组来存储二叉堆，以最大堆为例。\n\n最大堆：\n\n* **堆中的某个节点值不大于其父亲节点(不意味着层数越高，数值越大)**\n* **堆总是一棵完全二叉树(这也是可以用数组表示的原因)**\n\n<img src=\"堆排序-heap-sort\\二叉堆1.png\" style=\"zoom:80%;\" />\n\n给每个节点按照从上到小，从左到右进行编号，可以有以下的性质：\n\n* **左节点的序号是父节点的二倍**\n* **右边序号为父节点的二倍加1**\n\n<img src=\"堆排序-heap-sort\\二叉堆2.png\" style=\"zoom:80%;\" />\n\n用1来做起始标号是经典实现办法，数组对应的标号就是节点的索引：\n\n<img src=\"堆排序-heap-sort\\数组1.png\"  />\n\n```cpp\n# 找到i的父节点序号\nparent[i] = i / 2\n# i节点的孩子节点序号\nleftChild[i] = 2 * i\nrightChild[i] = 2 * i + 1\n```\n\n构建堆的基本结构：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\npublic:\n    MaxHeap(int capacity){\n        data = new Item[capacity+1];\n        count = 0;\n    }\n    ~MaxHeap(){\n        delete[] data;\n    }\n    int size(){\n        return count;\n    }\n    bool isEmpty(){\n        return count == 0;\n    }\n};\n```\n\n#### 添加元素(Shift Up)\n\n由于是用数组实现的堆，所以添加一个新的元素相当于在数组的末尾添加了一个元素：\n\n<img src=\"堆排序-heap-sort\\数组2.png\"  />\n\n相应的树形结构如下：\n\n<img src=\"堆排序-heap-sort\\shiftup1.png\" style=\"zoom:80%;\" />\n\n显然此时不符合最大堆的定义，新加入的52大于其父节点16，所以两个需要交换位置，以此类推，将52放在合适的位置，如下图所示：\n\n<img src=\"堆排序-heap-sort\\shiftup2.png\" style=\"zoom: 67%;\" />\n\n最终数组里的值为下图：\n\n<img src=\"堆排序-heap-sort\\数组3.png\"  />\n\n**Shift Up**代码实现(在基本结构基础上)：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\n    int capacity;\n    void shiftUp(int k){\n        // 孩子节点大于父节点需要交换，并更新节点位置\n        while( k > 1 && data[k/2] < data[k] ){\n            swap( data[k/2], data[k] );\n            k /= 2;\n        }\n    }\npublic:\n    MaxHeap(int capacity){\n        data = new Item[capacity+1];\n        count = 0;\n        this->capacity = capacity;\n    }\n    void insert(Item item){\n        assert( count + 1 <= capacity );\n        //添加新元素\n        data[count+1] = item;\n        count ++;\n        shiftUp(count);\n    }\n```\n\n#### 取出元素(Shift Down)\n\n对于堆来说，每次只能取根节点的那个元素，在这里就是取最大的元素。\n\n取出最大的元素后，根节点的位置就空出来了，这时候把最后一个元素补充到根节点处(保证仍然是一棵完全二叉树)，此时作为计数的变量`count--`，最后一个数组中的元素可以不动，使用`count`来卡住边界。\n\n<img src=\"堆排序-heap-sort\\shiftdown1.png\" style=\"zoom:80%;\" />\n\n此时数组中的元素为：\n\n<img src=\"堆排序-heap-sort\\数组4.png\"  />\n\n此时16也不满足最大堆的定义，接下来要调整这些元素的位置。将16一步一步的向下挪，直到合适的位置，所以叫**Shift Down**，不过每次下挪，有两个方向可以走，具体怎么选？**需要找到子节点中更大的那个值进行交换**，这样就可以保证子节点一定是不大于父节点的，过程如下：\n\n<img src=\"堆排序-heap-sort\\shiftdown2.png\" style=\"zoom:80%;\" />\n\n此时数组中的元素为：\n\n<img src=\"堆排序-heap-sort\\数组5\"  />\n\n**Shift Down**代码实现(在基本结构基础上)：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\n    int capacity;\n    void shiftDown(int k){\n        // 判断k是否有孩子\n        // 对于完全二叉树，有左孩子就代表一定有孩子\n        while( 2*k <= count ){\n            int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置\n            // j+1为右孩子，需要判断是否存在\n            // 再判断应该和哪个孩子交换\n            if( j+1 <= count && data[j+1] > data[j] ) // 右孩子大\n                j ++; // j代表右孩子，否则为左孩子\n            // data[j] 是 data[2*k]和data[2*k+1]中的最大值\n            if( data[k] >= data[j] ) break;\n            swap( data[k] , data[j] );\n            k = j; // 交换后的新节点，继续Shift Down\n        }\n    } \npublic:\n    Item extractMax(){\n        assert( count > 0 );\n        Item ret = data[1];\n\n        swap( data[1] , data[count] );\n        count --;\n        shiftDown(1);\n\n        return ret;\n    }\n    Item getMax(){\n        assert( count > 0 );\n        return data[1];\n    }\n};\n```\n\n#### Heapify(将普通数组变为堆)\n\n<img src=\"堆排序-heap-sort\\数组6.png\"  />\n\n对于以上数组，可以直接构建成堆，不用先进行插入元素，二叉树形式为下图：\n\n<img src=\"堆排序-heap-sort\\heapify1.png\" style=\"zoom:80%;\" />\n\n对于上图的树来说，所有的叶子节点都是一个最大堆：\n\n<img src=\"堆排序-heap-sort\\heapify2\" style=\"zoom:80%;\" />\n\n第一个非叶子节点的位置为`count/2`，即`10/2=5`，对于每个非叶子节点进行**Shift Down**操作。\n\n<img src=\"堆排序-heap-sort\\heapify3\" style=\"zoom: 67%;\" />\n\n**Heapify**代码实现：\n\n```cpp\ntemplate<typename Item>\nclass MaxHeap{\nprivate:\n    Item *data;\n    int count;\n    int capacity;\n    void shiftDown(int k){\n        // 判断k是否有孩子\n        // 对于完全二叉树，有左孩子就代表一定有孩子\n        while( 2*k <= count ){\n            int j = 2*k; \n            // 在此轮循环中,data[k]和data[j]交换位置\n            // j+1为右孩子，需要判断是否存在\n            // 再找到值更大的孩子\n            if( j+1 <= count && data[j+1] > data[j] ) \n                j ++;\n            // 如果孩子中最大值小于等于父节点的值，就不用交换了\n            if( data[k] >= data[j] ) break;\n            swap( data[k] , data[j] );\n            // 交换后的新节点，继续Shift Down\n            k = j; \n        }\n    } \npublic:\n    // 根据数组直接构造最大堆\n    MaxHeap(Item arr[], int n){\n        data = new Item[n+1];\n        capacity = n;\n\n        for( int i = 0 ; i < n ; i ++ )\n            data[i+1] = arr[i];\n        count = n;\n\n        for( int i = count/2 ; i >= 1 ; i -- )\n            shiftDown(i);\n    }\n    Item extractMax(){\n        assert( count > 0 );\n        Item ret = data[1];\n\n        swap( data[1] , data[count] );\n        count --;\n        shiftDown(1);\n\n        return ret;\n    }\n};\n```\n\n### 原地堆排序(从小到大)\n\n在之前构建一个堆需要额外的n个空间，实际上给定数组时候在原地也可以进行堆排序，过程如图所示：\n\n<img src=\"堆排序-heap-sort\\原地1.png\" style=\"zoom:80%;\" />\n\n* 先对数组进行`Heapify`操作，则V就是最大值，V和W进行交换，此时最大值在末尾\n* 此时V之前的数组不再是最大堆，对W进行`ShiftDown`操作使之前的数组再次成为最大堆\n* 再次把此时的V和W(倒数第二个元素)进行交换，以此类推。\n\n**此时的索引是从0开始的**，所以最后一个非叶子节点的索引为`(count-1)/2`，对于节点**i**，有：\n\n```cpp\nparent[i] = (i - 1) / 2;\nleft child[i] = 2 × i + 1;\nright child[i] = 2 × i + 2;\n```\n\n<img src=\"堆排序-heap-sort\\原地2.png\" style=\"zoom:80%;\" />\n\n对应的数组为：\n\n<img src=\"堆排序-heap-sort\\原地3.png\"  />\n\n代码实现：\n\n```cpp\npublic:\nvoid heapsort(T arr[], int n){\n    // heapify\n    // from 第一个非叶子节点\n    for(int i = (n - 1) / 2; i >= 0; --i)\n        __shiftDown(arr, n, i);\n    // i最后为1，当只有也给元素时无需进行操作\n    for(int i = n - 1; i > 0; --i){\n        swap(arr[0], arr[i]);\n        __shiftDown(arr, i, 0);\n    }\n}\nprivate:\nvoid __shiftDown(T arr[], int n, int k){\n    // 从0开始索引，k为父节点\n    while(2 * k + 1 < n){ // 如果左孩子存在\n        int j = 2 * k + 1;\n        // 以下操作是为了与左右孩子中更大的那个交换\n        if(j + 1 < n && arr[j+1] > arr[j])\n            j += 1;\n        if(arr[k] >= arr[j])\n            break;\n        swap(arr[k], arr[j]);\n        k = j;\n    } \n        \n}\n```\n\n### 索引堆(Index Heap)\n\n当进行堆排序之后，坐标和值的关系也就不复存在了，如果我们要继续使用坐标和值之间的关系，就需要对索引进行堆排序，以最大索引堆为例：\n\n<img src=\"堆排序-heap-sort\\index_heap1.png\" style=\"zoom:80%;\" />\n\n* `data`数组并未改变，只有`index`数组发生了改变(**根据data改变index**)\n* 堆顶的元素`index[1] = 10`，表示堆顶的元素是**10索引**所指向的`data[10]`，即62\n* 同理可得，`index[2] = 9`表示62的左孩子是**9索引**所指向的`data[9] = 41`，`index[3] = 7`表示62的右孩子是**7索引**所指向的`data[7] = 28`，以此类推\n\n**优点**：只有索引`index整型`数组发生了改变，`data`并未改变，`data`的类型并没有限制\n\n对于`shiftDown`和`shiftUp`变化不大，同时可以支持返回最大值的索引值，也可以根据索引值就直接返回`data`，最重要的操作是修改数据内容。\n\n```cpp\nvoid change( int i , Item newItem ){\n\n    i += 1;\n    data[i] = newItem;\n\n    // 找到indexes[j] = i, j表示data[i]在堆中的位置\n    // 之后shiftUp(j), 再shiftDown(j)，再次将index构建为最大堆\n\t// 这里用的是遍历，复杂度较高O(n + logn)\n    for( int j = 1 ; j <= count ; j ++ )\n        if( indexes[j] == i ){\n            shiftUp(j);\n            shiftDown(j);\n            return;\n        }\n}\n```\n\n#### 优化(change)\n\n<img src=\"堆排序-heap-sort\\index_heap2.png\"  />\n\n* `reverse[i]`表示索引`i`在`index`中的位置\n* 比如我们要查找`i = 4`这个索引在`index`中的位置，先找到`rev[4] = 9`，那么索引`i = 4`就在`index[9]`处，时间复杂度为O(1)\n\n```cpp\nindexes[i] = j;\nreverse[j] = i;\n\nindexes[reverse[i]] = i;\nreverse[indexes[i]] = i;\n```\n\n在`swap`操作中需要修改`reverse`\n\n代码如下：\n\n```cpp\npublic:\n    IndexMaxHeap(int capacity){\n\n        data = new Item[capacity+1];\n        indexes = new int[capacity+1];\n        reverse = new int[capacity+1];\n        // 初始化为0，代表不存在\n        for( int i = 0 ; i <= capacity ; i ++ )\n            reverse[i] = 0;\n\n        count = 0;\n        this->capacity = capacity;\n    }\n    ~IndexMaxHeap(){\n        delete[] data;\n        delete[] indexes;\n        delete[] reverse;\n    }\n    // 传入的i对用户而言,是从0索引的\n    void insert(int i, Item item){\n        assert( count + 1 <= capacity );\n        assert( i + 1 >= 1 && i + 1 <= capacity );\n\n        i += 1;\n        data[i] = item;\n        indexes[count+1] = i;\n        reverse[i] = count+1;\n        count++;\n\n        shiftUp(count);\n    }\n\t// 抽取最大的元素\n    Item extractMax(){\n        assert( count > 0 );\n\n        Item ret = data[indexes[1]];\n        swap( indexes[1] , indexes[count] );\n        // 此时最后一个元素没有意义了\n        // 此时的堆顶的第一个元素的reverse需要更新\n        reverse[indexes[count]] = 0;\n        reverse[indexes[1]] = 1;\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n\t// 抽取最大元素的坐标\n    int extractMaxIndex(){\n        assert( count > 0 );\n\n        int ret = indexes[1] - 1;\n        swap( indexes[1] , indexes[count] );\n        reverse[indexes[count]] = 0;\n        reverse[indexes[1]] = 1;\n        count--;\n        shiftDown(1);\n        return ret;\n    }\n\t// 返回最大元素的值\n    Item getMax(){\n        assert( count > 0 );\n        return data[indexes[1]];\n    }\n\t// 返回最大元素的坐标\n    int getMaxIndex(){\n        assert( count > 0 );\n        return indexes[1]-1;\n    }\n\t// 保证不越界\n    bool contain( int i ){\n        assert( i + 1 >= 1 && i + 1 <= capacity );\n        return reverse[i+1] != 0;\n    }\n\t// 返回i处的元素值\n    Item getItem( int i ){\n        assert( contain(i) );\n        return data[i+1];\n    }\n\t// 改变i处的元素值\n    void change( int i , Item newItem ){\n\n        assert( contain(i) );\n        i += 1;\n        data[i] = newItem;\n\n        int j = reverse[i];\n        shiftUp( j );\n        shiftDown( j );\n    }\n```\n\n```cpp\nprivate:   \n    void shiftUp( int k ){\n\n        while( k > 1 && data[indexes[k/2]] < data[indexes[k]] ){\n            swap( indexes[k/2] , indexes[k] );\n            reverse[indexes[k/2]] = k/2;\n            reverse[indexes[k]] = k;\n            k /= 2;\n        }\n    }\n    void shiftDown( int k ){\n\n        while( 2*k <= count ){\n            int j = 2*k;\n            if( j + 1 <= count && data[indexes[j+1]] > data[indexes[j]] )\n                j += 1;\n\n            if( data[indexes[k]] >= data[indexes[j]] )\n                break;\n\n            swap( indexes[k] , indexes[j] );\n            reverse[indexes[k]] = k;\n            reverse[indexes[j]] = j;\n            k = j;\n        }\n    }\n```\n\n### 用堆解决第一节问题思路\n\n使用堆实现优先队列，动态选择优先级最高的任务执行。\n\n第一节中的问题，在10000000个元素中选出前100名(在N个元素中选前M个元素)，维护一个优先队列(长度为100)，每次把最小的移除，遍历完成后，最后剩下的100个元素就是前100个元素。\n\n### 完整工程\n\nhttps://gitee.com/settlezxy/algorithm_and_data_structure.git\n\n","categories":["算法与数据结构"]},{"title":"string操作总结(不定期更新)","url":"//www.xingyuzhao.ltd/blog/2020/06/25/string操作总结/","content":"\n总结一下C++中string的常见用法，包括但不局限于：\n\n1. 初始化\n2. string对象上的操作（包括取子串）\n3. 查找/删除/替换\n4. 与数值的相互转换\n\n<!-- more-->\n\n### 初始化\n\n```cpp\n//默认初始化，s1为空\nstring s1;\n//用s1初始化s2\nstring s2(s1);\n//s3为字面值\"value\"的副本，直接初始化\nstring s3(\"value\");\n//与上述等价，不同之处在于这里是拷贝初始化\nstring s3 = \"value\";\n//类似vector，n个'c'组成字符串s4\nstring s4(n, 'c');\n```\n\n### string对象上的操作\n\n```cpp\n//从is读取一行给s，返回is\ngetline(is, s)\n//判断是否为空\ns.empty()\n//s的长度\ns.size() / s.length()\n//完全一样则相等，大小写敏感\ns1 == s2\n//字典序比较，大小写敏感\n<, <=, >, >=\n```\n\n#### 两个string对象相加\n\n```cpp\nstring s1 = \"hello, \", s2 = \"world\";\n//s3 = \"hello, world\"\nstring s3 = s1 + s2;\n//s1 = \"hello, world\"\ns1 += s2; \t\t\t\n```\n\n#### 字面值和string对象相加\n\n当把string对象和字符字面值及字符串字面值混在一起相加时，必须确保`+`的两侧运算对象至少有一个string：\n\n```cpp\nstring s4 = s1 + \",\"; \t\t//√\nstring s5 = \"hello\" + \",\"\t//×\n```\n\n注意：字符串字面值与string是不同类型，以上操作是自动进行了类型转换。\n\n#### 处理string对象中的字符\n\n```cpp\n//定义在头文件cctype中\nisalnum(c)\t\t//当c是字母或数字为真\nisalpha(c)\t\t//当c是字母为真\niscntrl(c)\t\t//当c是控制字符为真，ASCII码前32\nisdigit(c)\t\t//当c是数字为真\nislower(c)\t\t//当c是小写字母为真\nisupper(c)\t\t//当c是大写字母为真\nispunct(c)\t\t//当c是标点符号为真\nisspace(c)\t\t//当c是空白为真(空格，回车，制表符等)\ntolower(c)\t\t//如果c为大写字母，转为小写，否则不变\ntoupper(c)\t\t//如果c为小写字母，转为大写，否则不变\n```\n\n**范围for语句**\n\n```cpp\n//打印s1的所有内容\n//仅访问时可加上const\n//简化类型名可用auto代替\nstring s1 = \"zhaoxingyu\"\nfor(string s : s1)\n    cout << s;\n//同时修改s1内容全为a\nfor(string &s : s1)\n    s = 'a';\n```\n\n#### 取子串\n\n```cpp\n//s.substr(pos, n)\n//取s中从pos开始长度为n的子串\n//如果pos超过s.size()则抛出out_of_range异常\n//如果pos+n超过s.size()则substr自动调整n值，只拷贝到s末尾\nstring s = \"hello world\";\nstring str = s.substr(0, 5);\t//str = \"hello\"\n```\n\n### 查找/删除/替换\n\n#### 查找函数find\n\nstring中的find函数返回子串/字符第一次出现在母串中的位置，类型为size_t，可以把它视为一个范围很大的int类型。如果没有找到，返回一个npos标记，是一个很大的整数。\n\n```cpp\n//size_t pos = s.find(str, startPos)\n//str为子串或字符，startPos为开始搜索位置，缺省时默认为0\nstring s = \"hello world\";\nstring str = \"world\";\nsize_t pos = s.find(str);\t//等价于pos = s.find(\"world\")，返回6\nsize_t pos1 = s.find(\"c\");\t//等价于pos1 = s.find('c')，返回npos\n```\n\n还可以从后往前反向查找，函数为rfind\n\n``` cpp\nstring s = \"hello world\";\nsize_t pos = s.rfind(\"l\"); \t//返回9\n```\n\n其他一些find函数\n\n```cpp\n//返回子串首次出现位置\npos = s.find_first_of(str);\n//返回字串最后出现位置\npos = s.find_last_of(str);\n```\n\n#### 删除函数erase\n\nstring中提供的成员函数可以用来删除字符串中的字符，这里主要介绍`erase`方法\n\n1. 从给定位置pos开始删除长度为n的字符串\n\n```cpp\n//basic_string & erase(size_type pos=0, size_type n=npos)\n//n缺省时默认为删除到末尾\nstring s = \"hello world\";\ns.erase(5);\t\t\t//从位置5开始全部删除，s = \"hello\";\ns.erase(0, 2); \t\t//从0开始删除长度为2的字符串，s = \"llo\"\n```\n\n2. 删除迭代器位置处的单个字符，并返回**下个元素**的迭代器\n\n```cpp\n//iterator erase(const_iterator position)\nstring s = \"hello world\";\ns.erase(s.begin());\t//s = \"ello world\";\n```\n\n3. 删除迭代器`[first, last)`区间的所有字符,返回一个指向被删除的最后一个元素的下一个字符的迭代器.\n\n```cpp\n//iterator erase(const_iterator first, const_iterator last)\nstring s = \"hello world\";\n//iter = s.erase(s.begin() + 1, s.end() - 1); \t //可以直接删除\nauto iter = s.erase(s.begin() + 1, s.end() - 1); //删除并返回迭代器\n//s = \"hd\"，*iter = d\n```\n\n**注：也可以用pop_back()删除最后一个元素**\n\n#### 替换函数replace\n\n1. 用str替换指定字符串从pos开始长度为len的字符串\n\n```cpp\n//string& replace(size_t pos, size_t len, const string& str)\n//注意这里的str必须是string对象，不能是char字符\nstring s = \"hello world\";\nstring str = \"#\";\ns = s.replace(0, 5, str);\t//s = \"# world\"\n```\n\n2. 用str替换迭代器起始位置到终止位置的字符串\n\n```cpp\n//string& replace(const_iterator it1, const_iterator it2, const string& str)\n//注意这里的str必须是string对象，不能是char字符\nstring s = \"hello world\";\nstring str = \"#\";\ns = s.replace(s.begin(), s.begin() + 5, str);\t//s = \"# world\"\n```\n\n3. 用重复n次的c字符替换从指定位置pos长度为len的字符串\n\n```cpp\n//string& replace(size_t pos, size_t len, size_t n, char c)\n//注意这里的c必须是char类型，不能是string对象\nstring s = \"hello world\";\nchar c = '#';\ns = s.replace(0, 5, 2, c);\t//s = \"## world\"\n```\n\n4. 用重复n次的c字符替换从指定迭代器位置到终止位置的字符串\n\n```cpp\n//string& replace (const_iterator i1, const_iterator i2, size_t n, char c)\n//注意这里的c必须是char类型，不能是string对象\nstring s = \"hello world\";\nchar c = '#';\ns = s.replace(s.begin(), s.end(), 2, c);\t//s = \"## world\"\n```\n\n### string与int相互转换\n\n#### string转int\n\n```cpp\n# string直接转int\n//stoi(s, pos, b) 把字符串s从pos开始转换成b进制的int\nstring s = \"123\";\n//a = 123，如果里面含有非数字，那么从pos开始连续的字符串型数字才会被转为数字\nint a = stoi(s, 0, 10);\t\n//stol(s,p,b)\t把字符串s从p开始转换成b进制的long\n//stoul(s,p,b)\t把字符串s从p开始转换成b进制的unsigned long\n//stoll(s,p,b)\t把字符串s从p开始转换成b进制的long long\n//stoull(s,p,b)\t把字符串s从p开始转换成b进制的unsigned long long\n//stof(s,p)\t\t把字符串s从p开始转换成float\n//stod(s,p)\t\t把字符串s从p开始转换成double\n//stold(s,p)\t把字符串s从p开始转换成long double\n# char型数组字符串转int\n//c_str()函数返回一个指向正规C字符串的指针, 内容与string串相同\n//string类对象的成员函数c_str()把string转换为c类型字符串\n//如果string不是数字形式的则转换结果为0\n//实际步骤为string->char*->int\nstring s = \"123\";\nint a = atoi(s.c_str());\t//a = 123\n```\n\n#### int转string\n\n```cpp\n//to_string(val) 将val转为string\nint val = 100;\nstring s = to_string(val);\t//s = \"100\"\n```\n\n### 参考\n\n查找/删除/替换：\n\n1. https://www.cnblogs.com/xzxl/p/7243490.html\n\n2. https://blog.csdn.net/cai_niaocainiao/article/details/81260902?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase\n\n3. https://blog.csdn.net/u010472607/article/details/80431604\n\n字符串转数值\n\nhttps://blog.csdn.net/sinat_40872274/article/details/81367815","tags":["string"],"categories":["C++"]},{"title":"git提交失败-ssh重置","url":"//www.xingyuzhao.ltd/blog/2020/06/25/git提交失败-ssh重置/","content":"\n一段时间不提交，就容易出现“Please make sure you have the correct access rights and the repository exists.”，原因是ssh key出现了问题，记录一下解决方法，省的每次都去百度细节。\n\n**用手机热点可以提交成功，尚不清楚原因(updated：2020/7/15)** \n\n<!-- more -->\n\n1. 重新配置身份信息\n   * `git config --global user.name \"yourname\"`\n   * `git config --global user.email \"your@email.com\"`\n\n2. 删除.ssh文件夹下的所有文件\n3. 输入命令`ssh-keygen -t rsa -C \"your@email.com\"`，出现提示直接回车\n4. 此时在.ssh文件夹下生成**id_rsa**和**id_rsa.pub**，用记事本打开**id_rsa.pub**并复制所有内容\n5. 打开github主页并进入到`SSH and GPG keys`中，新建shh，把刚才复制的内容粘贴进去\n6. 输入命令`ssh -T git@github.com`，出现提示输入`yes`，不是直接回车\n7. **重新打开**git进行提交\n\n以上所有git操作都在hexo根目录下\n\n","categories":["Hexo"]},{"title":"LeetCode139-单词拆分","url":"//www.xingyuzhao.ltd/blog/2020/06/25/LeetCode139-单词拆分/","content":"\n这道题我一开始没想到可以用动态规划来做，先试着用暴力做了，结果通过34/36，看似只剩下3个没通过，但是问题很大，不好修改，具体原因后面分析。\n\n### 题目描述\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n* 拆分时可以重复使用字典中的单词。\n* 你可以假设字典中没有重复的单词。\n\n<!--more -->\n\n<img src=\"LeetCode139-单词拆分\\示例.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这道题题意还是挺好理解的，给定字符串s，从字典wordDict中取出单个或多个字符串（可重复），最后如果可以拼接成s，返回true，反之返回false。\n\n一开始暴力的思路就是遍历字典中的每一个字符串看是否出现在s中，如果出现了，那么用#号来代替s中的出现的子串，并且继续搜索，搜索完成后，将s中的#号清空，如果此时s为空，那么代表s可以被拆分，返回true。但是对于以下的例子：\n\n```cpp\ns = \"abbbc\"\nwordDict = [\"ab\", \"b\", \"bbc\"]\n```\n\ns可以由ab+bbc组合而成。但是用暴力法，只会搜到ab+b+b，再往下就搜索不到了，返回了false。如果需要修改，要用到dfs的思想，进行深搜，但是不剪枝也容易超时。在看了答案之后才知道可以用动态规划来做，而且很好理解。\n\n按照第二个示例来说，`s = \"applepenapple\", wordDcit = [\"apple\", \"pen\"]`，从s的第一个字符`a`开始遍历：\n\n* 当等于`apple`时候，存在与字典中，就可以认为在第5个字符处是可以拆的；\n* 继续向后遍历，当得到`applepen`时，增加了字符串`pen`，且它存在于字典中，所以可以知道第8个字符处也是可拆的；\n* 直到`applepenapple`时，增加了`apple`，且它存在于字典中，最后一个字符即第13个字符处可拆。\n\n从上述分析可以知道，如果最后一个字符处可拆，就返回true，否则返回false。\n\n#### 定义dp数组\n\n首先，`dp`数组应该是`bool`类型，长度为`s.length()+1`，并且`dp[0]=true`，否则dp数组全是false。**dp数组含义为当前位置的字符是否可以被拆分**。\n\n如果`dp[j]`代表当前位置，`dp[i]`是某一起始位置，那么就需要检查从`i`到`j`的子串是否在字典中，如果在，并且`dp[i]`是可以拆分的，那么`dp[j]`也应该是可以拆分的，否则`dp[j]=false`。\n\n#### 状态转移方程\n\n根据上面的分析，可以容易写出以下的状态转移方程，同时将字典放入`unordered_map`中方便查找：\n\n```cpp\ndp[j] = dp[i] && dict.count(s.substr(i, j - i))\n```\n\n#### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        // 存入字典，方便查找\n        unordered_map<string, bool> dict; \n        for(const auto &word : wordDict) dict[word] = true;\n        // 初始化dp数组，如果s为空，返回true\n        // 实际上只初始化dp[0]即可\n        bool *dp = new bool[s.length() + 1];\n        dp[0] = true; \n        for(int i = 1; i <= s.length(); i++){\n            dp[i] = false;\n        }\n        for(int j = 1; j <= s.length(); j++){\n            for(int i = j - 1; i >= 0; i--){\n                dp[j] = dp[i] && dict.count(s.substr(i, j - i));\n                if(dp[j]) break;\n            }\n        }\n        return dp[s.length()];    \n    }\n};\n```\n\n### 参考资料\n\nhttps://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-ju-jue-zhuang-xcong-jian-dan-de-xi/\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode739-每日温度","url":"//www.xingyuzhao.ltd/blog/2020/06/13/LeetCode739-每日温度/","content":"\n这次主要学习一下单调栈这种数据结构，同时用此数据结构解决739题\n\n### 题目描述\n\n请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n\n<!--more -->\n\n### 单调栈\n\n先学习一下单调栈这种数据结构，单调栈就是栈的基础上使用一定的逻辑，使栈中的元素单调递增或者递减，一般只处理一种典型的问题，叫做**下一个更大的元素**，这个问题是说：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。举例如下：给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。\n\n可以这样思考，把数组元素想象成人，如何求2的下一个更大的元素呢？如果2的下一个人比2还低或者一样高，那么就会被2遮挡住，直到第一个比他高的人，他挡不住了，就是答案。\n\n<img src=\"LeetCode739-每日温度\\人.jpg\" style=\"zoom: 30%;\" />\n\n代码实现如下：\n\n```cpp\nvector<int> nextGreaterElement(vector<int>& nums) {\n    vector<int> ans(nums.size()); // 存放答案的数组\n    stack<int> s;\n    for (int i = nums.size() - 1; i >= 0; i--) { // 倒着往栈里放\n        while (!s.empty() && s.top() <= nums[i]) { // 判定个子高矮，nums在s之前\n            s.pop(); // 矮个起开，反正也被挡着了。。。\n        }\n        ans[i] = s.empty() ? -1 : s.top(); // 这个元素身后的第一个高个\n        s.push(nums[i]); // 入栈\n    }\n    return ans;\n}\n```\n\n<img src=\"LeetCode739-每日温度\\栈.png\" style=\"zoom: 80%;\" />\n\n以上图是栈中元素的变化情况，只有当新的高个子来临，才会有出栈的操作。\n\n### 分析及代码实现\n\n上面已经把单调栈阐述了一遍，本题唯一的区别是要返回还需要多少天，而不是那天的温度，所以要用栈来存储一下温度的坐标，根据当前温度的坐标与栈顶温度坐标的差作为返回值。\n\n代码如下：\n\n```cpp\nvector<int> dailyTemperatures(vector<int>& T) {\n    vector<int> ans(T.size());\n    stack<int> s; // 这里放元素索引，而不是元素\n    for (int i = T.size() - 1; i >= 0; i--) {\n        while (!s.empty() && T[s.top()] <= T[i]) {\n            s.pop();\n        }\n        ans[i] = s.empty() ? 0 : (s.top() - i); // 得到索引间距\n        s.push(i); // 加入索引，而不是元素\n    }\n    return ans;\n}\n```\n\n### 扩展：如何处理循环数组\n\n同样是**下一个更大的元素**，现在假设给你的数组是个环形的，如何处理？\n\n给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 。通过取模运算符%就可以模拟环形数组的效果。\n\n```cpp\nvector<int> arr{1,2,3,4,5};\nint n = arr.length(), index = 0;\nwhile (true) {\n    cout << arr[index % n] << endl;\n    index++;\n}\n```\n\n一种方法是将数组翻倍，然后进行取模运算，节省空间的做法是直接将循环的坐标变成之前的2倍，代码看起来更容易理解，如下：\n\n```cpp\nvector<int> nextGreaterElements(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> res(n); // 存放结果\n    stack<int> s;\n    // 假装这个数组长度翻倍了\n    for (int i = 2 * n - 1; i >= 0; i--) {\n        while (!s.empty() && s.top() <= nums[i % n])\n            s.pop();\n        res[i % n] = s.empty() ? -1 : s.top();\n        s.push(nums[i % n]);\n    }\n    return res;\n}\n```\n\n### 参考资料\n\n《labuladong的算法小抄》 单调栈","tags":["单调栈"],"categories":["LeetCode"]},{"title":"LeetCode126-单词接龙2","url":"//www.xingyuzhao.ltd/blog/2020/06/07/LeetCode126-单词接龙2/","content":"\n这是今天的每日一题，难度为hard，不过与之前软挑赛的题目有很多相似之处，但是我还是没做出来，还是要多总结。最后看了别人的答案，用BFS+DFS才解决这个问题。\n\n### 题目描述\n\n给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：\n\n1. 每次转换只能改变一个字母。\n2. 转换过程中的中间单词必须是字典中的单词。\n\n**说明**：\n\n* 如果不存在这样的转换序列，返回一个空列表。\n* 所有单词具有相同的长度。\n* 所有单词只由小写字母组成。\n* 字典中不存在重复的单词。\n* 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。\n\n<!--more -->\n\n<img src=\"LeetCode126-单词接龙2\\示例.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n对于beginWord，一次只能更改一个字母，同时更改后的字母必须出现在wordList中，所以考虑将wordList放入一个集合中，方便每次判断是否在集合内。一开始我考虑的是直接用DFS解决，虽然DFS可以找到所有路径，然后从中挑选最短，但是它无法直接找到最短路径。如果某条长度过长，很容易出现超时，事实上在刷题群里很多大佬已经出现了这个问题，所以只能找别的办法。直接用BFS是可以的，在找最短的同时记录路径，我没有尝试，之后可以再试试，我选择了使用BFS+DFS的方法，使用BFS建立逆邻接表，使用DFS在逆邻接表基础上搜索答案。\n\n#### BFS建立逆邻接表\n\n使用BFS可以找到最短的路径，可以建立一个逆邻接表，用来表示可以到达当前节点的所有节点(当然这些节点必须是出现在wordList之中的)，**我们用curr代表当前节点，temp代表更改一个字母后的节点**。\n\n使用`unordered_map<string, vector<string>> neighbor`来表示，就拿示例1来说，如下图所示：<img src=\"LeetCode126-单词接龙2\\邻接表.png\"  />\n\n上图表示可以到达cog的节点为dog和log，具体的实现还是需要一个记录当前节点深度的哈希表`unordered_map<string, int> depth`，用来判断curr是否可达temp，同时省去一些不必要的遍历。具体操作是：首先队列弹出curr节点，检查和它相差一个字母的temp是否在wordList中出现，如果出现了：\n\n* 没有记录过(`depth[temp] = 0`)，记录`curr->temp`，同时`depth[temp] = depth[curr] + 1`，将temp入队\n* 记录过并且相邻(`depth[temp] = depth[curr] + 1`)，同时避免不是直接相邻的遍历，也避免了往回遍历。如下表，遍历改变pot一个字母的节点时，可能再次出现hot，但是此时`depth[hot] = 1 != depth[pot] + 1 = 2`所以避免了再次遍历hot。\n\n```nginx\n   hot\n /       \\\npot     hit\n \\        /\n    pit\n```\n\n通过以上步骤就可以建立逆临界表，代码实现如下：\n\n```cpp\nunordered_map<string,int> depth;\nunordered_map<string,vector<string>> neighbor;\n//将wordList添加至集合中\nunordered_set<string> wordSet(wordList.begin(),wordList.end());\n//使用BFS建立逆邻接表\ndepth[beginWord]=1;\nqueue<string> Q;\nQ.push(beginWord);\n//从begin到end建图\nwhile(!Q.empty()){\n\tstring curr=Q.front();\n\tQ.pop();\n    for(int i=0;i<curr.size();++i){\n        string temp=curr;\n        for(char c='a';c<='z';++c){\n            temp[i]=c;\n            //如果修改后的这个temp是在集合里面\n            if(wordSet.count(temp)){\n           \t\t//这个temp还没被添加进neighbor\n                if(depth[temp] == 0){ \n                    Q.push(temp);\n                    depth[temp]=depth[curr]+1;\t//更新深度\n                    neighbor[temp].push_back(curr);\n                    }\n                //已经被添加并且相邻\n                else if(depth[temp]==depth[curr]+1){\n\n                    neighbor[temp].push_back(curr);\n                }\n            }\n        }\n    }\n}\n```\n\n#### DFS从逆邻接表中搜索答案\n\n在上一步的BFS中已经存储了每个点的逆邻接点，我们从endWord沿着neighbor往回进行搜索，直到到达beginWord，将已经记录的路径(path)进行反转，存入最终的res中；如果无法到达，则DFS执行至末尾，将path重置(省去了使用&path引用的pop_back()操作)。代码如下：\n\n```cpp\nvoid dfs(string &begin, string &curr, vector<string> path, unordered_map<string, vector<string>> &neighbor, vector<vector<string>> &res){\n\tif(curr == begin){\n        path.push_back(curr);\n        reverse(path.begin(), path.end());\n        res.push_back(path);\n        return;\n    }\n    path.push_back(curr);\n    for(auto &word : neighbor[curr]){\n        dfs(begin, word, path, neighbor, res);\n    }\n}\n```\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n\n        vector<vector<string>> res;\n        //如果wordList中没有endWord，则返回空\n        if(find(wordList.begin(), wordList.end(), endWord) == wordList.end())\n            return res; \n        vector<string> path;\t//记录路径\n        unordered_map<string, int> depth;\t//记录深度\n        //存储节点的逆邻接\n        unordered_map<string, vector<string>> neighbor;\t\n        //将wordList添加至集合中\n        unordered_set<string> wordset(wordList.begin(), wordList.end());\n        depth[beginWord] = 1;\n        queue<string> Q;\n        Q.push(beginWord);\n        while(!Q.empty()){\n            string curr = Q.front();\n            Q.pop();\n            for(int i = 0; i < curr.size(); i++){\n                string temp = curr;\n                for(char c = 'a'; c <= 'z'; c++){\n                    temp[i] = c;\n                    //如果修改后的这个temp是在集合里面\n                    if(wordset.count(temp)){\n                        //这个temp还没被添加进neighbor\n                        if(depth[temp] == 0){\n                            Q.push(temp);\n                            depth[temp] = depth[curr] + 1;\t//更新深度\n                            neighbor[temp].push_back(curr);\n                        }\n                        //已经被添加并且相邻\n                        else if(depth[temp] == depth[curr] + 1){\n                            neighbor[temp].push_back(curr);\n                        }\n                    }\n                }\n            }\n        }\n        dfs(beginWord, endWord, path, neighbor, res);\n        return res;\n    }\n\n    void dfs(string &begin, string &curr, vector<string> path, unordered_map<string, vector<string>> &neighbor, vector<vector<string>> &res){\n        //当前点已经等于beginWord\n        if(curr == begin){\n            path.push_back(curr);\n            reverse(path.begin(), path.end());\t//反转\n            res.push_back(path);\n            return;\n        }\n        path.push_back(curr);\n        for(auto &word : neighbor[curr]){\n            dfs(begin, word, path, neighbor, res);\n        }\n\t\t//如果没有逆邻接，则执行完毕此函数后，path还原为上一次的值，即省去了pop_back()\n    }\n};\n```\n\n### 参考\n\nhttps://leetcode-cn.com/problems/word-ladder-ii/solution/zhe-ti-you-xie-nan-bie-ren-de-dai-ma-zuo-xia-zhu-s/","tags":["BFS","DFS"],"categories":["LeetCode"]},{"title":"LeetCode837-新21点","url":"//www.xingyuzhao.ltd/blog/2020/06/06/LeetCode837-新21点/","content":"\n### 题目描述\n\n爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：\n\n爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。\n\n当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？\n\n<!--more -->\n\n<img src=\"LeetCode837-新21点\\示例.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这道题一看不太明白什么意思，看过港片的都知道，在牌面加起来不大于21点时候，谁的牌面最大，谁就能获胜。这道题其实是求爱丽丝获胜的概率，不过点数为N，可以把规则复述一下：\n\n1. 她可以从`[1,W]`的牌中任意取一张，可以无限重复取，也就是说取到范围中某张牌的概率一直是`1/W`；\n2. 如果她手上的牌总额小于K时，她就会继续抽牌，大于等于K时就停止抽牌；\n3. 停止抽牌后，和N进行比较，当小于等于N时，她就获胜了，求获胜的概率。\n\n#### 定义dp数组的含义\n\n定义`dp[x]`为她手上牌面为x时，能获胜的概率。因为每次从`[1,W]`中抽取的机会都是均等的，所以`dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W]) `。x最多可以到`K-1`，因为x等于K时会停止抽牌，所以当抽牌结束后，她可能达到的最大牌面是`K-1+W`，开始时她的牌面为0，所以用长度为K+W的dp数组就够了，最后`dp[0]`，也就是爱丽丝还没有抽牌时的胜率就是最终答案。\n\n#### 状态转移方程\n\n其实上一步已经提到了状态转移方程：`dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W]) `，但是dp数组具体应该怎么算呢，可以把它看成一个填格子的游戏，如下图：\n\n<img src=\"LeetCode837-新21点\\image1.png\" style=\"zoom:80%;\" />\n\n将格子分为两个部分，在橘黄色的格子中，爱丽丝是可以抽牌的，而在蓝色的格子中是不可以的。我们每次需要W个格子的结果进行状态转移。\n\n在蓝色的格子中，对于`[K,K+W-1]`中小于等于N的值，相应的`dp[i]`概率就是1，反之为0，在初始化时候进行。\n\n<img src=\"LeetCode837-新21点\\image2.png\" style=\"zoom:80%;\" />\n\n接下来，从K-1处根据状态转移方程进行dp数组的计算。在计算K-2处概率值时，在上一步用一个中间变量`sumw`保存`[K,K+W-1]`的概率之和，这样新的概率和`sumw = sumw - dp[K-1+W] + dp[K-1]`，提高效率。这样从最右边橘黄色格子一直填到最左边，就是最后的结果dp[0]。\n\n#### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    double new21Game(int N, int K, int W) {\n        vector<double> dp(K + W, 0);\n        double sumw = 0;\n        for(int i = K; i <= K + W - 1; i++){\n            if(i <= N) dp[i] = 1;\n            sumw += dp[i];\n        }\n        for(int i = K-1; i >=0; i--){\n            dp[i] = (double)1 / W * sumw; //概率可能是小数，需要强制类型转换\n            sumw = sumw - dp[i+W] + dp[i]; \n            //这里就是减去最右边概率dp[i+W]，加上最左边概率dp[i]\n        }\n        return dp[0];\n    }\n};\n```\n\n### 参考资料\n\nhttps://leetcode-cn.com/problems/new-21-game/solution/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/\n\n\n\n","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode877-石子游戏","url":"//www.xingyuzhao.ltd/blog/2020/05/28/LeetCode877-石子游戏/","content":"\n### 题目描述\n\n亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。\n\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。\n\n<!--more -->\n\n<img src=\"LeetCode877-石子游戏\\877.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这个题其实一定是先手获胜，为了更具有一般性，假设**石头的堆数可以是任意正整数**，那么就能打破先手必定获胜的局面了，比如`piles = [1, 100, 3]`，先手不管拿1还是3，能够决胜的100都会被后手拿走，后手获胜。\n\n**博弈问题的难点在于，两个人要轮流进行选择，而且都很精明，应该如何编程表示这个过程呢？**首先明确 dp 数组的含义，只要找到「状态」和「选择」，一切就水到渠成了。\n\n#### 一、定义 dp 数组的含义\n\n先看一下dp数组的最终样子，再介绍其含义\n\n<img src=\"LeetCode877-石子游戏\\dp.png\" style=\"zoom:50%;\" />\n\n定义dp数组是二维的，并且每个单元包含first和second两个属性，将这两个属性简写为fir和sec。如按上图的数据，我们说 `dp[1][3].fir = 10`，`dp[0][1].sec = 3`。\n\n**以下是对 dp 数组含义的解释：**\n\n```cpp\ndp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。\ndp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。\n\n举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始\ndp[0][1].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。\ndp[1][3].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。\n```\n\n我们想求的答案是先手和后手最终分数哪个更大，按照这个定义也就是 `dp[0][n-1].fir`和`dp[0][n-1].sec`哪个更大。\n\n#### 二、状态转移方程\n\n要写状态转移方程，需要找到所有**状态**和每个状态可以做出的**选择**，然后择优。\n\n根据前面对 dp 数组的定义，**状态**显然有三个：**开始的索引 i，结束的索引 j，当前轮到的人。**\n\n```cpp\ndp[i][j][fir or sec]\n其中：\n0 <= i < piles.length\ni <= j < piles.length\n```\n\n对于这个问题的每个状态，可以做的**选择**有两个：**选择最左边的那堆石头，或者选择最右边的那堆石头。**\n\n这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？根据我们对 dp 数组的定义，很容易解决这个难点，**写出状态转移方程：**\n\n```cpp\ndp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)\nleft = piles[i] + dp[i+1][j].sec //选择最左边的石头堆\nright = piles[j] + dp[i][j-1].sec //选择最右边的石头堆\n# 解释：我作为先手，面对 piles[i...j] 时，有两种选择：\n# 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]\n# 在上一轮中，我是作为后手的；\n# 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]\n# 在上一轮中，我是作为后手的。\n\nif 先手选择左边:\n    dp[i][j].sec = dp[i+1][j].fir\nif 先手选择右边:\n    dp[i][j].sec = dp[i][j-1].fir\n# 解释：我作为后手，要等先手先选择，有两种情况：\n# 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]\n# 此时轮到我，我变成了先手；\n# 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]\n# 此时轮到我，我变成了先手。\n根据 dp 数组的定义，我们也可以找出base case，也就是最简单的情况：\n\ndp[i][j].fir = piles[i]\ndp[i][j].sec = 0\n其中 0 <= i == j < n\n# 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]，i != j时可以不需要初始化\n# 那么显然先手的得分为 piles[i]\n# 后手没有石头拿了，得分为 0\n```\n\n<img src=\"LeetCode877-石子游戏\\dp1.png\" style=\"zoom:50%;\" />\n\n这里需要注意一点，我们发现 base case 是斜着的，而且我们推算`dp[i][j]`时需要用到`dp[i+1][j]`和`dp[i][j-1]`:\n\n<img src=\"LeetCode877-石子游戏\\dp2.png\" alt=\"dp2\" style=\"zoom:50%;\" />\n\n```c++\n# 举例：若i = 0, j = 1\n# dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)\ndp[0][1].fir = max(piles[0] + dp[1][1].sec, piles[1] + dp[0][0].sec)\n    \t\t = max(3 + 0, 9 + 0) = 9\n# 先手选择右边第一堆\n# if 先手选择右边: dp[i][j].sec = dp[i][j-1].fir\ndp[0][1].sec = dp[0][0].fir = 3\ndp[0][1] = {9, 3}\n```\n\n所以说算法不能简单的一行一行遍历 dp 数组，**而要斜着遍历数组：**\n\n<img src=\"LeetCode877-石子游戏\\dp3.png\" style=\"zoom:50%;\" />\n\n如何斜着遍历二维数组是个问题，这里我不是很会，只是有个框架，具体的细节还需要再消化消化\n\n```c++\n# 遍历的是橘黄色的部分\nfor (int l = 2; l <= n; l++) {\n        for (int i = 0; i <= n - l; i++) {\n            int j = l + i - 1;\n            /*操作段*/\n        }\n}\n```\n\n#### 三、代码实现\n\n实现fir和sec这个单元可以用pair容器，也可以用`dp[n][n][2]`这种三维数组，我在这里使用了结构体。\n\n```c++\nclass Solution {\npublic:\n    struct Pair{\n        int fir;\n        int sec;\n        Pair() {};\n        Pair(int a, int b){\n            this->fir = a;\n            this->sec = b;\n        } \n    };\n    bool stoneGame(vector<int>& piles) {\n        int n = piles.size();\n        Pair** dp = new Pair*[n];\n        for(int i = 0; i < n; i++){\n            dp[i] = new Pair[n];\n        }\n        for(int i = 0; i < n; i++){\n            dp[i][i].fir = piles[i];\n            dp[i][i].sec = 0;\n        }\n\n        for(int l = 2; l <= n; l++){\n            for(int i = 0; i <= n - l; i++){\n                int j = l + i - 1;\n\n                int left = dp[i+1][j].sec + piles[i];\n                int right = dp[i][j-1].sec + piles[j];\n                if(left > right){\n                    dp[i][j].fir = left;\n                    dp[i][j].sec = dp[i+1][j].fir;\n                }\n                else{\n                    dp[i][j].fir = right;\n                    dp[i][j].sec = dp[i][j-1].fir;\n                }\n            }\n        }\n        if(dp[0][n-1].fir > dp[0][n-1].sec) return true;\n        return false;\n    }\n};\n```\n\n### 参考资料\n\n《labuladong的算法小抄》 动态规划之博弈问题","tags":["动态规划"],"categories":["LeetCode"]},{"title":"LeetCode300-最长上升子序列","url":"//www.xingyuzhao.ltd/blog/2020/05/26/LeetCode300-最长上升子序列/","content":"\n### 题目描述\n\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n<!--more -->\n\n<img src=\"LeetCode300-最长上升子序列\\sl.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n这是一道动态规划的经典入门题，这里的子序列不一定是连续的。比如示例中`[2, 3, 7, 101]`，只要是递增的，就是上升子序列，我需要找到这里面最长的上升子序列的长度。\n\n动态规划一般是由历史信息推断当前信息的，并且历史信息是是独立的子问题，相互之间不会影响。现在考虑一个dp数组，如果说dp[0]到dp[i-1]都可以得到了，如果可以推出dp[i]，就可以得到dp数组的全部结果。\n\n#### 一、定义dp数组的含义\n\n我们可以定义dp[i]表示以nums[i]这个数结尾的最长上升子序列的长度。举两个例子：\n\n<img src=\"LeetCode300-最长上升子序列\\ex1.png\" style=\"zoom:80%;\" />\n\n根据这个定义，最终结果(子序列的最大长度)就是dp数组中的最大值。\n\n#### 二、状态转移方程\n\n这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：\n\n我们已经知道了 dp[0]到dp[4] 的所有结果，我们如何通过这些已知结果推出 dp[5] 呢？\n\n<img src=\"LeetCode300-最长上升子序列\\ex2.png\" style=\"zoom:80%;\" />\n\n根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。\n\nnums[5] = 7，既然是递增子序列，我们只要找到前面那些结尾比 7 小的子序列，然后把 7 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。\n\n当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。\n\n```cpp\nfor (int j = 0; j < i; j++) {\n    if (nums[i] > nums[j]) \n        dp[i] = max(dp[i], dp[j] + 1);\n} \n# dp数组需要初始化为1，因为自己本身也算一个序列\n# 当i = 5时\n# nums[5] > nums[2] dp[5] = max{dp[5], dp[2] + 1} = max{1, 2} = 2\n# nums[5] > nums[3] dp[5] = max{dp[5], dp[3] + 1} = max{2, 2 + 1} = 3\n# nums[5] > nums[4] dp[5] = max{dp[5], dp[4] + 1} = max{3, 2 + 1} = 3\n# 所以dp[5] = 3\n```\n\n根据上述的状态转移公式，就可以得到dp数组的所有值，我们再取其中的最大值，就是答案。\n\n#### 三、代码实现\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        vector<int> dp(nums.size(), 1);\n\n        for(int i = 0; i < nums.size(); i++){\n            for(int j = 0; j < i; j++){\n                if(nums[i] > nums[j])\n                    dp[i] = max(dp[i],dp[j] + 1); \n                //dp[i]是指历史中的最大长度，否则后面的长度+1小于历史最大长度时，会覆盖\n            }\n        }\n        return *max_element(dp.begin(), dp.end());\n    }\n};\n```\n\n### 参考资料\n\n《labuladong的算法小抄》 动态规划设计：最长递增子序列","tags":["动态规划"],"categories":["LeetCode"]},{"title":"2020学习/工作计划","url":"//www.xingyuzhao.ltd/blog/2020/04/30/2020学习计划/","content":"\n### 概要\n\n1. 写在前面\n2. 疫情期间的工作\n3. 反思自己的不足\n4. 2020学习/工作计划\n\n<!--more -->\n\n#### 写在前面\n\n2020年已经过去了四分之一，我才意识到需要做一个全年计划。这几个月来，小计划不断，但是都没有很好的完成，并且很容易受到外界因素的干扰，自己不知道自己到底**需要做什么**，于是看似做了不少东西，但是意义不大。我觉得全年的学习生活应该有一个基调，一年中总是要完成一些事情的。来到西电读研是进一步的学习机会，我要抓住这个机会。\n\n#### 疫情期间都做了什么？\n\n1. 首先是帮助师兄改了一个polar码的scl译码方法，其实到现在我对其原理也不是很明白，只是知道代码怎么用...\n2. 开始刷leetcode的题目，目前大概刷了100+，还是有一定的作用的。完成了\n   - 数据结构部分：队列和栈，数组和字符串，二分查找(83%)，链表(46%)\n   - 算法：BFS，DFS，双指针\n   - C++中vector，map，set等容器的使用，发现自己掌握的真是冰山一角\n\n3. 阅读了机器学习的几篇论文，主要是了解了随机梯度下降(SGD)方法，后面还需要进一步学习\n4. 很有限的学习了机器学习，矩阵论相关的内容\n5. 参加了华为的软件精英挑战赛，西北赛区第十名，进入复赛\n\n#### 自己的不足\n\n真正认识自己的不足也是在比赛期间，当你看到你辛辛苦苦半个月做出来的成果别人只需要几天，并且成绩还比你好的多的时候，你就越发的感觉到自己的渺小，我后悔的事情太多了，本科时候没有参加ACM是最大的错误，无论是数学建模或者是电赛，对于以后要进军互联网来说都没有ACM的奖牌作用大。不过我也意识到了这是教育之间的差异，有些人在中学的时候就开始接触比赛了，到了大学继续比赛那肯定更加熟练。我在高中的时候谈到计算机估计想的就是装个软件，换个内存条什么的，编程这个词都不知道啥意思，更不用说参加信息类的比赛了。。。为社么别人可以做到那些，我做不到，这并不全是自己的问题，种一棵树从现在开始也不迟，**虽然已经知道和别人的差距很大，但是只要是能缩小差距，那就是自己的进步**！还有一年的时间，一年是很快的，而且还有实验室的事情需要忙，所以时间很紧迫，千万不能再浪费了！\n\n#### 2020学习/工作计划\n\n1. 继续刷leetcode，学习了新算法，新思路或者新的函数之后在博客中进行总结，至少一周一篇，并且要做好题目的分类，算法和思路在tags中注明算法/思路，函数在tags中注明函数，在分类中注明C++。其中保证每周做7题以上，对于过于简单的题不计算在内，书籍**《算法》**。\n2. 继续学习C++，把**《C++ Prime》**过一遍，每周在博客总结一次，标签：C++ Prime，分类：C++；辅助阅读**《STL源码剖析》**和**《Effective C++》**标签：书名，分类：C++\n3. **《计算机网络 自顶向下方法》**前四章内容\n4. **《UNIX 网络编程》《UNIX 环境高级编程》** 辅助书籍**《Unix/Linux 编程实践教程》**\n5. **《深入理解计算机系统》**三四章可以先不看\n6. 机器学习的相关课程：吴恩达机器学习基础课程，CS231n计算机视觉课程，适应阅读英文论文，加强英语的学习\n7. 积极参加有水平的比赛\n8. 阅读一本非专业的书籍，陶冶陶冶情操？\n\n","tags":["计划"],"categories":["生活随笔"]},{"title":"LeetCode17-电话号码的字母组合","url":"//www.xingyuzhao.ltd/blog/2020/02/16/LeetCode17-电话号码的字母组合/","content":"\n### 题目描述\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n已知数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n<!--more -->\n\n<img src=\"LeetCode17-电话号码的字母组合\\1.png\" style=\"zoom:80%;\" />\n\n### 分析\n\n字符串的长度不确定，所以用循环直接解决不实际；\n\n可以由下至上进行递归来求解，以“23”为例，如图：\n\n```mermaid\ngraph TD\nA[2] -->|a| B[3]\nA[2] -->|b| C[3]\nA[2] -->|c| D[3]\nB[3] -->|d| E[ad]\nB[3] -->|f| F[af]\nB[3] -->|g| G[ag]\nC[3] -->|d| H[bd]\nC[3] -->|f| I[bf]\nC[3] -->|g| J[bg]\nD[3] -->|d| K[cd]\nD[3] -->|f| L[cf]\nD[3] -->|g| M[cg]\n```\n\n记数字2为第0层，那么数字3为第1层，需要一个变量level，记录当前遍历数字的位置。递归表现在：如果选择了’a'，那么就需要再进行三次选择‘d’ ‘f’ ‘g’后才可以输出，再选择'b'，以此类推。即递归到最后一层，输出一次递归结果，全部递归完成，得到最终结果。\n\n具体算法如下：\n\n* 建立一个**map**，用来存储数字与其对应的字符串，当然，这里的数字是char类型。\n* 递归函数中，首先判断**level**，如果等于**digits**中数字的个数，那么将当前的结果并入**res**，然后返回。\n* 否则通过**digits**中的数字找到对应的字符串，然后遍历取出整个字符串，将每个字符串都加到当前的组合后面，再调用递归函数。\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        if(digits.empty()) return {};\n        map<char,string> num_str{{'2',\"abc\"},{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},\n                                {'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"}};\n        vector<string> res;\n        combin(digits,num_str,0,\"\",res);\n        return res;\n    }\n    void combin(string digits,map<char,string> num_str,int level,string out,vector<string> &res)\n    {\n        //递归\n        if(level == digits.length())\n        {\n            res.push_back(out);\n            return;\n        }\n        string buf = num_str[digits[level]];\n        for(int i=0;i<buf.length();i++)\n        {\n            combin(digits,num_str,level+1,out+buf[i],res);\n        }\n    }\n};\n```\n\n","tags":["递归"],"categories":["LeetCode"]},{"title":"转载：时间复杂度O(logn)意味着什么？（侵删）","url":"//www.xingyuzhao.ltd/blog/2020/01/01/转载：时间复杂度O-logn-意味着什么？（侵删）/","content":"\n<p>&nbsp;</p>\n<ul><li>原文地址：https://github.com/xitu/gold-miner/blob/master/TODO/what-does-the-time-complexity-o-log-n-actually-mean.md</li>\n\t<li>原文作者：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F%40maazrk\" rel=\"nofollow\">Maaz</a></li>\n\t<li>译文出自：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner\" rel=\"nofollow\">掘金翻译计划</a></li>\n\t<li>译者：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcdpath\" rel=\"nofollow\">cdpath</a></li>\n\t<li>校对者：<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fzaraguo\" rel=\"nofollow\">zaraguo (zaraguo)</a>,&nbsp;<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwhatbeg\" rel=\"nofollow\">whatbeg (Qiu Hu)</a></li>\n</ul><p>&nbsp;</p>\n\n<!-- more -->\n\n<p><em>友情提示：如果图片挂了，请翻墙或者点击原文地址阅读。</em></p>\n<p>&nbsp;</p>\n<p>预先知道算法的复杂度是一回事，了解其后的原理是另一件事情。</p>\n<p>&nbsp;</p>\n<p>不管你是计算机科班出身还是想有效解决最优化问题，如果想要用自己的知识解决实际问题，你都必须理解时间复杂度。</p>\n<p>先从简单直观的 O(1) 和 O(n) 复杂度说起。O(1) 表示一次操作即可直接取得目标元素（比如字典或哈希表），O(n) 意味着先要检查 n 个元素来搜索目标，但是 O(log n) 是什么意思呢？</p>\n<p>你第一次听说 O(log n) 时间复杂度可能是在学二分搜索算法的时候。二分搜索一定有某种行为使其时间复杂度为 log n。我们来看看是二分搜索是如何实现的。</p>\n<p>因为在最好情况下二分搜索的时间复杂度是 O(1)，最坏情况（平均情况）下 O(log n)，我们直接来看最坏情况下的例子。已知有 16 个元素的有序数组。</p>\n<p>举个最坏情况的例子，比如我们要找的是数字 13。</p>\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20191121164646526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70\"></p>\n<p>十六个元素的有序数组</p>\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20191121164704291.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70\"></p>\n<p>选中间的元素作为中心点（长度的一半）</p>\n<p><img alt=\"\" class=\"has\" height=\"191\" src=\"https://img-blog.csdnimg.cn/20191121164715238.jpeg\" width=\"628\"></p>\n<p>13 小于中心点，所以不用考虑数组的后一半</p>\n<p><img alt=\"\" class=\"has\" height=\"134\" src=\"https://img-blog.csdnimg.cn/20191121164726473.jpeg\" width=\"411\"></p>\n<p>重复这个过程，每次都寻找子数组的中间元素</p>\n<p>&nbsp;</p>\n<p><img alt=\"\" class=\"has\" height=\"101\" src=\"https://img-blog.csdnimg.cn/20191121164751215.jpeg\" width=\"285\"></p>\n<p><img alt=\"\" class=\"has\" height=\"91\" src=\"https://img-blog.csdnimg.cn/20191121164811565.jpeg\" width=\"223\"></p>\n<p>每次和中间元素比较都会使搜索范围减半。</p>\n<p>所以为了从 16 个元素中找到目标元素，我们需要把数组平均分割 4 次，也就是说，</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164824637.png\" width=\"288\"></p>\n<p>简化后的公式</p>\n<p>类似的，如果有 n 个元素，</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164908192.png\" width=\"301\"></p>\n<p>&nbsp;</p>\n<p>归纳一下</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164916433.png\" width=\"275\"></p>\n<p>分子和分母代入指数</p>\n<p><img alt=\"\" class=\"has\" height=\"141\" src=\"https://img-blog.csdnimg.cn/20191121164930660.png\" width=\"275\"></p>\n<p>等式两边同时乘以 2^k</p>\n<p><img alt=\"\" class=\"has\" height=\"100\" src=\"https://img-blog.csdnimg.cn/20191121164955503.png\" width=\"285\"></p>\n<p>最终结果</p>\n<p>现在来看看「对数」的定义：</p>\n<blockquote>\n<p>为使某数（底数）等于一给定数而必须取的乘幂的幂指数。</p>\n</blockquote>\n\n<p>也就是说可以写成这种形式</p>\n<p><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdnimg.cn/2019112116500667.png\" width=\"331\"></p>\n<p>对数形式</p>\n<p>所以 log n 的确是有意义的，不是吗？没有其他什么可以表示这种行为。</p>\n<p>就这样吧，我希望我讲得这些你都搞懂了。在从事计算机科学相关的工作时，了解这类知识总是有用的（而且很有趣）。说不定就因为你知道算法的原理，你成了小组里能找出问题的最优解的人呢，谁知道呢。祝好运！</p>","tags":["时间复杂度"],"categories":["转载"]},{"title":"链式栈","url":"//www.xingyuzhao.ltd/blog/2019/12/29/链式栈/","content":"\n### 本次学习要点\n\n1. 编写链式栈\n2. 括号匹配问题\n\n<!--more -->\n\n### 概述\n\n在程序中同时使用多个栈的情况下，使用链式栈不但可以提高存储效率，同时还可以达到共享存储空间的目的。\n\n链式栈的结构如图所示，一般都不使用头结点，而进行直接实现。\n\n<img src=\"链式栈\\结构图.png\" style=\"zoom: 50%;\" />\n\n#### 1. 结点类模板\n\n```c++\ntemplate<typename ElemType>\nstruct Node\n{\n\tElemType data;\n\tNode<ElemType> *next;\n\n\tNode();\n\tNode(ElemType item, Node<ElemType> *link);\n};\ntemplate<typename ElemType>\nNode<ElemType>::Node()\n{\n\tnext = NULL;\n}\ntemplate<typename ElemType>\nNode<ElemType>::Node(ElemType item, Node<ElemType> *link)\n{\n\tdata = item;\n\tnext = link;\n}\n```\n\n#### 2. 链式栈类模板\n\n```c++\ntemplate<typename ElemType>\nclass LinkStack\n{\nprotected:\n\tNode<ElemType> *top;//栈顶指针\n\tint count;//元素个数\n\npublic:\n\tLinkStack();//构造函数\n\tvirtual~LinkStack();//析构函数\n\tint Length() const;//栈的长度\n\tbool Empty() const;//栈是否为空\n\tvoid Clear();//清空栈\n\tvoid Traverse(void(*visit)(const ElemType&)) const;//对每个对象调用visit\n\tbool Push(const ElemType &e);//压栈\n\tbool Top(ElemType &e) const;//返回栈顶元素\n\tbool Pop(ElemType &e);//出栈\n\tLinkStack(const LinkStack<ElemType>&copy);//复制构造函数模板\n\tLinkStack<ElemType>&operator=(const LinkStack<ElemType>&copy);\n};\n```\n\n#### 3. 成员函数\n\n```c++\ntemplate<typename ElemType>\nLinkStack<ElemType>::LinkStack()\n{\n\ttop = NULL;\n\tcount = 0;\n}\ntemplate<typename ElemType>\nLinkStack<ElemType>::~LinkStack()\n{\n\tClear();\n}\ntemplate<typename ElemType>\nint LinkStack<ElemType>::Length() const\n{\n\treturn count;\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Empty() const\n{\n\treturn top == NULL;\n}\ntemplate<typename ElemType>\nvoid LinkStack<ElemType>::Clear()\n{\n\tElemType tmpElem;\n\twhile (!Empty())\n\t{\n\t\tPop(tmpElem);\n\t}\n}\ntemplate<typename ElemType>\nvoid LinkStack<ElemType>::Traverse(void(*visit)(const ElemType &)) const\n{\n\tNode<ElemType> *tmpPtr;\n\tLinkStack<ElemType> tmps;\n\tfor (tmpPtr = top; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\ttmps.Push(tmpPtr->data);\n\t}\n\tfor (tmpPtr = tmps.top; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\t(*visit)(tmpPtr->data);\n\t}\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Push(const ElemType &e)\n{\n\tNode<ElemType> *newTop = new Node<ElemType>(e, top);\n\tif (newTop == NULL)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\ttop = newTop;\n\t\tcount++;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Top(ElemType &e) const\n{\n\tif (Empty())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\te = top->data;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool LinkStack<ElemType>::Pop(ElemType &e)\n{\n\tif (Empty())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *old_top = top;\n\t\te = old_top->data;\n\t\ttop = old_top->next;\n\t\tdelete old_top;\n\t\tcount--;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nLinkStack<ElemType>::LinkStack(const LinkStack<ElemType> &copy)\n{\n\t//由栈copy构造新栈——复制构造函数模板\n\tif (copy.Empty())\n\t{\n\t\ttop = NULL;\n\t\tcount = 0;\n\t}\n\telse\n\t{\n\t\ttop = new Node<ElemType>(copy.top->data,copy.top);//栈顶\n\t\tcount = copy.count;\n\n\t\tNode<ElemType> *buttomPtr = top;//栈底\n\t\tfor (Node<ElemType>*tmpPtr = copy.top->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)//从copy中第二个值开始取，第一个已经被复制给top(buttomPtr)\n\t\t{\n\t\t\tbuttomPtr->next = new Node<ElemType>(tmpPtr->data,tmpPtr->next);\n\t\t\tbuttomPtr = buttomPtr->next;\n\t\t}\n\t}\n}\ntemplate<typename ElemType>\nLinkStack<ElemType>&LinkStack<ElemType>::operator=(const LinkStack<ElemType> &copy)\n{\n\t//将栈copy赋值给当前栈——重载赋值运算符\n\tif (&copy != this)\n\t{\n\t\tif (copy.Empty())\n\t\t{\t//copy为空\n\t\t\ttop = NULL;\n\t\t\tcount = 0;\n\t\t}\n\t\telse\n\t\t{\t//copy非空，复制栈\n\t\t\tClear();\n\t\t\ttop = new Node<ElemType>(copy.top->data,copy.top);\n\t\t\tcount = copy.count;\n\n\t\t\tNode<ElemType>*buttomPtr = top;\n\t\t\tfor (Node<ElemType>*tmpPtr = copy.top->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t\t\t{\n\t\t\t\tbuttomPtr->next = new Node<ElemType>(tmpPtr->data,tmpPtr-next);\n\t\t\t\tbuttomPtr = buttomPtr->next;\n\t\t\t}\n\t\t}\n\t}\n\treturn *this;\n}\n```\n\n#### 4. main()\n\n```c++\n#include<iostream>\n#include\"alg.h\"\nusing namespace std;\n\ntemplate<typename ElemType>\nvoid display(ElemType &e)\n{\n\tcout << e << \" \";\n}\n\nint main()\n{\n\tLinkStack<int> l1;\n\tint e1,e2;\n\tcout << \"输入的三个数分别为5，1，2\" << endl;\n\tl1.Push(5);\n\tl1.Push(1);\n\tl1.Push(2);\n\tcout << \"当前栈长为：\" << endl;\n\tcout << l1.Length() << endl;\n\tcout << \"弹出栈顶，返回值为：\" << endl;\n\tl1.Pop(e1);\n\tcout << e1 << endl;\n\tcout << \"当前栈长为：\" << endl;\n\tcout << l1.Length() << endl;\n\tl1.Top(e2);\n\tcout << \"返回当前栈顶元素：\\n\";\n\tcout << e2 << endl;\n\tcout << \"输出l1当前栈内元素(dir:bottom->top)：\\n\";\n\tl1.Traverse(display); cout << endl;\n\n\tLinkStack<int> l2(l1);\n\t//l2 = l1;//将l1复制给l2\n\n\tcout << \"输出l2当前栈内元素(dir:bottom->top)：\\n\";\n\tl2.Traverse(display); cout << endl;\n\treturn 0;\n}\n```\n\n测试结果如图：\n\n<img src=\"链式栈\\结果图.png\" style=\"zoom: 80%;\" />\n\n#### 问题\n\n设计一个算法判别用字符串表示的表达式中括号()[]{}是否配对出现，括号之间无优先级。\n\n算法思路：\n\n如果读入的字符为(、[、{，则进栈；\n\n若读入的字符为)，如果栈空则说明不匹配；栈顶括号为(，则出栈匹配，否则不匹配，此时栈顶为[、{或空；\n\n若读入的字符为]，如果栈空则说明不匹配；栈顶括号为[，则出栈匹配，否则不匹配，此时栈顶为(、{或空；\n\n若读入的字符为}，如果栈空则说明不匹配；栈顶括号为{，则出栈匹配，否则不匹配，此时栈顶为[、(或空；\n\n若读入其他字符，则继续读入；\n\n扫描完各字符后，如栈为空则匹配，否则不匹配（括号数量为偶数，但括号不一定匹配）\n\n代码如下：\n\n```c++\nbool match(char *s)\n{\n\tLinkStack<char> tmps;//临时栈\n\tchar tmpch;//临时字符\n\n\tfor (unsigned int i = 0; i < strlen(s); i++)\n\t{\n\t\tif (s[i] == '(' || s[i] == '[' || s[i] == '{')\n\t\t{\n\t\t\ttmps.Push(s[i]);\n\t\t}\n\t\telse if (s[i] == ')')\n\t\t{\n\t\t\tif (tmps.Empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmps.Top(tmpch), tmpch == '(')\n\t\t\t{\n\t\t\t\ttmps.Pop(tmpch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == ']')\n\t\t{\n\t\t\tif (tmps.Empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmps.Top(tmpch), tmpch == '[')\n\t\t\t{\n\t\t\t\ttmps.Pop(tmpch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == '}')\n\t\t{\n\t\t\tif (tmps.Empty())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (tmps.Top(tmpch), tmpch == '{')\n\t\t\t{\n\t\t\t\ttmps.Pop(tmpch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (tmps.Empty())\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n```\n\n测试代码：\n\n```c++\ncout << \"无括号优先级\" << endl;\nchar *s1 = \"{a*[c+d*(e+f)]}\";\nchar *s2 = \"{a*[c+d*[e+f)]}\";\nstring True = \"匹配\";\nstring False = \"不匹配\";\nstring s1_result = match(s1) ? True : False;\nstring s2_result = match(s2) ? True : False;\ncout << s1 << '\\t';\ncout << s1_result << endl;\ncout << s2 << '\\t';\ncout << s2_result << endl;\n```\n\n运行结果：\n\n<img src=\"链式栈\\匹配问题.png\"  />\n\n","categories":["算法与数据结构"]},{"title":"循环链表解决约瑟夫问题","url":"//www.xingyuzhao.ltd/blog/2019/11/18/循环链表解决约瑟夫问题/","content":"\n### 本次学习要点\n\n1. 编写循环链表，由单链表修改得到\n2. 使用循环链表解决约瑟夫问题\n\n<!--more -->\n\n### 循环链表与单链表的不同之处\n\n循环链表是另外一种线性表链式存储结构，它的节点结构与单链表相同，与单链表不同的是在循环链表中的表尾节点的`next`不为空（NULL），而是指向头节点，所以循环链表为空的条件为`head->next==head`,如图所示：\n\n<img src=\"循环链表解决约瑟夫问题\\非空循环链表.png\" style=\"zoom: 67%;\" />\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a)非空循环链表\n\n<img src=\"循环链表解决约瑟夫问题\\空循环链表.png\" style=\"zoom: 67%;\" />\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(b)空循环链表\n\n循环链表的操作与线性表的操作基本相同，只是将算法中的循环条件改为`temPtr`是否等于头指针，以下给出与单链表不同之处：\n\n```c++\ntemplate<typename ElemType>\nNode<ElemType> * SimpleCircLinkList<ElemType>::GetElemPtr(int position) const\n//返回指向第position个结点的指针,时间复杂度O(n)\n{\n\tif (position == 0)\n\t{\n\t\treturn head;\n\t}\n\t\n\tNode<ElemType> *tmpPtr = head->next; //用tmpPtr遍历线性表以查找第position个结点\n\tint pos = 1;\t\t\t\t\t//tmpPtr所指结点的位置\n\n\twhile (tmpPtr != head&&pos < position)\n\t{\t//顺指针向后查找，直到tmpPtr指向第position个结点\n\t\ttmpPtr = tmpPtr->next;\n\t\tpos++;\n\t}\n\tif (tmpPtr != head&&pos == position)\n\t{\t//查找成功\n\t\treturn tmpPtr;\n\t}\n\telse\n\t{\t//查找失败\n\t\treturn NULL;\n\t}\n}\n```\n\n```c++\ntemplate<typename ElemType>\nint SimpleCircLinkList<ElemType>::Length() const\n//返回线性表元素的个数\n{\n\tint count = 0;\n\tfor (Node<ElemType> *tmpPtr = head->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\tcount++;\n\t\tif (tmpPtr == head) break;\n\t}\n\treturn count;\n}\n```\n\n```c++\ntemplate<typename ElemType>\nbool SimpleCircLinkList<ElemType>::Empty() const\n//如果线性表为空，返回true，否则返回false\n{\n\treturn head->next == head;\n}\n```\n\n```C++\ntemplate<typename ElemType>\nvoid SimpleCircLinkList<ElemType>::Traverse(void(*visit)(const ElemType &)) const\n//依次对线性表每个元素调用函数(*visit)\n{\n\tfor (Node<ElemType> * tmpPtr = head->next; tmpPtr != head; tmpPtr = tmpPtr->next)\n\t{\n\t\t(*visit)(tmpPtr->data);\n\t}\n}\n```\n\n### 循环列表解决与瑟夫问题\n\n问题描述：一个旅行社要从n个旅客中选出一名旅客，为他提供免费旅行服务，选择方法是让n个旅客围成一个圆圈，然后从信封中取出一张纸条，用上面写着的正整数m(m<n)作为报数值，第一个人从1开始一个人一个人按顺时针报数，报到第m个旅客时，令其出列。然后从下一个人开始，从1顺时针报数，报到第m个游客时，再令其出列，如此下去，直到只剩下一个人为止。此人即为优胜者。如n=8，m=3，出列的顺序为3、6、1、5、2、8、4，最初编号为7的游客获得免费旅行服务。（待更新算法详细步骤）\n\n```\n//main.cpp\n#include<iostream>\n#include\"alg.h\"\n\nusing namespace std;\n\ntemplate<typename ElemType>\nvoid display(ElemType &e)\n{\n\tcout << e << \" \";\n}\n//循环链表解决约瑟夫问题\nint main()\n{\n\tSimpleCircLinkList<int> la;\n\tint n = 8, m = 3;\n\tint position = 1;\n\tint out, winer;\n\tfor (int k = 1; k <= n; k++)\n\t{\n\t\tla.Insert(k, k);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tif (position > la.Length())\n\t\t\t{\n\t\t\t\tposition = 1;\n\t\t\t}\n\t\t\tposition++;\n\t\t}\n\t\tposition--;\n\t\tla.Delete(position, out);\n\t\tcout << out << \" \";\n\t}\n\t\tla.GetElem(1, winer);\n\t\tcout << endl << \"优胜者：\" << winer << endl;\n\t\treturn 0;\n}\n```\n\n执行结果：\n\n<img src=\"循环链表解决约瑟夫问题\\结果.png\"  />\n\n","categories":["算法与数据结构"]},{"title":"单链表的基本操作","url":"//www.xingyuzhao.ltd/blog/2019/10/30/单链表的基本操作/","content":"\n### 本次学习要点（更新于2019.12.3）\n\n1. 掌握线性表的抽象数据类型\n2. 掌握链表的基本操作\n3. 学习链表的较复杂的操作\n\n<!--more -->\n\n### 线性表的抽象数据类型\n\n1. `int Length() const`\n\n* 初始条件：线性表已存在\n* 操作结果：返回线性表中元素的个数\n\n2. `bool Empty() const`\n\n* 初始条件：线性表已存在\n* 操作结果：判断线性表是否为空\n\n3. `void Clear()`\n\n* 初始条件：线性表已存在\n* 操作结果：清空线性表\n\n4. `void Traverse(void(*visit)(const ElemType &))`\n\n* 初始条件：线性表已存在\n* 操作结果：对每个元素调用函数(*visit)\n\n5. `bool GetElem(int position,ElemType &e) const`\n\n* 初始条件：线性表已存在，1<=position<=Length()\n* 操作结果：用e返回第position处的元素值\n\n6. `bool SetElem(int position,const ElemType &e) `\n\n* 初始条件：线性表已存在，1<=position<=Length()\n* 操作结果：设置第position处的元素值为e\n\n7. `bool Delete(int position,ElemType &e)`\n\n* 初始条件：线性表已存在，1<=position<=Length()\n* 操作结果：删除第position个元素，并用e返回其值，长度减少1\n\n8. `bool Insert(int position,const ElemType &e)`\n\n* 初始条件：线性表已存在，1<=position<=Length()+1\n* 操作结果：在第position前插入元素e，长度加1\n\n#### 思考\n\n函数声明中的`const`是什么作用？在不同位置的意思分别是什么？\n\n答：在成员函数后的`const`指常成员函数，不能更改类成员变量的值；在变量前的`const`指常变量，在函数体重不能更改变量值。\n\n### 单链表的实现\n\n```c++\n//文件名alg.h\n//结点结构体模板\ntemplate<typename ElemType>\nstruct Node\n{\n//数据成员\n\tElemType data;\n\tNode<ElemType> *next;\n//构造函数模板\n\tNode();//无参数的构造函数模板\n\tNode(ElemType item, Node<ElemType> *link);//已知数据元素和后继指针建立结构\n};\n//结点模板的实现部分\ntemplate<typename ElemType>\nNode<ElemType>::Node()\n//构造后继指针为空的结点\n{\n\tnext = NULL;\n}\ntemplate<typename ElemType>\nNode<ElemType>::Node(ElemType item, Node<ElemType> *link)\n//构造一个数据元素为item和后继指针为link的结点\n{\n\tdata = item;\n\tnext = link;\n}\n//线性链表简单实现为数据成员只有头指针，成员函数模板与顺序表相似\n\n\n//简单线性链表类模板\ntemplate<typename ElemType>\nclass SimpleLinkList\n{\nprotected:\n\tNode<ElemType> *head;\n\tNode<ElemType> *GetElemPtr(int position) const;//返回指向第position个结点的指针\npublic:\n\tSimpleLinkList();\n\tvirtual~SimpleLinkList();\n\tint Length() const;\n\tbool Empty() const;\n\tvoid Clear();\n\tvoid Traverse(void(*visit)(const ElemType &)) const;\n\tbool GetElem(int position, ElemType &e) const;\n\tbool SetElem(int position, const ElemType &e);\n\tbool Delete(int position, ElemType &e);\n\tbool Insert(int position, const ElemType &e);\n\tSimpleLinkList(const SimpleLinkList<ElemType> &copy);\n\tSimpleLinkList<ElemType>&operator=(const SimpleLinkList<ElemType>&copy);\n};\n\n//辅助函数模板的实现\t\ntemplate<typename ElemType>\nNode<ElemType> * SimpleLinkList<ElemType>::GetElemPtr(int position) const\n//返回指向第position个结点的指针,时间复杂度O(n)\n{\n\tNode<ElemType> *tmpPtr = head; //用tmpPtr遍历线性表以查找第position个结点\n\tint pos = 0;\t\t\t\t\t//tmpPtr所指结点的位置\n\n\twhile (tmpPtr != NULL&&pos < position)\n\t{\t//顺指针向后查找，知道tmpPtr指向第position个结点\n\t\ttmpPtr = tmpPtr->next;\n\t\tpos++;\n\t}\n\tif (tmpPtr != NULL&&pos == position)\n\t{\t//查找成功\n\t\treturn tmpPtr;\n\t}\n\telse\n\t{\t//查找失败\n\t\treturn NULL;\n\t}\n}\n\n//成员函数的实现\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>::SimpleLinkList()\n//构造一个空链表\n{\n\thead = new Node<ElemType>;\n}\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>::~SimpleLinkList()\n//销毁线性表\n{\n\tClear();\n\tdelete head;\n}\ntemplate<typename ElemType>\nint SimpleLinkList<ElemType>::Length() const\n//返回线性表元素的个数\n{\n\tint count = 0;\n\tNode<ElemType> *tmpPtr;\n\tfor (tmpPtr = head->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\tcount++;\n\t}\n\treturn count;\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::Empty() const\n//如果线性表为空，返回true，否则返回false\n{\n\treturn head->next == NULL;\n}\ntemplate<typename ElemType>\nvoid SimpleLinkList<ElemType>::Clear()\n//清空线性表\n{\n\tElemType tmpElem;\n\twhile (!Empty())\n\t{\t//线性表非空，删除第一个元素\n\t\tDelete(1, tmpElem);\n\t}\n}\ntemplate<typename ElemType>\nvoid SimpleLinkList<ElemType>::Traverse(void(*visit)(const ElemType &)) const\n//依次对线性表每个元素调用函数(*visit)\n{\n\tfor (Node<ElemType> * tmpPtr = head->next; tmpPtr != NULL; tmpPtr = tmpPtr->next)\n\t{\n\t\t(*visit)(tmpPtr->data);\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::GetElem(int position, ElemType &e) const\n//当线性表存在第position给元素时，用e返回其指，返回true，否则\n//返回false\n{\n\tif (position<1 || position>Length())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> * tmpPtr;\n\t\ttmpPtr = GetElemPtr(position);\n\t\te = tmpPtr->data;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::SetElem(int position, const ElemType &e)\n//将线性表的第position个位置的元素设置成e，position合法时返回true，否则\n//返回false\n{\n\tif (position<1 || position>Length())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *tmpPtr;\n\t\ttmpPtr = GetElemPtr(position);\n\t\ttmpPtr->data = e;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::Delete(int position, ElemType &e)\n{\n\tif (position<1 || position>Length())\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *tmpPtr;\n\t\ttmpPtr = GetElemPtr(position - 1);//取出指向第position-1个结点的指针\n\t\tNode<ElemType> *nextPtr;          //新建指针nextPtr\n\t\tnextPtr = tmpPtr->next;           //新指针为tmpPtr的后继\n\t\ttmpPtr->next = nextPtr->next;     //删除position处的结点\n\t\te = nextPtr->data;                //用e返回其值\n\t\tdelete nextPtr;                   //释放被删结点\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nbool SimpleLinkList<ElemType>::Insert(int position, const ElemType &e)\n{\n\tif (position<1 || position>Length() + 1)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tNode<ElemType> *tmpPtr;\n\t\ttmpPtr = GetElemPtr(position - 1);\n\t\tNode<ElemType> *nextPtr;\n\t\tnextPtr = new Node<ElemType>(e, tmpPtr->next);\n\t\ttmpPtr->next = nextPtr;\n\t\treturn true;\n\t}\n}\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>::SimpleLinkList(const SimpleLinkList<ElemType> &copy)\n{\n\t//未写\n}\ntemplate<typename ElemType>\nSimpleLinkList<ElemType>&SimpleLinkList<ElemType>::operator=(const SimpleLinkList<ElemType>&copy)\n{\n\t//未写\n}\n\n```\n\n```c++\n//文件名main.cpp\n//单链表的基本操作\n#include<iostream>\n#include\"alg.h\"\n\nusing namespace std;\n\ntemplate<typename ElemType>\nvoid display(ElemType &e)\n{\n\tcout << e << \" \";\n}\n\nint main()\n{\n\tSimpleLinkList<int> test;//定义空链表\n\tSimpleLinkList<int> test1;//定义空链表\n\tint e = 0;//返回值\n\tint e1 = 50;\n\tint n = 8;\n\tfor (int k = 1; k <= n; k++)//建立链表\n\t{\n\t\ttest.Insert(k, k);\n\t}\n\tcout << \"建立的链表:\";\n\ttest.Traverse(display);//显示数据\n\tcout << endl;\n\n\tcout << \"链表的长度为:\";\n\tcout << test.Length() << endl;\n\n\tcout << \"链表是否为空(0代表非空):\";\n\tcout << test.Empty() << endl;\n\n\tcout << \"返回第五个位置的值(5)(GetElem):\";\n\ttest.GetElem(5, e);//返回第五个值\n\tcout << e << endl;\n\n\tcout << \"设置第五个位置的值(50)(SetElem):\";\n\ttest.SetElem(5, e1);//设置第五个值为e1;\n\tcout << e1 << endl;\n\n\tcout << \"输出当前的链表:\";\n\ttest.Traverse(display);//显示数据\n\tcout << endl;\n\t\n\tcout << \"删除第5个元素:\";\n\ttest.Delete(5, e);\n\tcout << \"删除的元素值为:\" << e << endl;\n\n\tcout << \"链表的长度为:\";\n\tcout << test.Length() << endl;\n\n\tcout << \"输出当前的链表:\";\n\ttest.Traverse(display);//显示数据\n\tcout << endl;\n\n\tcout << \"清空线性表(Clear)\";\n\ttest.Clear();\n\tcout << endl;\n\n\tcout << \"链表是否为空(0代表非空):\";\n\tcout << test.Empty() << endl;\n\n\treturn 0;\n}\n```\n\n执行结果：\n\n<img src=\"单链表的基本操作\\基本操作.png\" style=\"zoom: 50%;\" />\n\n### 一个问题\n\n已知线性表la和lb中的数据元素按值递增，现在要将la和lb合并成新的线性表lc，使lc中的数据元素扔递增有序。","categories":["算法与数据结构"]},{"title":"Git的基本使用(三)-Stash、Checkout和Reset（未完待续）","url":"//www.xingyuzhao.ltd/blog/2019/10/08/Git的基本使用-Stash、Checkout和reset/","content":"\n### 本次学习要点\n\n`Stash、Checkout`和`Reset`指令\n\n经常有这样的事情发生，当你正在进行项目中某一部分的工作，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点，所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 `git stash`。\n\n<!--more -->\n\n### 基本指令-stash\n\n```\ngit stash \n#保存当前工作区所有内容到当前分支的储藏栈的栈顶(工作区会变为最后一次commit时的内容)。\ngit stash apply \n#应用当前分支的储藏栈栈顶的储藏到工作区。\ngit stash apply <stash id> \n#应用当前分支的储藏栈指定位置的储藏到工作区，例如git stash apply stash@{0}。\ngit stash list \n#列出当前分支的储藏栈详细信息。\ngit stash drop <stash id> \n#移除当前分支的储藏栈指定位置的储藏。\ngit stash pop\n#从git栈中获取到最近一次stash进去的内容，恢复工作区的内容，获取之后，会删除栈中对应的stash。\n```\n\n- 唯一需要注意的是，`git stash apply`并不会改变储藏栈的内容，所以如果你觉得之前的那个储藏没用了，请手动调用`git stash drop <stash id>`清理储藏栈。特别的，`git stash pop`会自动应用当前分支的储藏栈栈顶的储藏到工作区，并将其从栈顶移除。\n\n#### 练习一\n\n1. 新建一个仓库，建立文件`test.txt`，随意键入一段内容（123），提交。\n2. 创建分支`feature`，修改`test.txt`文件内容（321）然后运行`git status`可以看到以下中间过程的内容：\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n3. 现在你想切换分支，但是你还不想提交你正在进行中的工作；所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 `git stash`。\n\n```\n$ git stash\nSaved working directory and index state WIP on master: 7ac5b3d master注释\n#test.txt中的内容变成了“123”，工作区内容变为最后一次提交的内容\n```\n\n4. 这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 `git stash list`：\n\n```\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\n```\n\n5. 切换到分支`feature`并且使用指令`git stash pop`，观察`test.txt`中的内容变化。\n\n```\n$ git stash pop\nOn branch feature\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (81b72af21b8037e4b185820e3a86b78d95b9f8d8)\n#文档内容变成了“321”，也就是master修改后的工作区，但现在pop命令把储藏的栈顶弹出，是在feature分支进行工作的，此时feature的工作区是修改后的文档。\n```\n\n6. 再次使用指令`git stash`，然后`git checkout master`，再次使用`git stash pop`，那么修改后的文档就是在`master`工作区了，最后直接查看工作区状态。\n\n```\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n#### 练习二\n\n在练习一基础上使用`apply`指令：\n\n1. 当前工作区为`master`，`test.txt`中的内容是修改后的321，使用`stash`指令存储当前的工作区。\n\n```\n$ git stash\nSaved working directory and index state WIP on master: 7ac5b3d master注释\n\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\n```\n\n2. 此时`test.txt`内容为（123），修改其内容（1234），然后进行`add`（不进行此操作也可以），再进行一次存储。\n\n```\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\nstash@{1}: WIP on master: 7ac5b3d master注释\n#现在堆栈里存储了两个工作区，工作区空\n$ git status\nOn branch master\nnothing to commit, working tree clean\n#test.txt中内容变为“123”\n```\n\n3. 使用`apply`指令将堆栈中的栈顶应用到当前工作区，当前的栈顶应该是`stash@{0}`，所以内容应该恢复为“1234”。\n\n```\n$ git stash apply\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n#打开test.txt发现内容已经变回“1234”\n$ git stash list\nstash@{0}: WIP on master: 7ac5b3d master注释\nstash@{1}: WIP on master: 7ac5b3d master注释\n#堆栈中的内容不会主动删除，继续保存下来\n```\n\n4. 修改`test.txt`中的“1234”为“123”（初始工作区），然后使用`git stash apply`指令将栈中的`stash@{1}`（修改后的工作区，内容是“321”）返回到工作区，此时文档内容是“321”。\n\n```\n$ git stash apply stash@{1}\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n#test.txt中的内容是“321”\n```\n\n#### 一些标注\n\n##### 练习一\n\n初始工作区的`test.txt`内容为：123\n\n第一次修改后的`test.txt`内容为：321\n\n最后`master`中的`stash@{0}`内容为：321\n\n##### 练习二\n\n初始`master`中的`stash@{0}`内容为：321\n\n修改初始的工作区中的`test.txt`内容为：1234\n\n进行存储，`stash@{0}->stash@{1}`，内容为：321\n\n此时`stash@{0}`中的内容为：1234\n\n本次练习最后结果改回了“1234”。","tags":["Git"],"categories":["Git"]},{"title":"Git的基本使用(二) --撤销提交","url":"//www.xingyuzhao.ltd/blog/2019/09/29/Git的基本使用-撤销提交/","content":"\n### 本次学习要点：\n\nGit的撤销提交操作\n\n与回滚不同，如果认为某次的提交是有问题的，需要撤回这次的提交，应该怎么做呢？\n\n<!-- more -->\n\n### 主要指令\n\n```\n$ git revert <SHA ID>\n```\n\n该指令可以直接把某一次的提交取消，所有在本次提交中发生变更的文件都会还原回上一次提交的内容。因为针对同一分支master操作，所以会产生冲突（解决方法见一），解决冲突后，再将文件放入缓存区，进行提交.\n\n```\n$ git reset <之前某个版本ID>\n$ git reset --hard <之前某个版本ID>\n```\n\n上述指令是不安全的撤销方式。当年使用`git reset`来重置记录时，所有**在此之后**的记录都将永久消失，**但是还会保留当前的提交**。如果带上参数`--hard`，还会直接清空工作区里的所有变更（**如果此时做了修改但是还没有提交，那么直接就会被撤销到未改动的时刻**），直接使工作区内容撤销到指定提交的时刻，是一种比较暴力的撤销方式。\n\n### 实现1\n\n1. 新建一个库，新建一个文件`text.txt` ，输入内容“1”，保存后提交。并以此类推，一共得到三次提交，内容分别是“1”，“2”，“3”，使用`git log`查看提交历史。\n\n```\n$ git log\ncommit 51df17687ea6bb6a53ed24d614ddcfe9e455e9f9\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:47:24 2019 +0800\n\n    3.第三次提交\n    sign off:<543040659@qq.com>\n\ncommit 9e71ea1c78ff7aa910959e02acb44e8e3373a805\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:46:38 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 3d4d2f3a3f44c0fcb5d4357d85abf5cb33304e97\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:45:09 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n2. 使用`git revert`进行撤销操作，撤销到第二次提交，那么结果应该是显示第一次提交的内容，即“1”。\n\n```\n$ git revert 9e71ea\n```\n\n3. 此时产生了冲突，打开`test.txt`，将第三次的提交内容删除，留下内容“1”，不解决冲突无法提交。然后再加入缓存区，进行提交（当时没有记录，这里只有进行操作的指令，没有结果，失策失策）。\n\n```\n$ git add test.txt\n$ git status\t#可以看到test.txt加入了缓存，可以不写\n$ git commit\n```\n\n4. 最后使用`git log`查看提交记录，会产生一个新的提交记录，并且之前记录都会存在，所以是一种安全的撤销操作。\n\n```\n$ git log\ncommit 57124efed6dd52b7224c3e3b5ee0be7042cee27b (HEAD -> master)\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:50:18 2019 +0800\n\n    Revert \"2.第二次提交\"\n\n    This reverts commit 9e71ea1c78ff7aa910959e02acb44e8e3373a805.\n\ncommit 51df17687ea6bb6a53ed24d614ddcfe9e455e9f9\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:47:24 2019 +0800\n\n    3.第三次提交\n    sign off:<543040659@qq.com>\n\ncommit 9e71ea1c78ff7aa910959e02acb44e8e3373a805\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:46:38 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 3d4d2f3a3f44c0fcb5d4357d85abf5cb33304e97\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:45:09 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n总结：revert指令可以使版本撤销到之前的某一次提交，并且在那次提交中改变的部分都会还原为上一次提交的内容（比如撤销到第二次，那么内容就会还原为第一次提交的内容），并且在这个过程中会产生冲突，按照我的理解，产生冲突之后修改的txt文档，决定了还原的最终结果。如果我在解决冲突的过程中，留下了“3”，而不是“1”，那么还原的内容应该是“3”。\n\n### 实现2\n\n1. 新建一个库，新建一个文件`text.txt` ，输入内容“1”，保存后提交。并以此类推，一共得到三次提交，内容分别是“1”，“2”，“3”，使用`git log`查看提交历史。\n\n```\n$ git log\ncommit 9e541291495cfe4c57b62f699ff17deed99bd853 (HEAD -> master)\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:56:32 2019 +0800\n\n    3.第三次提交\n    sign off:<543040659@qq.com>\n\ncommit 1d0feb4e586995b4d1bd6e3d78af5350b2726b68\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:55:37 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 47bbd152043e6f2de771413739b2fccadad6893d\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:54:36 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n2. 使用`git reset`进行撤销操作1。先改变`test.txt`中的内容，开始应为“3”，现在可以任意改变，假如改为“5”，然后执行指令（撤销到第三次），并得到以下结果：\n\n```\n$ git reset 9e5412\nUnstaged changes after reset:\nM       test.txt\n```\n\n执行的结果就是`test.txt`文档中的”5”又变成了“3”，成功！\n\n3. 使用`git reset`进行撤销操作2。直接执行指令撤销到第二次，得到以下结果：\n\n```\n$ git reset 1d0fe\nUnstaged changes after reset:\nM       test.txt\n#再执行git log指令\n$ git log\ncommit 1d0feb4e586995b4d1bd6e3d78af5350b2726b68 (HEAD -> master)\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:55:37 2019 +0800\n\n    2.第二次提交\n    sign off:<543040659@qq.com>\n\ncommit 47bbd152043e6f2de771413739b2fccadad6893d\nAuthor: zhaoxingyu <543040659@qq.com>\nDate:   Thu Sep 26 21:54:36 2019 +0800\n\n    1.第一次提交\n    sign off:<543040659@qq.com>\n```\n\n可以发现第三次的提交已经没有了，所以是一种不安全的撤销，此时`test.txt`中应为“2”，如果你此时修改了文档中的内容，再执行以上步骤，文档中的内容修改会被继续保留下来，与下面的有所不同。\n\n4. 使用`git reset --hard`进行撤销操作。如前所述，此指令会直接撤销到**当前提交时刻的原始版本**（以撤销到第二次为例）。\n\n```\n$ git reset --hard 1d0feb\nHEAD is now at 1d0feb4 2.第二次提交\n```\n\n我们一开始在第二次提交时，里面的内容就是“2”，现在执行上述指令后，`test.txt`中就是“2”。如果把`test.txt`中的内容修改为“5”，甚至你已经进行add指令加入到了缓存，但是没有提交，那么再次执行上述hard指令后，文档中的内容又变成了“2”，你之前的所有修改都白费了，所以要特别小心，慎用！\n\n## 最后\n\n这次的练习收获很多，不过只是很浅显的一些理解，不免有些理解不到位或者容易产生歧义的地方。如果有哪里有疑问，可以和我联系进行讨论。\n\n","tags":["Git"],"categories":["Git"]},{"title":"Git的基本使用(一)","url":"//www.xingyuzhao.ltd/blog/2019/09/26/Git的基本使用（一）/","content":"\n### 本次学习要点：\n\n1. 如何建立一个本地仓库\n2. 设置你的个性化信息\n3. 工作区与缓存区\n\n4. 提交与历史\n\n<!--more -->\n\n### 如何建立一个本地仓库\n\n有两种方法，一种是Git GUI，一种是Git Bush，第一步都是先建立一个空文件夹。\n\n1. 在文件夹空白处右键，选择Git GUI Here，点击Create New Repository，OK。\n2. 在文件夹空白处右键，选择Git Bush Here，输入`git init`，OK。\n\n### 设置你的个性化信息\n\nGit是一个团队开发工作，你对团队的每次贡献都会有相应的记录。所以此时你应该告诉这个仓库你的个人信息，主要包括两个：\n\n- **邮箱** 邮箱是别人联系你的途径，当然你应当留意你的个人隐私问题，这个内容我们会放到之后的几章中讲，此处你可以随便填写一个邮箱。\n- **姓名** 你可以填真名或是化名，取决于你的实际开发和协作环境。\n\n1. 打开Git Bash界面，我们输入指令`git config --help`来查看`git config`的帮助文档。【–help】是一个很有用的指令参数，当你忘了某个指令的使用方法，你都可以如此进行搜寻。\n2. 我们可以看到如此一行：\n\n```\nuser.email\n\tYour email address to be recorded in any newly created commits. \n\tCan be overridden by the GIT_AUTHOR_EMAIL, GIT_COMMITTER_EMAIL, \n\tand EMAIL environment variables. See git-commit-tree(1).\n```\n\n* 使用`git config user.email <你的Email>`进行邮箱的设置。同样的，`git config user.name <你的名字或化名>`可以设置该本地仓库的所有者姓名。\n\n* 当你设置完这些值之后，可以打开`.gti/config`，查看到你刚刚所设置邮箱和姓名。\n\n### 工作区与缓存区\n\n<img src=\"Git的基本使用（一）\\GitFlow.jpg\" style=\"zoom:50%;\" />\n\n​                                                            上图来源于西电腾讯TIC-Git的培训资料\n\nGit的基本工作流程，目前阶段我们需要知道三个区域：**工作区域**、**缓存区**和**仓库记录**。其中，仓库记录是由**历史记录**构成的，因为历史纪录是一棵树状结构，也被叫做(History Tree)。\n\n- 用户在工作区域(或工作目录)中进行的修改会被Git检测到，通过`add`指令被提交到缓存区。\n- 缓存区中的文件是工作区域中的文件的一次快照备份，你之后在工作区域中做任何修改都不会影响到缓存区中同一个文件的内容，除非再次使用`add`指令更新缓存区。\n- 当你觉得工作做得差不多了，你可以使用`commit`指令，把缓存区中的文件提交到仓库记录，仓库记录会自动生成一次历史记录。你可以简单认为仓库记录就是个数据库，一次`commit`指令就是一次数据库写入请求。从此之后该记录将一直留在仓库中，你也可以把工作区中的数据文件随时回滚到当时提交的这个版本。\n- 缓存区中的文件在并未被`commit`之前，并不会被写入记录，也就意味着有些操作会导致你丢失缓存区的文件快照备份(如`checkout`等)。\n\n```\ngit add <filename>\n#添加文件至缓存区\ngit status\n#查看当前缓存区的状态\ngit commit\n#将缓存区的文件提交到仓库\n```\n\n### 提交与历史\n\n* 打开Git Bash，键入`git log`，即可查看提交的历史纪录。如果对当前提交不满意，找到上一次提交的版本ID值(SHA ID)，键入命令`git checkout <SHA ID>`，此时版本便已回滚到了之前那个版本，当前的提交会直接删除掉。\n\n* 在Vim界面中，按字母a来进入编辑模式，编辑完毕后按ESC键退出编辑，再按大写锁定，按ZZ来退出Vim。\n\n编辑模板\n\n提交了xxxx\n\n来自：Zxy<<543040659@qq.com>>","tags":["Git"],"categories":["Git"]},{"title":"Sublime Text3安装Emmet插件遇到的问题及解决","url":"//www.xingyuzhao.ltd/blog/2019/09/16/Sublime-text3安装Emmet插件遇到的问题及解决/","content":"\n# 写在前面\n\n最近对前端的知识准备进行一个入门，首先学习一下html文档的写法，第一步就是选择一个合适的开发工具。<!-- more -->当然，html文件也可以用记事本的方式进行编写，不过在尝试了记事本编写之后还是放弃了，缩进或者格式都得自己来，无疑是给自己徒增烦恼。\n\n在进行一番查看之后，选择了Sublime Text3这款工具来编写html文件，这款工具目前也比较流行，具体的好处就是可以带很多插件，提高你写代码的效率。这里附上ST3的下载网址：\n\nhttp://www.sublimetext.com/3\n\n# 为什么使用Emmet这个插件？\n\n在没有安装Emmet之前，Sublime Text的使用貌似和记事本没有什么不同，也是得自己写结构，区别就是颜色好看了些，而安装了Emmet之后就不同了，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度，可以直接使用 !+tab 快速得到一个标准的html5文档，如下图所示：\n\n<img src=\"Sublime-text3安装Emmet插件遇到的问题及解决\\ST界面.png\" style=\"zoom:50%;\" />\n\n# 安装Emmet插件\n\n这里已经默认你安装了Package Control，这个组件是用来安装/删除插件和其他一些功能要用到的（目前我就用到了安装和删除两个功能）。\n\n## 自动安装法\n\n这个方法就是看你运气，不过过程一定是正确的，但由于各种原因（墙、网络之类的）安装不成功的大有人在，所以先写一下自动安装法。\n\n1. 在Sublime Text3的主页面按**CTRL+SHIFT+P**打开Package Control\n2. 输入**install**，选择第一个回车\n3. 这时候会让你选择需要安装的插件，你输入**Emmet**，选择第一个回车即可\n4. 左下角会显示下载PyV8，在提示**PyV8 binary successfully loaded**即安装完成\n5. 重启Sublime Text3，安装完成！\n\n当然，一般人像我运气一样的，这样是成功不了的（坏笑）。\n\n## 手动安装法\n\n### 1.安装PyV8\n\n在你安装Emmet时，你可能出现下面这种错误提示：\n\n***Sublime Text Error while loading PyV8 binary: exit code 1 Try to manually install Pyv8 form https://github.com/emetio/pyv8-binaries***\n\n出现这种情况的原因就是下载PyV8这个包不成功，那么你就得手动去下载，这个里也把网址给你了，如下：https://github.com/emmetio/pyv8-binaries 选择合适你电脑的版本去下载，这个必须记住，不然可能会用不了，我第一次就犯了这个错误。因为我电脑装了python3.7，所以我选择了 **pyv8-win64-p3**，我把下载地址也贴出来，不过因为gtihub是国外的网站，所以下载会很慢，链接如下：\n\nhttps://github.com/emmetio/pyv8-binaries/raw/master/pyv8-win64-p3.zip\n\n下载好了之后，对它进行解压，得到下面这个文件：\n\n<img src=\"Sublime-text3安装Emmet插件遇到的问题及解决\\pyv8.png\" style=\"zoom:80%;\" />\n\n接下来按照以下的步骤做就ok了：\n\n1. 打开Sublime Text\n2. 依次选择首选项 -> 浏览插件目录（我的汉化了，不然是Preferences ->Browse Packages）\n3. 新建PyV8文件夹\n4. 在PyV8文件夹把上图中的文件复制过来\n5. 重启Sublime Text\n\n现在你就可以在ST3中使用Emmet的功能了，不过还有运气不好的人，还是不能用，比如说我，那么继续往下看。\n\n### 2.手动安装Emmet\n\n如果你还是无法使用Emmet，但是你在首选项菜单中的Package Settings还能看到Emmet的身影，然而那只是个空壳，继续进入插件目录，你会发现没有与Emmet相关的文件夹的存在，那么你就需要自己手动安装Emmet。下载地址如下（下载也比较慢，但是只有200k左右）：\n\nhttps://codeload.github.com/sergeche/emmet-sublime/zip/master\n\n下载好了之后，继续进入插件目录（首选项 -> 浏览插件目录），把解压后的文件放进去，如图：\n\n<img src=\"Sublime-text3安装Emmet插件遇到的问题及解决\\emmet.png\" style=\"zoom:50%;\" />\n\n接下来你再重启ST就行了，需要注意的是，如果你没有装PyV8，那么你打开ST之后它会自动再一次下载这个包，同样可能出现1中的问题，那么你可以先把PyV8装好，再手动安装Emmet，重启之后就大功告成，终于装好啦！我属于运气最差的那种，不好的都让我遇到了，刚接触花了几个小时才弄明白，虽然最后成功了，我还是流下了没有技术的眼泪。。。","tags":["html","Sublime Text"],"categories":["前端学习入门"]},{"title":"一个测试文档","url":"//www.xingyuzhao.ltd/blog/2019/09/06/一个测试文档/","content":"\n目前没有特别需要写的东西，就收藏几个网站，便于之后写文章时查阅语法\n\n<!-- more -->\n\n参考网站：\n\n[1]https://www.jianshu.com/p/56d99a3049a5\n\n[2]https://blog.csdn.net/u014061630/article/details/81359144\n\n记录一下: [我的博客](https://www.xingyuzhao.ltd)\n\n**使用该`<!-- more -->`标志来控制文章的摘要预览，因为这种方式可以让摘要也按照css文件中的样式来渲染。如果使用了自动摘要的功能，你会发现文章摘要是一大团没有样式的文本，很是难看。**\n\n","tags":["Markdown语法"],"categories":["Hexo"]},{"title":"使用hexo遇到的问题及解决方案","url":"//www.xingyuzhao.ltd/blog/2019/09/05/使用hexo遇到的问题及解决方案/","content":"使用hexo遇到的问题及解决\n\n<!-- more -->\n\n#### 上传步骤\n\n1. hexo generate\n2. hexo server (http://localhost:4000/)\n3. hexo deploy\n\n#### 公式的显示问题\n\n公式内换行使用`//`时，会被识别成转义字符，需要再加上`//`，故需要使用`////`。\n\n如果使用**kramed**对公式进行渲染，会导致序号的显示出现问题，所以又改了回来，继续使用**marked**。","categories":["Hexo"]}]