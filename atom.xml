<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>工欲善其事，必先利其器</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2021-02-25T14:16:51.518Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Zxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++模板与泛型编程（三）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/24/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/24/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-02-24T04:11:34.000Z</published>
    <updated>2021-02-25T14:16:51.518Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>重载与模板</li><li>可变参数模板</li><li>模板特例化</li></ol><a id="more"></a><h4 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h4><h5 id="编写重载模板"><a href="#编写重载模板" class="headerlink" title="编写重载模板"></a>编写重载模板</h5><p>在调试中可能用到的一组函数，每个函数都返回一个给定对象的 <code>string</code> 表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line"><span class="built_in">ostringstream</span> ret;</span><br><span class="line">ret &lt;&lt; t;</span><br><span class="line"><span class="keyword">return</span> ret.str(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个打印指针的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line"><span class="built_in">ostringstream</span> ret;</span><br><span class="line">ret &lt;&lt; <span class="string">"pointer: "</span> &lt;&lt; p; <span class="comment">// 打印指针本身的值</span></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">ret &lt;&lt; <span class="string">" "</span> &lt;&lt; debug_rep(*p); <span class="comment">// 打印p指向的值</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret &lt;&lt; <span class="string">" null pointer"</span>; <span class="comment">// 或指出p为空</span></span><br><span class="line"><span class="keyword">return</span> ret.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此函数不能打印字符指针</strong>。</p><ol><li>只能匹配第一个版本：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hi"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>两个版本都可匹配，而第二个精确匹配，选择第二个：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(&amp;s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="多个可行模板"><a href="#多个可行模板" class="headerlink" title="多个可行模板"></a>多个可行模板</h5><p>当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。</p><h5 id="非模板和模板重载"><a href="#非模板和模板重载" class="headerlink" title="非模板和模板重载"></a>非模板和模板重载</h5><p>对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</p><h5 id="重载模板与类型转换"><a href="#重载模板与类型转换" class="headerlink" title="重载模板与类型转换"></a>重载模板与类型转换</h5><p>C 风格字符串指针和字符串常量，考虑调用 <code>cout &lt;&lt; debug_rep(&quot;hi world!&quot;) &lt;&lt; endl</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debug_rep(<span class="keyword">const</span> T&amp;); <span class="comment">// T被绑定到char[10]</span></span><br><span class="line">debug_rep(T*); <span class="comment">// T被绑定到const char</span></span><br><span class="line">debug_rep(<span class="keyword">const</span> <span class="built_in">string</span>&amp;); <span class="comment">// 要求从const char*到string的类型转换</span></span><br></pre></td></tr></table></figure><h5 id="缺少声明可能导致程序行为异常"><a href="#缺少声明可能导致程序行为异常" class="headerlink" title="缺少声明可能导致程序行为异常"></a>缺少声明可能导致程序行为异常</h5><p>在定义任何函数之前，<strong>需要声明所有重载的函数版本</strong>，否则编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</p><h4 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h4><p>可变参数模板：接受<strong>可变数目</strong>参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>。</p><p>参数包有两种：</p><ol><li>模板参数包，表示零个或多个模板参数；</li><li>函数参数包，表示零个或多个函数参数。</li></ol><p>在一个模板参数列表中，<code>class...</code> 或 <code>typename...</code> 指出接下来的参数表示零个或多个类型的列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure><p>编译器从函数的实参推断模板参数类型，对于可变参数模板，编译器同时推断包中参数的数目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; <span class="built_in">string</span> s = <span class="string">"how now brown cow"</span>;</span><br><span class="line"><span class="comment">// void foo(const int&amp;, const string&amp;, const int&amp;, const double&amp;);</span></span><br><span class="line">foo(i, s, <span class="number">42</span>, d); <span class="comment">// 包中有三个参数</span></span><br><span class="line"><span class="comment">// void foo(const string&amp;, const int&amp;, const int&amp;, const char[3]&amp;);</span></span><br><span class="line">foo(s, <span class="number">42</span>, <span class="string">"hi"</span>); <span class="comment">// 包中有两个参数</span></span><br><span class="line"><span class="comment">// void foo(const double&amp;, const string&amp;);</span></span><br><span class="line">foo(d, s); <span class="comment">// 包中有一个参数</span></span><br><span class="line"><span class="comment">// void foo(const char[3]&amp;);</span></span><br><span class="line">foo(<span class="string">"hi"</span>); <span class="comment">// 空包</span></span><br></pre></td></tr></table></figure><h6 id="sizeof…运算符"><a href="#sizeof…运算符" class="headerlink" title="sizeof…运算符"></a>sizeof…运算符</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 类型参数的数目</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h5><p>可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">// 此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> os &lt;&lt; t; <span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">os &lt;&lt; t &lt;&lt; <span class="string">", "</span>; <span class="comment">// 打印第一个实参</span></span><br><span class="line"><span class="keyword">return</span> print(os, rest...); <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个版本的 <code>print</code> 负责终止递归并打印最后一个实参，第二个版本的 <code>print</code> 是可变参数版本，它打印绑定到 <code>t</code> 的实参，并调用自身来打印函数参数包中的剩余值。</p><p>对于 <code>print(cout, i, s, 42)</code>，递归会执行如下：</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/调用.png"><p>对于最后一个调用，两个函数提供同样好的匹配。但是<strong>非可变参数模板</strong>比<strong>可变参数模板</strong>更特例化，因此编译器选择非可变参数模板。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/调用warning.png"><h5 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h5><p>扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号 <code>...</code> 来触发扩展操作。（**此处不是很理解，包扩展不就是可变参数模板吗?**）</p><h6 id="理解包扩展"><a href="#理解包扩展" class="headerlink" title="理解包扩展"></a>理解包扩展</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在print调用中对每个实参调用debug_req</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line"><span class="comment">// print(os, debug_req(a1), debug_req(a2), ..., debug_req(an))</span></span><br><span class="line">print(os, debug_req(rest)...); <span class="comment">// print(os, debug_req(rest...))错误，此调用无匹配函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/24/C-模板与泛型编程（三）/包扩展.png"><h5 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h5><p>新标准下，我们可以组合使用可变参数模板与 <code>forward</code> 机制来编写函数，实现将其实参不变的传递给其他函数。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/建议_转发和可变参数模板.png"><h4 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h4><h5 id="定义函数模板特例化"><a href="#定义函数模板特例化" class="headerlink" title="定义函数模板特例化"></a>定义函数模板特例化</h5><p>定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。先前声明版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempalte &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span></span><br></pre></td></tr></table></figure><p>特例化版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// &lt;&gt;表示我们正在实例化一个模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数重载与模板实例化"><a href="#函数重载与模板实例化" class="headerlink" title="函数重载与模板实例化"></a>函数重载与模板实例化</h5><p><strong>一个特例化版本的本质上是一个实例，而非函数名的一个重载版本</strong>。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/函数重载与模板实例化.png"><img src="/blog/2021/02/24/C-模板与泛型编程（三）/普通作用域规则应用于特例化.png"><h5 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h5><p>P626.</p><h5 id="类模板部分特例化"><a href="#类模板部分特例化" class="headerlink" title="类模板部分特例化"></a>类模板部分特例化</h5><p>与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。</p><p>一个类模板的部分特例化（partial specialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/类模板部分特例化.png"><p>标准库 <code>remove_reference</code> 模板是通过一系列的特例化版本来完成其功能的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 最原始、最通用版本</span><br><span class="line">template &lt;class T&gt; struct remove_reference&#123;</span><br><span class="line">typedef T type;</span><br><span class="line">&#125;;</span><br><span class="line">// 部分特例化版本， 将用于左值引用和右值引用</span><br><span class="line">template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt;&#123;</span><br><span class="line">typedef T type;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt;&#123;</span><br><span class="line">typedef T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// decltype(42)为int，使用原始模板</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;</span><br><span class="line"><span class="comment">// decltype(i)为int&amp;，使用特例化版本一</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(i)&gt;::type b;</span><br><span class="line"><span class="comment">// decltype(std::move(i))为int&amp;&amp;，使用特例化版本二</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="built_in">std</span>::move(i))&gt;::type c;</span><br></pre></td></tr></table></figure><p>以上三个变量都是 <code>int</code> 类型。</p><h5 id="特例化成员而不是类"><a href="#特例化成员而不是类" class="headerlink" title="特例化成员而不是类"></a>特例化成员而不是类</h5><p>我们可以只特例化成员函数而不是特例化整个模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">Foo(<span class="keyword">const</span> T &amp;t = T()): mem(t)&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span>&#123; <span class="comment">/* ... */</span>&#125;</span><br><span class="line">T mem;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// 特例化</span></span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()&#123;</span><br><span class="line"><span class="comment">// 进行应用于int的特例化处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 <code>Foo&lt;int&gt;</code> 类的一个成员，其他成员由 <code>Foo</code> 模板提供：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs; <span class="comment">// Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.Bar(); <span class="comment">// Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi; <span class="comment">// Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.Bar(); <span class="comment">// 使用我们特例化版本的Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;重载与模板&lt;/li&gt;
&lt;li&gt;可变参数模板&lt;/li&gt;
&lt;li&gt;模板特例化&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++模板与泛型编程（二）——模板实参推断</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/23/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/23/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-23T15:34:45.000Z</published>
    <updated>2021-02-24T09:18:43.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>类型转换与模板类型参数</li><li>函数模板显式实参</li><li>尾置返回类型与类型转换</li><li>函数指针和实参推断</li><li>模板实参推断和引用</li><li>理解 <code>std::move</code></li><li>转发</li></ol><a id="more"></a><p>从函数实参来确定模板实参的过程称为<strong>模板实参推断</strong>。</p><h4 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h4><p>编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。顶层 <code>const</code>无论在形参还是实参中都会被忽略。</p><ul><li><code>const</code> 转换：可以将一个非 <code>const</code> 对象的引用（或指针）传递给一个 <code>const</code> 的引用（或指针）形参。</li><li>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li></ul><img src="/blog/2021/02/23/C-模板与泛型编程（二）/实参传递给模板类型的函数形参note.png"><h5 id="使用相同模板参数类型的函数形参"><a href="#使用相同模板参数类型的函数形参" class="headerlink" title="使用相同模板参数类型的函数形参"></a>使用相同模板参数类型的函数形参</h5><p>一个模板类型参数可以作为多个函数形参的类型，但是传递给形参的实参类型必须相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>); <span class="comment">// 错误，不能实例化compare(long, int)，类型不匹配</span></span><br></pre></td></tr></table></figure><p>如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span><span class="params">(<span class="keyword">const</span> A&amp; v1, <span class="keyword">const</span> B&amp; v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="正常类型转换应用于普通函数实参"><a href="#正常类型转换应用于普通函数实参" class="headerlink" title="正常类型转换应用于普通函数实参"></a>正常类型转换应用于普通函数实参</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>os</code> 类型固定，因此调用 <code>print</code> 时，传递给它的实参会正常进行类型转换。</p><img src="/blog/2021/02/23/C-模板与泛型编程（二）/正常类型转换应用于普通函数实参.png"><h4 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h4><h5 id="指定显式模板实参"><a href="#指定显式模板实参" class="headerlink" title="指定显式模板实参"></a>指定显式模板实参</h5><p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure><p>每次调用前，调用者必须为 <code>T1</code> 提供一个<strong>显式模板实参</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng); <span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure><p><strong>显式模板实参按照由左至右的顺序与对应的模板参数匹配</strong>。</p><h5 id="正常类型转换应用于显式指定的实参"><a href="#正常类型转换应用于显式指定的实参" class="headerlink" title="正常类型转换应用于显式指定的实参"></a>正常类型转换应用于显式指定的实参</h5><p>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>); <span class="comment">// 错误：模板类型不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">// 正确：实例化compare(long, long)，接受两个const long&amp;;</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">// 正确：实例化compare(int, int)，lng被转换为int;</span></span><br></pre></td></tr></table></figure><h4 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回类型允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg) // 迭代器解引用返回元素引用</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> *beg; <span class="comment">// 返回序列中的一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进行类型转换的标准库模板类"><a href="#进行类型转换的标准库模板类" class="headerlink" title="进行类型转换的标准库模板类"></a>进行类型转换的标准库模板类</h5><p>如果希望编写一个类似 <code>fcn</code> 的函数，但返回一个元素的值而非引用。可以使用标准库的<strong>类型转换</strong>模板，定义在头文件 <code>type_traits</code> 中。模板如下表：</p><img src="/blog/2021/02/23/C-模板与泛型编程（二）/标准类型转换模板.png"><p>上述模板中每个都拥有一个名为 <code>type</code> 的 <code>public</code> 成员，表示一个类型。</p><ul><li>如果不可能（不必要）转换模板参数，则 <code>type</code> 成员就是模板参数本身。</li></ul><p>组合使用 <code>remove_reference</code> ，尾置返回类型及 <code>decltype</code>，我们可以在函数中返回元素值的拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用typename表示type是一个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;typnemae It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)::type</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h4><p>当我们使用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure><p>如果不能从函数指针类型确定函数模板，则产生错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func的重载版本，每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line">func(compare); <span class="comment">// 错误，使用compare的哪个实例？</span></span><br></pre></td></tr></table></figure><p>可以使用显式模板实参来消除 <code>func</code> 调用的歧义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;); <span class="comment">// 传递compare(const int&amp;, const int&amp;)</span></span><br></pre></td></tr></table></figure><h4 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h4><h5 id="从左值引用函数参数推断类型"><a href="#从左值引用函数参数推断类型" class="headerlink" title="从左值引用函数参数推断类型"></a>从左值引用函数参数推断类型</h5><p>当一个函数参数是模板类型参数的一个普通(左值)引用时（即，形如T&amp;）。绑定规则告诉我们：</p><ul><li>只能传递给它一个左值（如，一个变量或一个返回引用类型的表达式）。</li></ul><p>实参可以是 <code>const</code> 类型，也可以不是。如果实参是 <code>const</code> 的，则 <code>T</code> 将被推断为 <code>const</code> 类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>; <span class="comment">// 实参必须是一个左值</span></span><br><span class="line">f1(i); <span class="comment">// i是一个int，模板参数类型T是int</span></span><br><span class="line">f1(ci); <span class="comment">// ci是一个const int，模板参数T是const int</span></span><br><span class="line">f1(<span class="number">5</span>); <span class="comment">// 错误：5是右值</span></span><br></pre></td></tr></table></figure><p>如果一个函数参数的类型是 <code>const T&amp;</code>，正常的绑定规则告诉我们：</p><ul><li>可以传递给它任何类型的实参一个对象（ <code>const</code> 或非 <code>const</code> ）、一个临时对象或是一个字面常量值。</li></ul><p>当函数参数本身是 <code>const</code> 时，其已经是<strong>函数参数类型</strong>的一部分，因此，<strong>它不会也是模板参数类型的一部分</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">// f2中的参数是const &amp;，实参中的const是无关的</span></span><br><span class="line"><span class="comment">// 在每个调用中，f2的函数实参都被推断为const int&amp;</span></span><br><span class="line">f2(i); <span class="comment">// i是一个int，模板参数类型T是int</span></span><br><span class="line">f2(ci); <span class="comment">// ci是一个const int，但模板参数T是int</span></span><br><span class="line">f2(<span class="number">5</span>); <span class="comment">// 一个const &amp;参数可以绑定到一个右值，T是int</span></span><br></pre></td></tr></table></figure><h5 id="从右值引用函数参数推断类型"><a href="#从右值引用函数参数推断类型" class="headerlink" title="从右值引用函数参数推断类型"></a>从右值引用函数参数推断类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>); <span class="comment">// 实参是一个int类型的右值，模板参数T是int</span></span><br></pre></td></tr></table></figure><h5 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h5><ul><li>X&amp; &amp;、X&amp; &amp;&amp; 和 X&amp;&amp; &amp; 都折叠成类型 X&amp;</li><li>类型 X&amp;&amp; &amp;&amp; 折叠成 X&amp;&amp;</li></ul><img src="/blog/2021/02/23/C-模板与泛型编程（二）/引用折叠.png"><p>这两个规则导致了两个重要结果：</p><ol><li>函数参数指向模板类型参数的右值引用，则它可以被绑定到一个左值；</li><li>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个普通左值引用参数。</li></ol><img src="/blog/2021/02/23/C-模板与泛型编程（二）/右值引用参数.png" style="zoom:80%;"><h5 id="编写接受右值引用参数的函数模板"><a href="#编写接受右值引用参数的函数模板" class="headerlink" title="编写接受右值引用参数的函数模板"></a>编写接受右值引用参数的函数模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>; <span class="comment">// 绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// 左值和const右值</span></span><br></pre></td></tr></table></figure><h4 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h4><h5 id="std-move是如何定义的"><a href="#std-move是如何定义的" class="headerlink" title="std::move是如何定义的"></a>std::move是如何定义的</h5><p>标准库定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引用折叠，我们既可以传递给 <code>move</code> 一个左值，也可以传递给它一个右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("hi!"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"bye!"</span>)); <span class="comment">// 正确，从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1); <span class="comment">// 正确，但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure><h5 id="std-move是如何工作的"><a href="#std-move是如何工作的" class="headerlink" title="std::move是如何工作的"></a>std::move是如何工作的</h5><p>在 <code>std::move(string(&quot;bye!&quot;))</code> 中：</p><ul><li>推断出的 <code>T</code> 的类型为 <code>string</code>。</li><li>因此，<code>remove reference</code> 用 <code>string</code> 进行实例化。</li><li><code>remove_reference&lt;string&gt; </code>的 <code>type</code> 成员是 <code>string</code>。</li><li><code>move</code> 的返回类型是 <code>string&amp;&amp;</code>。</li><li><code>move</code> 的函数参数 <code>t</code> 的类型为 <code>string&amp;&amp;</code>。</li></ul><p>这个调用实例化 <code>move&lt;string&gt;</code>，即函数：<code>string&amp;&amp; move(string &amp;&amp;t)</code>。无需类型转换。</p><p>第二个赋值，传递给 <code>move</code> 的实参是一个左值：</p><ul><li>推断出的 <code>T</code> 的类型为 <code>string&amp;</code>（ <code>string</code> 的引用，而非普通 <code>string</code>)。</li><li>因此，<code>remove_reference</code> 用 <code>string&amp;</code> 进行实例化。</li><li><code>remove_reference&lt;string&amp;&gt;</code> 的 <code>type</code> 成员是 <code>string</code>。</li><li><code>move</code>的返回类型仍是 <code>string&amp;</code>。</li><li><code>move</code> 的函数参数 <code>t</code> 实例化为 <code>string&amp; &amp;&amp;</code>，会折叠为 <code>string&amp;</code>。</li></ul><p>这个调用实例化 <code>move&lt;string&amp;&gt;</code>，即函数：<code>string&amp;&amp; move(string &amp;t)</code>。</p><p><strong>将一个右值引用绑定到一个左值</strong>。这个实例的函数体返回 <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>，在此情况下，<code>cast</code> 将 <code>t</code> 的类型 <code>string&amp;</code> 转换为 <code>string&amp;&amp;</code>。</p><h5 id="从一个左值static-cast到一个右值引用时允许的"><a href="#从一个左值static-cast到一个右值引用时允许的" class="headerlink" title="从一个左值static_cast到一个右值引用时允许的"></a>从一个左值static_cast到一个右值引用时允许的</h5><p> 可以用 <code>static_cast</code> 显式的将一个左值转换为一个右值引用。</p><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span>&#123;</span><br><span class="line">f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">" "</span> &lt;&lt; ++v2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>f</code> 改变了绑定到 <code>v2</code> 的实参的值，但是通过 <code>flip1</code> 调用 <code>f</code>，<code>f</code> 所作的改变就不会影响实参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">42</span>, i); <span class="comment">// f改变了实参i</span></span><br><span class="line">flip1(f, j, <span class="number">42</span>); <span class="comment">// 通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure><h5 id="定义能保持类型信息的函数参数"><a href="#定义能保持类型信息的函数参数" class="headerlink" title="定义能保持类型信息的函数参数"></a>定义能保持类型信息的函数参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/23/C-模板与泛型编程（二）/转发.png"><p>当 <code>flip2</code> 调用 <code>f</code> 时，<code>f</code> 中的引用参数 <code>v2</code> 被绑定到 <code>t1</code>，也就是绑定到 <code>j</code>，当 <code>f</code> 递增 <code>v2</code> 时，它同时改变了 <code>j</code> 的值。</p><p>上述 <code>flip2</code> 不能用于接受右值引用参数的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 <code>flip2</code> 调用 <code>g</code>，则参数 <code>t2</code> 将被传递给 <code>g</code> 的右值引用参数。即使我们传递一个右值给 <code>flip2</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flip2(g, i, <span class="number">42</span>); <span class="comment">// 函数参数为左值表达式，不能从一个左值实例化int&amp;&amp;</span></span><br></pre></td></tr></table></figure><h5 id="在调用中使用std-forward保持类型信息"><a href="#在调用中使用std-forward保持类型信息" class="headerlink" title="在调用中使用std::forward保持类型信息"></a>在调用中使用std::forward保持类型信息</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在头文件utility中，forward必须通过显式模板来调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; intermediary(Type &amp;&amp;arg)&#123;</span><br><span class="line">finalFcn(<span class="built_in">std</span>::forward&lt;Type&gt;(arg));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/23/C-模板与泛型编程（二）/forward.png"><p>重写翻转函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用 <code>flip(g, i, 42)</code>，<code>i</code> 将以 <code>int&amp;</code> 类型传递给 <code>g</code>，<code>42</code> 将以 <code>int&amp;&amp;</code> 类型传递给 <code>g</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;类型转换与模板类型参数&lt;/li&gt;
&lt;li&gt;函数模板显式实参&lt;/li&gt;
&lt;li&gt;尾置返回类型与类型转换&lt;/li&gt;
&lt;li&gt;函数指针和实参推断&lt;/li&gt;
&lt;li&gt;模板实参推断和引用&lt;/li&gt;
&lt;li&gt;理解 &lt;code&gt;std::move&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转发&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="泛型" scheme="http://www.xingyuzhao.ltd/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1052-爱生气的书店老板</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/23/LeetCode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/23/LeetCode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</id>
    <published>2021-02-23T07:12:44.000Z</published>
    <updated>2021-02-25T14:24:24.640Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><a id="more"></a><img src="/blog/2021/02/23/LeetCode1052-爱生气的书店老板/1052.png"><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>先求得原始条件下可获得的满意数量之和 <code>sum</code>；</li><li>维护一个长度为 <code>X</code> 的窗口，从 <code>customers</code> 起始位置开始滑动。先得到当前窗口原始条件下的满意总和，使用 <code>sum</code> 减去此和，再加上当前窗口顾客全部满意数的和；</li><li>更新最大满意数量 <code>ans = max(ans, sum)</code>。</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum_copy = sum;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = left + X;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; customers.size() + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> subSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grumpy[j] == <span class="number">0</span>)</span><br><span class="line">                    subSum += customers[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; subSum &lt;&lt; " ";</span></span><br><span class="line">            sum -= subSum;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">            sum += accumulate(customers.begin() + left, customers.begin() + right, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">            ans = max(sum, ans);</span><br><span class="line">            sum = sum_copy;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度很高，为 $O((2X)^n)$。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>在求得原始条件下可获得的满意数量之和 <code>sum</code>，同时将不生气时顾客的满意值置为 0 后，此时题目转换为：在修改后的 <code>customers</code> 数组中，长度为 <code>X</code> 的子数组的最大的和为多少？找的这个最大值再加上 <code>sum</code> 即可。时间复杂度为 $O(n)$。</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(X == customers.size()) <span class="keyword">return</span> accumulate(customers.begin(), customers.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += customers[i];</span><br><span class="line">                customers[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> subSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; ++i)</span><br><span class="line">            subSum += customers[i];</span><br><span class="line">        <span class="keyword">int</span> maxVal = subSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = X; i &lt; customers.size(); ++i)&#123;</span><br><span class="line">            subSum -= customers[i - X];</span><br><span class="line">            subSum += customers[i];</span><br><span class="line">            maxVal = max(maxVal, subSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum + maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>评论区：<a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/grumpy-bookstore-owner/comments/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;今天，书店老板有一家店打算试营业 &lt;code&gt;customers.length&lt;/code&gt; 分钟。每分钟都有一些顾客（&lt;code&gt;customers[i]&lt;/code&gt;）会进入书店，所有这些顾客都会在那一分钟结束后离开。&lt;/p&gt;
&lt;p&gt;在某些时候，书店老板会生气。 如果书店老板在第 &lt;code&gt;i&lt;/code&gt; 分钟生气，那么 &lt;code&gt;grumpy[i] = 1&lt;/code&gt;，否则 &lt;code&gt;grumpy[i] = 0&lt;/code&gt;。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。&lt;/p&gt;
&lt;p&gt;书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 &lt;code&gt;X&lt;/code&gt; 分钟不生气，但却只能使用一次。&lt;/p&gt;
&lt;p&gt;请你返回这一天营业下来，最多有多少客户能够感到满意的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://www.xingyuzhao.ltd/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>C++模板与泛型编程（一）——定义模板</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/22/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/22/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-22T09:01:08.000Z</published>
    <updated>2021-02-24T04:10:38.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>函数模板</li><li>类模板</li><li>模板参数</li><li>成员模板</li><li>控制实例化</li><li>效率与灵活性</li></ol><a id="more"></a><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模板定义中，模板参数列表不能为空。</p><h5 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h5><p>编译器用推断处的模板参数来进行<strong>实例化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化出int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// T为int</span></span><br></pre></td></tr></table></figure><h5 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h5><p>类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</p><p>类型参数前必须使用关键字 <code>class</code> 或 <code>typename</code>，两个关键字含义相同，可以互相使用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, class U&gt; calc(const T&amp;, const U&amp;);</span><br></pre></td></tr></table></figure><h5 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h5><p>一个非类型参数表示一个值而非一个类型。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用此函数 <code>compare(&quot;hi&quot;, &quot;mom&quot;)</code> 时，编译器使用字面常量的大小来代替 N 和 M，从而实例化模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[<span class="number">3</span>], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure><p><strong>非类型模板参数的模板实参必须是常量表达式</strong>。</p><h5 id="inline和constexpr的函数模板"><a href="#inline和constexpr的函数模板" class="headerlink" title="inline和constexpr的函数模板"></a>inline和constexpr的函数模板</h5><p>注意位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h5><p>模板的头文件通常既包括声明也包括定义。</p><ul><li>函数模板和类模板成员函数的定义通常放在头文件中。</li></ul><img src="/blog/2021/02/22/C-模板与泛型编程（一）/模板和头文件.png"><h5 id="大多数编译错误在实例化期间报告"><a href="#大多数编译错误在实例化期间报告" class="headerlink" title="大多数编译错误在实例化期间报告"></a>大多数编译错误在实例化期间报告</h5><img src="/blog/2021/02/22/C-模板与泛型编程（一）/调用者责任.png"><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><h5 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Blob之前只针对string</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h5><p>当使用一个类模板时，必须提供额外信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia; <span class="comment">// 空Blob&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>对我们指定的每一种元素类型，编译器都生成一个不同的类。</p><img src="/blog/2021/02/22/C-模板与泛型编程（一）/类模板的实例.png"><h5 id="在模板作用域中引用模板类型"><a href="#在模板作用域中引用模板类型" class="headerlink" title="在模板作用域中引用模板类型"></a>在模板作用域中引用模板类型</h5><p>通常将模板自己的参数当作被使用模板的参数。</p><h5 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h5><p>定义在类模板之外的成员函数必须以关键字 <code>template</code> 开始，后接类模板参数列表。</p><h5 id="类模板成员函数的实例化"><a href="#类模板成员函数的实例化" class="headerlink" title="类模板成员函数的实例化"></a>类模板成员函数的实例化</h5><p>成员函数只有在被用到时才进行实例化。</p><img src="/blog/2021/02/22/C-模板与泛型编程（一）/类模板成员函数实例.png"><h5 id="在类代码内简化模板类名的使用"><a href="#在类代码内简化模板类名的使用" class="headerlink" title="在类代码内简化模板类名的使用"></a>在类代码内简化模板类名的使用</h5><p>在类模板自己的作用域中，可以直接使用模板名而不提供实参。</p><h5 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h5><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。</p><h5 id="令模板自己的类型参数成为友元"><a href="#令模板自己的类型参数成为友元" class="headerlink" title="令模板自己的类型参数成为友元"></a>令模板自己的类型参数成为友元</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> Type; <span class="comment">// 将访问权限授予用来实例化Bar的类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如，对于某个类型名 <code>Foo</code>，<code>Foo</code> 将成为 <code>Bar&lt;Foo&gt;</code> 的友元。</p><h5 id="模板类型别名"><a href="#模板类型别名" class="headerlink" title="模板类型别名"></a>模板类型别名</h5><p>实例化的模板版本可以使用类型别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br></pre></td></tr></table></figure><p>新标准下，可以对类模板定义一个类型别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors; <span class="comment">// authors是一个pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure><h5 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个 <code>Foo</code> 实例都有自己的 <code>static</code> 成员实例，所有的 <code>Foo&lt;X&gt;</code> 类型的对象共享相同的 <code>ctr</code> 对象和 <code>count</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有三个对象共享相同的Foo&lt;int&gt;::ctr和Foo&lt;int&gt;::count成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2, fi3;</span><br></pre></td></tr></table></figure><p><strong>一个 static 成员函数只有在使用时才会实例化</strong>。</p><h4 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h4><h5 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h5><p>模板参数遵循普通的作用域规则。</p><h5 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h5><p>声明必须包括模板参数。且声明中的模板参数名字不必与定义中相同。</p><h5 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h5><p>假设 T 是一个模板参数类型，编译器遇到 <code>T::mem</code> 时不知道 <code>mem</code> 是一个类型成员还是一个 <code>static</code> 数据成员，直至实例化时才知道。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个p变量 or 一个名为size_type的static数据成员与变量p相乘</span></span><br><span class="line"><span class="comment">// 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型</span></span><br><span class="line">T::size_type * p;</span><br></pre></td></tr></table></figure><p>如果希望使用一个模板类型参数的类型成员，必须显示的告诉编译器该名字是一个类型，使用关键字 <code>typename</code> 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp;c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!c.empty())</span><br><span class="line"><span class="keyword">return</span> c.back();</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>top</code> 函数期待一个容器类型的实参，使用 <code>typename</code> 指明其返回类型并在 <code>c</code> 空时生成一个值初始化的元素返回给调用者。</p><img src="/blog/2021/02/22/C-模板与泛型编程（一）/名字表示类型.png"><h5 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="默认模板实参"></a>默认模板实参</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare有一个默认模板实参less&lt;T&gt;和一个默认函数实参F()</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = F())&#123;</span><br><span class="line"><span class="keyword">if</span>(f(v1, v2)) <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(f(v2,v1))) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>F</code> 为可调用对象的类型，新的函数参数 <code>f</code> 绑定到一个可调用对象上。</p><h5 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt; <span class="title">class</span> <span class="title">Numbers</span>&#123;</span> <span class="comment">// T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Numbers(T v = <span class="number">0</span>): val(v);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure><h4 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h4><h5 id="普通类的成员模板"><a href="#普通类的成员模板" class="headerlink" title="普通类的成员模板"></a>普通类的成员模板</h5><p>成员模板以模板参数列表开始。</p><h5 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h5><p>同时提供类模板和成员模板的参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。</p><h5 id="实例化与成员模板"><a href="#实例化与成员模板" class="headerlink" title="实例化与成员模板"></a>实例化与成员模板</h5><p>实例化一个类模板的成员模板，必须同时提供类和函数模板的实参。</p><h4 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h4><p>相同的实例可能出现在多个对象文件中，造成额外的开销。新标准中通过<strong>显示实例化</strong>来避免这种开销：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure><p><code>declaration</code> 是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span> <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure><p>当编译器遇到 <code>extern</code> 模板声明时，它不会再本文件中生成实例化代码。将一个实例化声明为 <code>extern</code> 就表示承诺在程序的其他位置有该实例化的一个非 <code>extern</code> 声明。对于一个给定的实例化版本，可能有多个 <code>extern</code> 声明，但必须只有一个定义。</p><h5 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h5><img src="/blog/2021/02/22/C-模板与泛型编程（一）/实例化定义会实例化所有成员.png"><h4 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h4><p>通过<strong>在编译时绑定删除器</strong>， <code>unique_ptr</code> 避免了间接调用删除器的运行时开销。通过<strong>在运行时绑定删除器</strong>，<code>shared_ptr</code> 使用户重载删除器更为方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;函数模板&lt;/li&gt;
&lt;li&gt;类模板&lt;/li&gt;
&lt;li&gt;模板参数&lt;/li&gt;
&lt;li&gt;成员模板&lt;/li&gt;
&lt;li&gt;控制实例化&lt;/li&gt;
&lt;li&gt;效率与灵活性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="泛型" scheme="http://www.xingyuzhao.ltd/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1004-最大连续1的个数Ⅲ</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/19/LeetCode1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/19/LeetCode1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%A2/</id>
    <published>2021-02-19T06:26:39.000Z</published>
    <updated>2021-02-19T06:39:45.159Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>，我们最多可以将 <code>K</code> 个值从 0 变成 1 。</p><p>返回仅包含 1 的最长（连续）子数组的长度。</p><a id="more"></a><img src="/blog/2021/02/19/LeetCode1004-最大连续1的个数Ⅲ/1004.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用指针 <code>left</code> 表示当前的<strong>连续 1 的子数组</strong>的左端点，<code>right</code> 指针表示当前的<strong>连续1的子数组</strong>的右端点。</p><ul><li>如果 <code>A[right]</code> 为 0，并且此时 K 不为零，说明当前元素可以由 0 变为 1，并将次数减 1；</li><li>如果 <code>A[right]</code> 为 0，并且此时 K 为零，说明当前元素不可以由 0 变为 1，并且需要将窗口左端点右移：<ul><li>如果 <code>A[left]</code> 为 0，说明用使用过一次从 0 到 1。此时需要将这次值的改变“回收”，即 K++；</li><li>更新滑动窗口的最大长度，同时将左端点右移。</li></ul></li><li>如果 <code>A[right]</code> 为 0，右端点右移即可。</li></ul><p>最后一个连续 1 的子数组可能没被统计，所以需要再更新一次窗口最大长度。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; A.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[right] == <span class="number">1</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[right] == <span class="number">0</span> &amp;&amp; K != <span class="number">0</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                K--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[right] == <span class="number">0</span> &amp;&amp; K == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[left] == <span class="number">0</span>) K++;</span><br><span class="line">                ans = max(ans, right - left);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; ans &lt;&lt; " ";</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(right - left, ans); <span class="comment">// 最后一个值为1</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个由若干 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 组成的数组 &lt;code&gt;A&lt;/code&gt;，我们最多可以将 &lt;code&gt;K&lt;/code&gt; 个值从 0 变成 1 。&lt;/p&gt;
&lt;p&gt;返回仅包含 1 的最长（连续）子数组的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://www.xingyuzhao.ltd/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象程序设计（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/12/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/12/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-12T04:45:27.000Z</published>
    <updated>2021-02-25T14:21:02.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>抽象基类</li><li>访问控制与继承</li><li>继承中的类作用域</li><li>构造函数与拷贝控制</li></ol><a id="more"></a><h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p>含有（或者未经覆盖直接继承？）纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。</p><p>在函数体的位置（即声明语句的分号之前）书写 = 0 就可以将一个虚函数说明为纯虚函数。</p><h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><h5 id="受保护的成员protected"><a href="#受保护的成员protected" class="headerlink" title="受保护的成员protected"></a>受保护的成员protected</h5><ul><li>和私有成员类似，受保护的成员对类的用户是不可访问的。</li><li>和公有成员类似，受保护的成员对于派生类的成员和友元来说可访问。</li></ul><p>除此之外：</p><p><strong>派生类的成员和友元只能通过派生类对象来访问基类的受保护成员，而不能访问基类对象中的受保护成员。</strong></p><h5 id="公有、私有和受保护继承"><a href="#公有、私有和受保护继承" class="headerlink" title="公有、私有和受保护继承"></a>公有、私有和受保护继承</h5><img src="/blog/2021/02/12/C-面向对象程序设计（二）/继承1.png" style="zoom:67%;"><img src="/blog/2021/02/12/C-面向对象程序设计（二）/继承2.png" style="zoom:67%;"><img src="/blog/2021/02/12/C-面向对象程序设计（二）/继承3.png" style="zoom:67%;"><p>某个类对其继承而来的成员的访问权限受两个因素影响：</p><ol><li>基类中该成员的访问说明符；</li><li>派生类在派生列表中的访问说明符。</li></ol><p><strong>派生类访问说明符对派生类的成员及友元能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。</strong></p><p><strong>派生类访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限</strong>。</p><img src="/blog/2021/02/12/C-面向对象程序设计（二）/类的设计与受保护的成员.png"><h5 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h5><p>友元关系不能<strong>传递或继承</strong>，每个类负责控制各自成员的访问权限。</p><h5 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h5><p>使用 <code>using</code> 声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Derived的用户可以使用size成员</span></span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Derived的派生类可以使用n</span></span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的内部使用 <code>using </code>声明语句，将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。</p><ul><li><p>如果一条 <code>using</code> 声明语句出现在类的 <code>private</code> 部分,则该名字只能被类的成员和友元访问；</p></li><li><p>如果 <code>using</code> 声明语句位于 <code>public</code> 部分，则类的所有用户都能访问它；</p></li><li><p>如果 <code>using</code> 声明语句位于 <code>protected</code> 部分，则该名字对于成员、友元和派生类是可访问的。</p></li></ul><h5 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h5><p>默认情况下，使用 <code>class</code> 关键字定义的派生类是私有继承的；而使用 <code>struct</code> 关键字定义的派生类是公有继承的。</p><h4 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h4><h5 id="在编译时进行名字查找"><a href="#在编译时进行名字查找" class="headerlink" title="在编译时进行名字查找"></a>在编译时进行名字查找</h5><h5 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h5><p>派生类的成员将隐藏同名的基类成员。</p><h5 id="通过作用域运算符来使用隐藏的成员"><a href="#通过作用域运算符来使用隐藏的成员" class="headerlink" title="通过作用域运算符来使用隐藏的成员"></a>通过作用域运算符来使用隐藏的成员</h5><p>我们可以通过作用域运算符来使用一个被隐藏的基类成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base::mem; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/12/C-面向对象程序设计（二）/名字重用.png"><img src="/blog/2021/02/12/C-面向对象程序设计（二）/名字查找与继承.png" style="zoom:80%;"><h5 id="名字查找先于类型检查"><a href="#名字查找先于类型检查" class="headerlink" title="名字查找先于类型检查"></a>名字查找先于类型检查</h5><h5 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h5><p>基类与派生类中的虚函数必须有相同的形参列表。</p><h4 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h4><h5 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h5><p>基类通常应该定义一个虚析构函数。如果基类的析构函数不是虚函数，则 <code>delete</code> 一个指向派生类对象的基类指针将产生未定义的行为。</p><p><strong>虚析构函数将阻止合成移动操作</strong>。</p><h5 id="合成拷贝控制和继承"><a href="#合成拷贝控制和继承" class="headerlink" title="合成拷贝控制和继承"></a>合成拷贝控制和继承</h5><p>合成的成员负责使用<strong>直接基类</strong>中对应的操作对一个对象的<strong>直接基类部分</strong>进行初始化、赋值或销毁的操作。</p><h5 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h5><img src="/blog/2021/02/12/C-面向对象程序设计（二）/派生类的拷贝控制成员.png"><h6 id="定义派生类的拷贝或移动构造函数"><a href="#定义派生类的拷贝或移动构造函数" class="headerlink" title="定义派生类的拷贝或移动构造函数"></a>定义派生类的拷贝或移动构造函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">D(<span class="keyword">const</span> D&amp; d): Base(d) <span class="comment">// 拷贝基类成员</span></span><br><span class="line"><span class="comment">/* D的成员的初始值 */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">D(D&amp;&amp; d): Base(<span class="built_in">std</span>::move(d)) <span class="comment">// 移动基类成员</span></span><br><span class="line"><span class="comment">/* D的成员的初始值 */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/12/C-面向对象程序设计（二）/派生类的拷贝或移动构造函数.png"><h6 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base::operator=(const Base&amp;) 不会被自动调用</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)&#123;</span><br><span class="line">Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// 为基类部分赋值</span></span><br><span class="line"><span class="comment">// 为派生类的成员赋值</span></span><br><span class="line"><span class="comment">// 处理自赋值及释放已有资源等</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Base::Base 被自动调用执行</span></span><br><span class="line">~D() &#123; <span class="comment">/* 用户定义清楚派生类成员的操作 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派生类的析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。</p><h6 id="在构造函数和析构函数中调用虚函数"><a href="#在构造函数和析构函数中调用虚函数" class="headerlink" title="在构造函数和析构函数中调用虚函数"></a>在构造函数和析构函数中调用虚函数</h6><img src="/blog/2021/02/12/C-面向对象程序设计（二）/在构造函数和析构函数中调用虚函数.png"><h5 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h5><p>使用 <code>using</code> 声明语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Disc_quote::Disc_quote; <span class="comment">// 继承Disc_quote的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数</span></span><br><span class="line">derived(parms) : base(args) &#123; &#125;</span><br></pre></td></tr></table></figure><h6 id="继承的构造函数特点"><a href="#继承的构造函数特点" class="headerlink" title="继承的构造函数特点"></a>继承的构造函数特点</h6><p>与普通成员的 <code>using</code> 声明不同，一个构造函数的 <code>using</code> 声明不会改变该构造函数的访问级别。</p><p><code>using</code> 声明语句不能指定 <code>explicit</code> 或 <code>constexpr</code>。</p><p><strong>当一个基类构造函数含有默认实参时，这些实参并不会被继承</strong>。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p><p>例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：</p><ol><li><p>构造函数接受两个形参（没有默认实参），<strong>此时并未省略掉一个形参？</strong>；</p></li><li><p>构造函数只接受一个形参，它对应于基类中最左侧的<strong>没有默认值</strong>的那个形参。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;抽象基类&lt;/li&gt;
&lt;li&gt;访问控制与继承&lt;/li&gt;
&lt;li&gt;继承中的类作用域&lt;/li&gt;
&lt;li&gt;构造函数与拷贝控制&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="面向对象" scheme="http://www.xingyuzhao.ltd/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>2021，新年快乐！</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/12/2021%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/12/2021%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/</id>
    <published>2021-02-12T04:36:12.000Z</published>
    <updated>2021-02-12T04:47:46.305Z</updated>
    
    <content type="html"><![CDATA[<p>祝大家新年快乐，心想事成，牛年吉祥！</p><p>2021，新的一年，机遇与挑战并存。</p><p><strong>抓住机遇，迎接挑战！</strong>                                                    </p><p>​                        </p><p>​                                                                                          赵星宇</p><p>​                                                                                 2021.2.12  大年初一</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;祝大家新年快乐，心想事成，牛年吉祥！&lt;/p&gt;
&lt;p&gt;2021，新的一年，机遇与挑战并存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓住机遇，迎接挑战！&lt;/strong&gt;                                                    &lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++面向对象程序设计（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/08/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/08/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-08T14:19:04.000Z</published>
    <updated>2021-02-25T14:21:10.750Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>OOP：概述</li><li>定义基类和派生类</li><li>虚函数</li></ol><a id="more"></a><h4 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h4><p>面向对象程序设计的核心思想是<strong>数据抽象、继承和动态绑定</strong>。</p><p><strong>OOP</strong> 三大特征为：<strong>封装、继承、多态</strong>。</p><p>数据抽象：将类的接口与实现分离。</p><p>继承：可以定义相似的类型并对其相似关系建模。</p><p>动态绑定：在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象。</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>通过<strong>继承</strong>联系在一起的类构成一种层次关系。层次关系的根部有一个<strong>基类</strong>，负责定义层次关系中所有类共同拥有的成员。通过从基类继承得到的类称为<strong>派生类</strong>，每个派生类定义各自特有的成员。</p><p>如果某些函数基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派生类必须通过使用<strong>类派生列表</strong>明确指出它是从哪个（哪些）基类继承而来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++11 新标准允许派生类显式的注明它将使用哪个成员函数改写基类的虚函数，在该函数形参列表之后增加一个 <code>override</code> 关键字即可</strong>。而不用在函数前加上 <code>virtual</code> 关键字。</p><h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p>也称为<strong>运行时绑定</strong>，在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。</p><h4 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h4><h5 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h5><p>基类通常都需要定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p><h6 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h6><p>基类必须将它得两种成员函数区分开来：</p><ol><li>基类希望其派生类进行覆盖的函数，将其定义为虚函数。<ul><li>当使用指针或引用调用虚函数时，该调用将被动态绑定。</li><li>如果基类把一个函数声明为虚函数，则该函数的派生类中隐式的也是虚函数。</li></ul></li><li>基类希望直接继承而不需要改变的类。</li></ol><h6 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h6><p>派生类可以访问基类的公有成员。如果基类希望派生类可以访问成员，并且该成员禁止其他用户访问，这种成员应定义为<strong>受保护的（protected）</strong>。</p><h5 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h5><p>通过<strong>类派生列表</strong>，形式为：首先是一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前可以有：<code>public</code>、<code>protected</code> 或 <code>private</code> 中的一个。</p><h6 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h6><h6 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h6><p>可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；也可以把派生类对象的指针用在需要基类指针的地方。</p><h6 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h6><p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc): </span><br><span class="line">Quote(book, p), min_qty(qty), discount(disc) &#123; &#125;</span><br></pre></td></tr></table></figure><h6 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h6><img src="/blog/2021/02/08/C-面向对象程序设计（一）/遵循基类的接口.png"><h6 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h6><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p><h6 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h6><p>声明中包含类名但不包含它的派生列表。</p><h6 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h6><p>如果要将某个类用作基类，则该类必须已经定义而非仅仅声明。</p><h6 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h6><p>C++11 新标准提供关键字 <code>final</code> 防止继承发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> &#123;</span> <span class="comment">/* */</span> &#125;; <span class="comment">// NoDerived 不能作为基类</span></span><br></pre></td></tr></table></figure><h5 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h5><p>当使用基类的引用（或指针）时，实际上我们并不知道该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p><h6 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h6><p>静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。</p><h6 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h6><h6 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h6><p>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。</p><img src="/blog/2021/02/08/C-面向对象程序设计（一）/在对象之间不存在类型转换_note.png"><h6 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h6><img src="/blog/2021/02/08/C-面向对象程序设计（一）/转换规则.png"><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>无论是否被用到，每个虚函数都需要定义。</p><h5 id="对虚函数的调用可能运行时才被解析"><a href="#对虚函数的调用可能运行时才被解析" class="headerlink" title="对虚函数的调用可能运行时才被解析"></a>对虚函数的调用可能运行时才被解析</h5><p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。</p><h5 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h5><img src="/blog/2021/02/08/C-面向对象程序设计（一）/多态性.png"><h5 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h5><p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则<strong>它的形参类型必须与它覆盖的基类函数完全一致</strong>。一般来说，返回类型也应该一致，除非类的虚函数返回类型是类本身的指针或引用。</p><h5 id="final-和-override-说明符"><a href="#final-和-override-说明符" class="headerlink" title="final 和 override 说明符"></a>final 和 override 说明符</h5><p>如果使用 <code>override</code> 标记了某个函数，但是该函数并没有覆盖已存在的虚函数，此时编译器将报错。</p><p>如果将某个函数指定为 <code>final</code>，则之后任何尝试覆盖该函数的操作都将引发错误。</p><p>上述两个函数出现在形参列表（包括任何 <code>const</code> 或引用修饰符）以即尾置返回类型之后。</p><h5 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h5><p>如果某次函数调用使用了默认实参， 则该实参值由本次调用的静态类型决定。</p><p>如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参。</p><img src="/blog/2021/02/08/C-面向对象程序设计（一）/虚函数与默认实参.png"><h5 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h5><p>通常当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，需要回避虚函数机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强行调用基类中定义的函数版本而不管 baseP 的动态类型到底是什么</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/08/C-面向对象程序设计（一）/回避虚函数机制.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;OOP：概述&lt;/li&gt;
&lt;li&gt;定义基类和派生类&lt;/li&gt;
&lt;li&gt;虚函数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="面向对象" scheme="http://www.xingyuzhao.ltd/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode978-最长湍流子数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/08/LeetCode978-%E6%9C%80%E9%95%BF%E6%B9%8D%E6%B5%81%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/08/LeetCode978-%E6%9C%80%E9%95%BF%E6%B9%8D%E6%B5%81%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2021-02-08T03:14:38.000Z</published>
    <updated>2021-02-08T03:44:36.040Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>当 <code>A</code> 的子数组 <code>A[i], A[i+1], ..., A[j]</code> 满足下列条件时，我们称其为湍流子数组：</p><p>若 <code>i &lt;= k &lt; j</code>，当 <code>k</code> 为奇数时， <code>A[k] &gt; A[k+1]</code>，且当 <code>k</code> 为偶数时，<code>A[k] &lt; A[k+1]</code>；<br>或 若 <code>i &lt;= k &lt; j</code>，当 <code>k</code> 为偶数时，<code>A[k] &gt; A[k+1]</code> ，且当 <code>k</code> 为奇数时， <code>A[k] &lt; A[k+1]</code>。<br>也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。</p><p>返回 A 的最大湍流子数组的<strong>长度</strong>。</p><a id="more"></a><img src="/blog/2021/02/08/LeetCode978-最长湍流子数组/978.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果当前值同时小于其前一个值和后一个值，或者当前值同时大于其前一个值和后一个值，说明这三个元素可以构成湍流数组。</p><p>当无法构成湍流数组时，更新起始位置，并且更新最长长度。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="number">0</span>] == arr[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i - <span class="number">1</span>] &amp;&amp; arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>] &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] != arr[i - <span class="number">1</span>]) ans = max(ans, i + <span class="number">1</span> - start);</span><br><span class="line">                <span class="keyword">else</span> ans = max(ans, i - start);</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="comment">// 遍历最后一组元素处恰好能截取最后一个湍流数组</span></span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">2</span>) flag = <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在末尾未截取湍流数组，表示还存在最后一个湍流数组</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) ans = max(ans, len - start);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>一种动态规划的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(arr.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">down</span><span class="params">(arr.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">                up[i] = down[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">                down[i] = up[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, max(up[i], down[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/solution/yi-zhang-dong-tu-xiang-jie-dong-tai-gui-wrwvn/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-turbulent-subarray/solution/yi-zhang-dong-tu-xiang-jie-dong-tai-gui-wrwvn/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;当 &lt;code&gt;A&lt;/code&gt; 的子数组 &lt;code&gt;A[i], A[i+1], ..., A[j]&lt;/code&gt; 满足下列条件时，我们称其为湍流子数组：&lt;/p&gt;
&lt;p&gt;若 &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt;，当 &lt;code&gt;k&lt;/code&gt; 为奇数时， &lt;code&gt;A[k] &amp;gt; A[k+1]&lt;/code&gt;，且当 &lt;code&gt;k&lt;/code&gt; 为偶数时，&lt;code&gt;A[k] &amp;lt; A[k+1]&lt;/code&gt;；&lt;br&gt;或 若 &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt;，当 &lt;code&gt;k&lt;/code&gt; 为偶数时，&lt;code&gt;A[k] &amp;gt; A[k+1]&lt;/code&gt; ，且当 &lt;code&gt;k&lt;/code&gt; 为奇数时， &lt;code&gt;A[k] &amp;lt; A[k+1]&lt;/code&gt;。&lt;br&gt;也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。&lt;/p&gt;
&lt;p&gt;返回 A 的最大湍流子数组的&lt;strong&gt;长度&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode665-非递减序列</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/07/LeetCode665-%E9%9D%9E%E9%80%92%E5%87%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/07/LeetCode665-%E9%9D%9E%E9%80%92%E5%87%8F%E5%BA%8F%E5%88%97/</id>
    <published>2021-02-07T08:58:26.000Z</published>
    <updated>2021-02-07T15:36:04.385Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个长度为 <code>n</code> 的整数数组，请你判断在 <strong>最多</strong> 改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中所有的 <code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p><a id="more"></a><img src="/blog/2021/02/07/LeetCode665-非递减序列/665.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>记当前遍历到的位置为 <code>i</code>， 如果 <code>nums[i] &lt; nums[i - 1]</code>，此时需要修改数组：</p><ul><li>如果 <code>nums[i] &gt;= nums[i - 2]</code> ，说明需要将 <code>nums[i - 1]</code> 改小，为了方便起见，令 <code>nums[i - 1] = nums[i]</code>；</li><li>否则，说明需要将 <code>nums[i]</code> 改大，令 <code>nums[i] = nums[i - 1]</code>。</li></ul><p>对于 <code>i = 1</code> 时 <code>nums[i] &lt; nums[i - 1]</code>，应将 <code>nums[i - 1]</code> 改小，令<code>nums[i - 1] = nums[i]</code>，这样做的目的是<strong>使已遍历的序列尽可能的小，减小修改次数</strong>。比如 <code>2,1,1</code>，如果修改为 <code>2,2,1</code>，那么就不能一次修改得到非递减序列；修改为 <code>1,1,1</code>即可。</p><p>修改的同时进行计数，计数必须小于等于 1。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; nums[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span> || nums[i] &gt;= nums[i - <span class="number">2</span>])&#123;</span><br><span class="line">                    nums[i - <span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://leetcode-cn.com/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组，请你判断在 &lt;strong&gt;最多&lt;/strong&gt; 改变 &lt;code&gt;1&lt;/code&gt; 个元素的情况下，该数组能否变成一个非递减数列。&lt;/p&gt;
&lt;p&gt;我们是这样定义一个非递减数列的： 对于数组中所有的 &lt;code&gt;i&lt;/code&gt; &lt;code&gt;(0 &amp;lt;= i &amp;lt;= n-2)&lt;/code&gt;，总满足 &lt;code&gt;nums[i] &amp;lt;= nums[i + 1]&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周赛-227</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/07/LeetCode%E5%91%A8%E8%B5%9B-227/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/07/LeetCode%E5%91%A8%E8%B5%9B-227/</id>
    <published>2021-02-07T08:57:53.000Z</published>
    <updated>2021-02-07T12:39:25.726Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li>检查数组能否经排序和轮转得到</li><li>移除石子的最大得分</li><li>构造字典序最大的合并字符串</li><li>最接近目标值的子序列和</li></ol><a id="more"></a><h4 id="检查数组能否经排序和轮转得到"><a href="#检查数组能否经排序和轮转得到" class="headerlink" title="检查数组能否经排序和轮转得到"></a>检查数组能否经排序和轮转得到</h4><p>给你一个数组 <code>nums</code> 。<code>nums</code> 的源数组中，所有元素与 <code>nums</code> 相同，但按非递减顺序排列。</p><p>如果 <code>nums</code> 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>源数组中可能存在 <strong>重复项</strong> 。</p><p>注意：我们称数组 <code>A</code> 在轮转 <code>x</code> 个位置后得到长度相同的数组 <code>B</code> ，当它们满足 <code>A[i] == B[(i+x) % A.length]</code> ，其中 % 为取余运算。</p><h5 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>根据已有等式，从 0 开始递增 <code>x</code>，如果轮转 <code>x</code> 后可以从 <code>A</code> 得到 <code>B</code>，返回 <code>true</code>，否则返回 <code>false</code>。如果数组长度很大，则时间复杂度会很高。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> buf = nums;</span><br><span class="line">        sort(buf.begin(), buf.end());</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; len)&#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] != buf[(i + x) % len])&#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h5><p>如果出现 <code>nums[i] &gt; nums[(i + 1) % n]</code> ，表示找到了一个轮转位置，如果最终找到的轮转位置数不大于 1，说明可以轮转。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[(i + <span class="number">1</span>) % n])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="移除石子的最大得分"><a href="#移除石子的最大得分" class="headerlink" title="移除石子的最大得分"></a>移除石子的最大得分</h4><p>你正在玩一个单人游戏，面前放置着大小分别为 <code>a</code>、<code>b</code> 和 <code>c</code> 的 <strong>三堆</strong> 石子。</p><p>每回合你都要从两个 <strong>不同的非空堆</strong> 中取出一颗石子，并在得分上加 <code>1</code> 分。当存在 <strong>两个或更多</strong> 的空堆时，游戏停止。</p><p>给你三个整数 <code>a</code> 、<code>b</code> 和 <code>c</code> ，返回可以得到的 <strong>最大分数</strong> 。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul><li>较小的两个值之和等于较大的值，此时最多得 <strong>较大值</strong> 的分数；</li><li>较小的两个值之和大于较大的值，此时最多得分为： <strong>较大值</strong> 的分数加 <strong>较小值之和的一半</strong> 的分数之和；</li><li>较小的两个值之和小于较大的值，此时最多得 <strong>较小值之和</strong> 的分数；</li></ul><p>情况①：较小的两个值之和等于较大的值</p><p>两个较小值可以将较大值<strong>一一抵消</strong>。</p><p>情况②：较小的两个值之和大于较大的值</p><p>除了较大的值可以将两个较小的值抵消一部份外，剩下的两个较小值需要<strong>尽可能平分抵消后剩下的石子</strong>，目的是可以最大程度的拿掉更多的石子。这样做还可以获得的分数为<strong>抵消后两者之和的一半</strong>。</p><p>情况③：较小的两个值之和小于较大的值</p><p>那么较大的值最多可以将较小的两个值<strong>全部抵消</strong>。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;a, b, c&#125;;</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">if</span>(vec[<span class="number">0</span>] + vec[<span class="number">1</span>] == vec[<span class="number">2</span>]) <span class="keyword">return</span> vec[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vec[<span class="number">0</span>] + vec[<span class="number">1</span>] &gt; vec[<span class="number">2</span>]) <span class="keyword">return</span> vec[<span class="number">2</span>] + (vec[<span class="number">0</span>] + vec[<span class="number">1</span>] - vec[<span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> vec[<span class="number">0</span>] + vec[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造字典序最大的合并字符串"><a href="#构造字典序最大的合并字符串" class="headerlink" title="构造字典序最大的合并字符串"></a>构造字典序最大的合并字符串</h4><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。你需要按下述方式构造一个新字符串 <code>merge</code> ：如果 <code>word1</code> 或 <code>word2</code> 非空，选择 <strong>下面选项之一</strong> 继续操作：</p><p>如果 <code>word1</code> 非空，将 <code>word1</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word1</code> 中移除。<br>例如，<code>word1 = &quot;abc&quot;</code> 且 <code>merge = &quot;dv&quot;</code> ，在执行此选项操作之后，<code>word1 = &quot;bc&quot;</code> ，同时 <code>merge = &quot;dva&quot;</code> 。<br>如果 <code>word2</code> 非空，将 <code>word2</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word2</code> 中移除。<br>例如，<code>word2 = &quot;abc&quot;</code> 且 <code>merge = &quot;&quot;</code> ，在执行此选项操作之后，<code>word2 = &quot;bc&quot;</code> ，同时 <code>merge = &quot;a&quot;</code> 。<br>返回你可以构造的字典序 <strong>最大</strong> 的合并字符串 <code>merge</code> 。</p><p>长度相同的两个字符串 <code>a</code> 和 <code>b</code> 比较字典序大小，如果在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，<code>a</code> 中字符在字母表中的出现顺序位于 <code>b</code> 中相应字符之后，就认为字符串 <code>a</code> 按字典序比字符串 <code>b</code> 更大。例如，<code>&quot;abcd&quot;</code> 按字典序比 <code>&quot;abcc&quot;</code> 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 <code>d</code> 在字母表中的出现顺序位于 <code>c</code> 之后。</p><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>从 <code>word1</code> 和 <code>word2</code> 的首字符中挑选更大的一个加入到答案字符串中。如果字符相同，则比较两个字符串剩下的子串，选取字典序更大的一个字符串的首字符加入答案中，如果两者相等，则任取一个字符串中的首字符。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestMerge</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt; word1.size() &amp;&amp; index2 &lt; word2.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[index1] &gt; word2[index2])&#123;</span><br><span class="line">                ans += word1[index1];</span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(word1[index1] &lt; word2[index2])&#123;</span><br><span class="line">                ans += word2[index2];</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前字符相等，取字典序更大的子串中的第一个字符</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">string</span> word1Helper = word1.substr(index1, word1.size() - index1);</span><br><span class="line">                <span class="built_in">string</span> word2Helper = word2.substr(index2, word2.size() - index2);</span><br><span class="line">                <span class="keyword">if</span>(word1Helper &gt; word2Helper)&#123;</span><br><span class="line">                    ans += word1[index1++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(word1Helper &lt; word2Helper)&#123;</span><br><span class="line">                    ans += word2[index2++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果子串相等，任取一个字符</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += word1[index1++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index2 != word2.size()) ans += word2.substr(index2, word2.size() - index2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index1 != word1.size()) ans += word1.substr(index1, word1.size() - index1);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最接近目标值的子序列和"><a href="#最接近目标值的子序列和" class="headerlink" title="最接近目标值的子序列和"></a>最接近目标值的子序列和</h4><p>给你一个整数数组 <code>nums</code> 和一个目标值 <code>goal</code> 。</p><p>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 <code>sum</code> ，你需要 最小化绝对差 <code>abs(sum - goal)</code> 。</p><p>返回 <code>abs(sum - goal)</code> 可能的 最小值 。</p><h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><ol><li>将序列均分为两部分，分别求其相应的所有子集之和（这里使用<strong>位运算</strong>求子集）；</li><li>将其中的一个子集之和进行排序；</li><li>遍历另外一个子集之和，每个元素记为 <code>x</code>，求出每个 <code>goal - x</code>，在排好序的子集之和中进行二分查找，循环更新，找到差值绝对值的最小值。</li></ol><p>对于步骤 3：</p><p>设已排序数组元素为 <code>y</code>，未排序数组为 <code>x</code>，差值的绝对值为 <code>a</code>，则有：<br>$$<br>|goal - (x + y)|=a<br>$$<br>化简可得：<br>$$<br>goal - x = y + \pm a<br>$$<br>即：步骤 3 中找到的就是 <code>y</code>，找到后将其与 <code>goal - x</code> 作差，再取绝对值就是当前<strong>差值绝对值的最小值</strong>。</p><p>由于使用 <code>lower_bound</code> 查找的值不一定存在，需要比较 <code>goal - x</code> 与<strong>插入位置的值</strong>和<strong>插入位置之前的值</strong>的差值中哪个的绝对值更小一点；如果插入位置为起点或者末尾，则只需要与插入位置的值进行对比即可。以上都是更新差值绝对值的最小值：<br>$$<br>ans = min(ans, {待比较值})<br>$$<br><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="comment">// 分成两部分</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.begin(), nums.begin() + len / <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums2</span><span class="params">(nums.begin() + len / <span class="number">2</span>, nums.end())</span></span>;</span><br><span class="line">        <span class="comment">// 分别求和的子集</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum1;</span><br><span class="line">        subVecSum(nums1, sum1);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum2;</span><br><span class="line">        subVecSum(nums2, sum2);</span><br><span class="line">        sort(sum1.begin(), sum1.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : sum2)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = goal - x;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(sum1.begin(), sum1.end(), val);</span><br><span class="line">            <span class="comment">// 注意如何更新ans</span></span><br><span class="line">            <span class="keyword">if</span>(it == sum1.begin()) ans = min(ans, <span class="built_in">abs</span>(val - *it));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(it == sum1.end()) ans = min(ans, <span class="built_in">abs</span>(val - *--it));</span><br><span class="line">            <span class="keyword">else</span> ans = min(ans, min(<span class="built_in">abs</span>(val - *it), <span class="built_in">abs</span>(val - *--it)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subVecSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vecSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = vec.size();</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span> &lt;&lt; len;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(mask; mask &lt; end; ++mask)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; i) &amp; mask)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    sum += vec[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) vecSum.push_back(sum);</span><br><span class="line">            <span class="keyword">else</span> vecSum.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;检查数组能否经排序和轮转得到&lt;/li&gt;
&lt;li&gt;移除石子的最大得分&lt;/li&gt;
&lt;li&gt;构造字典序最大的合并字符串&lt;/li&gt;
&lt;li&gt;最接近目标值的子序列和&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode周赛" scheme="http://www.xingyuzhao.ltd/categories/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="分治算法" scheme="http://www.xingyuzhao.ltd/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://www.xingyuzhao.ltd/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1423-可获得的最大点数</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/06/LeetCode1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/06/LeetCode1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/</id>
    <published>2021-02-06T12:41:49.000Z</published>
    <updated>2021-02-06T12:53:00.644Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p><a id="more"></a><img src="/blog/2021/02/06/LeetCode1423-可获得的最大点数/1423.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于每次都是从端点取数，所以取到的数是连续的（将数组首尾连接为一个循环数组）。</p><p>可以维护一个长度为 <code>n - k</code> 的窗口在 <code>cardPoints</code> 数组上滑动，当窗口内值的和最小时，剩下的 <code>k</code> 个数和最大，也就是可以获得的最大点数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cardPoints.size() == <span class="number">1</span>) <span class="keyword">return</span> cardPoints[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = cardPoints.size() - k;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(cardPoints.begin(), cardPoints.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> windowSum = accumulate(cardPoints.begin(), cardPoints.begin() + len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(right != cardPoints.size() - <span class="number">1</span>)&#123; <span class="comment">// 注意最后一次未比较</span></span><br><span class="line">            ans = max(ans, sum - windowSum);</span><br><span class="line">            windowSum -= cardPoints[left++];</span><br><span class="line">            windowSum += cardPoints[++right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一组窗口的和还没进行比较，这里需要再比较一次</span></span><br><span class="line">        ans = max(ans, sum - windowSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;几张卡牌 &lt;strong&gt;排成一行&lt;/strong&gt;，每张卡牌都有一个对应的点数。点数由整数数组 &lt;code&gt;cardPoints&lt;/code&gt; 给出。&lt;/p&gt;
&lt;p&gt;每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 &lt;code&gt;k&lt;/code&gt; 张卡牌。&lt;/p&gt;
&lt;p&gt;你的点数就是你拿到手中的所有卡牌的点数之和。&lt;/p&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;cardPoints&lt;/code&gt; 和整数 &lt;code&gt;k&lt;/code&gt;，请你返回可以获得的最大点数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://www.xingyuzhao.ltd/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1208-尽可能使字符串相等</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/05/LeetCode1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/05/LeetCode1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</id>
    <published>2021-02-05T06:51:59.000Z</published>
    <updated>2021-02-05T09:15:52.764Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p><p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p><p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p><a id="more"></a><img src="/blog/2021/02/05/LeetCode1208-尽可能使字符串相等/1208.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用一个变量 <code>cost</code> 记录当前子串的总消耗，<code>start</code> 和 <code>end</code> 分别为子串的起始位置和终点位置。如果此时：</p><ul><li><code>cost &gt; maxCost</code>，更新字符串的长度，选择之前子串与当前子串中长度更大的一个。同时从总消耗 <code>cost</code> 中减去当前子串起始位置 <code>start</code> 的消耗，并使起始位置 <code>start</code> 加 1。</li><li><code>cost &lt;= maxCost</code>，满足消耗要求时，使终点位置 <code>end</code> 加 1，同时加上此时 <code>end</code> 处的消耗。</li><li>循环上述步骤，直到 <code>end</code> 到达字符串尾。</li></ul><p>如果此时 <code>cost &lt;= maxCost</code>，说明还剩下最后一个子串消耗符合要求，选择<strong>此时的子串长度</strong>和<strong>之前子串长度最大值</strong>中较大的一个，即为答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="built_in">abs</span>(s[<span class="number">0</span>] - t[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; maxCost)&#123;</span><br><span class="line">                maxLen = max(maxLen, end - start);</span><br><span class="line">                cost -= <span class="built_in">abs</span>(t[start] - s[start]);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">            cost += <span class="built_in">abs</span>(t[end] - s[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cost &lt;= maxCost) <span class="keyword">return</span> max(end - start, maxLen);</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>一开始把题目想复杂了，导致这道题花了一个小时，还需要继续努力！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你两个长度相同的字符串，&lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;s&lt;/code&gt; 中的第 &lt;code&gt;i&lt;/code&gt; 个字符变到 &lt;code&gt;t&lt;/code&gt; 中的第 &lt;code&gt;i&lt;/code&gt; 个字符需要 &lt;code&gt;|s[i] - t[i]|&lt;/code&gt; 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。&lt;/p&gt;
&lt;p&gt;用于变更字符串的最大预算是 &lt;code&gt;maxCost&lt;/code&gt;。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。&lt;/p&gt;
&lt;p&gt;如果你可以将 &lt;code&gt;s&lt;/code&gt; 的子字符串转化为它在 &lt;code&gt;t&lt;/code&gt; 中对应的子字符串，则返回可以转化的最大长度。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;s&lt;/code&gt; 中没有子字符串可以转化成 &lt;code&gt;t&lt;/code&gt; 中对应的子字符串，则返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++操作重载与类型转换</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/04/C-%E6%93%8D%E4%BD%9C%E9%87%8D%E8%BD%BD%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/04/C-%E6%93%8D%E4%BD%9C%E9%87%8D%E8%BD%BD%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-02-04T07:47:06.000Z</published>
    <updated>2021-02-06T14:17:18.088Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>基本概念</li><li>输入和输出运算符</li><li>算术和关系运算符</li><li>赋值运算符</li><li>下标运算符</li><li>递增和递减运算符</li><li>成员访问运算符</li><li>函数调用运算符</li><li>重载、类型转换与运算符</li></ol><a id="more"></a><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。</p><p>当一个重载的运算符是成员函数时，<code>this</code> 绑定到左侧运算对象。成员运算符函数的参数数量比运算对象的数量少一个。</p><p><strong>可以被重载的运算符</strong></p><img src="/blog/2021/02/04/C-操作重载与类型转换/可重载的运算符.png"><h5 id="直接调用一个重载的运算符函数"><a href="#直接调用一个重载的运算符函数" class="headerlink" title="直接调用一个重载的运算符函数"></a>直接调用一个重载的运算符函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个非成员运算符函数的等价调用</span></span><br><span class="line">data1 + data2;</span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);</span><br><span class="line"><span class="comment">// 成员运算符函数</span></span><br><span class="line">data1 += data2;</span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);</span><br></pre></td></tr></table></figure><h5 id="某些运算符不应被重载"><a href="#某些运算符不应被重载" class="headerlink" title="某些运算符不应被重载"></a>某些运算符不应被重载</h5><img src="/blog/2021/02/04/C-操作重载与类型转换/不应该被重载的运算符.png"><h5 id="选择作为成员或者非成员"><a href="#选择作为成员或者非成员" class="headerlink" title="选择作为成员或者非成员"></a>选择作为成员或者非成员</h5><ul><li>赋值（=）、下标（[ ]）、调用（( )）、和成员访问箭头（-&gt;）运算符必须为成员。</li><li>复合赋值运算符一般为成员。</li><li>递增、递减、解引用通常为成员。</li><li>对称性运算符通常为非成员函数，如算术、相等性、关系和位运算符等。</li></ul><h4 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h4><h5 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h5><p>第一个形参是一个非常量 <code>ostream</code> 对象的引用；第二个形参是一个常量的引用，该常量是我们想要打印类类型。为了和其他输出运算符保持一致，<code>operator&lt;&lt;</code> 一般要返回它的 <code>ostream</code> 形参。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, Sales_data &amp;item)&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="输入输出运算符必须是非成员函数"><a href="#输入输出运算符必须是非成员函数" class="headerlink" title="输入输出运算符必须是非成员函数"></a>输入输出运算符必须是非成员函数</h6><p>除此之外，<code>I/O</code>运算符一般被声明为友元。</p><h5 id="重载输出运算符-gt-gt"><a href="#重载输出运算符-gt-gt" class="headerlink" title="重载输出运算符&gt;&gt;"></a>重载输出运算符&gt;&gt;</h5><p>第一个形参是将要读取的流的引用；第二个形参是将要读入到的（非常量）对象的引用。该运算符返回某个给定流的引用。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sale_data &amp;item)&#123;</span><br><span class="line"><span class="keyword">double</span> price;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span>(is) <span class="comment">// 输入成功</span></span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 失败，对象被赋予默认状态</span></span><br><span class="line">        item = Sales_data();</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/04/C-操作重载与类型转换/输入输出运算符.png"><h4 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h4><p>算术和关系运算符通常定义为非成员函数。</p><h5 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;</span><br><span class="line">           lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">           lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/04/C-操作重载与类型转换/相等运算符.png"><h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><img src="/blog/2021/02/04/C-操作重载与类型转换/关系运算符.png"><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符必须定义为类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</p><h4 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h4><p>下标运算符必须是成员函数。</p><img src="/blog/2021/02/04/C-操作重载与类型转换/下标运算符.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[n];</span><br><span class="line">    &#125;</span><br><span class="line">    cosnt <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[n];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *elements;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************/</span></span><br><span class="line"><span class="keyword">const</span> StrVec cvec = svec; <span class="comment">// 假设svec是一个StrVec对象</span></span><br><span class="line"><span class="keyword">if</span>(svec.size() &amp;&amp; svec[<span class="number">0</span>].empty())&#123;</span><br><span class="line">    svec[<span class="number">0</span>] = <span class="string">"zero"</span>; <span class="comment">// 正确：下标运算符返回string的引用</span></span><br><span class="line">    cvec[<span class="number">0</span>] = <span class="string">"Zip"</span>; <span class="comment">// 错误：对cvec区取下标返回是常量引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h4><p>建议将它们设为成员函数。</p><h5 id="定义前置递增-递减运算符"><a href="#定义前置递增-递减运算符" class="headerlink" title="定义前置递增/递减运算符"></a>定义前置递增/递减运算符</h5><p>为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">StrBlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="区分前置和后置运算符"><a href="#区分前置和后置运算符" class="headerlink" title="区分前置和后置运算符"></a>区分前置和后置运算符</h5><p>为了和前置区分，后置接受一个额外的（不被使用）<code>int</code> 类型的形参。</p><p>为了和内置版本保持一致，后置运算符应该返回对象的原值，返回的是一个值而非引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="显示的调用后置运算符"><a href="#显示的调用后置运算符" class="headerlink" title="显示的调用后置运算符"></a>显示的调用后置运算符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>; <span class="comment">// p 指向 a1 中的 vector</span></span><br><span class="line">p.<span class="keyword">operator</span>(<span class="number">0</span>); <span class="comment">// 调用后置版本的 operator</span></span><br><span class="line">p.<span class="keyword">operator</span>(); <span class="comment">// 前置版本</span></span><br></pre></td></tr></table></figure><h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h4><p>箭头运算符必须是类的成员，解引用运算符通常是类的成员。</p><p><strong>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象</strong>。</p><h4 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h4><p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</p><ul><li><p>如果类定义了调用运算符，则该类的对象称作<strong>函数对象</strong>。这些对象“行为像函数一样”。</p><h5 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h5></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据单词长度对其进行排序，对于长度相同的单词按照字母表顺序排序</span></span><br><span class="line">stable_sort(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.size() &lt; b.size();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其行为类似与下面这个类的一个未命名对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShorterString</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">stable_sort(words.begin(), words.end(), ShorterString());</span><br></pre></td></tr></table></figure><h6 id="表示lambda及相应捕获行为的类"><a href="#表示lambda及相应捕获行为的类" class="headerlink" title="表示lambda及相应捕获行为的类"></a>表示lambda及相应捕获行为的类</h6><p>引用捕获变量不需多加考虑。</p><p>值捕获的变量被拷贝到 <code>lambda</code> 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得第一个指向满足条件的迭代器，该元素满足其size() &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123;</span><br><span class="line"><span class="keyword">return</span> a.size() &gt;= sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该 <code>lambda</code> 表达式产生的类将形如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComp</span>&#123;</span></span><br><span class="line">SizeComp(<span class="keyword">size_t</span> n): sz(n)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.size() &gt;= sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">size_t</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(word.begin(), words.end(), SizeComp(sz));</span><br></pre></td></tr></table></figure><h5 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h5><img src="/blog/2021/02/04/C-操作重载与类型转换/标准库函数对象.png" style="zoom:80%;"><ul><li><code>greater</code> 类型的对象执行降序排列（<code>&gt;</code>）。</li></ul><h5 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h5><p>不同类型可能具有相同的调用形式，下述可调用对象共享调用形式 <code>int(int, int)</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123; <span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"><span class="comment">// 函数对象类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divide</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> denominator / divisor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果使用 <code>map&lt;string, int(*)(int,int) binops;</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binops.insert(&#123;<span class="string">"+"</span>, add&#125;); <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">// 但是不能将 mod 和 divide 存入 binops，类型不匹配</span></span><br></pre></td></tr></table></figure><p> 为了解决上述问题，可以使用 <code>function</code>。</p><h6 id="标准库function类型"><a href="#标准库function类型" class="headerlink" title="标准库function类型"></a>标准库function类型</h6><p><code>function</code> 定义在头文件 <code>functional</code> 中。</p><img src="/blog/2021/02/04/C-操作重载与类型转换/function.png" style="zoom:80%;"><p>使用 <code>funtion</code> 可以解决上小节问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;</span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide();</span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123; <span class="keyword">return</span> i * j; &#125;;</span><br></pre></td></tr></table></figure><p>可以用 <code>map&lt;string, function&lt;int(int, int)&gt;&gt; binops</code> 将上述类型添加。</p><p><strong>不能直接将重载函数的名字存入function类型的对象中</strong>。</p><h4 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h4><h5 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h5><p>是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>其中，<code>type</code> 表示某种类型。</p><img src="/blog/2021/02/04/C-操作重载与类型转换/类型转换运算符note.png"><h6 id="类型转换运算可能产生意外结果"><a href="#类型转换运算可能产生意外结果" class="headerlink" title="类型转换运算可能产生意外结果"></a>类型转换运算可能产生意外结果</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">cin &lt;&lt; i; // 如果 bool 的类型转换不是显式的，则编译可通过</span><br></pre></td></tr></table></figure><p>该代码使用 <code>istream</code> 的 <code>bool</code> 类型转换运算符将 <code>cin</code> 转换成 <code>bool</code>（P516）。</p><h6 id="显式的类型转换运算符（explicit-conversion-operator）"><a href="#显式的类型转换运算符（explicit-conversion-operator）" class="headerlink" title="显式的类型转换运算符（explicit conversion operator）"></a>显式的类型转换运算符（explicit conversion operator）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 编译器不会自动执行这一类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;</span><br><span class="line">si + <span class="number">3</span>; <span class="comment">// 错误，无隐式类型转换</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p><strong>该规定存在一个例外</strong>，如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它：</p><ol><li><code>if</code>、<code>while </code>及 <code>do</code> 语句的条件部分。</li><li><code>for</code> 语句头的条件表达式。</li><li><code>!</code>、<code>||</code>、<code>&amp;&amp;</code> 的运算对象。</li><li><code>?:</code> 的条件表达式。</li></ol><h6 id="转换为bool"><a href="#转换为bool" class="headerlink" title="转换为bool"></a>转换为bool</h6><p>无论何时在条件中使用流对象，都会使用为 <code>IO</code> 类型定义的 <code>operator bool</code>。</p><img src="/blog/2021/02/04/C-操作重载与类型转换/转换为bool.png"><h5 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h5><ol><li>最好不要在两个类之间构建相同的类型转换。</li><li>最好不要创建两个转换源/转换对象都是算术类型的类型转换。</li></ol><img src="/blog/2021/02/04/C-操作重载与类型转换/二义性类型转换note.png"><h5 id="函数匹配与重载运算符"><a href="#函数匹配与重载运算符" class="headerlink" title="函数匹配与重载运算符"></a>函数匹配与重载运算符</h5><img src="/blog/2021/02/04/C-操作重载与类型转换/函数匹配与重载运算符.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;基本概念&lt;/li&gt;
&lt;li&gt;输入和输出运算符&lt;/li&gt;
&lt;li&gt;算术和关系运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;下标运算符&lt;/li&gt;
&lt;li&gt;递增和递减运算符&lt;/li&gt;
&lt;li&gt;成员访问运算符&lt;/li&gt;
&lt;li&gt;函数调用运算符&lt;/li&gt;
&lt;li&gt;重载、类型转换与运算符&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="Class" scheme="http://www.xingyuzhao.ltd/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>C++拷贝控制</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/03/C-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/03/C-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</id>
    <published>2021-02-03T15:22:39.000Z</published>
    <updated>2021-02-05T07:13:02.318Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>拷贝、赋值与销毁</li><li>拷贝控制和资源管理</li><li>交换操作</li><li>拷贝控制示例</li><li>动态内存管理类</li><li>对象移动</li></ol><a id="more"></a><h4 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h4><h5 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h5><p>如果一个构造函数的第一个参数是自身类型的引用，且任何额外的参数都有默认值，则此构造函数是拷贝构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(); <span class="comment">// 默认构造函数</span></span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h6><p>如果没有为一个类定义拷贝构造函数，编译器会自动定义一个，称为合成拷贝构造函数。</p><p>对某些类来说，<strong>合成拷贝构造函数用来阻止拷贝该类型的对象</strong>。除此之外，合成拷贝构造函数会将参数的成员依次拷贝到正在创建的对象中。</p><h6 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">'.'</span>)</span></span>; <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(dots)</span></span>; <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="comment">// 拷贝初始化，将右侧的对象拷贝到新创建的对象中</span></span><br><span class="line"><span class="built_in">string</span> s2 = dots;</span><br></pre></td></tr></table></figure><h6 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h6><p>在函数调用过程中，具有<strong>非引用类型</strong>的参数要进行拷贝初始化。</p><p>拷贝构造函数被用来初始化<strong>非引用类型参数</strong>，所以拷贝构造函数自己的参数必须是<strong>引用类型</strong>，从而可以拷贝实参。</p><h6 id="拷贝初始化的限制"><a href="#拷贝初始化的限制" class="headerlink" title="拷贝初始化的限制"></a>拷贝初始化的限制</h6><p>拷贝构造函数通常不应该是 <code>explicit</code> 的。</p><h6 id="编译器可以绕过拷贝构造函数"><a href="#编译器可以绕过拷贝构造函数" class="headerlink" title="编译器可以绕过拷贝构造函数"></a>编译器可以绕过拷贝构造函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-99999-9"</span>; <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>  <span class="title">null_book</span><span class="params">(<span class="string">"9-999-99999-9"</span>)</span></span>; <span class="comment">// 编译器忽略拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>拷贝/移动构造函数必须是存在且可访问的（不能为 <code>private</code> ）。</p><h5 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h5><h6 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h6><p>赋值运算符就是一个 <code>operator=</code> 的函数，它有一个返回类型和一个参数列表。并且必须定义为成员函数，其左侧运算对象绑定到隐式的 <code>this</code> 参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;); <span class="comment">// 赋值运算符 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>赋值运算符应该返回一个指向其左侧运算对象的引用</strong>。</p><h6 id="合成拷贝赋值运算符"><a href="#合成拷贝赋值运算符" class="headerlink" title="合成拷贝赋值运算符"></a>合成拷贝赋值运算符</h6><p>如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝运算符。</p><p>对某些类来说，<strong>合成拷贝赋值运算符用来阻止该类型对象的赋值</strong>。除此之外，合成拷贝赋值运算符会将右侧运算对象的每个非 <code>static</code> 成员赋予左侧对象的对应成员。</p><p>下述代码等价于合成拷贝赋值运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">    bookNo = rhs.bookNo;</span><br><span class="line">    units_sold = rhs.units_sold;</span><br><span class="line">    revenue = rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>析构函数释放对象所使用的资源，并销毁对象的非 <code>static</code> 数据成员。</p><h6 id="合成析构函数"><a href="#合成析构函数" class="headerlink" title="合成析构函数"></a>合成析构函数</h6><p>当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。如果其作用不是为了阻止某些类对象被销毁，那么它的函数体就为空。</p><h5 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h5><ul><li>需要析构函数的类也需要拷贝和赋值操作。</li><li>需要拷贝操作的类也需要赋值操作，反之亦然。</li></ul><h5 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h5><p>将拷贝控制成员定义为 <code>=default</code> 来显式地要求编译器生成合成的版本。</p><h5 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h5><p>某些类的拷贝构造函数和拷贝赋值运算符操作是没有意义的，如：<code>iostream</code> 类阻止拷贝，以避免多个对象写入或读取相同的 <code>IO</code> 缓冲。</p><p>新标准下，可以在函数参数列表后加上 <code>=delete</code> 表示它是<strong>删除</strong>的。且 <code>=delete</code> 必须出现在函数第一次声明时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span>&#123;</span></span><br><span class="line">NoCopy() = <span class="keyword">default</span>; <span class="comment">// 使用合成的默认构造函数</span></span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止拷贝</span></span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止赋值</span></span><br><span class="line">    ~NoCopy() = <span class="keyword">default</span>; <span class="comment">// 使用合成的析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="析构函数不能是删除的成员"><a href="#析构函数不能是删除的成员" class="headerlink" title="析构函数不能是删除的成员"></a><strong>析构函数不能是删除的成员</strong></h6><h6 id="合成的拷贝控制成员可能是删除的"><a href="#合成的拷贝控制成员可能是删除的" class="headerlink" title="合成的拷贝控制成员可能是删除的"></a><strong>合成的拷贝控制成员可能是删除的</strong></h6><h6 id="private拷贝控制"><a href="#private拷贝控制" class="headerlink" title="private拷贝控制"></a><strong>private拷贝控制</strong></h6><p>通过声明（但不定义）<code>private</code> 的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图。</p><h4 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h4><h5 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h5><p>类的行为像一个值，表示它有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。</p><p><strong>关键概念：赋值运算符</strong></p><ul><li>如果将一个对象赋予它自身，赋值运算符必须能正常工作。</li><li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作。</li></ul><h5 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h5><p>行为像指针的类则共享状态，当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。</p><p>除了使用 <code>shared__ptr</code> 来管理类中的资源，如果想要直接管理资源，需要使用<strong>引用计数</strong>。</p><h4 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h4><p>如果使用重排元素顺序的算法来操作类，那么定义一个 <code>swap</code> 就很重要了，算法在需要交换两个元素时调用 <code>swap</code>。</p><h5 id="编写我们自己的swap函数"><a href="#编写我们自己的swap函数" class="headerlink" title="编写我们自己的swap函数"></a>编写我们自己的swap函数</h5><p>我们希望交换指针而不是分配新副本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.ps, rhs.ps); <span class="comment">// 交换string指针</span></span><br><span class="line">    swap(lhs.i, rhs.i); <span class="comment">// 交换int成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个调用都应该是 <code>swap</code> 而不是 <code>std::swap</code> 。</p><h5 id="在赋值运算符中使用swap"><a href="#在赋值运算符中使用swap" class="headerlink" title="在赋值运算符中使用swap"></a>在赋值运算符中使用swap</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rhs按值传递，HasPtr拷贝构造函数将右侧运算对象中的string拷贝到rhs</span></span><br><span class="line"><span class="function">HasPtr&amp; <span class="title">HasPtr::operator</span><span class="params">(HasPtr rhs)</span></span>&#123;</span><br><span class="line">    swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// rhs被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝控制示例"><a href="#拷贝控制示例" class="headerlink" title="拷贝控制示例"></a>拷贝控制示例</h4><p>实例，写为工程。</p><h4 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a>动态内存管理类</h4><p>实例，写为工程。</p><h4 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h4><p>很多情况下发生对象拷贝后就立即销毁了，如果此时进行移动而非拷贝对象会大幅度提升性能。</p><img src="/blog/2021/02/03/C-拷贝控制/对象移动_note.png"><h5 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h5><p>右值引用就是必须绑定到右值的引用，使用 <code>&amp;&amp;</code> 而不是 <code>&amp;</code> 来获取右值引用。</p><p><strong>右值引用有一个重要的性质——只能绑定到一个将要销毁的对象，因此，我们可以将一个右值引用的资源移动到另一个对象中。</strong></p><ul><li>一般而言，一个左值表达式表示的是一个对象的身份，而右值表达式表示的对象的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i; <span class="comment">// 正确，r 引用 i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i; <span class="comment">// 错误，不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>; <span class="comment">// 错误，i*42是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>; <span class="comment">// 正确， 可以将一个 const 的引用绑定到一个右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>; <span class="comment">// 正确，将 rr2 绑定到乘法结果上</span></span><br></pre></td></tr></table></figure><h6 id="左值持久，右值短暂"><a href="#左值持久，右值短暂" class="headerlink" title="左值持久，右值短暂"></a>左值持久，右值短暂</h6><p>右值要么是字面值常量，要么是在表达式求值过程中创建的临时对象。</p><h6 id="变量是左值"><a href="#变量是左值" class="headerlink" title="变量是左值"></a>变量是左值</h6><h6 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库move函数</h6><p>头文件 <code>utility</code> 中，名为 <code>move</code> 的函数可以显式地将一个左值转换为对应地右值引用。使用 <code>move</code> 时应使用 <code>std::move</code> ，避免潜在的名字冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = <span class="built_in">std</span>::move(rr1); <span class="comment">// 调用move意味着：除了对rr1赋值或销毁它外，我们将不再使用它</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/02/03/C-拷贝控制/move_note.png"><h5 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h5><h6 id="移动操作、标准库容器和异常"><a href="#移动操作、标准库容器和异常" class="headerlink" title="移动操作、标准库容器和异常"></a>移动操作、标准库容器和异常</h6><p>移动操作不会抛出任何异常，我们应将此事通知给标准库，一种方法为在构造函数中指明 <code>noexcept</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">StrVec(StrVec&amp;&amp;) <span class="keyword">noexcept</span>; <span class="comment">// 移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : <span class="comment">/*成员初始化器*/</span></span><br><span class="line">&#123; <span class="comment">/* 构造函数体 */</span>&#125;</span><br></pre></td></tr></table></figure><h6 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h6><p>如果我们的移动赋值预算符不抛出任何异常，我们就应该将其标记为 <code>noexcept</code>。</p><h6 id="移后源对象必须可析构"><a href="#移后源对象必须可析构" class="headerlink" title="移后源对象必须可析构"></a>移后源对象必须可析构</h6><p>在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p><h6 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h6><img src="/blog/2021/02/03/C-拷贝控制/合成的移动操作_note.png"><p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地定义为删除的。</p><h6 id="移动右值，拷贝左值"><a href="#移动右值，拷贝左值" class="headerlink" title="移动右值，拷贝左值"></a>移动右值，拷贝左值</h6><h6 id="如果没有移动构造函数，右值也被拷贝"><a href="#如果没有移动构造函数，右值也被拷贝" class="headerlink" title="如果没有移动构造函数，右值也被拷贝"></a>如果没有移动构造函数，右值也被拷贝</h6><img src="/blog/2021/02/03/C-拷贝控制/右值拷贝.png"><h6 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h6><p>新标准库中定义了一种<strong>移动迭代器</strong>适配器，其解引用运算符生成一个右值引用。我们通过调用标准库中的 <code>make_move_iterator</code> 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个迭代器。</p><img src="/blog/2021/02/03/C-拷贝控制/不要随意使用移动操作.png"><h5 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h5><p>如果一个成员函数同时提供拷贝和移动版本，其中一个版本接受一个指向 <code>const</code> 的左值引用，第二个版本接受一个指向非 <code>const</code> 的右值引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>; <span class="comment">// 拷贝，绑定到任意类型的X</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>; <span class="comment">// 移动，只能绑定到类型X可修改的右值</span></span><br></pre></td></tr></table></figure><h6 id="引用限定符"><a href="#引用限定符" class="headerlink" title="引用限定符"></a><strong>引用限定符</strong></h6><p>引用限定符可以是 <code>&amp;</code> 或 <code>&amp;&amp;</code>，分别指出 <code>this</code> 可以指向一个左值或右值，只能用于非 <code>static</code> 成员函数，且必须同时出现在函数的声明和定义中。一个函数可以同时用 <code>const</code> 和引用限定，引用限定必须跟随在 <code>const</code> 限定符之后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="keyword">const</span></span>; <span class="comment">// 错误，const 限定符必须在前</span></span><br><span class="line"><span class="function">FOO <span class="title">anotherMem</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>; <span class="comment">// 正确，const 限定符在前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们对一个右值进行排序时，可以安全的直接对 <code>data</code> 成员进行排序；当对一个 <code>const</code> 右值或一个左值执行排序时，我们不能改变对象，因此需要在排序前拷贝 <code>data</code>。</p><img src="/blog/2021/02/03/C-拷贝控制/引用限定符_note.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;拷贝、赋值与销毁&lt;/li&gt;
&lt;li&gt;拷贝控制和资源管理&lt;/li&gt;
&lt;li&gt;交换操作&lt;/li&gt;
&lt;li&gt;拷贝控制示例&lt;/li&gt;
&lt;li&gt;动态内存管理类&lt;/li&gt;
&lt;li&gt;对象移动&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="Class" scheme="http://www.xingyuzhao.ltd/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode424-替换后的最长重复字符</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/03/LeetCode424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/03/LeetCode424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/</id>
    <published>2021-02-03T13:26:15.000Z</published>
    <updated>2021-02-03T13:54:41.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p>注意：字符串长度 和 <em>k</em> 不会超过 10^4。</p><a id="more"></a><img src="/blog/2021/02/03/LeetCode424-替换后的最长重复字符/424.PNG"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>第一眼看上去像动态规划，实际上是双指针，或者说滑动窗口。</p><p>我们记 <code>left</code> 为左指针，<code>right</code> 为右指针：</p><ol><li>固定 <code>left</code>，<code>right</code> 向右滑动的同时，记录遍历过的每个字符出现的次数，同时记录所遍历的字符中，出现次数最多的字符的数量。</li><li>如果出现次数最多的字符 + k 小于 <code>right - left</code> ，说明在 <code>[left, right)</code> 区间中，<strong>除出现最多的字符外，需要修改的其他字符的总数已经大于 k 了</strong>。</li><li>此时，需要将左指针 <code>left</code> 向右滑动，下一个字符与当前相同或者不同，都不会影响结果，记录此时的 <code>right - left</code> 表示当前可以连续的字符串长度。重复步骤 1，直到 <code>right</code> 指向字符串末尾。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> freq[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.size())&#123;</span><br><span class="line">            freq[s[right] - <span class="string">'A'</span>]++;</span><br><span class="line">            <span class="comment">// 找到出现次数最多的字母</span></span><br><span class="line">            maxCount = max(maxCount, freq[s[right] - <span class="string">'A'</span>]);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 除了最多字母外，不够修改k次其他字母</span></span><br><span class="line">            <span class="keyword">if</span>(right - left &gt; maxCount + k)&#123;</span><br><span class="line">                freq[s[left] - <span class="string">'A'</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 &lt;em&gt;k&lt;/em&gt; 次。在执行上述操作后，找到包含重复字母的最长子串的长度。&lt;/p&gt;
&lt;p&gt;注意：字符串长度 和 &lt;em&gt;k&lt;/em&gt; 不会超过 10^4。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>I/O控制（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/02/I-O%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/02/I-O%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-02T02:30:41.000Z</published>
    <updated>2021-02-02T13:57:15.583Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>假脱机技术（SPOOLing技术）</li><li>设备的分配与回收</li><li>缓冲区管理</li></ol><a id="more"></a><h4 id="假脱机技术（SPOOLing技术）"><a href="#假脱机技术（SPOOLing技术）" class="headerlink" title="假脱机技术（SPOOLing技术）"></a>假脱机技术（SPOOLing技术）</h4><h5 id="什么是脱机技术"><a href="#什么是脱机技术" class="headerlink" title="什么是脱机技术"></a>什么是脱机技术</h5><p>脱离主机的控制进行输入/输出操作。</p><h5 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h5><p>又称SPOOLing技术，使用软件方式模拟脱机技术。组成如下：</p><img src="/blog/2021/02/02/I-O控制（二）/输入井和输出井.png" style="zoom:80%;"><p>输入进程模拟脱机输入时的外围控制机，在其控制下，输入缓冲区暂存从输入设备输入的数据，之后再转存到输入井中。</p><p>输出进程模拟脱机输出时的外围控制机，在其控制下，输出缓冲区暂存从输出井送来的数据，之后再传送到输出设备上。</p><p>输入缓冲区和输出缓冲区是在<strong>内存中</strong>的缓冲区。</p><h4 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h4><p>设备可分为三种：独占设备、共享设备、虚拟设备。</p><p>独占设备：一个时段只能分配给一个进程（如打印机）。</p><p>共享设备：可同时分配给多个进程使用，宏观同时使用设备，微观交替使用设备（如磁盘）。</p><p>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程（共享打印机）。</p><h5 id="设备分配时应考虑因素"><a href="#设备分配时应考虑因素" class="headerlink" title="设备分配时应考虑因素"></a>设备分配时应考虑因素</h5><p>安全分配方式：为进程分配一个设备后将其阻塞，直到本次 I/O 完成后才将其唤醒。</p><ul><li>优点：不会死锁。</li><li>缺点：同一进程 CPU 与 I/O 串行工作。</li></ul><p>不安全分配方式：进程发出 I/O 请求后，系统为其分配 I/O 设备，进程可继续执行，之后还可以发出新的 I/O 请求。只有某个 I/O 请求得不到满足时才将其阻塞。</p><ul><li>优点：进程的计算任务和 I/O 任务可并行处理。</li><li>缺点：可能发生死锁。</li></ul><h5 id="静态-动态分配"><a href="#静态-动态分配" class="headerlink" title="静态/动态分配"></a>静态/动态分配</h5><p>静态分配：进程运行前为其分配所需资源，运行结束后归还资源。</p><p>动态分配：进程运行过程中动态申请设备资源。</p><h5 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h5><p>设备、控制器、通道之间的关系：</p><img src="/blog/2021/02/02/I-O控制（二）/设备、控制器、通道关系.png" style="zoom:80%;"><p>一个通道可以控制多个设备控制器，每个设备控制器可控制多个设备。</p><h6 id="设备控制表（DCT）"><a href="#设备控制表（DCT）" class="headerlink" title="设备控制表（DCT）"></a>设备控制表（DCT）</h6><p>系统为每个设备配置一张 DCT，用于记录设备情况。</p><img src="/blog/2021/02/02/I-O控制（二）/DCT.PNG" style="zoom:80%;"><h6 id="控制器控制表（COCT）"><a href="#控制器控制表（COCT）" class="headerlink" title="控制器控制表（COCT）"></a>控制器控制表（COCT）</h6><p>每个设备控制器都会对应一张 COCT，操作系统根据 COCT 的信息对控制器进行操作和管理。</p><img src="/blog/2021/02/02/I-O控制（二）/COCT.PNG" style="zoom:80%;"><h6 id="通道控制表（CHCT）"><a href="#通道控制表（CHCT）" class="headerlink" title="通道控制表（CHCT）"></a>通道控制表（CHCT）</h6><p>每个通道都会对应一张 CHCT，操作系统根据 CHCT 的信息对通道进行操作和管理。</p><img src="/blog/2021/02/02/I-O控制（二）/CHCT.PNG" style="zoom:80%;"><h6 id="系统设备表（SDT）"><a href="#系统设备表（SDT）" class="headerlink" title="系统设备表（SDT）"></a>系统设备表（SDT）</h6><p>记录了系统中全部设备的情况，每个设备对应一个表目。</p><img src="/blog/2021/02/02/I-O控制（二）/SDT.PNG" style="zoom:80%;"><h5 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h5><ol><li>根据进程请求的逻辑设备名查找 SDT (注：用户变成时提供的逻辑设备名就是“设备类型”)。</li><li>根据 SDT 找到用户进程<strong>指定类型且空闲的设备</strong>，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。</li><li>根据 DCT 找到 COCT，若控制器忙碌则将进程 PCB 挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据 COCT 找到 CHCT ，若通道忙碌则将进程 PCB 挂到通道等待队列中，不忙碌则将通道分配给进<br>程。</li></ol><img src="/blog/2021/02/02/I-O控制（二）/设备分配的步骤.PNG" style="zoom:80%;"><p><strong>逻辑设备表（LUT）</strong></p><p>建立逻辑设备名与物理设备名之间的映射关系。</p><img src="/blog/2021/02/02/I-O控制（二）/LUT.PNG"><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/02/02/I-O控制（二）/设备的分配与回收小结.PNG"><h4 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h4><h5 id="缓冲区概念及作用"><a href="#缓冲区概念及作用" class="headerlink" title="缓冲区概念及作用"></a>缓冲区概念及作用</h5><p>缓冲区：一个存储区域，可以由专门的硬件组成，也可利用内存作为缓冲区，一般使用内存作为缓冲区。</p><p>作用：</p><ol><li>缓和 CPU 与 I/O 设备之间速度不匹配的矛盾。</li><li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制。</li><li>解决数据粒度不匹配的问题（输出进程每次生成一块数据，而 I/O 设备每次只能输出一个字符）。</li><li>提高 CPU 与 I/O 设备之间的并行性。</li></ol><h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><p>操作系统在主存中为其分配一个缓冲区（一般为一个块）。</p><p><strong>缓冲区写满之后才能读，读空之后才能写</strong>。</p><p>处理一块数据平均耗时：$MAX(C,T) + M$。字符意思如下：</p><img src="/blog/2021/02/02/I-O控制（二）/单缓冲区.PNG" style="zoom:80%;"><h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><p>操作系统在主存中为其分配两个缓冲区。</p><img src="/blog/2021/02/02/I-O控制（二）/双缓冲区.PNG" style="zoom:80%;"><p>处理一块数据平均耗时：$MAX(T,C+M)$。</p><h5 id="使用单-双缓冲在通信时的区别"><a href="#使用单-双缓冲在通信时的区别" class="headerlink" title="使用单/双缓冲在通信时的区别"></a>使用单/双缓冲在通信时的区别</h5><p>单缓冲区同一时间只能单向传输，而双缓冲区同一时刻可以实现双向的数据传输。</p><h5 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h5><p>将多个大小相等的缓冲区链接成一个<strong>循环队列</strong>。</p><img src="/blog/2021/02/02/I-O控制（二）/循环缓冲区.PNG" style="zoom:80%;"><h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可分为：空缓冲队列、装满输入数据的缓冲队列（输出队列）、装满输出数据的缓冲队列（输出队列）。</p><img src="/blog/2021/02/02/I-O控制（二）/缓冲池.PNG" style="zoom:80%;"><p>hin：用于收容输入数据的工作缓冲区。</p><p>sin：用于提取收入数据的工作缓冲区。</p><p>hout：用于收容输出数据的工作缓冲区。</p><p>sout：用于提取输出数据的工作缓冲区。</p><img src="/blog/2021/02/02/I-O控制（二）/队列.PNG" style="zoom:80%;"><ol><li>输入进程请求输入数据：</li></ol><img src="/blog/2021/02/02/I-O控制（二）/输入进程请求输入数据.PNG" style="zoom:80%;"><ol start="2"><li>计算进程想要取得一块输入数据：</li></ol><img src="/blog/2021/02/02/I-O控制（二）/计算进程想要取得一块输入数据.PNG" style="zoom:80%;"><ol start="3"><li>计算进程想要将准备好的数据冲入缓冲区：</li></ol><img src="/blog/2021/02/02/I-O控制（二）/计算进程想要将准备好的数据冲入缓冲区.PNG" style="zoom:80%;"><ol start="4"><li>输出进程请求输出数据：</li></ol><img src="/blog/2021/02/02/I-O控制（二）/输出进程请求输出数据.PNG" style="zoom:80%;"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/02/02/I-O控制（二）/缓冲区管理小结.PNG">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;假脱机技术（SPOOLing技术）&lt;/li&gt;
&lt;li&gt;设备的分配与回收&lt;/li&gt;
&lt;li&gt;缓冲区管理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>I/O控制（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/02/I-O%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/02/I-O%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-02T02:30:34.000Z</published>
    <updated>2021-02-02T09:54:08.653Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>I/O设备的基本概念和分类</li><li>I/O控制器</li><li>I/O控制方式</li><li>I/O软件层次结构</li><li>I/O核心子系统</li></ol><a id="more"></a><h4 id="I-O设备的基本概念和分类"><a href="#I-O设备的基本概念和分类" class="headerlink" title="I/O设备的基本概念和分类"></a>I/O设备的基本概念和分类</h4><h5 id="什么是I-O设备？"><a href="#什么是I-O设备？" class="headerlink" title="什么是I/O设备？"></a>什么是I/O设备？</h5><p>I/O设备就是可以将数据输入到计算机，或从计算机接收数据的外部设备，属于计算机中的硬件部件。</p><ul><li><code>write</code> 操作：向外部设备写出数据。</li><li><code>read</code> 操作：从外部设备读入数据。</li></ul><h5 id="I-O设备分类"><a href="#I-O设备分类" class="headerlink" title="I/O设备分类"></a>I/O设备分类</h5><p><strong>按使用特性分类</strong>：</p><ol><li>人机交互类设备</li><li>存储设备</li><li>网络通信设备</li></ol><p><strong>按传输速率分类</strong>：</p><ol><li>低速设备</li><li>中速设备</li><li>高速设备</li></ol><p><strong>按信息交换的单位分类</strong>：</p><ol><li>块设备（传输快，可寻址）</li><li>字符设备（传输慢，不可寻址，常采用中断驱动方式）</li></ol><h4 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h4><p>I/O设备由<strong>机械设备</strong>和<strong>电子设备</strong>构成。</p><p><strong>机械部件</strong>：执行具体的 I/O 操作，如鼠标键盘等。</p><p><strong>电子部件</strong>：插入主板扩充槽的印刷电路板。</p><hr><p>电子部件（I/O控制器）</p><p>I/O 控制器是 CPU 和 I/O 设备机械部件之间的<strong>桥梁</strong>。CPU 可控制 I/O 控制器，再由 I/O 控制器来控制设备的机械部件。</p><hr><h5 id="I-O控制器的功能"><a href="#I-O控制器的功能" class="headerlink" title="I/O控制器的功能"></a>I/O控制器的功能</h5><ol><li>接受和识别 CPU 发出的命令（I/O 控制器中的<strong>控制寄存器</strong>存放命令和参数）。</li><li>向 CPU 报告设备的状态（I/O 控制器中的<strong>状态寄存器</strong>记录 I/O 设备的当前状态）。</li><li>数据交换（I/O 控制器中的 <strong>数据寄存器</strong>，作为 CPU 与设备数据交换的桥梁）。</li><li>地址识别（I/O 控制器通过 CPU 提供的地址来判断 CPU 读写哪个寄存器）。</li></ol><h5 id="I-O控制器的组成"><a href="#I-O控制器的组成" class="headerlink" title="I/O控制器的组成"></a>I/O控制器的组成</h5><img src="/blog/2021/02/02/I-O控制（一）/I-O控制器的组成.png" style="zoom: 67%;"><p>上述寄存器如果地址占用内存地址的一部分，称为<strong>内存映像 I/O</strong> ；如果采用 I/O 专用地址，称为<strong>寄存器独立编址</strong>。</p><p>两者区别如下：</p><img src="/blog/2021/02/02/I-O控制（一）/内存映像与寄存器独立编址.png" style="zoom: 67%;"><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/02/02/I-O控制（一）/I-O控制器小结.png"><h4 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h4><h5 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h5><img src="/blog/2021/02/02/I-O控制（一）/程序直接控制方式.png" style="zoom: 67%;"><ol><li>CPU 干预的频率高，等待 I/O 的过程中一直轮询检查。</li><li>每次读写一个<strong>字</strong>。</li><li>数据流向：<ol><li>数据输入： I/O 设备 -&gt; CPU -&gt; 内存</li><li>数据输出： 内存 -&gt; CPU -&gt;  I/O 设备</li></ol></li><li>优点：实现简单。</li><li>缺点：CPU 和 I/O设备只能串行工作，CPU 长期处于<strong>忙等</strong>状态，利用率低。</li></ol><h5 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h5><img src="/blog/2021/02/02/I-O控制（一）/中断驱动方式.png"><ol><li><p>I/O 操作开始前、完成后需要 CPU 介入。</p></li><li><p>每次读写一个<strong>字</strong>。</p></li><li><p>数据流向：</p><ol><li>数据输入： I/O 设备 -&gt; CPU -&gt; 内存</li><li>数据输出： 内存 -&gt; CPU -&gt;  I/O 设备</li></ol></li><li><p>优点：CPU 和 I/O 设备可并行工作。</p></li><li><p>缺点：每个字传输时，都需要中断，频繁中断消耗较多的 CPU 时间。</p></li></ol><h5 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h5><p>DMA（Direct Memory Access，直接存储器存取），主要用于<strong>块设备</strong> I/O 控制，<strong>不需要经过 CPU</strong>。</p><img src="/blog/2021/02/02/I-O控制（一）/DMA方式.png" style="zoom:80%;"><p><strong>DMA控制器</strong></p><img src="/blog/2021/02/02/I-O控制（一）/DMA控制器.PNG" style="zoom:80%;"><p>DR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据，<strong>也是一个字一个字的存入</strong>。<br>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR 表示数据应放到内存中的什么位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。<br>DC（Data Counter，数据计数器）：表示剩余要读/写的字节数。<br>CR（Command Register，命令/状态寄存器）：用于存放 CPU 发来的 I/O 命令，或设备的状态信息。</p><ol><li><p>仅在传送开始或结束时，才需要 CPU 干预。</p></li><li><p>每次读写<strong>一个或多个块（必须连续）</strong>。</p></li><li><p>数据流向：</p><ol><li>数据输入： I/O 设备  -&gt; 内存</li><li>数据输出： 内存 -&gt;  I/O 设备</li></ol></li><li><p>优点：数据传输以<strong>块</strong>为单位，且 CPU 接入频率进一步降低，进一步提高了 CPU 和 I/O 设备的并行性。</p></li><li><p>缺点：只能读写一个或多个连续的数据块。如果数据块离散，CPU 需发出多次 I/O 指令。</p></li></ol><h5 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h5><p>通道：一种硬件，可以理解为<strong>弱化版的 CPU</strong>，可以识别并执行一系列的通道指令，通道执行的指令很单一，与 CPU 共享内存。</p><img src="/blog/2021/02/02/I-O控制（一）/通道.PNG" style="zoom:80%;"><ol><li><p>CPU 干预频率极低，通道完成一组数据块的读写后才发出中断信号。</p></li><li><p>每次读写<strong>一组数据块</strong>。</p></li><li><p>数据流向：</p><ol><li>数据输入： I/O 设备  -&gt; 内存</li><li>数据输出： 内存 -&gt;  I/O 设备</li></ol></li><li><p>优点：CPU、通道、I/O 设备并行工作，资源利用率高。</p></li><li><p>缺点：实现复杂，，需要专门的通道硬件支持。</p></li></ol><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/02/02/I-O控制（一）/I-O控制方式.PNG" style="zoom: 67%;"><h4 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I/O软件层次结构"></a>I/O软件层次结构</h4><img src="/blog/2021/02/02/I-O控制（一）/I-O软件层次结构.PNG" style="zoom: 80%;"><h5 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h5><p>实现与用户交互的接口，用户可直接使用该层提供的，与 I/O 操作相关的库函数对设备进行操作。用户层软件将用户请求翻译为格式化的 I/O 请求，通过<strong>系统调用</strong>请求操作系统内核的服务。</p><h5 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h5><p>又称设备无关性软件，与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>主要实现的功能：</p><ol><li>向上层提供统一的调用接口。</li><li>设备的保护。设备被看作是一种特殊的文件，不同用户的访问权限不同。</li><li>差错处理。</li><li>设备的分配与回收。</li><li>数据缓冲区管理。</li><li>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序。</li></ol><p>设备独立性软件需要通过<strong>逻辑设备表（LUT， Logical Unit Table）</strong>来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。有两种方式：①整个系统只设置一张 LUT，只适合单用户操作系统；②为每个用户设置一张 LUT。</p><p><strong>不同设备需要不同设备驱动程序的原因</strong>？</p><p>答：不同设备有不同的硬件特性，具体细节只有厂家知道。驱动程序一般会以一个独立进程的方式存在。</p><h5 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h5><img src="/blog/2021/02/02/I-O控制（一）/中断处理程序.png" style="zoom:80%;"><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>中断处理程序和设备驱动程序会和硬件打交道。</p><h4 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I/O核心子系统"></a>I/O核心子系统</h4><p> I/O 核心子系统要实现的功能就是中间三层要实现的功能，主要有： I/O 调度、设备保护、设备分配与回收、缓冲区管理，还有假脱机技术（SPOOLing技术），<strong>其中假脱机技术是在用户层软件实现的</strong>。</p><h5 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I/O调度"></a>I/O调度</h5><p>用某种算法确定一个好的顺序来处理各个 I/O 请求。</p><p>如磁盘调度：先来先服务算法、最短寻道优先算法等确定 I/O 请求的顺序。</p><p>同理，打印机等设备也可以用先来先服务、优先级算法等确定 I/O 请求的顺序。</p><h5 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h5><p>不同用户对各个文件拥有不同的访问权限。可参考<strong>文件保护</strong>小节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;I/O设备的基本概念和分类&lt;/li&gt;
&lt;li&gt;I/O控制器&lt;/li&gt;
&lt;li&gt;I/O控制方式&lt;/li&gt;
&lt;li&gt;I/O软件层次结构&lt;/li&gt;
&lt;li&gt;I/O核心子系统&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode888-公平的糖果交换</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/01/LeetCode888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/01/LeetCode888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E4%BA%A4%E6%8D%A2/</id>
    <published>2021-02-01T02:03:50.000Z</published>
    <updated>2021-02-01T02:20:17.782Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>爱丽丝和鲍勃有不同大小的糖果棒：<code>A[i]</code> 是爱丽丝拥有的第 <code>i</code> 根糖果棒的大小，<code>B[j]</code> 是鲍勃拥有的第 <code>j</code> 根糖果棒的大小。</p><p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</p><p>返回一个整数数组 <code>ans</code>，其中 <code>ans[0]</code> 是爱丽丝必须交换的糖果棒的大小，<code>ans[1]</code> 是 <code>Bob</code> 必须交换的糖果棒的大小。</p><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p><p>本题和<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a>并无本质区别。</p><a id="more"></a><img src="/blog/2021/02/01/LeetCode888-公平的糖果交换/888.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>记 A 糖果总数为 sum1，B 糖果总数为 sum2，A 需要交换的糖果棒大小为 x，B 需要交换的糖果棒大小为 y，那么可以得到以下等式：<br>$$<br>sum1-x+y=sum2-y+x<br>$$<br>经过化简可得：<br>$$<br>x=y-\frac{sum2-sum1}{2}<br>$$<br>将 A 的所有糖果棒长度存入哈希表，遍历 B，找到哈希表中满足上述等式的值后，返回此时的 x, y 即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fairCandySwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; ans(2);</span></span><br><span class="line">        <span class="keyword">int</span> sum1 = accumulate(A.begin(), A.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum2 = accumulate(B.begin(), B.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = (sum2 - sum1) / <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">set</span><span class="params">(A.begin(), A.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y : B)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.count(y - sum))</span><br><span class="line">                <span class="keyword">return</span> &#123;y - sum, y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 总是有解的，所以返回什么无所谓</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;爱丽丝和鲍勃有不同大小的糖果棒：&lt;code&gt;A[i]&lt;/code&gt; 是爱丽丝拥有的第 &lt;code&gt;i&lt;/code&gt; 根糖果棒的大小，&lt;code&gt;B[j]&lt;/code&gt; 是鲍勃拥有的第 &lt;code&gt;j&lt;/code&gt; 根糖果棒的大小。&lt;/p&gt;
&lt;p&gt;因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）&lt;/p&gt;
&lt;p&gt;返回一个整数数组 &lt;code&gt;ans&lt;/code&gt;，其中 &lt;code&gt;ans[0]&lt;/code&gt; 是爱丽丝必须交换的糖果棒的大小，&lt;code&gt;ans[1]&lt;/code&gt; 是 &lt;code&gt;Bob&lt;/code&gt; 必须交换的糖果棒的大小。&lt;/p&gt;
&lt;p&gt;如果有多个答案，你可以返回其中任何一个。保证答案存在。&lt;/p&gt;
&lt;p&gt;本题和&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;两数之和&lt;/a&gt;并无本质区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode839-相似字符串组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/31/LeetCode839-%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/31/LeetCode839-%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/</id>
    <published>2021-01-31T08:09:50.000Z</published>
    <updated>2021-01-31T08:31:40.990Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>如果交换字符串 <code>X</code> 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p><p>例如，<code>&quot;tars&quot;</code> 和 <code>&quot;rats&quot;</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)； <code>&quot;rats&quot;</code> 和 <code>&quot;arts&quot;</code> 也是相似的，但是 <code>&quot;star&quot;</code> 不与 <code>&quot;tars&quot;</code>，<code>&quot;rats&quot;</code>，或 <code>&quot;arts&quot;</code> 相似。</p><p>总之，它们通过相似性形成了两个关联组：<code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> 和 <code>{&quot;star&quot;}</code>。注意，<code>&quot;tars&quot;</code> 和 <code>&quot;arts&quot;</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p><p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p><a id="more"></a><img src="/blog/2021/01/31/LeetCode839-相似字符串组/839.png"><p><strong>备注：</strong></p><p>​    字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题如果理解了题目的意思，就不难。</p><p><strong>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词</strong>。再结合备注可知：所有的字符串都是由<strong>相同的字母</strong>组成，无非就是字母顺序不一样罢了。</p><p>题目要求<strong>相似</strong>的字符串为一组，何为相似？有两种情况：</p><ol><li>两个字符串相同。</li><li>其中一个字符串交换一对字母后与另一字符串相同。</li></ol><p><strong>如何操作</strong>？</p><p>使用一个变量统计两个字符串对应位置字母不相同的个数。如果计数等于 0 或者 2，说明这两个字符串是相似的，使用并查集进行合并即可。</p><p>返回合并后的连通集数就是最终答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>暴力遍历即可。35% 99%</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        parent[pRoot] = qRoot;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = strs.size();</span><br><span class="line">        <span class="keyword">int</span> len = strs[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[i][k] != strs[j][k])</span><br><span class="line">                        cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对比完一个后，如果只有两个字母不同，说明在同一个分组里面</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">2</span> || cnt == <span class="number">0</span>) uf.unionElem(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;如果交换字符串 &lt;code&gt;X&lt;/code&gt; 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;&amp;quot;tars&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;rats&amp;quot;&lt;/code&gt; 是相似的 (交换 &lt;code&gt;0&lt;/code&gt; 与 &lt;code&gt;2&lt;/code&gt; 的位置)； &lt;code&gt;&amp;quot;rats&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;arts&amp;quot;&lt;/code&gt; 也是相似的，但是 &lt;code&gt;&amp;quot;star&amp;quot;&lt;/code&gt; 不与 &lt;code&gt;&amp;quot;tars&amp;quot;&lt;/code&gt;，&lt;code&gt;&amp;quot;rats&amp;quot;&lt;/code&gt;，或 &lt;code&gt;&amp;quot;arts&amp;quot;&lt;/code&gt; 相似。&lt;/p&gt;
&lt;p&gt;总之，它们通过相似性形成了两个关联组：&lt;code&gt;{&amp;quot;tars&amp;quot;, &amp;quot;rats&amp;quot;, &amp;quot;arts&amp;quot;}&lt;/code&gt; 和 &lt;code&gt;{&amp;quot;star&amp;quot;}&lt;/code&gt;。注意，&lt;code&gt;&amp;quot;tars&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;arts&amp;quot;&lt;/code&gt; 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。&lt;/p&gt;
&lt;p&gt;给你一个字符串列表 &lt;code&gt;strs&lt;/code&gt;。列表中的每个字符串都是 &lt;code&gt;strs&lt;/code&gt; 中其它所有字符串的一个字母异位词。请问 &lt;code&gt;strs&lt;/code&gt; 中有多少个相似字符串组？&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
