<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2020-12-27T02:36:50.000Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode205-同构字符串</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/27/LeetCode205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/27/LeetCode205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-12-27T02:29:59.000Z</published>
    <updated>2020-12-27T02:36:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，判断它们是否是同构的。</p><p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong><em>t</em></strong> ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p>本题是<a href="http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more">LeetCode290-单词规律</a>的简化版。</p><a id="more"></a><img src="/blog/2020/12/27/LeetCode205-同构字符串/205.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>与<a href="http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more">LeetCode290-单词规律</a>基本一致。</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>此题字母大小写均可，数组初始化时为0，每对字符都应唯一映射为同一个数。如果两个数不同，返回<code>false</code>，否则返回<code>true</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; map1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; map2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            map1[s[i]].insert(t[i]);</span><br><span class="line">            map2[t[i]].insert(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(map1[s[i]].size() &gt; <span class="number">1</span> || map2[t[i]].size() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> map1[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> map2[<span class="number">256</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1[s[i]] != map2[t[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            map1[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            map2[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解评论区：</p><p><a href="https://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt;，判断它们是否是同构的。&lt;/p&gt;
&lt;p&gt;如果 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 中的字符可以被替换得到 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt; ，那么这两个字符串是同构的。&lt;/p&gt;
&lt;p&gt;所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。&lt;/p&gt;
&lt;p&gt;本题是&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more&quot;&gt;LeetCode290-单词规律&lt;/a&gt;的简化版。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.xingyuzhao.ltd/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode85-最大矩形</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/26/LeetCode85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/26/LeetCode85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</id>
    <published>2020-12-26T10:46:28.000Z</published>
    <updated>2020-12-26T12:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p>本题与<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LeetCode84-柱状图中最大的矩形</a>基本一致。</p> <a id="more"></a><img src="/blog/2020/12/26/LeetCode85-最大矩形/85.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如图，使坐标值竖向移动，求出每个坐标轴下的矩形最大面积，再从中取最大值就是最大的矩形：</p><img src="/blog/2020/12/26/LeetCode85-最大矩形/坐标轴.png" style="zoom:80%;"><p>很明显在图三中得到最大矩形，面积为6。求当前坐标轴下的最大矩形面积与<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/c-dan-diao-zhan-si-lu-qing-xi-you-tu-you-ip3c/" target="_blank" rel="noopener">LeetCode84-柱状图中最大的矩形</a>方法一致。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preHeights;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heights;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    heights.push_back(matrix[i][j] - <span class="string">'0'</span>);    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>) </span><br><span class="line">                        heights.push_back(preHeights[j] + matrix[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        heights.push_back(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            preHeights = heights;</span><br><span class="line">            res = max(res, maxArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heights)</span></span>&#123;</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> mArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()])&#123;</span><br><span class="line">                <span class="keyword">int</span> v = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> right = i;</span><br><span class="line">                <span class="keyword">int</span> left = st.empty() ? <span class="number">0</span> : st.top() + <span class="number">1</span>;</span><br><span class="line">                area = heights[v] * (right - left);</span><br><span class="line">                mArea = max(mArea, area);</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>评论区：<a href="https://leetcode-cn.com/problems/maximal-rectangle/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-rectangle/comments/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个仅包含 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 、大小为 &lt;code&gt;rows x cols&lt;/code&gt; 的二维二进制矩阵，找出只包含 &lt;code&gt;1&lt;/code&gt; 的最大矩形，并返回其面积。&lt;/p&gt;
&lt;p&gt;本题与&lt;a href=&quot;https://leetcode-cn.com/problems/largest-rectangle-in-histogram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode84-柱状图中最大的矩形&lt;/a&gt;基本一致。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="单调栈" scheme="http://www.xingyuzhao.ltd/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode84-柱状图中最大的矩形</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/26/LeetCode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/26/LeetCode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</id>
    <published>2020-12-26T08:09:01.000Z</published>
    <updated>2020-12-27T12:22:05.018Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><a id="more"></a><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/84.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>找到当前高度下的最大矩形面积，然后从所有得到的面积中挑出最大的那一个就是能够勾勒出来矩形的最大面积，如下：</p><ol><li>第1个高度，当前面积为2。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-1.png"><ol start="2"><li>第2个高度，当前面积为6。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-2.png"><ol start="3"><li>第3个高度，当前面积为10。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-3.png"><ol start="4"><li>第4个高度，当前面积为6。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-4.png"><ol start="5"><li>第5个高度，当前面积为8。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-5.png"><ol start="6"><li>第6个高度，当前面积为3。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-6.png"><p>综上，面积最大出现在第三个高度，此时面积为5。</p><p>我们需要找到当前高度下可以构成矩形的左边界和右边界，再去计算矩形的面积，使用单调栈来实现：</p><ul><li><p>计算高度：如果当前高度小于栈顶元素，此时的栈顶就是上一次高度的最大值（准确一点，是上一次高度最大值的坐标），将其记录并出栈，这时候就可以计算上一个高度面积的最大值了，直到遇到栈顶元素小于等于当前元素或者栈为空，在此之前会一直计算高度</p></li><li><p>寻找边界：当前遍历到的坐标 $i$ 就是右边界，左边界就是 $st.top()+1$（对于示例，当遍历到第二个2时，坐标为4，作为<strong>右边界</strong>；经过一系列的出栈操作，栈中<strong>最后剩下</strong>的元素坐标为1，而<strong>左边界</strong>就应该是<strong>1+1​</strong>而不是1），<strong>如果栈为空，那么左边界就是0</strong>。如下图：</p></li></ul><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-边界.png"><p>所以为了提供坐标6，还需要给高度矩阵后面续上一个0。</p><p>由于找到了下一个小于栈顶高度的值时才会计算面积，所以对于示例，最后得到的结果及顺序如下：</p><table><thead><tr><th align="center">坐标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th></tr></thead><tbody><tr><td align="center">高度</td><td align="center">2</td><td align="center">1</td><td align="center">5</td><td align="center">6</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">当前坐标最大面积</td><td align="center">2</td><td align="center">6</td><td align="center">10</td><td align="center">6</td><td align="center">8</td><td align="center">3</td></tr><tr><td align="center">面积出现的顺序</td><td align="center">1</td><td align="center">6</td><td align="center">3</td><td align="center">2</td><td align="center">5</td><td align="center">4</td></tr></tbody></table><p>即，真正得到的面积结果为<code>2, 6, 10, 3, 8, 6</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> mArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()])&#123;</span><br><span class="line">                <span class="keyword">int</span> v = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> right = i;</span><br><span class="line">                <span class="keyword">int</span> left = st.empty() ? <span class="number">0</span> : st.top() + <span class="number">1</span>;</span><br><span class="line">                area = heights[v] * (right - left);</span><br><span class="line">                mArea = max(mArea, area);</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>CSDN：<a href="https://blog.csdn.net/Zolewit/article/details/88863970" target="_blank" rel="noopener">https://blog.csdn.net/Zolewit/article/details/88863970</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
&lt;p&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="单调栈" scheme="http://www.xingyuzhao.ltd/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode365-水壶问题</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-25T14:44:59.000Z</published>
    <updated>2020-12-27T12:23:01.343Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有两个容量分别为 <code>x</code> 升和 <code>y</code> 升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <code>z</code> 升的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <code>z</code> 升水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><a id="more"></a><img src="/blog/2020/12/25/LeetCode365-水壶问题/365.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题实际上是一个数学问题，需要有先验知识——<a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&fromid=5185441" target="_blank" rel="noopener">贝祖定理</a>：若 $a, b$ 是整数，且$gcd(a,b)=d$，那么对于任意的整数 $x$$，y$，$ax+by$ 都一定是 $d$ 的倍数，特别地，一定存在整数 $x$,  $y$，使 $ax+by=d$ 成立。$gcd(a,b)$ 用来求 $a, b$ 的最大公约数，称为辗转相除法。</p><p>实际上，每次操作只会让桶里的水增加<code>x</code>或增加<code>y</code>，减少<code>x</code>或减少<code>y</code>，两个桶不可能同时有水且不满，观察所有的操作都至少有一个桶是空的或满的。如果往一个不满的桶里加水或将其倒空是没有意义的，这是因为：</p><ul><li>向有水且不满的桶加水是没有意义的：<ul><li>另一个桶满，加水等价于从初始状态给两个桶加满水</li><li>另一个桶空，加水等价于将不满的桶加满</li></ul></li><li>将有水且不满的桶倒掉是没有意义的：<ul><li>另一个桶满，倒水等价于从初始状态给另一个桶加满水</li><li>另一个桶空，倒水等价于两个桶都没水，回到初始状态</li></ul></li></ul><p>所以每次操作只会给水的总量带来<code>x</code>或<code>y</code>的变化量，所以目标为找到一组 $a, b$ ，满足：<br>$$<br>ax+by=z<br>$$<br>根据贝祖定理，当且仅当<code>z</code>是  $a, b$ 最大公约数倍数时，有解。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b) swap(a, b);</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x + y &lt; z) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> z == <span class="number">0</span> || x + y == z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(z % gcd(x, y) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：</p><p><a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/</a></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>要满足$z\le{x+y}$，且这样的 $a, b$ 存在，目标就可以达成，是因为：</p><ul><li><p>若 $a\ge0, b\ge0$时，可以达成</p></li><li><p>若 $a&lt;0$ ，那么执行以下操作：</p><ul><li>将<code>y</code>壶倒满</li><li>将<code>y</code>壶中水倒入<code>x</code>壶</li><li>如果<code>y</code>不为空，那么<code>x</code>肯定是满的，把<code>x</code><strong>倒空</strong>，再把<code>y</code>剩下的倒入<code>x</code>壶</li></ul><p>重复以上操作直到某一步<code>x</code>壶进行了 $a$ 次倒空，<code>y</code>壶进行了 $b$ 次倒水操作。</p></li><li><p>若 $b&lt;0$，方法同上，<code>x</code>与<code>y</code>互换。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;有两个容量分别为 &lt;code&gt;x&lt;/code&gt; 升和 &lt;code&gt;y&lt;/code&gt; 升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 &lt;code&gt;z&lt;/code&gt; 升的水？&lt;/p&gt;
&lt;p&gt;如果可以，最后请用以上水壶中的一或两个来盛放取得的 &lt;code&gt;z&lt;/code&gt; 升水。&lt;/p&gt;
&lt;p&gt;你允许：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装满任意一个水壶&lt;/li&gt;
&lt;li&gt;清空任意一个水壶&lt;/li&gt;
&lt;li&gt;从一个水壶向另外一个水壶倒水，直到装满或者倒空&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数学" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode12-整数转罗马数字</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2020-12-25T13:20:32.000Z</published>
    <updated>2020-12-27T12:24:34.507Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><img src="/blog/2020/12/25/LeetCode12-整数转罗马数字/12.png"><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>主要是处理那些特殊的样例，结合代码，对于示例中的1994，去掉1000后还剩下994，这个900的表示是特殊的，所以如果当前 $num$ 范围是900-999，就需要加上”CM”；$num$ 还剩下94，这个90也是特殊的，所以如果当前 $num$ 范围是90-99，就需要加上”XC”；最后剩下4，所以加上”IV”，得到结果”MCMXCIV”。</p><p><strong>需要注意<code>if</code>语句的顺序不能改变，就像状态机一样，执行完一个状态后才能执行下一个状态</strong>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前面几行针对特定案例，注释了也不影响</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">4</span>) <span class="keyword">return</span> <span class="string">"IV"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">9</span>) <span class="keyword">return</span> <span class="string">"IX"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">40</span>) <span class="keyword">return</span> <span class="string">"XL"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">90</span>) <span class="keyword">return</span> <span class="string">"XC"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">400</span>) <span class="keyword">return</span> <span class="string">"CD"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">900</span>) <span class="keyword">return</span> <span class="string">"CM"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num / <span class="number">1000</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">1000</span>, <span class="string">'M'</span>);</span><br><span class="line">                num -= num / <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">900</span> &amp;&amp; num &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">                res += <span class="string">"CM"</span>;</span><br><span class="line">                num -= <span class="number">900</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">500</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">500</span>, <span class="string">'D'</span>);</span><br><span class="line">                num -= num / <span class="number">500</span> * <span class="number">500</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">400</span> &amp;&amp; num &lt; <span class="number">500</span>)&#123;</span><br><span class="line">                res += <span class="string">"CD"</span>;</span><br><span class="line">                num -= <span class="number">400</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">100</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">100</span>, <span class="string">'C'</span>);</span><br><span class="line">                num -= num / <span class="number">100</span> * <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">90</span> &amp;&amp; num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                res += <span class="string">"XC"</span>;</span><br><span class="line">                num -= <span class="number">90</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">50</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">50</span>, <span class="string">'L'</span>);</span><br><span class="line">                num -= num / <span class="number">50</span> * <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">40</span> &amp;&amp; num &lt; <span class="number">50</span>)&#123;</span><br><span class="line">                res += <span class="string">"XL"</span>;</span><br><span class="line">                num -= <span class="number">40</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">10</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">10</span>, <span class="string">'X'</span>);</span><br><span class="line">                num -= num / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">9</span>)&#123;</span><br><span class="line">                res += <span class="string">"IX"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">5</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">5</span>, <span class="string">'V'</span>);</span><br><span class="line">                num -= num / <span class="number">5</span> * <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">4</span>)&#123;</span><br><span class="line">                res += <span class="string">"IV"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">1</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">1</span>, <span class="string">'I'</span>);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;罗马数字包含以下七种字符： &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;/blog/2020/12/25/LeetCode12-整数转罗马数字/12.png&quot;&gt;

&lt;p&gt;例如， 罗马数字 2 写做 &lt;code&gt;II&lt;/code&gt; ，即为两个并列的 1。12 写做 &lt;code&gt;XII&lt;/code&gt; ，即为 &lt;code&gt;X&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。 27 写做  &lt;code&gt;XXVII&lt;/code&gt;, 即为 &lt;code&gt;XX&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 &lt;code&gt;IIII&lt;/code&gt;，而是 &lt;code&gt;IV&lt;/code&gt;。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 &lt;code&gt;IX&lt;/code&gt;。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; 可以放在 &lt;code&gt;V&lt;/code&gt; (5) 和 &lt;code&gt;X&lt;/code&gt; (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; 可以放在 &lt;code&gt;L&lt;/code&gt; (50) 和 &lt;code&gt;C&lt;/code&gt; (100) 的左边，来表示 40 和 90。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt; 可以放在 &lt;code&gt;D&lt;/code&gt; (500) 和 &lt;code&gt;M&lt;/code&gt; (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="状态机" scheme="http://www.xingyuzhao.ltd/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode455-分发饼干</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</id>
    <published>2020-12-25T01:23:17.000Z</published>
    <updated>2020-12-25T01:45:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j]</code> &gt;= <code>g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><a id="more"></a><img src="/blog/2020/12/25/LeetCode455-分发饼干/455.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先将两个数组分别排序，使用两个指针分别指向两个数组的首元素，当饼干值满足胃口值时，两个指针后移；否则只需要将饼干数组的指针进行后移，直到满足胃口值或到达数组末尾。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; g.size() &amp;&amp; j &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] &gt;= g[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。&lt;/p&gt;
&lt;p&gt;对每个孩子 &lt;code&gt;i&lt;/code&gt;，都有一个胃口值 &lt;code&gt;g[i]&lt;/code&gt;，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 &lt;code&gt;j&lt;/code&gt;，都有一个尺寸 &lt;code&gt;s[j]&lt;/code&gt; 。如果 &lt;code&gt;s[j]&lt;/code&gt; &amp;gt;= &lt;code&gt;g[i]&lt;/code&gt;，我们可以将这个饼干 &lt;code&gt;j&lt;/code&gt; 分配给孩子 &lt;code&gt;i&lt;/code&gt; ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode135-分发糖果</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/24/LeetCode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/24/LeetCode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</id>
    <published>2020-12-24T07:43:02.000Z</published>
    <updated>2020-12-24T10:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><a id="more"></a><img src="/blog/2020/12/24/LeetCode135-分发糖果/135.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用数组 $store$ 记录每个孩子得到的糖果数，$store[i]$ 表示第 $i$ 个孩子获得的糖果数。</p><p>首先找到最低的评分，这个位置记为 $pos$，最低分孩子的糖果数必为1，所以可以得到 $store[pos]=1$ ，以 $pos$为界，将评分数组分为两个部分分别操作，两个部分是<strong>互不影响</strong>的。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/评分数组.png" style="zoom:80%;"><ol><li><p>对于 $pos$ 之前（包括 $pos$），往回遍历评分数组，在不越界的条件下可以得到：</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从后往前1.png" style="zoom:80%;"><ol><li><p>如果前一个评分小于当前评分：</p><ol><li><p>当前糖果数不为1，那么前一个孩子获得的糖果置为1，结束；</p></li><li><p>当前糖果数为1，那么前一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于前一个孩子获得的糖果数（前一个评分小于当前评分）。所以需要从前一个位置开始往后遍历：</p><ol><li><p>如果遇到<strong>后一个评分大于当前评分，并且后一个的糖果等于当前糖果数（上图红线）</strong>，需要给后一个糖果数加1，保证后一个的糖果大于当前糖果数。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从后往前2.png" style="zoom:80%;"></li><li><p>如果后一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从后往前3.png" style="zoom:80%;"></li></ol></li></ol></li><li><p>如果前一个评分等于当前评分，前一个糖果数为1</p></li><li><p>如果前一个评分大于当前评分，前一个糖果数为当前糖果数加1</p></li></ol></li><li><p>对于 $pos$ 之后（包括 $pos$），往后遍历评分数组，在不越界的条件下：</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从前往后1.png" style="zoom:80%;"><ol><li><p>如果后一个评分小于当前评分：</p><ol><li><p>当前糖果数不为1，那么后一个孩子获得的糖果置为1，结束；</p></li><li><p>当前糖果数为1，那么后一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于后一个孩子获得的糖果数（后一个评分小于当前评分）。所以需要从后一个位置开始往前遍历：</p><ol><li><p>如果遇到<strong>前一个评分大于当前评分，并且前一个的糖果等于当前糖果数（上图红线）</strong>，需要给前一个糖果数加1，保证前一个的糖果大于当前糖果数。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从前往后2.png" style="zoom: 80%;"></li><li><p>如果前一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从前往后3.png" style="zoom:80%;"></li></ol></li></ol></li><li><p>如果后一个评分等于当前评分，后一个糖果数为1</p></li><li><p>如果后一个评分大于当前评分，后一个糖果数为当前糖果数加1</p></li></ol></li></ol><p>最终结果：</p><table><thead><tr><th>ratings</th><th>2</th><th>3</th><th>3</th><th>1</th><th>3</th><th>2</th><th>2</th><th>1</th></tr></thead><tbody><tr><td>store</td><td>1</td><td>2</td><td>2</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td></tr></tbody></table><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = min_element(ratings.begin(), ratings.end());</span><br><span class="line">        <span class="keyword">int</span> val = *iter;</span><br><span class="line">        <span class="keyword">int</span> pos = iter - ratings.begin();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">store</span><span class="params">(ratings.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        store[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从pos往前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ratings[i - <span class="number">1</span>] &lt; ratings[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(store[i] != <span class="number">1</span>) store[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    store[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &lt; pos; ++j)&#123;</span><br><span class="line">                        <span class="comment">// 往后走</span></span><br><span class="line">                        <span class="comment">// 下一个评分比当前评分高，并且下一个的糖果又没当前糖果多</span></span><br><span class="line">                        <span class="keyword">if</span>(ratings[j + <span class="number">1</span>] &gt; ratings[j] &amp;&amp; store[j + <span class="number">1</span>] &lt;= store[j])&#123;</span><br><span class="line">                            store[j + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(ratings[j + <span class="number">1</span>] == ratings[j]) <span class="keyword">break</span>;                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ratings[i - <span class="number">1</span>] == ratings[i])&#123;</span><br><span class="line">                store[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ratings[i - <span class="number">1</span>] &gt; ratings[i])&#123;</span><br><span class="line">                store[i - <span class="number">1</span>] = store[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从pos往后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; ratings.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.size() &amp;&amp; ratings[i + <span class="number">1</span>] &lt; ratings[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(store[i] != <span class="number">1</span>) store[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    store[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; pos; --j)&#123;</span><br><span class="line">                        <span class="comment">// 往前走</span></span><br><span class="line">                        <span class="comment">// 上一个评分比当前评分高，并且上一个的糖果又没当前糖果多</span></span><br><span class="line">                        <span class="keyword">if</span>(ratings[j - <span class="number">1</span>] &gt; ratings[j] &amp;&amp; store[j - <span class="number">1</span>] &lt;= store[j])&#123;</span><br><span class="line">                            store[j - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(ratings[j - <span class="number">1</span>] == ratings[j]) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.size() &amp;&amp; ratings[i + <span class="number">1</span>] == ratings[i])&#123;</span><br><span class="line">                store[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.size() &amp;&amp; ratings[i + <span class="number">1</span>] &gt; ratings[i])&#123;</span><br><span class="line">                store[i + <span class="number">1</span>] = store[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto &amp;v : store) cout &lt;&lt; v &lt;&lt; " ";</span></span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(store.begin(), store.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p><strong>相邻的孩子中，评分高的孩子必须获得更多的糖果</strong>。这句话可以拆为两个规则分别处理：</p><ul><li>左规则：当 $ratings[i-1]&lt;ratings[i]$ 时，$i$ 获得的糖果要多于 $i-1$ 。</li><li>右规则：当 $ratings[i]&gt;ratings[i+1]$ 时，$i$ 获得的糖果要多于 $i+1$ 。</li></ul><p>遍历数组两次，分别得到每一个孩子满足左规则和右规则的糖果数，取两者之间的最大值就是这个孩子最少分配的糖果数。</p><p>在实际代码中，我们先计算出左规则 $left$ 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(ratings.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ratings.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ratings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.size() &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>])&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += max(left[i], right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;老师想给孩子们分发糖果，有 &lt;em&gt;N&lt;/em&gt; 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。&lt;/p&gt;
&lt;p&gt;你需要按照以下要求，帮助老师给这些孩子分发糖果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个孩子至少分配到 1 个糖果。&lt;/li&gt;
&lt;li&gt;相邻的孩子中，评分高的孩子必须获得更多的糖果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么这样下来，老师至少需要准备多少颗糖果呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode387-字符串中的第一个唯一字符</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/23/LeetCode387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/23/LeetCode387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</id>
    <published>2020-12-23T01:11:04.000Z</published>
    <updated>2020-12-23T01:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><a id="more"></a><img src="/blog/2020/12/23/LeetCode387-字符串中的第一个唯一字符/387.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用一个哈希表记录一下每个字母出现的次数，返回第一个出现次数为1的字母位置即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)</span><br><span class="line">            cnt[ch - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[s[i] - <span class="string">'a'</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.xingyuzhao.ltd/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode103-二叉树的锯齿形层序遍历</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/22/LeetCode103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/22/LeetCode103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2020-12-22T03:16:27.000Z</published>
    <updated>2020-12-22T03:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><a id="more"></a><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><img src="/blog/2020/12/22/LeetCode103-二叉树的锯齿形层序遍历/103.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题和二叉树的层序遍历很相似，无非就是遍历完每一层需要改变一次方向，使用一个标志位标记从前往后或者从后往前遍历。可以使用双端队列，根据标志位决定从队列的那一头开始遍历。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; deq;</span><br><span class="line">        deq.push_back(root);</span><br><span class="line">        <span class="keyword">int</span> dir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deq.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">            <span class="comment">// 前往后</span></span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">0</span>)&#123;</span><br><span class="line">                dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> n = deq.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                    TreeNode* tmp = deq.front();</span><br><span class="line">                    buf.push_back(tmp-&gt;val);</span><br><span class="line">                    <span class="comment">// 前向时需要先将左边的点入队，保证下次遍历的顺序正确</span></span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;left) deq.push_back(tmp-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;right) deq.push_back(tmp-&gt;right);</span><br><span class="line">                    deq.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后往前</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dir = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> n = deq.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                    TreeNode* tmp = deq.back();</span><br><span class="line">                    buf.push_back(tmp-&gt;val);</span><br><span class="line">                    <span class="comment">// 后向时需要先将右边的点入队，保证下次遍历的顺序正确</span></span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;right) deq.push_front(tmp-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;left) deq.push_front(tmp-&gt;left);</span><br><span class="line">                    deq.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(buf);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                buf.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="二叉树" scheme="http://www.xingyuzhao.ltd/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++关联容器</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/21/C-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/21/C-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2020-12-21T11:50:14.000Z</published>
    <updated>2020-12-24T14:50:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>使用关联容器</li><li>关联容器概述</li><li>关联容器操作</li><li>无序容器</li></ol><a id="more"></a><p>关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是<strong>map</strong>和<strong>set</strong>。</p><ul><li><code>map</code>中元素是一些关键字-值（key-value）对，关键字起到索引的作用，值则表示于索引相关联的数据。</li><li><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作-检查一个给定的关键字是否在set中。</li></ul><img src="/blog/2020/12/21/C-关联容器/关联容器类型.png"><p>类型<code>map</code>和<code>multimap</code>定义在头文件<code>map</code>中；<code>set</code>和<code>multiset</code>定义在头文件<code>set</code>中；无序容器定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中。</p><h4 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h4><h5 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h5><p>单词计数程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> count;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">++word_count[word];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; w.second</span><br><span class="line">    &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">" times"</span> : <span class="string">" time"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>此程序读取输入，报告每个单词出现多少次。<code>map</code>保存的每个元素中，关键字是<code>string</code>，值是<code>size_t</code>类型。如果<code>word</code>还未在<code>map</code>中。下标运算符会创建一个新元素。从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象，<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p><h5 id="使用set"><a href="#使用set" class="headerlink" title="使用set"></a>使用set</h5><p>对上一个程序扩展，忽略常见单词，如“the”、“and”、“or”等。可以用<code>set</code>保存想忽略的单词，只对不在集合中的单词统计出现次数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>, <span class="string">"But"</span>, <span class="string">"And"</span>, <span class="string">"Or"</span>, <span class="string">"An"</span>, <span class="string">"A"</span>,</span><br><span class="line">                       <span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>, <span class="string">"or"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> count;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    <span class="keyword">if</span>(exclude.find(word) == exclude.end())</span><br><span class="line">++word_count[word];</span><br></pre></td></tr></table></figure><p>在<code>if</code>中，<code>find</code>返回一个迭代器。如果给定关键字在<code>set</code>中，迭代器指向该关键字。否则，<code>find</code>返回尾后迭代器。</p><h4 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h4><h5 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h5><p>当定义一个<code>map</code>时，必须指明<strong>关键字类型</strong>和<strong>值类型</strong>；而定义一个<code>set</code>时，只需要指明<strong>关键字类型</strong>。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count; <span class="comment">// 空容器</span></span><br><span class="line"><span class="comment">// 列表初始化</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>, <span class="string">"But"</span>, <span class="string">"And"</span>, <span class="string">"Or"</span>, <span class="string">"An"</span>, <span class="string">"A"</span>,</span><br><span class="line">                       <span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>, <span class="string">"or"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>&#125;;</span><br><span class="line"><span class="comment">// 三个元素；authors将姓映射为名</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; authors = &#123; &#123;<span class="string">"zhao"</span>, <span class="string">"xingyu"</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">"zhou"</span>, <span class="string">"yanxuan"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>初始化<code>map</code>时，每对映射用花括号包含：{<em>key</em>, <em>value</em>}。</p><h5 id="初始化multimap或multiset"><a href="#初始化multimap或multiset" class="headerlink" title="初始化multimap或multiset"></a>初始化multimap或multiset</h5><p><code>map</code>和<code>set</code>的关键字都是唯一的。容器<code>multiset</code>和<code>multimap</code>没有此限制，它们都允许多个元素具有相同的关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个有20哥元素的vector，保存0到9每个整数的两个拷贝</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iset包含来自ivec的不重复的元素；miset包含所有20个元素</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(ivec.begin(), ivec.end())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">miset</span><span class="params">(ivec.begin(), ivec.end())</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; miset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h5><h6 id="有序容器的关键字类型"><a href="#有序容器的关键字类型" class="headerlink" title="有序容器的关键字类型"></a>有序容器的关键字类型</h6><p>所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>。可以将严格弱序看作“小于”（<strong>书上是”小于等于”，网上查到为小于</strong>），它必须具备以下性质：</p><ul><li>两个关键字不能同时“小于”对方</li><li>如果k1”小于”k2，k2“小于”k3，那么k1必须”小于“k3</li><li>如果存在两个关键字，任何一个都不”小于“另一个，那么我们称这两个关键字是”等价“的。并且等价具有传递性。</li></ul><p>如果两个关键字等价，那么容器将它们视作相等来处理。</p><h6 id="使用关键字类型的比较函数"><a href="#使用关键字类型的比较函数" class="headerlink" title="使用关键字类型的比较函数"></a>使用关键字类型的比较函数</h6><p>在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数的形式提供真正的比较操作（其类型必须与尖括号中指定的类型相吻合）。</p><p>例如：我们不能直接定义一个<code>Sales_data</code>的<code>multiset</code>，因为<code>Sales_data</code>没有<code>&lt;</code>运算符。以下函数在<code>ISBN</code>成员上定义一个严格弱序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要使用自己定义的操作</strong>，在定义<code>multiset</code>时必须提供两个类型：<strong>关键字类型</strong>Sales_data以及<strong>比较操作类型</strong>——应该是一种函数指针类型，可以指向<code>compareIsbn</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bookstore中多条记录可以有相同的ISBN</span></span><br><span class="line"><span class="comment">// bookstore中的元素以ISBN的顺序进行排列</span></span><br><span class="line">multiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn);</span><br></pre></td></tr></table></figure><p>*<em>当用decltype来获得一个函数指针类型时，必须加上一个</em>来指出我们要使用一个给定函数的指针**。<code>bookstore</code>中的元素将按它们的<code>ISBN</code>成员的值升序排列。</p><h5 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h5><p><code>pair</code>标注库类型定义在头文件<code>utility</code>中。<code>pair</code>保存两个数据成员，它是一个用来生成特定类型的模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span> &gt; anon;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; line;</span><br></pre></td></tr></table></figure><p><code>pair</code>的默认构造函数对数据成员进行值初始化。以下三种初始化都是可以的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">pair&lt;int, int&gt; m(1,1);</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/21/C-关联容器/pair上的操作.png"><h6 id="创建pair对象的函数"><a href="#创建pair对象的函数" class="headerlink" title="创建pair对象的函数"></a>创建pair对象的函数</h6><p>新标准下，可以对返回值进行列表初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, int&gt; process(vector&lt;string&gt; &amp;v)&#123;</span><br><span class="line"><span class="comment">// 处理v</span></span><br><span class="line">    <span class="keyword">if</span>(!v.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;v.back(), v.back().size()&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(); <span class="comment">// 隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>早期版本必须显式的构造返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!v.empty())</span><br><span class="line">    <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(v.back(), v.back().size());</span><br></pre></td></tr></table></figure><p>还可以使用<code>make_pair</code>来生成<code>pair</code>对象，<code>pair</code>的两个类型来自于<code>make_pair</code>的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!v.empty())</span><br><span class="line"><span class="keyword">return</span> make_pair(v.back(), v.back().size());</span><br></pre></td></tr></table></figure><h4 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h4><img src="/blog/2020/12/21/C-关联容器/关联容器额外的类型别名.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::value_type v1; <span class="comment">// v1是一个string</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::key_value v2; <span class="comment">// v2是一个string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type v3; <span class="comment">// v3是一个pair&lt;const string, int&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::key_type v4; <span class="comment">// v4是一个string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::mapped_type v5; <span class="comment">// v5是一个int</span></span><br></pre></td></tr></table></figure><p>只有<code>map</code>类型（<code>unordered_map、unordered_multimap、multimap、map</code>）才定义了<code>mapped_type</code>;</p><h5 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h5><p>解引用一个关联容器的迭代器时，得到一个类型为容器的<code>value_type</code>的值的<strong>引用</strong>。对<code>map</code>而言，<code>value_type</code>是一个<code>pair</code>类型，其<code>first</code>成员保存<code>cosnt</code>的关键字，<code>second</code>成员保存值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得指向word_count中一个元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.begin();</span><br><span class="line"><span class="comment">// *map_it是指向一个pair&lt;const string, size_t&gt;对象的引用</span></span><br><span class="line"><span class="comment">// 或者使用(*map_it).first，(*map_it).second</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first; <span class="comment">// 打印此元素的关键字</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; map_it-&gt;second; <span class="comment">// 打印此元素的值</span></span><br><span class="line">map_it-&gt;first = <span class="string">"new key"</span>; <span class="comment">// 错误：关键字是const的</span></span><br><span class="line">++map_it-&gt;second; <span class="comment">// 正确：可以通过迭代器改变元素</span></span><br></pre></td></tr></table></figure><h6 id="set的迭代器是const的"><a href="#set的迭代器是const的" class="headerlink" title="set的迭代器是const的"></a>set的迭代器是const的</h6><p>虽然<code>set</code>类型同时定义了<code>iterator</code>和<code>const_iterator</code>类型， 但两种类型都只允许读<code>set</code>中的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator set_it = iset.begin();</span><br><span class="line"><span class="keyword">if</span>(set_it != iset.end())&#123;</span><br><span class="line">    *set_it = <span class="number">42</span>; <span class="comment">// 错误：set中的关键字是只读的</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *set_it &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正确：可以读关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="遍历关联容器"><a href="#遍历关联容器" class="headerlink" title="遍历关联容器"></a>遍历关联容器</h6><p><code>map</code>和<code>set</code>都支持之前所说的<code>begin</code>和<code>end</code>操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.cbegin();</span><br><span class="line"><span class="keyword">while</span>(map_it != word_count.cbegin())&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; map_it-&gt;first &lt;&lt; <span class="string">" occurs"</span></span><br><span class="line">         &lt;&lt; map_it-&gt;second &lt;&lt; <span class="string">" times"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++map_it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="关联容器和算法"><a href="#关联容器和算法" class="headerlink" title="关联容器和算法"></a>关联容器和算法</h6><p>通常不对关联容器使用泛型算法，有其专用算法。如果真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的位置。</p><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>使用关联容器的<code>insert</code>成员向容器中添加一个元素或一个元素范围：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;; <span class="comment">// ivec有8个元素</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set2;</span><br><span class="line">set2.insert(ivec.cbegin(), ivec.cend()); <span class="comment">// set2有4个元素</span></span><br><span class="line">set2.insert(&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;); <span class="comment">// set2现在有8个元素</span></span><br></pre></td></tr></table></figure><h6 id="向map添加元素"><a href="#向map添加元素" class="headerlink" title="向map添加元素"></a>向map添加元素</h6><p>对一个<code>map</code>进行<code>insert</code>操作时，必须记住元素类型是<code>pair</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向word_count插入word的4种方法</span></span><br><span class="line">word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.insert(make_pair(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;::value_type(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/21/C-关联容器/关联容器insert操作.png"><h6 id="检测insert返回值"><a href="#检测insert返回值" class="headerlink" title="检测insert返回值"></a>检测insert返回值</h6><p><code>insert</code>(或<code>emplace</code>)返回的值依赖于容器类型和参数。对于<strong>不包含重复关键字</strong>的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，告诉我们插入操作是否成功。<code>pair</code>的<code>first</code>成员是一个<strong>迭代器</strong>，指向<strong>具有给定关键字的元素</strong>；<code>second</code>成员是一个<code>bool</code>值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则<code>insert</code>什么事情也不做，且返回值中的<code>bool</code>部分为<code>false</code>。如果关键字不存在，元素被插入容器中，且<code>bool</code>值为<code>true</code>。</p><p>例子，重写单词计数程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>(!ret.second)</span><br><span class="line">        ++ret.first-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="展开递增语句"><a href="#展开递增语句" class="headerlink" title="展开递增语句"></a>展开递增语句</h6><ul><li><strong>ret</strong>：保存<code>insert</code>返回的值，是一个<strong>pair</strong></li><li><strong>ret.first</strong>：是一个<code>map</code>迭代器，指向具有给定关键字的元素</li><li>**ret.first-&gt;**：解引用此迭代器，提取<code>map</code>种元素，元素也是一个<code>pair</code></li><li><strong>ret.first-&gt;second</strong>：<code>map</code>中元素的值部分</li><li><strong>++ret.first-&gt;second</strong>：递增此值</li></ul><h6 id="向multiset或multimap添加元素"><a href="#向multiset或multimap添加元素" class="headerlink" title="向multiset或multimap添加元素"></a>向multiset或multimap添加元素</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; authors;</span><br><span class="line"><span class="comment">// 插入第一个元素，关键字为zxy</span></span><br><span class="line">authors.insert(&#123;<span class="string">"zxy"</span>, <span class="string">"c++泛型算法"</span>&#125;);</span><br><span class="line"><span class="comment">// 正确：添加第二个元素，关键字也是zxy"</span></span><br><span class="line">authors.insert(&#123;<span class="string">"zxy"</span>, <span class="string">"c++关联容器"</span>&#125;);</span><br></pre></td></tr></table></figure><p>这里<code>insert</code>操作返回一个指向新元素的迭代器。无需返回一个<code>bool</code>值，因为<code>insert</code>总是向这类容器中加入一个新元素。</p><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>关联容器定义了三个版本的<code>erase</code>，如下：</p><img src="/blog/2020/12/21/C-关联容器/关联容器erase操作.png"><p>后两个与顺序容器一样，第一个是关联容器额外提供的，它接受一个<code>key_type</code>类型。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除元素的数量。</p><ul><li>对于保存不重复关键字的容器，<code>erase</code>的返回值总是0或1。0表示要删除的元素不在容器中</li><li>对于允许重复关键字的容器，删除元素的数量可能大于1</li></ul><h5 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h5><p><code>map</code>和<code>unordered_map</code>容器提供了下标运算符和一个对应的<code>at</code>函数：</p><img src="/blog/2020/12/21/C-关联容器/map和unordered_map的下标操作.png"><p><strong><code>set</code>类型不支持下标，因为<code>set</code>中元素本身就是关键字，同时也不能对<code>multimap</code>或者<code>unordered_multimap</code>进行下标操作，因为这些容器中可能有多个值与一个关键字相关联</strong>。</p><img src="/blog/2020/12/21/C-关联容器/map_note.png"><h6 id="使用下标操作的返回值"><a href="#使用下标操作的返回值" class="headerlink" title="使用下标操作的返回值"></a>使用下标操作的返回值</h6><p>当对一个<code>map</code>进行下标操作时，会获得一个<code>mapped_type</code>对象；但当解引用一个<code>map</code>迭代器时，会得到一个<code>value_type</code>对象。与其他下标运算符相同的是，<code>map</code>的下标运算符返回一个左值，所以既可以读也可以写元素。</p><img src="/blog/2020/12/21/C-关联容器/map下标_note.png"><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><p>关联容器提供多种查找一个指定元素的方法，应该使用哪个取决我们要解决什么问题。</p><img src="/blog/2020/12/21/C-关联容器/在一个关联容器种查找元素的操作.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">iset.find(<span class="number">1</span>); <span class="comment">// 返回一个迭代器，指向key = 1的元素</span></span><br><span class="line">iset.find(<span class="number">11</span>); <span class="comment">// 返回一个迭代器，其值等于iset.end()</span></span><br><span class="line">iset.count(<span class="number">1</span>); <span class="comment">// 返回1</span></span><br><span class="line">iset.count(<span class="number">11</span>); <span class="comment">// 返回0</span></span><br></pre></td></tr></table></figure><h6 id="对map和find代替下标操作"><a href="#对map和find代替下标操作" class="headerlink" title="对map和find代替下标操作"></a>对map和find代替下标操作</h6><p>如果我们只是想知道一个给定的关键字是否在<code>map</code>中，而不想改变<code>map</code>（下标操作会插入一个未在<code>map</code>的元素）。这种情况下应该使用<code>find</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(word_count.find(<span class="string">"foobar"</span>) == word_count.end())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"foobar is not in the map"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h6 id="在multimap或multiset中查找元素"><a href="#在multimap或multiset中查找元素" class="headerlink" title="在multimap或multiset中查找元素"></a>在multimap或multiset中查找元素</h6><p>如果一个<code>multimap</code>或<code>multiset</code>中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。</p><p>例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。可以用三种不同方法来解决这个问题。最直观的方法是使用<code>find</code>和<code>count</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">search_item</span><span class="params">(<span class="string">"zxy"</span>)</span></span>; <span class="comment">// 作者</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors.count(search_item); <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.find(search_item); <span class="comment">// 作者的第一本书</span></span><br><span class="line"><span class="comment">// 查找此作者所有著作</span></span><br><span class="line"><span class="keyword">while</span>(entries)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印书名</span></span><br><span class="line">    ++iter; <span class="comment">// 下一本</span></span><br><span class="line">    --entries; <span class="comment">// 打印一次，计数减一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/21/C-关联容器/multimap或multiset中查找元素_note.png"><h6 id="一种不同的，面向迭代器的解决办法"><a href="#一种不同的，面向迭代器的解决办法" class="headerlink" title="一种不同的，面向迭代器的解决办法"></a>一种不同的，面向迭代器的解决办法</h6><p>可以使用<code>lower_bound</code>和<code>upper_bound</code>来解决。</p><ul><li>关键字在容器中，<code>lower_bound</code>返回迭代器将指向第一个具有给定关键字的元素，<code>upper_bound</code>返回迭代器指向最后一个匹配关键字元素之后的位置</li><li>关键字不在容器中，两者返回一个不影响排序的关键字插入位置</li></ul><p>因此，使用相同关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到关键字元素的范围。我们可以重写程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> beg = authors.lower_bound(search_item),</span><br><span class="line">    end = authors.upper_bound(search_item);</span><br><span class="line">    beg != end; ++ beg)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/21/C-关联容器/lower_bound和upper_bound_note.png"><h6 id="equal-range函数"><a href="#equal-range函数" class="headerlink" title="equal_range函数"></a>equal_range函数</h6><p>此函数接受一个关键字，返回一个**迭代器<code>pair</code>**（不是<code>pair</code>对象）。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。再次修改程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = authors.equal_range(search_item);</span><br><span class="line">pos.first != pos.second; ++pos.first)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pos.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="一个单词转换的map"><a href="#一个单词转换的map" class="headerlink" title="一个单词转换的map"></a>一个单词转换的map</h5><p>程序功能：给定一个<code>string</code>，将它转换为另一个<code>string</code>。我们需要根据单词转换文件将待转换的文本转换为我们想要的样子：</p><p>单词转换文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k okay?</span><br><span class="line">y why</span><br><span class="line">r are</span><br><span class="line">u you</span><br><span class="line">pic picture</span><br><span class="line">thk thank!</span><br><span class="line">l8r later</span><br></pre></td></tr></table></figure><p>待转换文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where r u</span><br><span class="line">y dont u send me a pic</span><br><span class="line">k thk l8r</span><br></pre></td></tr></table></figure><p>转换结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where are you</span><br><span class="line">why dont you send me a picture</span><br><span class="line">okay? thanks! later</span><br></pre></td></tr></table></figure><h6 id="单词转换程序"><a href="#单词转换程序" class="headerlink" title="单词转换程序"></a>单词转换程序</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map_file 转换规则</span></span><br><span class="line"><span class="comment">// input 待转换文本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">word_transform</span><span class="params">(ifstream &amp;map_file, ifstream &amp;input, ofstream &amp;output)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> trans_map = buildMap(map_file);</span><br><span class="line">    <span class="built_in">string</span> text; <span class="comment">// 保存输入中的每一行</span></span><br><span class="line">    <span class="keyword">while</span>(getline(input, text))&#123; <span class="comment">// 读取每一行输入</span></span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">stream</span><span class="params">(text)</span></span>; <span class="comment">// 读取每个单词</span></span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">bool</span> firstword = <span class="literal">true</span>; <span class="comment">// 控制是否打印空格</span></span><br><span class="line">        <span class="keyword">while</span>(stream &gt;&gt; word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(firstword)</span><br><span class="line">                firstword = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                output &lt;&lt; <span class="string">" "</span>; <span class="comment">// 单词间打印一个空格</span></span><br><span class="line">            output &lt;&lt; transform(word, trans_map); <span class="comment">// 打印输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        output &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 完成一行的转换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="建立转换映射"><a href="#建立转换映射" class="headerlink" title="建立转换映射"></a>建立转换映射</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; buildMap(ifstream &amp; map_file)&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; trans_map; <span class="comment">// 保存转换规则</span></span><br><span class="line">    <span class="built_in">string</span> key; <span class="comment">// 要转换的单词</span></span><br><span class="line">    <span class="built_in">string</span> value; <span class="comment">// 替换后的内容</span></span><br><span class="line">    <span class="comment">// 读取第一个单词存入key，剩余存入value（包括标点）</span></span><br><span class="line">    <span class="comment">// map_file&gt;&gt;key流只读取第一个空格前string，剩下的流由getline读取到value中</span></span><br><span class="line">    <span class="keyword">while</span>(map_file &gt;&gt; key &amp;&amp; getline(map_file, value))</span><br><span class="line">        <span class="keyword">if</span>(value.size() &gt; <span class="number">1</span>) <span class="comment">// 检查是否有转换规则</span></span><br><span class="line">            trans_map[key] = value.substr(<span class="number">1</span>); <span class="comment">// 跳过前导空格，getline不会跳过前导空格</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"no rule for "</span> + key);</span><br><span class="line">    <span class="keyword">return</span> trans_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="生成转换文本"><a href="#生成转换文本" class="headerlink" title="生成转换文本"></a>生成转换文本</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">transform</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; &amp;m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> map_it = m.find(s);</span><br><span class="line">    <span class="keyword">if</span>(map_it != m.cend())</span><br><span class="line">        <span class="keyword">return</span> map_it-&gt;second; <span class="comment">// 使用替换短语</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s; <span class="comment">// 否则返回原string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h4><p>新标准定义了<strong>4</strong>个<strong>无序关联容器</strong>，这些容器使用一个哈希函数和关键字类型的<code>==</code>运算符。</p><h6 id="使用无序容器"><a href="#使用无序容器" class="headerlink" title="使用无序容器"></a>使用无序容器</h6><p>用于<code>map</code>和<code>set</code>的操作也能用于<code>unordered_map</code>和<code>unordered_set</code>，如<code>find、insert</code>等。无序容器也有允许重复关键字的版本。</p><h6 id="管理桶"><a href="#管理桶" class="headerlink" title="管理桶"></a>管理桶</h6><p>无序容器在存储上组织为<strong>一组桶</strong>，每个桶保存零个或多个元素。<strong>无序容器使用一个哈希函数将元素映射到桶</strong>。</p><ul><li><p>为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。</p></li><li><p>容器将具有一个特定哈希值的所有元素都保存在相同的桶中。</p></li><li><p>如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。</p></li></ul><p>因此，无序容器的性能依赖于<strong>哈希函数的质量</strong>和<strong>桶的数量和大小</strong>。</p><p>对于相同的参数，哈希函数必须总是产生相同的结果。<strong>理想情况下，哈希函数将每个特定的值映射到唯一的桶</strong>。但是，<strong>将不同关键字的元素映射到相同的桶也是允许的</strong>。</p><ul><li>当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。</li><li>计算一个元素的哈希值和在桶中搜索通常都是很快的操作。</li><li>如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。</li></ul><p>以下这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。</p><img src="/blog/2020/12/21/C-关联容器/无序容器管理操作.png"><h6 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h6><p>默认情况下，无序容器使用关键字类型<code>==</code>运算符来比较元素，它们还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来<strong>生成每个元素的哈希值</strong>。</p><ul><li>无序容器支持关键字是<strong>内置类型(包括指针类型)**、</strong><code>string</code><strong>或者</strong>智能指针**类型的无序容器。</li><li>无序容器<strong>不能</strong>直接定义<strong>关键字类型为自定义类类型的无序容器</strong>。与容器不同，不能直接使用哈希模板，而必须提供我们自己的<code>hash</code>模板版本。</li><li>不使用默认的<code>hash</code>，而是使用一种类似于<strong>为有序容器重载关键字类型</strong>的默认比较操作。</li></ul><p>为了能将<code>Sale_data</code>用作关键字，我们需要提供函数来替代<code>==</code>运算符和哈希值计算函数。我们从定义这些重载函数开始：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;sd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hasher</code>函数使用标准库<code>hash</code>类型对象计算<code>ISBN</code>成员的哈希值，该哈希值建立在<code>string</code>之上。</p><p><code>eqOp</code>函数通过比较<code>ISBN</code>号来比较两个<code>Salas_data</code>。</p><p>使用以上函数来定义一个<code>unordered_multiset</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SD_multiset = <span class="built_in">unordered_multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(hasher)*, <span class="keyword">decltype</span>(eqOp)*&gt;;</span><br><span class="line"><span class="comment">// 参数是桶大小、哈希函数指针和相等性判断运算符指针</span></span><br><span class="line"><span class="function">SD_miltiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqOp)</span></span>;</span><br></pre></td></tr></table></figure><p>此集合的哈希和相等性判断操作与<code>hasher</code>和<code>eqOp</code>函数有着相同的类型。在定义<code>bookstore</code>时可以将我们希望它使用的函数的指针传递给它。</p><p>如果类定义了<code>==</code>运算符，则可以只重载哈希函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用FooHash生成哈希值；Foo必须有==运算符</span></span><br><span class="line">unordered_set&lt;Foo, decltype(FooHash)*&gt; fooSet(10, FoolHash);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用关联容器&lt;/li&gt;
&lt;li&gt;关联容器概述&lt;/li&gt;
&lt;li&gt;关联容器操作&lt;/li&gt;
&lt;li&gt;无序容器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode746-使用最小花费爬楼梯</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/21/LeetCode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/21/LeetCode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2020-12-21T06:57:07.000Z</published>
    <updated>2020-12-21T07:16:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组的每个索引作为一个阶梯，第<code>i</code>个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><a id="more"></a><img src="/blog/2020/12/21/LeetCode746-使用最小花费爬楼梯/746.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>像这种爬楼梯问题考虑动态规划，当前状态花费 $dp[i]$ 可以由上一次 $dp[i-1]$ 或者上上次 $dp[i-2]$ 中的最小花费得到（对应爬一层台阶和爬两层台阶），其次当前状态还有体力消耗 $cost[i]$，所以可以定义状态转移方程：<br>$$<br>dp[i]=min(dp[i-1],dp[i-2])+cost[i]<br>$$<br>当楼梯只有两阶时，假定有第三阶，那么到达第三阶的花费就为0，初始化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">cost.push_back(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        cost.push_back(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.size(); ++i)&#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;数组的每个索引作为一个阶梯，第&lt;code&gt;i&lt;/code&gt;个阶梯对应着一个非负数的体力花费值 &lt;code&gt;cost[i]&lt;/code&gt;(索引从0开始)。&lt;/p&gt;
&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。&lt;/p&gt;
&lt;p&gt;您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode316-去除重复字母</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/20/LeetCode316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/20/LeetCode316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</id>
    <published>2020-12-20T11:21:12.000Z</published>
    <updated>2020-12-20T12:26:58.182Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p><a id="more"></a><img src="/blog/2020/12/20/LeetCode316-去除重复字母/316.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对于一个字符串来说，如果 $s[i]&gt;s[i+1]$ ，去除此时的 $s[i]$ 可以使剩下的字符串字典序最小。我们将 $s[i]$ 称为<strong>关键字符</strong>。</p><p>从前往后遍历字符串。假定在 $s[i-1]$ 之前所有的<strong>关键字符</strong>都已经去除，那么在扫描 $s[i]$ 时，新出现的<strong>关键字符</strong>只能出现在 $s[i]$ 或者其后的位置。</p><p>所以用栈来维护去除<strong>关键字符</strong>后得到的字符串。如果栈顶字符大于 $s[i]$ ，说明栈顶字符应当被去除，此时新的栈顶字符就与 $s[i]$ 相邻（保持相对位置）。重复此操作，直到栈为空或者栈顶字符不大于 $s[i]$ 。</p><p>还需要满足 $s$ 中的每个字符都出现在新字符串中且只出现一次，所以还需要考虑：</p><ul><li>如果字符 $s[i]$ 已经存在于栈中，则不再将此字符加入栈，所以需要记录字符是否被使用过</li><li>弹出栈顶字符时，如果后面再没有此字符（此字符剩余数量为0），则不能弹出，所以需要记录每个字符出现的次数；如果可以弹出，需要将此字符再次置为未使用的状态</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 记录字符使用次数</span></span><br><span class="line">        <span class="built_in">bitset</span>&lt;26&gt; vis; <span class="comment">// 记录字符是否被使用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s) cnt[ch - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">            <span class="comment">// 如果字符没被使用</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[ch - <span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="comment">// 如果栈不为空且栈顶字符大于当前字符，需要看是否弹出</span></span><br><span class="line">                <span class="keyword">while</span>(!st.empty() &amp;&amp; st.top() &gt; ch)&#123;</span><br><span class="line">                    <span class="comment">// 如果此字符串剩余次数不为0，可以弹出，并且此字符置为「未使用」</span></span><br><span class="line">                    <span class="keyword">if</span>(cnt[st.top() - <span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        vis[st.top() - <span class="string">'a'</span>] = <span class="number">0</span>;</span><br><span class="line">                        st.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前字符入栈，并且置为「已使用」</span></span><br><span class="line">                vis[ch - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">                st.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前字符被使用了一次</span></span><br><span class="line">            cnt[ch - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出栈中字符并输出</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            res += st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：</p><p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 &lt;strong&gt;返回结果的字典序最小&lt;/strong&gt;（要求不能打乱其他字符的相对位置）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="单调栈" scheme="http://www.xingyuzhao.ltd/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>C++泛型算法（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/19/C-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/19/C-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-12-19T15:37:38.000Z</published>
    <updated>2020-12-20T12:49:02.989Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>再探迭代器</li><li>泛型算法结构</li><li>特定容器算法</li></ol><a id="more"></a><h4 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h4><p>标准库在头文件<code>iterator</code>中还定义了额外集中迭代器。包括：</p><ul><li><strong>插入迭代器（insert iterator）</strong>：这些迭代器被绑定在一个容器上，可用来向容器插入元素。</li><li><strong>流迭代器（stream iterator）</strong>：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</li><li><strong>反向迭代器（reverse iterator）</strong>：这些迭代器向前而不是向后移动（<strong>书上写的是向后而不是向前，疑问？</strong>），除了<code>forward_list</code>之外的标准库容器都有反向迭代器。</li><li><strong>移动迭代器（move iterator）</strong>：这些专用的迭代器不是拷贝其中的元素，而是移动它们。后面会提到。</li></ul><h5 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h5><p>插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。</p><p>插入器有三种类型，差异在于元素插入的位置：</p><ul><li><strong>back_inserter</strong>：创建一个使用<code>push_back</code>的迭代器。</li><li><strong>front_inserter</strong>：创建一个使用<code>push_front</code>的迭代器。</li><li><strong>inserter</strong>创建一个使用<code>insert</code>的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。<strong>元素将被插入到给定得到所表示的元素之前</strong>。</li></ul><img src="/blog/2020/12/19/C-泛型算法（二）/插入迭代器_note.png"><p>当调用<code>inserter(c, iter)</code>时，会得到一个迭代器，接下来使用它时，会将元素插入到<code>iter</code>原来所指向的元素之前的位置。即，如果<code>it</code>是由<code>iterator</code>生成的迭代器，则下面两段代码效果一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*it = val;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">it = c.insert(it, val); <span class="comment">// it指向新加入的元素</span></span><br><span class="line">++it; <span class="comment">// 递增it使它指向原来的元素</span></span><br></pre></td></tr></table></figure><p><code>front_inserter</code>生成的迭代器的行为于<code>inserter</code>生成的迭代器完全不一样。当我们使用<code>front_inserter</code>时，元素总是插入到容器第一个元素之前。即使我们传递给<code>inserter</code>的位置原来是指向第一个元素的，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2, lst3; <span class="comment">// 空list</span></span><br><span class="line"><span class="comment">// 拷贝完成后，lst2包含4 3 2 1</span></span><br><span class="line">copy(lst.begin(), lst.end(), front_inserter(lst2));</span><br><span class="line"><span class="comment">// 拷贝完成后，lst3包含1 2 3 4</span></span><br><span class="line">copy(lst.begin(), lst.end(), inserter(lst3, lsr3.begin());</span><br></pre></td></tr></table></figure><h5 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h5><p>虽然<code>iostream</code>不是迭代器，但标准库定义了一个可以用于这些IO类型对象的迭代器。<strong>iostream_iterator</strong>读入输入流，<strong>ostream_iterator</strong>向一个输出流写数据。这些迭代器将它们对应的流当作一个特定的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。</p><h6 id="istream-iterator操作"><a href="#istream-iterator操作" class="headerlink" title="istream_iterator操作"></a>istream_iterator操作</h6><p>当创建一个流迭代器时，必须指定将要读写的对象类型。一个<code>istream_iterator</code>使用<code>&gt;&gt;</code>来读取流。因此，<code>istream_iterator</code>要读取的类型必须定义了输入运算符。当创建一个<code>istream_iterator</code>时，我们可以将它绑定到一个流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">// 从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof; <span class="comment">// 尾后迭代器</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"afile"</span>)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; str_it; <span class="comment">// 从"afile"读取字符串</span></span><br></pre></td></tr></table></figure><p>下面是一个用<code>istream_iterator</code>从标准输入读取数据，存入一个<code>vector</code>的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">// 从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof; <span class="comment">// istream尾后迭代器</span></span><br><span class="line"><span class="keyword">while</span>(in_iter != eof)&#123;</span><br><span class="line">    <span class="comment">// 后置递增运算读取流，返回迭代器的旧值</span></span><br><span class="line">    <span class="comment">// 解引用迭代器，获得从流读取的前一个值</span></span><br><span class="line">    vec.push_back(*in_iter++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eof</code>被定义为空的<code>istream_iterator</code>，从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等。</p><p>上述程序可以改写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in_iter(cin), eof; // 从cin读取int</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>; <span class="comment">// 从迭代器范围构造vec</span></span><br></pre></td></tr></table></figure><img src="/blog/2020/12/19/C-泛型算法（二）/istream_iterator操作.png" style="zoom: 80%;"><h6 id="使用算法操作流迭代器"><a href="#使用算法操作流迭代器" class="headerlink" title="使用算法操作流迭代器"></a>使用算法操作流迭代器</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in(cin), eof;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(in, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>此调用会计算出从标准输入读取的值的和。</p><h6 id="istream-iterator允许使用懒惰求值"><a href="#istream-iterator允许使用懒惰求值" class="headerlink" title="istream_iterator允许使用懒惰求值"></a>istream_iterator允许使用懒惰求值</h6><p>当我们将一个<code>istream_iterator</code>绑定到一个流时，标准库并不保证迭代器立即从流读取数据。可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。</p><h6 id="ostream-iterator操作"><a href="#ostream-iterator操作" class="headerlink" title="ostream_iterator操作"></a>ostream_iterator操作</h6><p>我们可以对具有输出运算符<code>&lt;&lt;</code>的类型定义<code>ostream_iterator</code>。创建一个<code>ostream_iterator</code>时，可选第二个参数，它是一个<strong>C</strong>风格字符串（<strong>即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）</strong>。在输出的每个元素之后都会打印此字符串。并且必须将<code>ostream_iterator</code>绑定到一个指定的流，不允许空的或表示尾后位置的<code>ostream_iterator</code>。</p><img src="/blog/2020/12/19/C-泛型算法（二）/ostream_iterator操作.png" style="zoom:80%;"><p>我们可以用<code>ostream_iterator</code>来输出值的序列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">" "</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : vec)</span><br><span class="line">*out_iter++ = e; <span class="comment">// 赋值语句实际上将元素写到cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 下面的也行，但不推荐</span></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">" "</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : vec)</span><br><span class="line">out_iter = e; <span class="comment">// 赋值语句将元素写到cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运算符<code>*</code>和<code>++</code>不对<code>ostream_iterator</code>对象做任何操作。第一种写法流迭代器的使用与其他迭代器的使用保持一致。</p><p>可以通过<code>copy</code>来打印<code>vec</code>中的元素，更简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy(vec.begin(), vec.end(), out_iter);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h6 id="使用流迭代器处理类类型"><a href="#使用流迭代器处理类类型" class="headerlink" title="使用流迭代器处理类类型"></a>使用流迭代器处理类类型</h6><p>对于之前的<code>Sales_item</code>既有输入运算符也有输出运算符，可以使用IO迭代器重写书店程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始程序</span></span><br><span class="line">Sales_item total; <span class="comment">// 保存下一条交易记录的变量</span></span><br><span class="line"><span class="comment">// 读入第一条交易记录，并确保有数据可以处理</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span> &gt;&gt; total)&#123;</span><br><span class="line">    Sales_item trans; <span class="comment">// 保存和的变量</span></span><br><span class="line">    <span class="comment">// 读入并处理剩余交易记录</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; trans)&#123;</span><br><span class="line">        <span class="comment">// 如果我们仍在处理相同的书</span></span><br><span class="line">        <span class="keyword">if</span>(total.isbn() == trans.isbn())</span><br><span class="line">            totao += trans; <span class="comment">// 更新销售总额</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 打印前一本书的结果</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            total = trans; <span class="comment">// total现在表示下一本书的销售额</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用IO迭代器重写</span></span><br><span class="line">istream_iterator&lt;Sales_item&gt; item_iter(cin), eof;</span><br><span class="line"><span class="function">ostream_iterator&lt;Sales_item&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">"\n"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 将第一笔交易记录存在sum中，并读取下一条记录</span></span><br><span class="line">Sales_item sum = *item_iter++;</span><br><span class="line"><span class="keyword">while</span>(item_iter != eof)&#123;</span><br><span class="line">    <span class="comment">// 如果当前交易记录（存在item_iter中）有相同的ISBN号</span></span><br><span class="line">    <span class="keyword">if</span>(item_iter-&gt;isbn() == sum.isbn())</span><br><span class="line">        sum += *item_iter++;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        out_iter = sum;</span><br><span class="line">        sum = *item_iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">out_iter = sum;</span><br></pre></td></tr></table></figure><h5 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h5><p>顾名思义，反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增和递减含义会颠倒过来。递增一个反向迭代器（<code>++it</code>）会移动到前一个元素；递减一个反向迭代器（<code>--it</code>）会移动到后一个元素。反向迭代器也有<code>const</code>和非<code>const</code>版本。</p><img src="/blog/2020/12/19/C-泛型算法（二）/反向迭代器.png" style="zoom:80%;"><p>下面是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> r_iter = vec.crbegin(); r_iter != vec.crend(); ++r_iter)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *r_iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 打印6，5，4，3，2，1</span></span><br></pre></td></tr></table></figure><p>可以通过向<code>sort</code>传递一对反向迭代器来将<code>vector</code>整理为递减：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(vec.begin(), vec.end()); <span class="comment">// 递增</span></span><br><span class="line">sort(vec.rbegin(), vec.rend()); <span class="comment">// 递减</span></span><br></pre></td></tr></table></figure><h6 id="反向迭代器和其他迭代器间的关系"><a href="#反向迭代器和其他迭代器间的关系" class="headerlink" title="反向迭代器和其他迭代器间的关系"></a>反向迭代器和其他迭代器间的关系</h6><p>假定有一个名为<code>line</code>的<code>string</code>，保存着以逗号分隔的单词列表，我们希望打印<code>line</code>中的第一个单词，可以使用<code>find</code>完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> comma = find(line.cbegin(), line.cend(), <span class="string">','</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(line.cbegin(), comma) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>如果<code>line</code>中有逗号，那么<code>comma</code>将指向这个逗号，否则它指向<code>line.cend()</code>。如果希望打印最后一个单词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> rcomma = find(line.crbegin(), line.crend(), <span class="string">','</span>);</span><br></pre></td></tr></table></figure><p>当我们试图打印找到的单词时，不能用以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，对于FIRST,MIDDLE,LAST会打印出TSAL</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(line.crbegin(), rcomma) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>需要做的是，将<code>rcomma</code>转换为一个普通迭代器，能在<code>line</code>中正向移动。可以调用<code>reverse_iterator</code>中的<code>base</code>成员来完成这一转换，此成员函数会返回其对应的普通迭代器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(rcomma.base(), line.cend()) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/19/C-泛型算法（二）/反向迭代器_使用base.png" style="zoom:80%;"><p>需要注意的是：</p><img src="/blog/2020/12/19/C-泛型算法（二）/反向迭代器_note.png" style="zoom: 80%;"><h4 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h4><p>算法所要求的迭代器操作可以分为5个迭代器类别：</p><img src="/blog/2020/12/19/C-泛型算法（二）/迭代器类别.png" style="zoom:80%;"><h5 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h5><p>对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。<strong>而这种错误很多编译器不会给出任何警告和提示</strong>。</p><h6 id="输入迭代器（input-iterator）"><a href="#输入迭代器（input-iterator）" class="headerlink" title="输入迭代器（input iterator）"></a>输入迭代器（input iterator）</h6><p>可以读取序列中的元素。一个输入迭代器必须支持：</p><ul><li>用于比较两个迭代器的相等和不相等运算符（<code>==、!=</code>）</li><li>用于推进迭代器的前置和后置递增运算（<code>++</code>）</li><li>用于读取元素的解引用运算符（<code>*</code>）；解引用只会出现在赋值运算符的右侧</li><li>箭头运算符（<code>-&gt;</code>），等价于<code>(*it).member</code>，即，解引用迭代器，并提取对象的成员</li></ul><p>输入迭代器只用于顺序访问，只能用于单边扫描算法。算法<code>find</code>和<code>accumulate</code>要求输入迭代器；而<code>istream_iterator</code>是一种输入迭代器。</p><h6 id="输出迭代器（output-iterator）"><a href="#输出迭代器（output-iterator）" class="headerlink" title="输出迭代器（output iterator）"></a>输出迭代器（output iterator）</h6><p>可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：</p><ul><li>用于推进迭代器的前置和后置递增运算（<code>++</code>）</li><li>解引用运算符（<code>*</code>），只出现在赋值运算符的左侧</li></ul><p>例如，<code>copy</code>函数的第三个参数就是输出迭代器；<code>ostream_iterator</code>是一种输出迭代器。</p><h6 id="前向迭代器（forward-iterator）"><a href="#前向迭代器（forward-iterator）" class="headerlink" title="前向迭代器（forward iterator）"></a>前向迭代器（forward iterator）</h6><p>可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法<code>replace</code>要求前向迭代器， <code>forward_list</code>上的迭代器是前向迭代器。</p><h6 id="双向迭代器（bidirectional-iterator）"><a href="#双向迭代器（bidirectional-iterator）" class="headerlink" title="双向迭代器（bidirectional iterator）"></a>双向迭代器（bidirectional iterator）</h6><p>可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（<code>--</code>）。算法<code>reverse</code>要求双向迭代器，除了<code>forward_list</code>之外，其他标准库都提供符合双向迭代器要求的迭代器.</p><h6 id="随机访问迭代器（random-access-iterator）"><a href="#随机访问迭代器（random-access-iterator）" class="headerlink" title="随机访问迭代器（random-access iterator）"></a>随机访问迭代器（random-access iterator）</h6><p>提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，还支持以下操作：</p><ul><li>用于比较两个迭代器相对位置的关系运算符（<code>&lt;、&lt;=、&gt;</code>和<code>&gt;=</code>) </li><li>迭代器和一个整数值的加减运算（<code>+、+=、-</code>和<code>-=</code>），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置</li><li>用于两个迭代器上的减法运算符（<code>-</code>），得到两个迭代器的距离</li><li>下标运算符<code>iter[n]</code>，与<code>*(iter[n])</code>等价</li></ul><p>算法<code>sort</code>要求随机访问迭代器。<code>array、deque、string、vector</code>的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。</p><h5 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h5><p>大多数算法具有如下4种形式之一：</p><ul><li><strong><em>alg</em></strong> ( beg, end, <strong><em>other args</em></strong>)</li><li><strong><em>alg</em></strong> ( beg, end, dest, <strong><em>other args</em></strong>)</li><li><strong><em>alg</em></strong> ( beg, end, beg2, <strong><em>other args</em></strong>)</li><li><strong><em>alg</em></strong> ( beg, end, be2, end2, <strong><em>other args</em></strong>)</li></ul><h5 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h5><p>如何提供一个操作代替默认的<code>&lt;</code>或<code>==</code>运算符，以及算法是将输出数据写入输入序列，还是写入分离的目的位置等问题。</p><h6 id="一些算法使用重载形式传递一个谓词"><a href="#一些算法使用重载形式传递一个谓词" class="headerlink" title="一些算法使用重载形式传递一个谓词"></a>一些算法使用重载形式传递一个谓词</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique(beg, end); <span class="comment">// 使用 == 运算符比较元素</span></span><br><span class="line">unique(beg, end, comp); <span class="comment">// 使用comp比较元素</span></span><br></pre></td></tr></table></figure><h6 id="if版本的算法"><a href="#if版本的算法" class="headerlink" title="_if版本的算法"></a>_if版本的算法</h6><p>接受一个元素值得算法通常有另一个不同名的版本（非重载），该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的<code>_if</code>前缀：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val); <span class="comment">// 查找输入范围种val第一次出现的位置</span></span><br><span class="line">find_if(beg, end, pred);<span class="comment">// 查找第一个令pred为真的元素</span></span><br></pre></td></tr></table></figure><h6 id="区分拷贝元素的版本和不拷贝的版本"><a href="#区分拷贝元素的版本和不拷贝的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝的版本"></a>区分拷贝元素的版本和不拷贝的版本</h6><p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个<code>_copy</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse(beg, end); <span class="comment">// 反转输入范围中元素的顺序</span></span><br><span class="line">reverse_copy(beg, end ,dest); <span class="comment">// 将元素按逆序拷贝到dest</span></span><br></pre></td></tr></table></figure><p>一些算法同时提供<code>_if</code>和<code>_copy</code>版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从v1中删除奇数元素</span></span><br><span class="line">remove_if(v1.begin(), v1.end(), </span><br><span class="line">          [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span>; &#125;);</span><br><span class="line"><span class="comment">// 将偶数元素从v1拷贝到v2，v1不变</span></span><br><span class="line">remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),</span><br><span class="line">              [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h4><p>与其他容器不同，链表类型<code>list</code>和<code>forward_list</code>定义了几个成员函数形式的算法，它们定义了独有的<code>sort、merge、remove、reverse、unique</code>，这些独有的版本比通用版本好得多。</p><img src="/blog/2020/12/19/C-泛型算法（二）/特定容器算法.png" style="zoom:80%;"><p>算法如下：</p><img src="/blog/2020/12/19/C-泛型算法（二）/list.png" style="zoom:80%;"><h5 id="splice成员"><a href="#splice成员" class="headerlink" title="splice成员"></a>splice成员</h5><img src="/blog/2020/12/19/C-泛型算法（二）/splice.png" style="zoom:80%;"><h5 id="链表特有的操作会改变容器"><a href="#链表特有的操作会改变容器" class="headerlink" title="链表特有的操作会改变容器"></a>链表特有的操作会改变容器</h5><p>链表特有版本会改变底层的容器，例如<code>remove</code>会删除指定的元素。<code>unique</code>会删除第二个和后继的重复元素。</p><p>类似的，通用版本<code>merge</code>将合并的序列写到一个给定的目的迭代器，两个输入序列是不变的。而链表版本的<code>merge</code>会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用<code>merge</code>的链表对象中。在<code>merge</code>之后，来自两个链表中的元素依然存在，但它们都已在同一个链表中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;再探迭代器&lt;/li&gt;
&lt;li&gt;泛型算法结构&lt;/li&gt;
&lt;li&gt;特定容器算法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++泛型算法（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/19/C-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/19/C-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-12-19T15:37:19.000Z</published>
    <updated>2020-12-20T12:35:54.151Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>概述</li><li>初识泛型算法</li><li>定制操作</li></ol><a id="more"></a><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>大多数算法都定义在头文件<code>algorithm</code>中。标准库还在头文件<code>numeric</code>中定义了一组数值泛型算法。</p><h5 id="算法永远不会执行容器的操作"><a href="#算法永远不会执行容器的操作" class="headerlink" title="算法永远不会执行容器的操作"></a>算法永远不会执行容器的操作</h5><p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。算法永远<strong>不会改变</strong>底层容器的大小。算法可能<strong>改变</strong>容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p><p>标准库定义了一类特殊的迭代器，称为插入器（inserter）。它们会在底层的容器上执行插入操作。当一个算法操作这样的一个迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身<strong>不会</strong>做这样的操作。</p><h4 id="初识泛型算法"><a href="#初识泛型算法" class="headerlink" title="初识泛型算法"></a>初识泛型算法</h4><p>标准库算法都对一个范围内的元素进行操作。此范围称为“输入范围”。输入范围使用两个参数：要处理的第一个元素和尾元素之后的位置的迭代器。</p><h5 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h5><p>此类算法只会读取其输入范围内的元素，而从不改变元素。如<code>find</code>，<code>count</code>。定义在<code>numeric</code>中有只读算法<code>accumulate</code>，前两个指出需要求和的元素的范围，第三个参数是和的初值。最好用<code>cbegin()</code>和<code>cend()</code>，除非打算用返回的迭代器来改变元素的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对vec中的元素求和，和的初值为0</span></span><br><span class="line"><span class="keyword">int</span> sum = accumulate(v.cbegin(), v.cend(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h6 id="算法和元素类型"><a href="#算法和元素类型" class="headerlink" title="算法和元素类型"></a>算法和元素类型</h6><p><code>accumulate</code>第三个参数为求和起点，包含了一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须和第三个参数匹配。由于<code>string</code>定义了<code>+</code>操作，所以可以将<code>vector</code>中的所有<code>string</code>连接起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="built_in">string</span>(<span class="string">""</span>));</span><br></pre></td></tr></table></figure><p>将空串当作一个字符串字面值传递给第三个参数是不可以的，会导致编译错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：const char*上没有定义+运算符</span></span><br><span class="line"><span class="built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="string">""</span>);</span><br></pre></td></tr></table></figure><h6 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h6><p>只读算法<code>equal</code>用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素和第二个序列中的对应元素逐个比较，如果都相等返回<code>true</code>，否则返回<code>false</code>。此算法接受三个迭代器：前两个表示第一个序列范围，第三个表示第二个序列的首元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roster2中的元素数目应该至少于roster1一样多</span></span><br><span class="line">equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());</span><br></pre></td></tr></table></figure><p><code>equal</code>基于假设：第二个序列至少与第一个序列一样长。</p><p>*<strong>注意！！！**</strong>那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。*</p><h5 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h5><p>一些算法将新值赋予序列中的元素，需要确保序列原大小至少不小于要求算法写入的元素数目。例如<code>fill</code>接受一对迭代器表示一个范围，还接受一个值作为第三个参数，将范围内的值置为第三个参数的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fill(vec.begin(), vec.end(), <span class="number">0</span>); <span class="comment">// 将每个元素重置为0</span></span><br><span class="line"><span class="comment">// 将容器的一个子序列设置为10</span></span><br><span class="line">fill(vec.begin(), vec.begin() + vec.size() / <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h6 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h6><p>一些算法接受一个迭代器来指出一个单独的目的位置，从目的位置开始，将新值赋予一个序列中的元素。例如<code>fill_n</code>接受一个单迭代器、一个计数值和一个值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill_n(dest, n, val);</span><br></pre></td></tr></table></figure><p><code>fill_n</code>假定<code>dest</code>指向一个元素，从<code>dest</code>开始的序列至少包含n个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">// 空vector</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">fill_n(vec.begin(), vec.size(); <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 错误,vec并没有10个元素</span></span><br><span class="line">fill_n(vec.begin(), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h6 id="介绍back-inserter"><a href="#介绍back-inserter" class="headerlink" title="介绍back_inserter"></a>介绍back_inserter</h6><p><code>back_inserter</code>定义在头文件<code>iterator</code>中，其接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it = back_inserter(vec);</span><br><span class="line">*it = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>常常使用<code>back_inserter</code>创建一个迭代器，作为算法的目的位置来使用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill_n(back_inserter(vec), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h6 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h6><p>此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。算法将输入范围中的元素拷贝到目的序列中。<strong>传递给<code>copy</code>的目的序列至少要包含与输入序列一样多的元素</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="keyword">sizeof</span>(a1) / <span class="keyword">sizeof</span>(*a1)];</span><br><span class="line"><span class="keyword">auto</span> ret = copy(begin(a1), end(a1), a2);</span><br></pre></td></tr></table></figure><p><code>copy</code>返回其目的位置迭代器（递增后）的值，即<code>ret</code>恰好指向拷贝到<code>a2</code>的尾元素之后的位置。</p><p>多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放在输入序列的末尾，而是创建一个新序列保存这些结果。</p><p>如<code>replace</code>，其读入一个序列，并将其中所有等于给定值元素都改为另一个值，此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有值为0的元素改为42</span></span><br><span class="line">replace(ilist.begin(), ilist.end(), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>对于它的“拷贝”版本<code>replace_copy</code>，此算法接受额外第三个迭代器参数，指出点整后序列的保存位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用back_inserter按需要增长目标序列</span></span><br><span class="line">replace_copy(ilist.cbegin(), ilist.cend(),</span><br><span class="line">             back_inserter(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>经过此调用，<code>ilist</code>并未改变，<code>ivec</code>包含<code>ilist</code>的一份拷贝，不过原来在<code>ilist</code>中值为0的元素在<code>ivec</code>中都变为42。</p><h5 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h5><p>假定已经有一个<code>vector</code>，保存了多个故事的文本，简化这个<code>vector</code>，使得每个单词只出现一次。输入如下：</p><img src="/blog/2020/12/19/C-泛型算法（一）/重排_输入.png" style="zoom:80%;"><p>要求得到的结果如下：</p><img src="/blog/2020/12/19/C-泛型算法（一）/重排_输出.png"><p>为了消除重复单词，先对<code>vector</code>排序，使得重复的单词相邻出现，之后可以使用另一个称为<code>unique</code>的标准库算法来重排<code>vector</code>，使得不重复的元素出现在<code>vector</code>的开始部分。由于算法不能执行容器的操作，可以使用<code>vector</code>的成员<code>erase</code>来完成真正的删除操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</span><br><span class="line">sort(words.begin(), words.end());</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">end_unique</span><span class="params">(words.begin(), words.end())</span></span>;</span><br><span class="line">    words.erase(end_unique, words.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>words</code>排序完毕后，使用<code>unique</code>算法重排输入序列，将相邻的重复项”消除“，并<strong>返回一个指向最后一个不重复元素之后的位置的迭代器</strong>。调用<code>unique</code>后，<code>vector</code>将变为：</p><img src="/blog/2020/12/19/C-泛型算法（一）/after_unique.png"><p>如上图所示，<code>unique</code>并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列的开始部分。<code>unique</code>返回的迭代器位置之后的元素依旧存在，但不知道是什么。</p><p><strong>标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元。素</strong></p><p>最后，使用<code>erase</code>删除从<code>end_unique</code>开始至<code>words</code>末尾的范围内的所有元素。即使<code>words</code>中没有重复单词，调用<code>erase</code>也是安全的，删除空的范围没什么不良后果。</p><h4 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h4><p>详见<a href="http://www.xingyuzhao.ltd/blog/2020/08/02/C-11%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">C++11之lambda表达式</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;初识泛型算法&lt;/li&gt;
&lt;li&gt;定制操作&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode48-旋转图像</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/19/LeetCode48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/19/LeetCode48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2020-12-19T02:05:48.000Z</published>
    <updated>2020-12-20T12:56:07.564Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个 $n × n$ 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><a id="more"></a><img src="/blog/2020/12/19/LeetCode48-旋转图像/48.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>不好意思，一开始我还是用了新的数组。</p><p>从最后一列往前，从第一行往后，每一列都是由相应的行复制过来，如下图（示例二）：</p><img src="/blog/2020/12/19/LeetCode48-旋转图像/48_思路.png" style="zoom:80%;"><p>新建数组保存原始数组的拷贝，然后再根据原始数组拷贝来修改原始数组。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> scale = matrix.size();</span><br><span class="line">        <span class="keyword">auto</span> matrixHelper = matrix;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// 表示当前遍历到拷贝数组的第pos行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = scale - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; ++i)&#123;</span><br><span class="line">                <span class="comment">// 前面的i表示原始数组的行，后面的i表示拷贝数组的列</span></span><br><span class="line">                matrix[i][j] = matrixHelper[pos][i];</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度和空间复杂度都是$O(N^2)$。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>仔细观察旋转后的图：</p><img src="/blog/2020/12/19/LeetCode48-旋转图像/48_思路.png" style="zoom:80%;"><p>对于矩阵中第 $i$ 行的第 $j$ 个元素，在旋转后，它出现在倒数第 $i $ 列的第 $j$ 个位置。即：<br>$$<br>matrix_{new}[col][n-row-1]=matrix[row][col]<br>$$<br>这样可以得到以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">auto</span> matrixHelper = matrix;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = matrixHelper[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样也不是原地修改，但是可以得到上面那个重要等式。</p><p>如果对矩阵先进行水平轴翻转，再进行主对角线翻转，也可以得到旋转后的矩阵，以示例二为例：</p><ol><li>水平翻转：</li></ol><p>$$<br>\left[<br>\begin{matrix}<br>    5 &amp; 1 &amp; 9 &amp; 11 \\<br>    2 &amp; 4 &amp; 8 &amp; 10 \\<br>    13 &amp; 3 &amp; 6 &amp; 7 \\<br>    15 &amp; 14 &amp; 12 &amp; 16<br>    \end{matrix}<br>    \right]\stackrel{\Large水平翻转}{\huge\longrightarrow}<br>\left[<br>\begin{matrix}<br>    15 &amp; 14 &amp; 12 &amp; 16\\<br>    13 &amp; 3 &amp; 6 &amp; 7 \\<br>    2 &amp; 4 &amp; 8 &amp; 10 \\<br>    5 &amp; 1 &amp; 9 &amp; 11<br>    \end{matrix}<br>    \right]<br>$$</p><p>$$<br>matrix[row][col]=matrix[n-row-1][col]<br>$$</p><ol start="2"><li>主对角线翻转：</li></ol><p>$$<br>\left[<br>\begin{matrix}<br>    15 &amp; 14 &amp; 12 &amp; 16 \\<br>    13 &amp; 3 &amp; 6 &amp; 7 \\<br>    2 &amp; 4 &amp; 8 &amp; 10 \\<br>    5 &amp; 1 &amp; 9 &amp; 11<br>    \end{matrix}<br>    \right]\stackrel{\Large主对角线翻转}{\huge\longrightarrow}<br>\left[<br>\begin{matrix}<br>    15 &amp; 13 &amp; 2 &amp; 5 \\<br>    14 &amp; 3 &amp; 4 &amp; 1 \\<br>    12 &amp; 6 &amp; 8 &amp; 9 \\<br>    16 &amp; 7 &amp; 10 &amp; 11<br>    \end{matrix}<br>    \right]<br>$$</p><p>$$<br>matrix[row][col]=matrix[col][row]<br>$$</p><p>综合以上两式，可以得到：<br>$$<br>matrix[row][col]\stackrel{\large水平翻转}{\large\longrightarrow}matrix[n-row-1][col]<br>$$</p><p>$$<br>matrix[n-row-1][col]\stackrel{\large主对角线翻转}{\large\longrightarrow}matrix[col][n-row-1]<br>$$</p><p>即：<br>$$<br>matrix[row][col]=matrix_{new}[col][n-row-1]<br>$$<br>这就与之前得到的重要等式相同了。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：</p><p><a href="https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个 $n × n$ 的二维矩阵表示一个图像。&lt;/p&gt;
&lt;p&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;你必须在&lt;strong&gt;原地&lt;/strong&gt;旋转图像，这意味着你需要直接修改输入的二维矩阵。&lt;strong&gt;请不要&lt;/strong&gt;使用另一个矩阵来旋转图像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode389-找不同</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/18/LeetCode389-%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/18/LeetCode389-%E6%89%BE%E4%B8%8D%E5%90%8C/</id>
    <published>2020-12-18T01:54:31.000Z</published>
    <updated>2020-12-18T01:58:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，它们只包含小写字母。</p><p>字符串 <strong><em>t</em></strong> 由字符串 <strong><em>s</em></strong> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <strong><em>t</em></strong> 中被添加的字母。</p><a id="more"></a><img src="/blog/2020/12/18/LeetCode389-找不同/389.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用一个长为26的数组记录在 <strong><em>t</em></strong> 中所有字母的出现次数，然后再去遍历 <strong><em>s</em></strong> ，对每次遇到的字母对应的次数减一，最后再遍历这个数组，如果有出现次数为1的字母，那么这就是 <strong><em>t</em></strong> 中被添加的字母。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : t)&#123;</span><br><span class="line">            <span class="built_in">map</span>[ch - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">            <span class="built_in">map</span>[ch - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">char</span>(i + <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">char</span>(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt;，它们只包含小写字母。&lt;/p&gt;
&lt;p&gt;字符串 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt; 由字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 随机重排，然后在随机位置添加一个字母。&lt;/p&gt;
&lt;p&gt;请找出在 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt; 中被添加的字母。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode714-买卖股票的最佳时机含手续费</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</id>
    <published>2020-12-17T03:46:09.000Z</published>
    <updated>2020-12-20T12:56:46.674Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 $prices$，其中第 $i$ 个元素代表了第 $i$ 天的股票价格；非负整数 $fee$ 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><a id="more"></a><img src="/blog/2020/12/17/LeetCode714-买卖股票的最佳时机含手续费/714.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="定义-dp-数组"><a href="#定义-dp-数组" class="headerlink" title="定义$dp$数组"></a>定义$dp$数组</h5><p>使用两个数组 $dp1[i]$ 和 $dp2[i]$ 分别表示当天持有股票or当天不持有股票时的最大收益。</p><h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul><li>$dp1[i]$表示第 $i$ 天未持有的最大收益，由上一天未持有或者上一天持有当天卖出得到：</li></ul><p>$$<br>dp1[i] = max(dp1[i - 1], dp2[i - 1] + prices[i] - fee)<br>$$</p><ul><li>$dp2[i] $表示第 $i$ 天持有的最大收益，由上一天持有或者上一天不持有今天买入得到：</li></ul><p>$$<br>dp2[i] = max(dp2[i - 1], dp1[i - 1] - prices[i])<br>$$</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li>第一天未持有股票时，收益为0，$dp1[0] = 0$。</li><li>第一天持有股票时，收益为当天买入所需要的钱，$dp2[0] = -prices[0]$。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(prices.size())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp2</span><span class="params">(prices.size())</span></span>;</span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp2[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp1[i] = max(dp1[i - <span class="number">1</span>], dp2[i - <span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp2[i] = max(dp2[i - <span class="number">1</span>], dp1[i - <span class="number">1</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1[prices.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>注意到 $dp1[i]$ 和 $dp2[i]$ 只会从 $dp1[i-1]$ 和 $dp2[i-1]$ 转移而来，所以用两个变量 $sell$ 以及 $buy$ 分别表示 $dp1[i]$ 和 $dp2[i]$，空间复杂度降为 $O(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = sell;</span><br><span class="line">            sell = max(sell, buy + prices[i] - fee);</span><br><span class="line">            buy = max(buy, sell - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>评论区：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/comments/</a></p><p>官方题解：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个整数数组 $prices$，其中第 $i$ 个元素代表了第 $i$ 天的股票价格；非负整数 $fee$ 代表了交易股票的手续费用。&lt;/p&gt;
&lt;p&gt;你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。&lt;/p&gt;
&lt;p&gt;返回获得利润的最大值。&lt;/p&gt;
&lt;p&gt;注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode290-单词规律</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</id>
    <published>2020-12-16T03:47:07.000Z</published>
    <updated>2020-12-17T08:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。</p><p>这里的 <code>遵循</code> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><a id="more"></a><img src="/blog/2020/12/16/LeetCode290-单词规律/290.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>字母和单词一一对应时返回true，否则返回false。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">istr</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str;</span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">while</span>(istr &gt;&gt; word)&#123;</span><br><span class="line">            str.push_back(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern.size() != str.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&gt; map1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; map2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.size(); ++i)&#123;</span><br><span class="line">            map1[pattern[i]].insert(str[i]);</span><br><span class="line">            map2[str[i]].insert(pattern[i]);</span><br><span class="line">            <span class="comment">// 如果不是一一对应，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(map1[pattern[i]].size() &gt; <span class="number">1</span> || map2[str[i]].size() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一种规律 &lt;code&gt;pattern&lt;/code&gt; 和一个字符串 &lt;code&gt;str&lt;/code&gt; ，判断 &lt;code&gt;str&lt;/code&gt; 是否遵循相同的规律。&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;遵循&lt;/code&gt; 指完全匹配，例如， &lt;code&gt;pattern&lt;/code&gt; 里的每个字母和字符串 &lt;code&gt;str&lt;/code&gt; 中的每个非空单词之间存在着双向连接的对应规律。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode738-单调递增的数字</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/15/LeetCode738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/15/LeetCode738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-12-15T01:25:29.000Z</published>
    <updated>2020-12-20T12:55:51.505Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个非负整数 <code>N</code>，找出小于或等于 <code>N</code> 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。（当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是单调递增的。）</p><a id="more"></a><img src="/blog/2020/12/15/LeetCode738-单调递增的数字/738.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这种思路太繁琐，不想看的话直接转至<strong>更进一步</strong>。</p><hr><p>输入是一个非负整数，所以第一步要将其转换成可以遍历的形式，可以先将整数转换为字符串序列。</p><p>从<strong>输入序列</strong>的第一个数开始，一个一个数的建立起<strong>答案序列</strong>。</p><ol><li><strong>输入序列单调不减</strong>，答案序列的当前值最大可以取到输入序列的当前值。如输入为1234，那么答案序列的第一个位置最大可以取到1，继续遍历，取到当前位置最大值时，一直会大于等于上一个取到的值，所以最终可以得到答案1234：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums; <span class="comment">// 输入序列</span></span><br><span class="line"><span class="built_in">string</span> res; <span class="comment">// 答案序列</span></span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">-1</span>; <span class="comment">// 初始化为-1，保证第一个值可以取到</span></span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">    cur = nums[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur &gt;= pre)&#123;</span><br><span class="line">        res += to_string(cur);</span><br><span class="line">        pre = nums[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>输入序列非单调不减</strong>，如果当前值小于上一个可以取到的最大值，就需要回退，直到当前值不小于上一个可以取到的最大值。如输入332。<ol><li>当取到2时小于上一个取到的值3，上一个值减去1作为当前值（得到2），<code>res</code>出栈一次，如果出栈后<code>res</code>为空，那么存下当前值并退出。否则，上一个值取<code>res</code>末尾的值（第一个3）。</li><li>当前值为2，上一个值为第一个3，由于2小于3，那么再将上一个值减1作为当前值得到2），出栈一次，遍历回退一次，那么当前值变为2，此时<code>res</code>为空，记录2并且退出遍历。</li></ol></li></ol><ul><li>使用一个<code>flag</code>标记是否回退。</li><li>如果<code>res == &quot;0&quot;</code>，说明第一个数为0，此时答案长度为输入序列的长度减去1，全部为9；否则，就在<code>res</code>后补充9直到和输入序列长度相同。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> nums = to_string(N);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                cur = nums[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= pre)&#123;</span><br><span class="line">                    res += to_string(cur);</span><br><span class="line">                    pre = nums[i] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    pre--;</span><br><span class="line">                    res.pop_back();</span><br><span class="line">                    <span class="keyword">if</span>(res.empty())&#123;</span><br><span class="line">                        res += to_string(pre);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = pre;</span><br><span class="line">                    pre = res.back() - <span class="string">'0'</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= pre)&#123;</span><br><span class="line">                    res += to_string(cur);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre--;</span><br><span class="line">                res.pop_back();</span><br><span class="line">                <span class="keyword">if</span>(res.empty())&#123;</span><br><span class="line">                    res += to_string(pre);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = pre;</span><br><span class="line">                pre = res.back() - <span class="string">'0'</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> resVal;</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="string">"0"</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">buf</span><span class="params">(n, <span class="string">'9'</span>)</span></span>;</span><br><span class="line">            resVal = stoi(buf, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = res.size(); j &lt; nums.size(); ++j)&#123;</span><br><span class="line">                res += <span class="string">'9'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            resVal = stoi(res, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种思路实现起来太繁琐了（我是sb）。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>局部最优：遇到<code>nums[i - 1] &gt; nums[i]</code>的情况，让<code>nums[i - 1]--</code>，然后<code>nums[i]</code>值为9，可以保证这两位变成最大单调不减整数。</p><p>全局最优：尽量使<code>nums[i - 1]--</code>靠后，这样做可以使整数尽可能的大，因为越后面减去1，对整数的损失越小，所以从后往前遍历。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> nums = to_string(N);</span><br><span class="line">        <span class="keyword">int</span> flag = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; nums[i])&#123;</span><br><span class="line">                nums[i - <span class="number">1</span>]--;</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(flag; flag &lt; nums.size(); ++flag)&#123;</span><br><span class="line">            nums[flag] = <span class="string">'9'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stoi(nums, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>题解：</p><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/solution/738-dan-diao-di-zeng-de-shu-zi-tan-xin-s-vq4r/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/monotone-increasing-digits/solution/738-dan-diao-di-zeng-de-shu-zi-tan-xin-s-vq4r/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个非负整数 &lt;code&gt;N&lt;/code&gt;，找出小于或等于 &lt;code&gt;N&lt;/code&gt; 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。（当且仅当每个相邻位数上的数字 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 满足 &lt;code&gt;x &amp;lt;= y&lt;/code&gt; 时，我们称这个整数是单调递增的。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode49-字母异位词分组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/14/LeetCode49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/14/LeetCode49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</id>
    <published>2020-12-14T07:20:32.000Z</published>
    <updated>2020-12-20T12:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><a id="more"></a><img src="/blog/2020/12/14/LeetCode49-字母异位词分组/49.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>主要是理解哈希表的 $key$ 和 $value$ 表示什么数或者集合。对于字母构造相同的几个<code>string</code>，它们进行排序后的结果是一致的，所以可以将排序后的结果作为哈希表的 $key$，而对应的 $value$ 来存储排序后等于此 $key$ 的所有<code>string</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> str = strs[i];</span><br><span class="line">            sort(str.begin(), str.end());</span><br><span class="line">            <span class="built_in">map</span>[str].push_back(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;m : <span class="built_in">map</span>)</span><br><span class="line">            res.push_back(m.second);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p><strong>唯一分解定理</strong>：任何一个大于1的<strong>自然数</strong>N,如果N不为<strong>质数</strong>，那么N可以唯一分解成<strong>有限个质数</strong>的乘积。</p><p>用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。并且每个乘积只能是由这几个质数相乘得到。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">double</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">double</span> value[<span class="number">26</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">double</span> v = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : strs[i])&#123;</span><br><span class="line">                v *= value[ch - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[v].push_back(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;m : <span class="built_in">map</span>)</span><br><span class="line">            res.push_back(m.second);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>评论区<a href="https://leetcode-cn.com/problems/group-anagrams/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams/comments/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
