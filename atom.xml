<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>我见青山多妩媚，料青山见我应如是。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2021-02-02T13:57:15.583Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>赵星宇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>I/O控制（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/02/I-O%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/02/I-O%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-02T02:30:41.000Z</published>
    <updated>2021-02-02T13:57:15.583Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>假脱机技术（SPOOLing技术）</li><li>设备的分配与回收</li><li>缓冲区管理</li></ol><a id="more"></a><h4 id="假脱机技术（SPOOLing技术）"><a href="#假脱机技术（SPOOLing技术）" class="headerlink" title="假脱机技术（SPOOLing技术）"></a>假脱机技术（SPOOLing技术）</h4><h5 id="什么是脱机技术"><a href="#什么是脱机技术" class="headerlink" title="什么是脱机技术"></a>什么是脱机技术</h5><p>脱离主机的控制进行输入/输出操作。</p><h5 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h5><p>又称SPOOLing技术，使用软件方式模拟脱机技术。组成如下：</p><img src="/blog/2021/02/02/I-O控制（二）/输入井和输出井.png" style="zoom:80%;"><p>输入进程模拟脱机输入时的外围控制机，在其控制下，输入缓冲区暂存从输入设备输入的数据，之后再转存到输入井中。</p><p>输出进程模拟脱机输出时的外围控制机，在其控制下，输出缓冲区暂存从输出井送来的数据，之后再传送到输出设备上。</p><p>输入缓冲区和输出缓冲区是在<strong>内存中</strong>的缓冲区。</p><h4 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h4><p>设备可分为三种：独占设备、共享设备、虚拟设备。</p><p>独占设备：一个时段只能分配给一个进程（如打印机）。</p><p>共享设备：可同时分配给多个进程使用，宏观同时使用设备，微观交替使用设备（如磁盘）。</p><p>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程（共享打印机）。</p><h5 id="设备分配时应考虑因素"><a href="#设备分配时应考虑因素" class="headerlink" title="设备分配时应考虑因素"></a>设备分配时应考虑因素</h5><p>安全分配方式：为进程分配一个设备后将其阻塞，直到本次 I/O 完成后才将其唤醒。</p><ul><li>优点：不会死锁。</li><li>缺点：同一进程 CPU 与 I/O 串行工作。</li></ul><p>不安全分配方式：进程发出 I/O 请求后，系统为其分配 I/O 设备，进程可继续执行，之后还可以发出新的 I/O 请求。只有某个 I/O 请求得不到满足时才将其阻塞。</p><ul><li>优点：进程的计算任务和 I/O 任务可并行处理。</li><li>缺点：可能发生死锁。</li></ul><h5 id="静态-动态分配"><a href="#静态-动态分配" class="headerlink" title="静态/动态分配"></a>静态/动态分配</h5><p>静态分配：进程运行前为其分配所需资源，运行结束后归还资源。</p><p>动态分配：进程运行过程中动态申请设备资源。</p><h5 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h5><p>设备、控制器、通道之间的关系：</p><img src="/blog/2021/02/02/I-O控制（二）/设备、控制器、通道关系.png" style="zoom:80%;"><p>一个通道可以控制多个设备控制器，每个设备控制器可控制多个设备。</p><h6 id="设备控制表（DCT）"><a href="#设备控制表（DCT）" class="headerlink" title="设备控制表（DCT）"></a>设备控制表（DCT）</h6><p>系统为每个设备配置一张 DCT，用于记录设备情况。</p><img src="/blog/2021/02/02/I-O控制（二）/DCT.PNG" style="zoom:80%;"><h6 id="控制器控制表（COCT）"><a href="#控制器控制表（COCT）" class="headerlink" title="控制器控制表（COCT）"></a>控制器控制表（COCT）</h6><p>每个设备控制器都会对应一张 COCT，操作系统根据 COCT 的信息对控制器进行操作和管理。</p><img src="/blog/2021/02/02/I-O控制（二）/COCT.PNG" style="zoom:80%;"><h6 id="通道控制表（CHCT）"><a href="#通道控制表（CHCT）" class="headerlink" title="通道控制表（CHCT）"></a>通道控制表（CHCT）</h6><p>每个通道都会对应一张 CHCT，操作系统根据 CHCT 的信息对通道进行操作和管理。</p><img src="/blog/2021/02/02/I-O控制（二）/CHCT.PNG" style="zoom:80%;"><h6 id="系统设备表（SDT）"><a href="#系统设备表（SDT）" class="headerlink" title="系统设备表（SDT）"></a>系统设备表（SDT）</h6><p>记录了系统中全部设备的情况，每个设备对应一个表目。</p><img src="/blog/2021/02/02/I-O控制（二）/SDT.PNG" style="zoom:80%;"><h5 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h5><ol><li>根据进程请求的逻辑设备名查找 SDT (注：用户变成时提供的逻辑设备名就是“设备类型”)。</li><li>根据 SDT 找到用户进程<strong>指定类型且空闲的设备</strong>，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。</li><li>根据 DCT 找到 COCT，若控制器忙碌则将进程 PCB 挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据 COCT 找到 CHCT ，若通道忙碌则将进程 PCB 挂到通道等待队列中，不忙碌则将通道分配给进<br>程。</li></ol><img src="/blog/2021/02/02/I-O控制（二）/设备分配的步骤.PNG" style="zoom:80%;"><p><strong>逻辑设备表（LUT）</strong></p><p>建立逻辑设备名与物理设备名之间的映射关系。</p><img src="/blog/2021/02/02/I-O控制（二）/LUT.PNG"><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/02/02/I-O控制（二）/设备的分配与回收小结.PNG"><h4 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h4><h5 id="缓冲区概念及作用"><a href="#缓冲区概念及作用" class="headerlink" title="缓冲区概念及作用"></a>缓冲区概念及作用</h5><p>缓冲区：一个存储区域，可以由专门的硬件组成，也可利用内存作为缓冲区，一般使用内存作为缓冲区。</p><p>作用：</p><ol><li>缓和 CPU 与 I/O 设备之间速度不匹配的矛盾。</li><li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制。</li><li>解决数据粒度不匹配的问题（输出进程每次生成一块数据，而 I/O 设备每次只能输出一个字符）。</li><li>提高 CPU 与 I/O 设备之间的并行性。</li></ol><h5 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h5><p>操作系统在主存中为其分配一个缓冲区（一般为一个块）。</p><p><strong>缓冲区写满之后才能读，读空之后才能写</strong>。</p><p>处理一块数据平均耗时：$MAX(C,T) + M$。字符意思如下：</p><img src="/blog/2021/02/02/I-O控制（二）/单缓冲区.PNG" style="zoom:80%;"><h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><p>操作系统在主存中为其分配两个缓冲区。</p><img src="/blog/2021/02/02/I-O控制（二）/双缓冲区.PNG" style="zoom:80%;"><p>处理一块数据平均耗时：$MAX(T,C+M)$。</p><h5 id="使用单-双缓冲在通信时的区别"><a href="#使用单-双缓冲在通信时的区别" class="headerlink" title="使用单/双缓冲在通信时的区别"></a>使用单/双缓冲在通信时的区别</h5><p>单缓冲区同一时间只能单向传输，而双缓冲区同一时刻可以实现双向的数据传输。</p><h5 id="循环缓冲区"><a href="#循环缓冲区" class="headerlink" title="循环缓冲区"></a>循环缓冲区</h5><p>将多个大小相等的缓冲区链接成一个<strong>循环队列</strong>。</p><img src="/blog/2021/02/02/I-O控制（二）/循环缓冲区.PNG" style="zoom:80%;"><h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可分为：空缓冲队列、装满输入数据的缓冲队列（输出队列）、装满输出数据的缓冲队列（输出队列）。</p><img src="/blog/2021/02/02/I-O控制（二）/缓冲池.PNG" style="zoom:80%;"><p>hin：用于收容输入数据的工作缓冲区。</p><p>sin：用于提取收入数据的工作缓冲区。</p><p>hout：用于收容输出数据的工作缓冲区。</p><p>sout：用于提取输出数据的工作缓冲区。</p><img src="/blog/2021/02/02/I-O控制（二）/队列.PNG" style="zoom:80%;"><ol><li>输入进程请求输入数据：</li></ol><img src="/blog/2021/02/02/I-O控制（二）/输入进程请求输入数据.PNG" style="zoom:80%;"><ol start="2"><li>计算进程想要取得一块输入数据：</li></ol><img src="/blog/2021/02/02/I-O控制（二）/计算进程想要取得一块输入数据.PNG" style="zoom:80%;"><ol start="3"><li>计算进程想要将准备好的数据冲入缓冲区：</li></ol><img src="/blog/2021/02/02/I-O控制（二）/计算进程想要将准备好的数据冲入缓冲区.PNG" style="zoom:80%;"><ol start="4"><li>输出进程请求输出数据：</li></ol><img src="/blog/2021/02/02/I-O控制（二）/输出进程请求输出数据.PNG" style="zoom:80%;"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/02/02/I-O控制（二）/缓冲区管理小结.PNG">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;假脱机技术（SPOOLing技术）&lt;/li&gt;
&lt;li&gt;设备的分配与回收&lt;/li&gt;
&lt;li&gt;缓冲区管理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>I/O控制（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/02/I-O%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/02/I-O%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-02T02:30:34.000Z</published>
    <updated>2021-02-02T09:54:08.653Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>I/O设备的基本概念和分类</li><li>I/O控制器</li><li>I/O控制方式</li><li>I/O软件层次结构</li><li>I/O核心子系统</li></ol><a id="more"></a><h4 id="I-O设备的基本概念和分类"><a href="#I-O设备的基本概念和分类" class="headerlink" title="I/O设备的基本概念和分类"></a>I/O设备的基本概念和分类</h4><h5 id="什么是I-O设备？"><a href="#什么是I-O设备？" class="headerlink" title="什么是I/O设备？"></a>什么是I/O设备？</h5><p>I/O设备就是可以将数据输入到计算机，或从计算机接收数据的外部设备，属于计算机中的硬件部件。</p><ul><li><code>write</code> 操作：向外部设备写出数据。</li><li><code>read</code> 操作：从外部设备读入数据。</li></ul><h5 id="I-O设备分类"><a href="#I-O设备分类" class="headerlink" title="I/O设备分类"></a>I/O设备分类</h5><p><strong>按使用特性分类</strong>：</p><ol><li>人机交互类设备</li><li>存储设备</li><li>网络通信设备</li></ol><p><strong>按传输速率分类</strong>：</p><ol><li>低速设备</li><li>中速设备</li><li>高速设备</li></ol><p><strong>按信息交换的单位分类</strong>：</p><ol><li>块设备（传输快，可寻址）</li><li>字符设备（传输慢，不可寻址，常采用中断驱动方式）</li></ol><h4 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I/O控制器"></a>I/O控制器</h4><p>I/O设备由<strong>机械设备</strong>和<strong>电子设备</strong>构成。</p><p><strong>机械部件</strong>：执行具体的 I/O 操作，如鼠标键盘等。</p><p><strong>电子部件</strong>：插入主板扩充槽的印刷电路板。</p><hr><p>电子部件（I/O控制器）</p><p>I/O 控制器是 CPU 和 I/O 设备机械部件之间的<strong>桥梁</strong>。CPU 可控制 I/O 控制器，再由 I/O 控制器来控制设备的机械部件。</p><hr><h5 id="I-O控制器的功能"><a href="#I-O控制器的功能" class="headerlink" title="I/O控制器的功能"></a>I/O控制器的功能</h5><ol><li>接受和识别 CPU 发出的命令（I/O 控制器中的<strong>控制寄存器</strong>存放命令和参数）。</li><li>向 CPU 报告设备的状态（I/O 控制器中的<strong>状态寄存器</strong>记录 I/O 设备的当前状态）。</li><li>数据交换（I/O 控制器中的 <strong>数据寄存器</strong>，作为 CPU 与设备数据交换的桥梁）。</li><li>地址识别（I/O 控制器通过 CPU 提供的地址来判断 CPU 读写哪个寄存器）。</li></ol><h5 id="I-O控制器的组成"><a href="#I-O控制器的组成" class="headerlink" title="I/O控制器的组成"></a>I/O控制器的组成</h5><img src="/blog/2021/02/02/I-O控制（一）/I-O控制器的组成.png" style="zoom: 67%;"><p>上述寄存器如果地址占用内存地址的一部分，称为<strong>内存映像 I/O</strong> ；如果采用 I/O 专用地址，称为<strong>寄存器独立编址</strong>。</p><p>两者区别如下：</p><img src="/blog/2021/02/02/I-O控制（一）/内存映像与寄存器独立编址.png" style="zoom: 67%;"><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/02/02/I-O控制（一）/I-O控制器小结.png"><h4 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h4><h5 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h5><img src="/blog/2021/02/02/I-O控制（一）/程序直接控制方式.png" style="zoom: 67%;"><ol><li>CPU 干预的频率高，等待 I/O 的过程中一直轮询检查。</li><li>每次读写一个<strong>字</strong>。</li><li>数据流向：<ol><li>数据输入： I/O 设备 -&gt; CPU -&gt; 内存</li><li>数据输出： 内存 -&gt; CPU -&gt;  I/O 设备</li></ol></li><li>优点：实现简单。</li><li>缺点：CPU 和 I/O设备只能串行工作，CPU 长期处于<strong>忙等</strong>状态，利用率低。</li></ol><h5 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h5><img src="/blog/2021/02/02/I-O控制（一）/中断驱动方式.png"><ol><li><p>I/O 操作开始前、完成后需要 CPU 介入。</p></li><li><p>每次读写一个<strong>字</strong>。</p></li><li><p>数据流向：</p><ol><li>数据输入： I/O 设备 -&gt; CPU -&gt; 内存</li><li>数据输出： 内存 -&gt; CPU -&gt;  I/O 设备</li></ol></li><li><p>优点：CPU 和 I/O 设备可并行工作。</p></li><li><p>缺点：每个字传输时，都需要中断，频繁中断消耗较多的 CPU 时间。</p></li></ol><h5 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h5><p>DMA（Direct Memory Access，直接存储器存取），主要用于<strong>块设备</strong> I/O 控制，<strong>不需要经过 CPU</strong>。</p><img src="/blog/2021/02/02/I-O控制（一）/DMA方式.png" style="zoom:80%;"><p><strong>DMA控制器</strong></p><img src="/blog/2021/02/02/I-O控制（一）/DMA控制器.PNG" style="zoom:80%;"><p>DR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据，<strong>也是一个字一个字的存入</strong>。<br>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR 表示数据应放到内存中的什么位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。<br>DC（Data Counter，数据计数器）：表示剩余要读/写的字节数。<br>CR（Command Register，命令/状态寄存器）：用于存放 CPU 发来的 I/O 命令，或设备的状态信息。</p><ol><li><p>仅在传送开始或结束时，才需要 CPU 干预。</p></li><li><p>每次读写<strong>一个或多个块（必须连续）</strong>。</p></li><li><p>数据流向：</p><ol><li>数据输入： I/O 设备  -&gt; 内存</li><li>数据输出： 内存 -&gt;  I/O 设备</li></ol></li><li><p>优点：数据传输以<strong>块</strong>为单位，且 CPU 接入频率进一步降低，进一步提高了 CPU 和 I/O 设备的并行性。</p></li><li><p>缺点：只能读写一个或多个连续的数据块。如果数据块离散，CPU 需发出多次 I/O 指令。</p></li></ol><h5 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h5><p>通道：一种硬件，可以理解为<strong>弱化版的 CPU</strong>，可以识别并执行一系列的通道指令，通道执行的指令很单一，与 CPU 共享内存。</p><img src="/blog/2021/02/02/I-O控制（一）/通道.PNG" style="zoom:80%;"><ol><li><p>CPU 干预频率极低，通道完成一组数据块的读写后才发出中断信号。</p></li><li><p>每次读写<strong>一组数据块</strong>。</p></li><li><p>数据流向：</p><ol><li>数据输入： I/O 设备  -&gt; 内存</li><li>数据输出： 内存 -&gt;  I/O 设备</li></ol></li><li><p>优点：CPU、通道、I/O 设备并行工作，资源利用率高。</p></li><li><p>缺点：实现复杂，，需要专门的通道硬件支持。</p></li></ol><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/02/02/I-O控制（一）/I-O控制方式.PNG" style="zoom: 67%;"><h4 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I/O软件层次结构"></a>I/O软件层次结构</h4><img src="/blog/2021/02/02/I-O控制（一）/I-O软件层次结构.PNG" style="zoom: 80%;"><h5 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h5><p>实现与用户交互的接口，用户可直接使用该层提供的，与 I/O 操作相关的库函数对设备进行操作。用户层软件将用户请求翻译为格式化的 I/O 请求，通过<strong>系统调用</strong>请求操作系统内核的服务。</p><h5 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h5><p>又称设备无关性软件，与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>主要实现的功能：</p><ol><li>向上层提供统一的调用接口。</li><li>设备的保护。设备被看作是一种特殊的文件，不同用户的访问权限不同。</li><li>差错处理。</li><li>设备的分配与回收。</li><li>数据缓冲区管理。</li><li>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序。</li></ol><p>设备独立性软件需要通过<strong>逻辑设备表（LUT， Logical Unit Table）</strong>来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。有两种方式：①整个系统只设置一张 LUT，只适合单用户操作系统；②为每个用户设置一张 LUT。</p><p><strong>不同设备需要不同设备驱动程序的原因</strong>？</p><p>答：不同设备有不同的硬件特性，具体细节只有厂家知道。驱动程序一般会以一个独立进程的方式存在。</p><h5 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h5><img src="/blog/2021/02/02/I-O控制（一）/中断处理程序.png" style="zoom:80%;"><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>中断处理程序和设备驱动程序会和硬件打交道。</p><h4 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I/O核心子系统"></a>I/O核心子系统</h4><p> I/O 核心子系统要实现的功能就是中间三层要实现的功能，主要有： I/O 调度、设备保护、设备分配与回收、缓冲区管理，还有假脱机技术（SPOOLing技术），<strong>其中假脱机技术是在用户层软件实现的</strong>。</p><h5 id="I-O调度"><a href="#I-O调度" class="headerlink" title="I/O调度"></a>I/O调度</h5><p>用某种算法确定一个好的顺序来处理各个 I/O 请求。</p><p>如磁盘调度：先来先服务算法、最短寻道优先算法等确定 I/O 请求的顺序。</p><p>同理，打印机等设备也可以用先来先服务、优先级算法等确定 I/O 请求的顺序。</p><h5 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h5><p>不同用户对各个文件拥有不同的访问权限。可参考<strong>文件保护</strong>小节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;I/O设备的基本概念和分类&lt;/li&gt;
&lt;li&gt;I/O控制器&lt;/li&gt;
&lt;li&gt;I/O控制方式&lt;/li&gt;
&lt;li&gt;I/O软件层次结构&lt;/li&gt;
&lt;li&gt;I/O核心子系统&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode839-相似字符串组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/31/LeetCode839-%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/31/LeetCode839-%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/</id>
    <published>2021-01-31T08:09:50.000Z</published>
    <updated>2021-01-31T08:31:40.990Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>如果交换字符串 <code>X</code> 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p><p>例如，<code>&quot;tars&quot;</code> 和 <code>&quot;rats&quot;</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)； <code>&quot;rats&quot;</code> 和 <code>&quot;arts&quot;</code> 也是相似的，但是 <code>&quot;star&quot;</code> 不与 <code>&quot;tars&quot;</code>，<code>&quot;rats&quot;</code>，或 <code>&quot;arts&quot;</code> 相似。</p><p>总之，它们通过相似性形成了两个关联组：<code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> 和 <code>{&quot;star&quot;}</code>。注意，<code>&quot;tars&quot;</code> 和 <code>&quot;arts&quot;</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p><p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p><a id="more"></a><img src="/blog/2021/01/31/LeetCode839-相似字符串组/839.png"><p><strong>备注：</strong></p><p>​    字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题如果理解了题目的意思，就不难。</p><p><strong>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词</strong>。再结合备注可知：所有的字符串都是由<strong>相同的字母</strong>组成，无非就是字母顺序不一样罢了。</p><p>题目要求<strong>相似</strong>的字符串为一组，何为相似？有两种情况：</p><ol><li>两个字符串相同。</li><li>其中一个字符串交换一对字母后与另一字符串相同。</li></ol><p><strong>如何操作</strong>？</p><p>使用一个变量统计两个字符串对应位置字母不相同的个数。如果计数等于 0 或者 2，说明这两个字符串是相似的，使用并查集进行合并即可。</p><p>返回合并后的连通集数就是最终答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>暴力遍历即可。35% 99%</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        parent[pRoot] = qRoot;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = strs.size();</span><br><span class="line">        <span class="keyword">int</span> len = strs[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[i][k] != strs[j][k])</span><br><span class="line">                        cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对比完一个后，如果只有两个字母不同，说明在同一个分组里面</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">2</span> || cnt == <span class="number">0</span>) uf.unionElem(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;如果交换字符串 &lt;code&gt;X&lt;/code&gt; 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;&amp;quot;tars&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;rats&amp;quot;&lt;/code&gt; 是相似的 (交换 &lt;code&gt;0&lt;/code&gt; 与 &lt;code&gt;2&lt;/code&gt; 的位置)； &lt;code&gt;&amp;quot;rats&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;arts&amp;quot;&lt;/code&gt; 也是相似的，但是 &lt;code&gt;&amp;quot;star&amp;quot;&lt;/code&gt; 不与 &lt;code&gt;&amp;quot;tars&amp;quot;&lt;/code&gt;，&lt;code&gt;&amp;quot;rats&amp;quot;&lt;/code&gt;，或 &lt;code&gt;&amp;quot;arts&amp;quot;&lt;/code&gt; 相似。&lt;/p&gt;
&lt;p&gt;总之，它们通过相似性形成了两个关联组：&lt;code&gt;{&amp;quot;tars&amp;quot;, &amp;quot;rats&amp;quot;, &amp;quot;arts&amp;quot;}&lt;/code&gt; 和 &lt;code&gt;{&amp;quot;star&amp;quot;}&lt;/code&gt;。注意，&lt;code&gt;&amp;quot;tars&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;arts&amp;quot;&lt;/code&gt; 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。&lt;/p&gt;
&lt;p&gt;给你一个字符串列表 &lt;code&gt;strs&lt;/code&gt;。列表中的每个字符串都是 &lt;code&gt;strs&lt;/code&gt; 中其它所有字符串的一个字母异位词。请问 &lt;code&gt;strs&lt;/code&gt; 中有多少个相似字符串组？&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode778-水位上升的游泳池中游泳</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/30/LeetCode778-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%B8%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/30/LeetCode778-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%B8%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/</id>
    <published>2021-01-30T09:10:41.000Z</published>
    <updated>2021-02-02T14:14:59.442Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个 N x N 的坐标方格 <code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示在位置 <code>(i,j)</code> 的平台高度。</p><p>现在开始下雨了。当时间为 <code>t</code> 时，此时雨水导致水池中任意位置的水位为 <code>t</code> 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p><p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 <code>(N-1, N-1)</code>？</p><p>本题与<a href>LeetCode1631-最小体力消耗路径</a>基本一致。</p><a id="more"></a><img src="/blog/2021/01/30/LeetCode778-水位上升的游泳池中游泳/778.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将本题抽象为一个图论模型：</p><ul><li>将每个位置抽象为一个节点，共有 <code>n * n</code> 个节点。</li><li>每个节点与其上下左右构成带权无向图（存在此节点的话）。</li><li>当存在一条从左上角到右下角的路径时，所需要的最小时间 T。</li></ul><p>设置一个时间阈值 t，如果存在一条路径可以由左上角到右下角，那么可以继续缩短时间 t。直到找到最短的时间。本题高度范围是 <code>[0, N*N - 1]</code>，从 0 到 N*N - 1 设置阈值，进行二分搜索。</p><ul><li>如果当前高度大于 t，说明此路不通，需要跳过。</li><li>当前高度小于等于 t，并且其四个方向也存在小于等于 t 的高度，才可以继续搜索。</li></ul><p><strong>对于图论的最短路径问题，考虑使用广度优先搜索（BFS）</strong>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            q.emplace(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n * n, <span class="number">0</span>)</span></span>;</span><br><span class="line">            vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(grid[x][y] &gt; mid) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">                    <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !vis[nx * n + ny] &amp;&amp; grid[nx][ny] &lt;= mid)&#123;</span><br><span class="line">                        vis[nx * n + ny] = <span class="literal">true</span>;</span><br><span class="line">                        q.emplace(nx, ny);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(vis[n * n - <span class="number">1</span>])&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一个 N x N 的坐标方格 &lt;code&gt;grid&lt;/code&gt; 中，每一个方格的值 &lt;code&gt;grid[i][j]&lt;/code&gt; 表示在位置 &lt;code&gt;(i,j)&lt;/code&gt; 的平台高度。&lt;/p&gt;
&lt;p&gt;现在开始下雨了。当时间为 &lt;code&gt;t&lt;/code&gt; 时，此时雨水导致水池中任意位置的水位为 &lt;code&gt;t&lt;/code&gt; 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。&lt;/p&gt;
&lt;p&gt;你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 &lt;code&gt;(N-1, N-1)&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;本题与&lt;a href&gt;LeetCode1631-最小体力消耗路径&lt;/a&gt;基本一致。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="BFS" scheme="http://www.xingyuzhao.ltd/tags/BFS/"/>
    
      <category term="二分法" scheme="http://www.xingyuzhao.ltd/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1631-最小体力消耗路径</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/29/LeetCode1631-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/29/LeetCode1631-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/</id>
    <published>2021-01-29T15:32:37.000Z</published>
    <updated>2021-01-30T09:33:49.875Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p><p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p><p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p><a id="more"></a><img src="/blog/2021/01/29/LeetCode1631-最小体力消耗路径/1631.png"><img src="/blog/2021/01/29/LeetCode1631-最小体力消耗路径/1631-提示.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将本题抽象为一个图论模型：</p><ul><li>将每个位置抽象为一个节点，共有 <code>m * n</code> 个节点。</li><li>每个节点与其上下左右构成带权无向图（存在此节点的话），其权值为节点间高度差的绝对值。</li><li>寻找一条从左上角到右下角的最短路径，一条路径的长度定义为所有边权的最大值。</li></ul><p>我们可以设置一个阈值 x，看是否存在一条路径，从左上角到右下角所累加的权值小于等于 x；如果小于等于 x，说明可能存在更小的阈值，使路径存在，并进一步缩小阈值范围。</p><p>本题高度差范围是 <code>[1,1000000]</code>，从 0 到 999999 设置阈值，进行二分搜索。</p><p><strong>对于图论的最短路径问题，考虑使用广度优先搜索（BFS）</strong>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = heights.size(); </span><br><span class="line">        <span class="keyword">int</span> n = heights[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1000000</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(m * n, <span class="number">0</span>)</span></span>;</span><br><span class="line">            vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">                    <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; heights.size() &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; heights[<span class="number">0</span>].size() &amp;&amp; !vis[nx * n + ny] &amp;&amp; <span class="built_in">abs</span>(heights[nx][ny] - heights[x][y]) &lt;= mid)&#123;</span><br><span class="line">                        vis[nx * n + ny] = <span class="literal">true</span>;</span><br><span class="line">                        q.emplace(nx, ny);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(vis[m * n - <span class="number">1</span>])&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;你准备参加一场远足活动。给你一个二维 &lt;code&gt;rows x columns&lt;/code&gt; 的地图 &lt;code&gt;heights&lt;/code&gt; ，其中 &lt;code&gt;heights[row][col]&lt;/code&gt; 表示格子 &lt;code&gt;(row, col)&lt;/code&gt; 的高度。一开始你在最左上角的格子 &lt;code&gt;(0, 0)&lt;/code&gt; ，且你希望去最右下角的格子 &lt;code&gt;(rows-1, columns-1)&lt;/code&gt; （注意下标从 &lt;strong&gt;0&lt;/strong&gt; 开始编号）。你每次可以往 &lt;strong&gt;上&lt;/strong&gt;，&lt;strong&gt;下&lt;/strong&gt;，&lt;strong&gt;左&lt;/strong&gt;，&lt;strong&gt;右&lt;/strong&gt; 四个方向之一移动，你想要找到耗费 &lt;strong&gt;体力&lt;/strong&gt; 最小的一条路径。&lt;/p&gt;
&lt;p&gt;一条路径耗费的 &lt;strong&gt;体力值&lt;/strong&gt; 是路径上相邻格子之间 &lt;strong&gt;高度差绝对值&lt;/strong&gt; 的 &lt;strong&gt;最大值&lt;/strong&gt; 决定的。&lt;/p&gt;
&lt;p&gt;请你返回从左上角走到右下角的最小 &lt;strong&gt;体力消耗值&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="BFS" scheme="http://www.xingyuzhao.ltd/tags/BFS/"/>
    
      <category term="二分法" scheme="http://www.xingyuzhao.ltd/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>文件管理（四）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2021-01-28T13:15:44.000Z</published>
    <updated>2021-02-01T03:42:32.483Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>磁盘的结构</li><li>磁盘调度算法</li><li>减少磁盘延迟时间的方法</li><li>磁盘的管理</li></ol><a id="more"></a><h4 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h4><h5 id="磁盘、磁道、扇区"><a href="#磁盘、磁道、扇区" class="headerlink" title="磁盘、磁道、扇区"></a>磁盘、磁道、扇区</h5><p>磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。</p><p>磁道与扇区：</p><img src="/blog/2021/01/28/文件管理（四）/磁道与扇区.png" style="zoom:80%;"><h5 id="如何在磁盘中读-写数据"><a href="#如何在磁盘中读-写数据" class="headerlink" title="如何在磁盘中读/写数据"></a>如何在磁盘中读/写数据</h5><p>将<strong>磁头</strong>移动到想要读/写扇区所在的磁道，磁盘转动，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。</p><h5 id="盘面、柱面"><a href="#盘面、柱面" class="headerlink" title="盘面、柱面"></a>盘面、柱面</h5><img src="/blog/2021/01/28/文件管理（四）/盘面、柱面.png" style="zoom:80%;"><h5 id="磁盘的物理地址"><a href="#磁盘的物理地址" class="headerlink" title="磁盘的物理地址"></a>磁盘的物理地址</h5><p>地址形式：（柱面号，盘面号，扇区号）。</p><p><strong>如何读写？</strong></p><ol><li>根据柱面号移动磁臂，让磁头指向指定柱面。</li><li>激活指定盘面对应的磁头。</li><li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，完成读写。</li></ol><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/28/文件管理（四）/磁盘的结构小结.png"><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><h5 id="一次磁盘读写操作需要的时间"><a href="#一次磁盘读写操作需要的时间" class="headerlink" title="一次磁盘读写操作需要的时间"></a>一次磁盘读写操作需要的时间</h5><p><strong>寻道时间</strong> $T_s$：在读写数据前，将磁头移动到指定磁道所花的时间。<br>$$<br>T_s = s + m\times n<br>$$<br>其中，$s$ 为启动磁头臂时间；$m$ 为跨越一个磁道耗时；$n$ 为跨越磁道总数。</p><p><strong>延迟时间</strong> $T_R$：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。<br>$$<br>T_R = \frac{1}{2} \times \frac{1}{r} = \frac{1}{2r}<br>$$<br>其中，$\frac{1}{2}$ 为平均找到目标扇区所走的圈数；$r$ 为磁盘转速。</p><p><strong>传输时间</strong> $T_t$：从磁盘读写数据所需时间。<br>$$<br>T_t = \frac{1}{r} \times \frac{b}{N} = \frac{b}{rN}<br>$$<br>其中，$r$ 为磁盘转速；$b$ 为此次读写的字节数；$N$ 为每个磁道上的字节数。</p><p><strong>后两个是磁盘固有时间消耗，无法优化</strong>。总消耗时间 $T_a$ 如下：<br>$$<br>T_a = T_s + \frac{1}{2r} + \frac{b}{rN}<br>$$<br><strong>消耗时间的优化主要从寻道时间入手</strong>。</p><h5 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h5><p>根据进程请求访问磁盘的先后顺序进行调度。</p><ul><li>优点：公平；如果请求访问的磁道比较集中，性能还行。</li><li>缺点：如果大量进程竞争使用磁盘且较分散，性能差，寻到时间长，</li></ul><h5 id="最短寻找时间优先（SSTF）"><a href="#最短寻找时间优先（SSTF）" class="headerlink" title="最短寻找时间优先（SSTF）"></a>最短寻找时间优先（SSTF）</h5><p>此算法优先处理与当前磁头最近的磁道。可保证每次的寻道时间最短，但不保证总寻道时间最短。</p><ul><li>优点：性能较好，平均寻道时间短。</li><li>缺点：可能产生<strong>饥饿</strong>现象。</li></ul><h5 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h5><p>在 SSTF 算法的基础上规定：只有磁头移动到嘴最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动，也叫电梯算法。</p><ul><li>优点：性能较好，平均寻道时间短，不会产生饥饿现象。</li><li>缺点：①只有到最边上才会改变磁头方向；②各个位置磁道的响应频率不平均，靠边的响应频率更高一些。</li></ul><h5 id="LOOK-调度算法"><a href="#LOOK-调度算法" class="headerlink" title="LOOK 调度算法"></a>LOOK 调度算法</h5><p><strong>为解决 SCAN 缺点①。</strong></p><p>在 SCAN 算法的基础上规定：如果在磁头移动的方向上已经没有别的请求，就可以立即改变磁头移动方向。</p><ul><li>优点：较 SCAN 算法寻道时间进一步缩短。</li></ul><h5 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h5><p><strong>为解决 SCAN 缺点②。</strong></p><p>在 SCAN 算法的基础上规定：只有朝某个方向移动磁头时才处理磁道访问请求，返回时直接移动至起始端。</p><ul><li>优点：磁道响应平均。</li><li>缺点：到最边上才改变磁头方向。</li></ul><h5 id="C-LOOK-调度算法"><a href="#C-LOOK-调度算法" class="headerlink" title="C-LOOK 调度算法"></a>C-LOOK 调度算法</h5><p>在 C-SCAN 算法的基础上规定：如果磁头移动的方向上已经没有磁道访问请求了，可以让磁头立即返回有磁道访问请求的位置。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/28/文件管理（四）/磁盘调度算法小结.png"><h4 id="减少延迟时间的方法"><a href="#减少延迟时间的方法" class="headerlink" title="减少延迟时间的方法"></a>减少延迟时间的方法</h4><p>磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，需要较长延迟时间。</p><h5 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h5><p>让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p><img src="/blog/2021/01/28/文件管理（四）/交替编号.png" style="zoom:80%;"><h5 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h5><p>相邻盘面的扇区编号错位。</p><img src="/blog/2021/01/28/文件管理（四）/错位命名.png" style="zoom:80%;"><h5 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h5><p>为什么磁盘的物理地址是 （柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？</p><p>答：读取地址连续的磁盘块时，采用前者可以减少磁头移动消耗的时间。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><img src="/blog/2021/01/28/文件管理（四）/减少延迟时间的方法.png"><h4 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h4><h5 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h5><ol><li>低级初始化（物理格式化）：将磁盘的各个磁道划分为扇区。一个扇区分为 头、数据区域（如512B大小）、尾 三个部分。</li><li>将磁盘分区，每个分区由若干<strong>柱面</strong>组成（C、D、E盘等）。</li><li>逻辑格式化，创建文件系统。创建文件根目录，初始化存储空间管理所用的数据结构，如位示图、空闲分区表等。</li></ol><h5 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h5><p>计算机开机时需要初始化，通过执行<strong>初始化程序（自举程序）</strong>完成。</p><img src="/blog/2021/01/28/文件管理（四）/自举程序.png" style="zoom:80%;"><p>完整的自举程序放在磁盘的启动块（引导块/启动分区）上，启动块位于磁盘的固定位置，拥有启动分区的磁盘称为启动磁盘或系统磁盘（C盘）。</p><h5 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h5><p>简单磁盘可以在<strong>逻辑格式化</strong>时，对磁盘进行坏块检查，标明坏扇区，如：在 FAT 表上标明，坏块对操作系统不透明。</p><p>复杂磁盘会有一个<strong>磁盘控制器</strong>（磁盘中的一个硬件）来维护坏块链表。同时会保留一些“备用扇区”，用于替换坏块。此种方式坏块对操作系统透明。</p><h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/28/文件管理（四）/磁盘的管理.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;磁盘的结构&lt;/li&gt;
&lt;li&gt;磁盘调度算法&lt;/li&gt;
&lt;li&gt;减少磁盘延迟时间的方法&lt;/li&gt;
&lt;li&gt;磁盘的管理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="磁盘" scheme="http://www.xingyuzhao.ltd/tags/%E7%A3%81%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>文件管理（三）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/28/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-01-28T13:15:32.000Z</published>
    <updated>2021-01-28T15:36:54.028Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>文件的基本操作</li><li>文件共享</li><li>文件保护</li><li>文件系统的层次结构</li></ol><a id="more"></a><h4 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h4><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><p>使用 <strong>create</strong> 系统调用，需要提供几个主要参数：</p><ol><li>所需的外存空间大小。</li><li>文件存放路径。</li><li>文件名。</li></ol><p>操作系统在处理 <strong>create</strong> 系统调用时，主要做了两件事：</p><ol><li>在外存中找到文件所需的空间（空闲链表法等）。</li><li>根据文件存放路径信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。</li></ol><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><p>使用 <strong>delete</strong> 系统调用，需要提供几个主要参数：</p><ol><li>文件存放路径。</li><li>文件名。</li></ol><p>操作系统在处理 <strong>delete</strong> 系统调用时，主要做了三件事：</p><ol><li>从目录中找到文件名对应的目录项。</li><li>根据目录项记录的文件信息，回收文件占用的磁盘块。</li><li>从目录表中删除文件对应的目录项。</li></ol><h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><p>使用 <strong>open</strong> 系统调用，需要提供几个主要参数：</p><ol><li>文件存放路径。</li><li>文件名。</li><li>要对文件的操作类型（如：r 只读；rw 读写等）。</li></ol><p>操作系统在处理 <strong>open</strong> 系统调用时，主要做了两件事：</p><ol><li>从目录中找到文件名对应的目录项，并检查该用户是否有指定的操作权限。</li><li>将目录项复制到内存中的<strong>打开文件表</strong>中。并返回对应的编号返回。之后用户使用打开文件表的编号来知名要操作的文件。这样做可以加快文件的访问速度。</li></ol><h5 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h5><p>进程使用完文件后，要关闭文件，操作系统在处理 <strong>close</strong> 系统调用时，需要做以下三件事：</p><ol><li>将<strong>用户进程的打开文件表</strong>相应表项删除。</li><li>回收分配给该文件的内存空间等资源。</li><li><strong>系统打开文件表（整个系统只有一张）</strong>的打开计数器 count 减一，若 count = 0，则删除对应表项。</li></ol><h5 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h5><p>使用 <strong>read</strong> 系统调用，需要提供几个主要参数：</p><ol><li>指明是哪个文件。</li><li>指明要读入多少数据。</li><li>指明读入的数据放在内存何处。</li></ol><p>操作系统从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><p>使用 <strong>write</strong> 系统调用，需要提供几个主要参数：</p><ol><li>指明是哪个文件。</li><li>指明要写出多少数据。</li><li>写回外存的数据放在内存中的什么位置。</li></ol><p>操作系统从用户指定的内存区域中，将指定大小的数据写回指针指向的外存。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/28/文件管理（三）/文件基本操作小结.png"><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>操作系统提供给用户文件共享功能，可以让多个用户共享的使用同一个文件。</p><h5 id="基于索引结点的共享方式（硬链接）"><a href="#基于索引结点的共享方式（硬链接）" class="headerlink" title="基于索引结点的共享方式（硬链接）"></a>基于索引结点的共享方式（硬链接）</h5><p>由于检索时只需用到文件名，所以将除了文件名之外的其他信息放到索引结点中，目录项仅包含文件名和索引结点指针。</p><img src="/blog/2021/01/28/文件管理（三）/索引结点.png" style="zoom:80%;"><p>count 记录链接到本索引结点上的用户目录项数，当 count = 0 时，系统删除该文件。</p><h5 id="基于符合链的共享方式（软链接）"><a href="#基于符合链的共享方式（软链接）" class="headerlink" title="基于符合链的共享方式（软链接）"></a>基于符合链的共享方式（软链接）</h5><p>使用 <strong>link</strong> 类型文件，记录<strong>文件的路径</strong>。</p><img src="/blog/2021/01/28/文件管理（三）/符号链.png" style="zoom:80%;"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/28/文件管理（三）/文件共享小结.png" style="zoom:80%;"><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><p>保护文件数据的安全。</p><h5 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h5><p>为文件设置一个口令，用户请求访问该文件时必须提供口令。</p><ul><li>优点：保存口令的空间开销不多，验证口令的时间开销小。</li><li>缺点：正确的口令存放在系统内部，不够安全。</li></ul><h5 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h5><p>使用某个密码对文件进行加密，访问文件时需提供正确密码。例如：异或加密。</p><ul><li>优点：保密性强，不需要在系统中存储密码。</li><li>缺点：编/解码，加/解密需要花费一定时间。</li></ul><h5 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h5><p>在每个文件的 FCB 中增加一个<strong>访问控制列表（Access-Control List, ACL）</strong>，该表记录各个用户可以对该文件进行的操作。</p><img src="/blog/2021/01/28/文件管理（三）/访问控制.png" style="zoom:80%;"><p>精简访问列表：可将用户以<strong>组</strong>为单位，来管理用户可以进行哪些操作。</p><img src="/blog/2021/01/28/文件管理（三）/精简访问列表.png" style="zoom:80%;"><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/28/文件管理（三）/文件保护小结.png" style="zoom:80%;"><h4 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h4><img src="/blog/2021/01/28/文件管理（三）/文件系统的层次结构.png"><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><p>某用户请求删除文件 <code>test.txt</code> ：</p><ol><li>用户通过操作系统提供的接口发出删除请求——<strong>用户接口</strong>。</li><li>用户提供的是文件存放路径，操作系统需查找目录，找到目录项——<strong>文件目录系统</strong>。</li><li>不同用户的操作权限不同，需要检查用户的权限——<strong>存取控制模块（存取控制验证层）</strong>。</li><li>验证权限后，操作系统将用户提供的<strong>记录号</strong>转变为对应的逻辑地址——<strong>逻辑文件系统与文件信息缓冲区</strong>。</li><li>将逻辑地址转换为物理地址——<strong>物理文件系统</strong>。</li><li>要删除这条记录，需要对磁盘设备发出请求——<strong>设备管理程序模块</strong>。</li><li>删除后，会有一些磁盘空闲，因此需要将其回收——<strong>辅助分配模块</strong>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;文件的基本操作&lt;/li&gt;
&lt;li&gt;文件共享&lt;/li&gt;
&lt;li&gt;文件保护&lt;/li&gt;
&lt;li&gt;文件系统的层次结构&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="文件共享" scheme="http://www.xingyuzhao.ltd/tags/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    
      <category term="文件保护" scheme="http://www.xingyuzhao.ltd/tags/%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1579-保证图可完全遍历</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/27/LeetCode1579-%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/27/LeetCode1579-%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/</id>
    <published>2021-01-27T14:21:51.000Z</published>
    <updated>2021-01-27T15:12:51.758Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边：</p><ul><li>类型 1：只能由 Alice 遍历。</li><li>类型 2：只能由 Bob 遍历。</li><li>类型 3：Alice 和 Bob 都可以遍历。</li></ul><p>给你一个数组 $edges$ ，其中 $edges[i] = [type_i, u_i, v_i]$ 表示节点 $u_i$ 和 $v_i$ 之间存在类型为 $type_i$ 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p><p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1。</p><a id="more"></a><img src="/blog/2021/01/27/LeetCode1579-保证图可完全遍历/1567.png" style="zoom:120%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题和<a href="http://www.xingyuzhao.ltd/blog/2021/01/23/LeetCode1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/#more">LeetCode1319-连通网络的操作次数</a>很相似，可以说是1319的加强版。这道题需要给两位主角分别建立一个并查集，并且要解决下面三个问题：</p><p><strong>1. 如何判断边重复？</strong></p><p>在进行 <code>union</code> 操作前后，如果 <code>count</code> 变化（减一），代表进行了合并；否则，说明此边重复，可以删掉。</p><p><strong>2. 什么是公共边？</strong></p><p>对于此题来说，$type$ 为 3 的边既可以被 Alice 遍历，也可以被 Bob 遍历。所以此种类型的边就是公共边。</p><p><strong>3. 如何处理公共边？</strong></p><p>这是本题的重点，对 Alice 和 Bob 分别根据公共边进行合并。</p><ul><li>如果先对 Alice 根据公共边合并，当发现边重复时，就需要删掉此边，不会对节点之间的连通性造成任何影响。</li><li>再对 Bob 根据公共边合并时，就不需要删边了，因为上一步已经删去了重复公共边，不需要再一次删除了。两者的联通集是一致的。</li></ul><p>总而言之，<strong>公共边只能删除一次。</strong></p><p>经历上述操作后，再分别对两个人按照自己可以遍历的类型进行合并，同样遇到了重复边可以删掉。将重复公共边总数和非公共边重复总数求和，就是最终结果了。</p><p>当然，如果合并结束后，两个并查集中有一个或多个不止一个联通集，说明无法全部遍历，返回 -1。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>顺序可能不太一致，但不影响最终结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumEdgesToRemove</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">unionFind <span class="title">Alice</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">unionFind <span class="title">Bob</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Alice</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> type = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(type != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> count = Alice.getCount();</span><br><span class="line">            Alice.unionElem(u - <span class="number">1</span>, v - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(Alice.getCount() == count)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> type = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(type != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> count = Alice.getCount();</span><br><span class="line">            Alice.unionElem(u - <span class="number">1</span>, v - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(Alice.getCount() == count)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Bob</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> type = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(type != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Bob.unionElem(u - <span class="number">1</span>, v - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> type = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(type != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> count = Bob.getCount();</span><br><span class="line">            Bob.unionElem(u - <span class="number">1</span>, v - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(Bob.getCount() == count)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Alice.getCount() == <span class="number">1</span> &amp;&amp; Bob.getCount() == <span class="number">1</span> ? cnt : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型 1：只能由 Alice 遍历。&lt;/li&gt;
&lt;li&gt;类型 2：只能由 Bob 遍历。&lt;/li&gt;
&lt;li&gt;类型 3：Alice 和 Bob 都可以遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给你一个数组 $edges$ ，其中 $edges[i] = [type_i, u_i, v_i]$ 表示节点 $u_i$ 和 $v_i$ 之间存在类型为 $type_i$ 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。&lt;/p&gt;
&lt;p&gt;返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode959-由斜杠划分区域</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/25/LeetCode959-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/25/LeetCode959-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/</id>
    <published>2021-01-25T06:53:07.000Z</published>
    <updated>2021-01-26T12:47:31.099Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在由 1 x 1 方格组成的 N x N 网格 <code>grid</code> 中，每个 1 x 1 方块由 <code>/</code>、<code>\</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p><p>（请注意，反斜杠字符是转义的，因此 <code>\</code> 用 <code>&quot;\\&quot;</code> 表示。）。</p><p>返回区域的数目。</p><a id="more"></a><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>输入 <code>grid</code> 的长度 <code>n</code> 就是网格的<strong>边长</strong>。比如示例中 <code>grid</code> 的长度为2，那么就是对 $2\times2$ 的网格中的每一小格，通过字符确定如何划分这一小格。</p><p>将一个小格分为<strong>4</strong>个部分，分别为 <code>0,1,2,3</code>，如下：</p><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_1.png"><ul><li><p>如果输入字符为 <code>&quot;/&quot;</code> ，则将 <code>0-1</code> 与 <code>3-2</code> 分别连接。</p></li><li><p>如果输入字符为 <code>&quot;\\&quot;</code> ，则将 <code>0-3</code> 与 <code>1-2</code> 分别连接。</p></li><li><p>如果输入字符为 <code> &quot; &quot;</code>，则将 <code>0-1-2-3</code> 全部连接。</p></li></ul><p>左右相邻的两个小格需要将左边的 <code>1</code> 与右边的 <code>3</code> 相连：</p><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_2.png" style="zoom:80%;"><p>上下相邻的两个小格需要将上面的 <code>2</code>  与下边的 <code>0</code> 相连：</p><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_3.png"><p>除了第一行和第一列，其他的行和列都需要考虑上述两种相邻的情况。</p><p>合并结束后，连通集的个数就是区域的数目。</p><p>以示例4为例：</p><ul><li>仅对于每个字符合并：</li></ul><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_4.png"><ul><li>对行和列相邻的小格进行合并：</li></ul><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_5.png"><p>如上图所示，区域一共有5个。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">genCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">regionsBySlashes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(<span class="number">4</span> * n * n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> start = <span class="number">4</span> * (i * n + j); <span class="comment">// 0号位置</span></span><br><span class="line">                <span class="keyword">switch</span>(grid[i][j])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                        uf.unionElem(start, start + <span class="number">1</span>);</span><br><span class="line">                        uf.unionElem(start + <span class="number">1</span>, start + <span class="number">2</span>);</span><br><span class="line">                        uf.unionElem(start + <span class="number">2</span>, start + <span class="number">3</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                        uf.unionElem(start, start + <span class="number">3</span>);</span><br><span class="line">                        uf.unionElem(start + <span class="number">1</span>, start + <span class="number">2</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">                        uf.unionElem(start, start + <span class="number">1</span>);</span><br><span class="line">                        uf.unionElem(start + <span class="number">2</span>, start + <span class="number">3</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 连接同一列2-0</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>) uf.unionElem(start, start - <span class="number">4</span> * n + <span class="number">2</span>);</span><br><span class="line">                <span class="comment">// 连接同一行1-3</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>) uf.unionElem(start + <span class="number">3</span>, start - <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.genCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>评论区：<a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regions-cut-by-slashes/comments/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在由 1 x 1 方格组成的 N x N 网格 &lt;code&gt;grid&lt;/code&gt; 中，每个 1 x 1 方块由 &lt;code&gt;/&lt;/code&gt;、&lt;code&gt;\&lt;/code&gt; 或空格构成。这些字符会将方块划分为一些共边的区域。&lt;/p&gt;
&lt;p&gt;（请注意，反斜杠字符是转义的，因此 &lt;code&gt;\&lt;/code&gt; 用 &lt;code&gt;&amp;quot;\\&amp;quot;&lt;/code&gt; 表示。）。&lt;/p&gt;
&lt;p&gt;返回区域的数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1319-连通网络的操作次数</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/23/LeetCode1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/23/LeetCode1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</id>
    <published>2021-01-23T02:51:28.000Z</published>
    <updated>2021-01-23T07:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>用以太网线缆将 <code>n</code> 台计算机连接成一个网络，计算机的编号从 <code>0</code> 到 <code>n-1</code>。线缆用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 连接了计算机 <code>a</code> 和 <code>b</code>。</p><p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p><p>给你这个计算机网络的初始布线 <code>connections</code>，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。</p><a id="more"></a><img src="/blog/2021/01/23/LeetCode1319-连通网络的操作次数/1319.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先我们需要得到<strong>多余</strong>的边的总数：先判断两个节点是否处于同一个连通集，如果处于同一个连通集并且当前还有一条边连接它们，那么就将<strong>可用边</strong>计数加1。</p><p>其次，我们需要得到连通集的个数，连通集的总数减去1就是要将它们连接起来<strong>所需要边</strong>的个数。</p><p>如果<strong>可用边</strong>小于<strong>所需要边</strong>的个数，就返回-1，代表无法使所有计算机连通。否则，取两者中的较小值，就是最小需要移动边的个数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeConnected</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> lines = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connections.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = uf.getCount();</span><br><span class="line">            uf.unionElem(connections[i][<span class="number">0</span>], connections[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(count == uf.getCount()) lines++;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">int</span> need = uf.getCount() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; lines &lt;&lt; " " &lt;&lt; need;</span></span><br><span class="line">        <span class="keyword">if</span>(lines &gt;= need)&#123;</span><br><span class="line">            <span class="keyword">return</span> min(lines, need);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;用以太网线缆将 &lt;code&gt;n&lt;/code&gt; 台计算机连接成一个网络，计算机的编号从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;。线缆用 &lt;code&gt;connections&lt;/code&gt; 表示，其中 &lt;code&gt;connections[i] = [a, b]&lt;/code&gt; 连接了计算机 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。&lt;/p&gt;
&lt;p&gt;给你这个计算机网络的初始布线 &lt;code&gt;connections&lt;/code&gt;，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++动态数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/20/C-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/20/C-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/</id>
    <published>2021-01-20T14:42:27.000Z</published>
    <updated>2021-01-24T12:20:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li><code>new</code> 和数组</li><li><code>allocator</code> 类</li><li>使用标准库：文本查询程序</li></ol><a id="more"></a><h4 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h4><p>使用 <code>new</code> 分配一个对象数组，在类型名后跟一对方括号，在其中指明要分配的对象的数目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()]; <span class="comment">// pia指向第一个int</span></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>]; <span class="comment">// arrT表示42个int的数组类型</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT; <span class="comment">// 分配一个42个int的数组；p指向第一个int</span></span><br></pre></td></tr></table></figure><h5 id="分配一个数组会得到一个元素类型的指针"><a href="#分配一个数组会得到一个元素类型的指针" class="headerlink" title="分配一个数组会得到一个元素类型的指针"></a>分配一个数组会得到一个元素类型的指针</h5><p>分配的内存不是一个数组类型，因此不能对动态数组调用 <code>begin</code> 和 <code>end</code> ，也不能用范围 <code>for</code>。</p><h5 id="初始化动态分配对象的数组"><a href="#初始化动态分配对象的数组" class="headerlink" title="初始化动态分配对象的数组"></a>初始化动态分配对象的数组</h5><p>动态数组中的元素可以进行值初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 未初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](); <span class="comment">// 值初始化（0）</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]; <span class="comment">// 10个空string</span></span><br><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>](); <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p>新标准下还可以用花括号列表进行初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 前四个用给定的初始化器初始化，剩余的进行值初始化</span></span><br><span class="line"><span class="built_in">string</span> *pia = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]&#123;<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>,<span class="built_in">string</span>(<span class="number">3</span>, <span class="string">'x'</span>)&#125;;</span><br></pre></td></tr></table></figure><p>同时，动态分配一个空数组是合法的。</p><h5 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h5><p>在指针前加上一个空方括号对：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> []pa; <span class="comment">// pa必须指向一个动态分配的数组或为空</span></span><br></pre></td></tr></table></figure><h5 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// up指向一个包含10个未初始化int的数组</span></span><br><span class="line">unique_ptr&lt;int[]&gt; uo(new int[10]);</span><br><span class="line">up.release(); <span class="comment">// 自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure><p>当一个 <code>unique_ptr</code> 指向一个数组时，可以使用下标运算符来访问数组中的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">up[i] = i; <span class="comment">// 为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态数组/指向数组的unique_ptr.png"><p><em>如果希望使用 <code>shared_ptr</code> 管理一个动态数组，必须提供自己定义的删除器。</em></p><h4 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h4><p>标准库 <code>allocator</code> 类定义在 <code>memory</code> 中，它将内存分配和对象构造分离开来。当一个 <code>allocator</code> 对象分配内存时，它会根据给定的<strong>对象类型</strong>来确定恰当的内存大小和对齐位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc; <span class="comment">// 可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); <span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态数组/标准库allocator类及其算法.png"><h5 id="allocator-分配未构造的内存"><a href="#allocator-分配未构造的内存" class="headerlink" title="allocator 分配未构造的内存"></a>allocator 分配未构造的内存</h5><p><code>allocator</code> 分配的内存是未构造的，我们按需要在此内存中使用 <code>construct</code> 构造对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">// q指向最后构造的元素之后的位置</span></span><br><span class="line">alloc.construct(q++); <span class="comment">// *q为空字符串</span></span><br><span class="line">alloc.construct(q++, <span class="number">10</span>, <span class="string">'c'</span>); <span class="comment">// *q为cccccccccc</span></span><br><span class="line">alloc.construct(q++, <span class="string">"hi"</span>); <span class="comment">// *q为hi</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态数组/alloc_warning.png"><p>使用完对象后，必须对<strong>每个构造</strong>的元素调用 <code>destory</code> 来销毁它们。其接受一个指针，对指向的对象执行析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q != p)</span><br><span class="line">alloc.destory(--q); <span class="comment">// 第一次调用时，q指向最后一个构造的元素</span></span><br></pre></td></tr></table></figure><p>元素被销毁后，可以将这部分内存来保存其他 <code>string</code>，也可将其归还给系统，使用 <code>deallocate</code> 完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.deallocate(p, n);</span><br></pre></td></tr></table></figure><h5 id="拷贝和填充未初始化内存的算法"><a href="#拷贝和填充未初始化内存的算法" class="headerlink" title="拷贝和填充未初始化内存的算法"></a>拷贝和填充未初始化内存的算法</h5><p>标准库还定义了两个伴随算法，可以在未初始化内存中创建对象：</p><img src="/blog/2021/01/20/C-动态数组/allocator算法.png"><h4 id="使用标准库：文本查询程序"><a href="#使用标准库：文本查询程序" class="headerlink" title="使用标准库：文本查询程序"></a>使用标准库：文本查询程序</h4><p>在一个给定的文件中查询单词，结果是单词在文件中出现的次数及其所在行。如果一个单词一行中出现多次，只列出一次。行会按照升序输出。</p><p>读入一个英文文本，在其中查询单词 <code>element</code> ，输出结果的前几行如下图：</p><img src="/blog/2021/01/20/C-动态数组/example.png"><h5 id="查询类TextQuery"><a href="#查询类TextQuery" class="headerlink" title="查询类TextQuery"></a>查询类TextQuery</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> line_no = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">    TextQuery(ifstream&amp;);</span><br><span class="line">    <span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file; <span class="comment">// 输入文件，需要两个类共享</span></span><br><span class="line">    <span class="comment">// 每个单词到它所在的行号的集合的映射</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br><span class="line">TextQuery::TextQuery(ifstream &amp;is): file(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">string</span> text;</span><br><span class="line">    <span class="keyword">while</span>(getline(is, text))&#123; <span class="comment">// 对文件中每一行</span></span><br><span class="line">        file-&gt;push_back(text); <span class="comment">// 保存此行文本</span></span><br><span class="line">        <span class="keyword">int</span> n = file-&gt;size() - <span class="number">1</span>; <span class="comment">// 当前行号</span></span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">line</span><span class="params">(text)</span></span>; <span class="comment">// 将文本分解为单词</span></span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">while</span>(line &gt;&gt; word)&#123; <span class="comment">// 对行中的每个单词</span></span><br><span class="line">            <span class="comment">// 如果单词不在wm中，以之为下标在wm中添加一项</span></span><br><span class="line">            <span class="comment">// lines是一个引用，改变lines也会改变wm中的元素</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;lines = wm[word];</span><br><span class="line">            <span class="keyword">if</span>(!lines) <span class="comment">// 在我们第一次遇到这个单词时，此指针为空</span></span><br><span class="line">                lines.reset(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;); <span class="comment">// 分配一个新的set</span></span><br><span class="line">            lines-&gt;insert(n); <span class="comment">// 将此行号插入set中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QueryResult <span class="title">TextQuery::query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sought)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果未找到sought，返回一个指向此set的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; <span class="title">nodata</span><span class="params">(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;)</span></span>;</span><br><span class="line">    <span class="comment">// 使用find而不是下标运算符来查找单词，避免将单词添加到wm中</span></span><br><span class="line">    <span class="keyword">auto</span> loc = wm.find(sought);</span><br><span class="line">    <span class="keyword">if</span>(loc == wm.end())</span><br><span class="line">        <span class="keyword">return</span> QueryResult(sought, nodata, file); <span class="comment">// 未找到</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> QueryResult(sought, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询结果类QueryResult"><a href="#查询结果类QueryResult" class="headerlink" title="查询结果类QueryResult"></a>查询结果类QueryResult</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr,<span class="keyword">const</span> <span class="built_in">string</span> &amp;word, <span class="keyword">const</span> <span class="built_in">string</span> &amp;ending)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>; <span class="comment">// 友元函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> line_no = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">    QueryResult(<span class="built_in">string</span> s, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; p, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; f):</span><br><span class="line">                sought(s), lines(p), file(f)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> sought; <span class="comment">// 查询单词</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; lines; <span class="comment">// 出现的行号</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file; <span class="comment">// 输入文件</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> QueryResult &amp;qr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果找到了单词，打印出现次数和所有出现的位置</span></span><br><span class="line">    os &lt;&lt; qr.sought &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; qr.lines-&gt;size() &lt;&lt; <span class="string">" "</span></span><br><span class="line">       &lt;&lt; make_plural(qr.lines-&gt;size(), <span class="string">"time"</span>, <span class="string">"s"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 打印单词出现的每一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : *qr.lines)</span><br><span class="line">        <span class="comment">// 行号从1开始</span></span><br><span class="line">        os &lt;&lt; <span class="string">"\t(lines "</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; <span class="string">") "</span></span><br><span class="line">           &lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;word, <span class="keyword">const</span> <span class="built_in">string</span> &amp;ending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctr == <span class="number">1</span>) ? word : word + ending;<span class="comment">//make_plural(wc, "word ", "s ")当输入中文本中</span></span><br><span class="line">    <span class="comment">//word数大于一是在word后加s，为words为word的复数！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"test.txt"</span>)</span></span>;</span><br><span class="line">    runQueries(infile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span>&#123;</span><br><span class="line">    <span class="function">TextQuery <span class="title">tq</span><span class="params">(infile)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入要查询的单词，或按q退出："</span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">cin</span> &gt;&gt; s) || s == <span class="string">"q"</span>) <span class="keyword">break</span>;</span><br><span class="line">        print(<span class="built_in">cout</span>, tq.query(s)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h5><p><a href="https://gitee.com/settlezxy/learning-cpp.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/learning-cpp.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; 和数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allocator&lt;/code&gt; 类&lt;/li&gt;
&lt;li&gt;使用标准库：文本查询程序&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="动态数组" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++动态内存与智能指针</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/20/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/20/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2021-01-20T14:41:49.000Z</published>
    <updated>2021-01-25T15:04:57.562Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li><code>shared_ptr</code> 类</li><li>直接管理内存</li><li><code>shared_ptr</code> 和 <code>new</code> 结合使用</li><li>智能指针和异常</li><li><code>unique_ptr</code></li><li><code>weak_ptr</code></li></ol><a id="more"></a><p>静态内存：保存局部 <code>static</code> 对象、类 <code>static</code> 数据成员及定义在任何函数之外的变量。</p><p>栈内存：保存和定义在函数内的非 <code>static</code> 对象。</p><p>除了静态内存和栈内存，程序还拥有一个内存池，被称为<strong>自由空间</strong>或<strong>堆</strong>。程序用堆来存储<strong>动态分配</strong>的对象，当动态对象不再使用时，必须用代码显式的销毁它们。</p><p><strong>动态内存与智能指针</strong></p><ul><li><code>new</code> ：在动态内存中为对象分配空间并返回一个指向该对象的指针。</li><li><code>delete</code> ：接受一个动态对象的指针，销毁该对象，并释放相关内存。</li></ul><p>不合理时释放内存会出现内存泄漏（忘记释放）或产生引用非法内存的指针（有指针还在引用内存时就释放了它）。</p><p>标准库提供两种<strong>智能指针</strong>管理动态对象，它们可以自动释放所指向的对象。</p><ol><li><code>shared_ptr</code> 允许多个指针指向同一个对象。</li><li><code>unique_ptr</code> 则<strong>独占</strong>所指向的对象。</li></ol><p>标准库还定义了一个名为 <code>weak_ptr</code> 的伴随类，它是一种弱引用（**?**），指向 <code>shared_ptr</code> 所管理的对象。这三种类型都定义在 <code>memory</code> 头文件中。</p><h4 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h4><p>智能指针也是模板，必须提供指针可以指向的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1; <span class="comment">// 指向string</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;  p2; <span class="comment">// 指向int的list</span></span><br></pre></td></tr></table></figure><p>如果在一个条件判断中使用智能指针，效果就是检测它是否为空：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果p1不为空，并且指向一个空的string</span></span><br><span class="line"><span class="keyword">if</span>(p1 &amp;&amp; p1-&gt;empty())</span><br><span class="line">*p1 = <span class="string">"hi"</span>;</span><br></pre></td></tr></table></figure><p><code>shared_ptr </code>和 <code>unique_ptr</code> 都支持的操作：</p><img src="/blog/2021/01/20/C-动态内存与智能指针/shared_ptr与unique_ptr都支持的操作.png"><p><code>shared_ptr</code> 独有的操作：</p><img src="/blog/2021/01/20/C-动态内存与智能指针/shared_ptr独有的操作.png"><h5 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h5><p>此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 <code>shared_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向一个值为42的int的shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 指向一个值初始化的int，即，值为0</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p4 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="comment">// 也可以用auto</span></span><br></pre></td></tr></table></figure><p><strong>调用make_shared<t>时必须与T的某个构造函数相匹配</t></strong>。</p><h5 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h5><p>当进行拷贝或赋值操作时，每个 <code>shared_ptr</code> 都会记录又多少个其他 <code>shared_ptr</code> 指向相同的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">// p和q指向相同对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure><p>每个 <code>shared_ptr</code> 都有要给<strong>引用计数</strong>，只要我们拷贝一个 <code>shared_ptr</code> ，计数器就会增加，当我们给 <code>shared_ptr</code> 赋予一个新值或是 <code>shared_ptr</code> 被销毁，计数器递减。</p><p>一旦计数器变为0，它就会自动释放自己所管理的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q; <span class="comment">// 给r赋值，令它指向另一个地址</span></span><br><span class="line">   <span class="comment">// 递增q指向的对象的引用计数</span></span><br><span class="line">   <span class="comment">// 递减r原来指向的对象的引用计数</span></span><br><span class="line">   <span class="comment">// r原来指向的对象已经没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure><h5 id="shared-ptr自动销毁所管理的对象"><a href="#shared-ptr自动销毁所管理的对象" class="headerlink" title="shared_ptr自动销毁所管理的对象"></a>shared_ptr自动销毁所管理的对象</h5><p>当指向一个对象的最后一个 <code>shared_ptr</code> 被销毁时，<code>shared_ptr</code> 类会通过<strong>析构函数</strong>销毁此对象。<code>shared_ptr</code> 的析构函数会递减它所指向的对象的引用计数，如果引用计数变为0， <code>shared_ptr</code> 的析构函数就会销毁对象，并释放它占用的内存。</p><h5 id="shared-ptr还会自动释放相关联的内存"><a href="#shared-ptr还会自动释放相关联的内存" class="headerlink" title="shared_ptr还会自动释放相关联的内存"></a>shared_ptr还会自动释放相关联的内存</h5><img src="/blog/2021/01/20/C-动态内存与智能指针/note_shared_ptr释放内存.png"><h5 id="使用了动态生存期的资源的类"><a href="#使用了动态生存期的资源的类" class="headerlink" title="使用了动态生存期的资源的类"></a>使用了动态生存期的资源的类</h5><p>程序使用动态内存出于一下三种原因之一 ：</p><ol><li>程序不知道自己需要使用多少对象。</li><li>程序不知道所需对象的准确类型。</li><li>程序需要在多个对象间共享数据。</li></ol><p>一般而言，如果两个对象共享底层的数据，当某个对象被销毁时，我们不能单方面的销毁底层数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="built_in">string</span>&gt; b1; <span class="comment">// 空Blob</span></span><br><span class="line">&#123;新作用域</span><br><span class="line">    Blob&lt;<span class="built_in">string</span>&gt; b2 = &#123;<span class="string">"z"</span>,<span class="string">"zx"</span>,<span class="string">"zxy"</span>&#125;;</span><br><span class="line"> b1 = b2; <span class="comment">// b1和b2共享相同的元素</span></span><br><span class="line">&#125; <span class="comment">// b2被销毁了，但b2中的元素不能销毁</span></span><br><span class="line">  <span class="comment">// b1指向最初由b2创建的元素</span></span><br></pre></td></tr></table></figure><p>此例中，<code>b1</code> 和 <code>b2</code> 共享相同的元素。当 <code>b2</code> 离开作用域时，这些元素必须保留，<code>b1</code> 仍然在使用它们。</p><h4 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h4><h5 id="使用new动态分配和初始化对象"><a href="#使用new动态分配和初始化对象" class="headerlink" title="使用new动态分配和初始化对象"></a>使用new动态分配和初始化对象</h5><p>使用传统构造方式（使用圆括号），或列表初始化（使用花括号）初始化一个动态分配的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// pi指向的对象的值为1024</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'9'</span>); <span class="comment">// *ps为"9999999999"</span></span><br><span class="line"><span class="comment">// vector有10个元素，值以此从0到9</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>对动态分配的对象进行值初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(); <span class="comment">// 值初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// 值初始化为0；*pi为0</span></span><br></pre></td></tr></table></figure><h5 id="动态分配的const对象"><a href="#动态分配的const对象" class="headerlink" title="动态分配的const对象"></a>动态分配的const对象</h5><p>用 <code>new</code> 分配 <code>const</code> 是合法的，但必须进行初始化，返回一个指向 <code>cosnt</code> 的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *pcs = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// const对象是可以销毁的</span></span><br><span class="line"><span class="keyword">delete</span> pci;</span><br></pre></td></tr></table></figure><h5 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h5><p>如果 <code>new</code> 不能分配所要求的内存空间，它会抛出一个类型为 <code>bad_alloc</code> 的异常，但是可以使用 <code>new</code>  的方式阻止其抛出异常，称这种形式的 <code>new</code> 为<strong>定位new</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果分配失败，new返回一个空指针</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new抛出std:bad_alloc;</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new返回要给空指针</span></span><br></pre></td></tr></table></figure><h5 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或是一个空指针</span></span><br></pre></td></tr></table></figure><p>释放一块非 <code>new</code> 分配的内存，或者将相同的指针值释放多次，其行为是未定义的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *pi1 = &amp;i;</span><br><span class="line"><span class="keyword">delete</span> pi1; <span class="comment">// 未定义：pi1指向一个局部变量</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> pi2; <span class="comment">// 正确：释放一个空指针总是没有错误的</span></span><br></pre></td></tr></table></figure><h5 id="动态对象的生存期直到被释放时为止"><a href="#动态对象的生存期直到被释放时为止" class="headerlink" title="动态对象的生存期直到被释放时为止"></a>动态对象的生存期直到被释放时为止</h5><img src="/blog/2021/01/20/C-动态内存与智能指针/warning_释放动态对象.png"><h5 id="使用new和delete管理动态内存存在的三个常见问题"><a href="#使用new和delete管理动态内存存在的三个常见问题" class="headerlink" title="使用new和delete管理动态内存存在的三个常见问题"></a>使用new和delete管理动态内存存在的三个常见问题</h5><ol><li>忘记 <code>delete</code> 内存，会导致<strong>内存泄漏</strong>，因为这种内存永远不可能被归还给自由空间了，只有真正耗尽内存时，才能检测到这种错误。</li><li>使用已释放掉的内存。</li><li>同一块内存释放两次。</li></ol><h5 id="delete之后重置指针值"><a href="#delete之后重置指针值" class="headerlink" title="delete之后重置指针值"></a>delete之后重置指针值</h5><p>在 <code>delete</code> 之后，指针就变成了<strong>空悬指针</strong>，即，指向一块曾经保存数据对象但现在已经无效的内存的指针。</p><h4 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h4><p>我们可以使用 <code>new</code> 返回的指针来初始化智能指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure><p>接受指针参数的智能指针的构造函数是 <code>explicit</code> 的，因此必须使用直接初始化形式来初始化一个智能指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态内存与智能指针/定义和改变shared_ptr的其他方法1.png"><img src="/blog/2021/01/20/C-动态内存与智能指针/定义和改变shared_ptr的其他方法2.png"><h5 id="get使用注意"><a href="#get使用注意" class="headerlink" title="get使用注意"></a>get使用注意</h5><img src="/blog/2021/01/20/C-动态内存与智能指针/warning_get_use.png"><h5 id="其他shared-ptr操作"><a href="#其他shared-ptr操作" class="headerlink" title="其他shared_ptr操作"></a>其他shared_ptr操作</h5><p>我们可以同 <code>reset</code> 来将一个新的指针赋予一个 <code>shared_ptr</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误，不能将一个指针赋予shared_ptr</span></span><br><span class="line">p.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>)); <span class="comment">// 正确，p指向一个新对象</span></span><br></pre></td></tr></table></figure><p><code>reset</code> 成员常与 <code>unique</code> 一起使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p.unique())&#123;</span><br><span class="line">p.reset(<span class="keyword">new</span> <span class="built_in">string</span>(*p)); <span class="comment">// 不是唯一用户，分配新的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line">*p += newVal; <span class="comment">// 现在唯一，可以改变对象的值</span></span><br></pre></td></tr></table></figure><h4 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h4><p>如果使用智能指针，即使程序块过早结束，智能指针也能确保在内存不再需要时将其释放；而 <code>new</code> 和 <code>delete</code> 之间发生异常，且异常未被捕获，则内存就永远不会被释放了。</p><h5 id="使用自己的释放操作"><a href="#使用自己的释放操作" class="headerlink" title="使用自己的释放操作"></a>使用自己的释放操作</h5><p>有些类未定义析构函数，需要用户显示地释放所使用的任何资源。假定我们正在使用一个C和C++都使用的网络库，使用这个库的代码可能如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">destination</span>;</span> <span class="comment">// 表示我们正在连接什么</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span>;</span> <span class="comment">// 使用连接所需的信息</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination *)</span></span>; <span class="comment">// 打开连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(connect)</span></span>; <span class="comment">// 关闭给定的连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获得一个连接，记住使用完之后要关闭！</span></span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 如果我们在f推出前忘记调用disconnect，就无法关闭c了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>shared_ptr</code> 来保证 <code>connection</code> 被正确关闭：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数来代替delete</span></span><br><span class="line"><span class="comment">// 这个「删除器」函数必须能够完成对shared_ptr中保存的指针进行释放的操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconnect (*p); &#125;;</span><br><span class="line"><span class="comment">// 创建shared_ptr时，可以传递一个（可选的）指向删除器函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 当f退出时（即使时因为异常而退出），connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>当我们定义一个 <code>unique_ptr</code> 时，需要将其绑定到一个 <code>new</code> 返回的指针上。如果进行初始化，必须是直接初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; p1; <span class="comment">// 可以指向一个double的unique_ptr</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure><p><code>unique</code> 不支持普通的拷贝或赋值操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"zxy"</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 错误，不能拷贝</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3;</span><br><span class="line">p3 = p2; <span class="comment">// 错误，不能赋值</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态内存与智能指针/unique_str操作.png"><p>可以通过 <code>release</code> 或 <code>reset</code> 将指针的所有权（非const）从一个 <code>unique_ptr</code> 转移给另一个 <code>unique_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有权从p1转移给p2，并将p1置空</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;</span><br><span class="line"><span class="comment">// 将所有权从p3转移给p2，并将p3置空</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Zxy"</span>))</span></span>;</span><br><span class="line">p2.reset(p3.release()); <span class="comment">// reset释放了p2原来指向的内存</span></span><br></pre></td></tr></table></figure><p>需要注意：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2.release(); <span class="comment">// 错误，p2不会释放内存，而且我们丢失了指针</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.release(); <span class="comment">// 正确，但必须记得delete(p);</span></span><br></pre></td></tr></table></figure><h5 id="传递unique-ptr参数和返回unique-ptr"><a href="#传递unique-ptr参数和返回unique-ptr" class="headerlink" title="传递unique_ptr参数和返回unique_ptr"></a>传递unique_ptr参数和返回unique_ptr</h5><p>不能拷贝 <code>unique_ptr</code> 规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 <code>unique_ptr</code> 。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回局部对象的拷贝</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(p))</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="向unique-ptr传递删除器"><a href="#向unique-ptr传递删除器" class="headerlink" title="向unique_ptr传递删除器"></a>向unique_ptr传递删除器</h5><p>用 <code>unique_ptr</code> 来代替 <code>shared_ptr</code> ，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconnect (*p); &#125;;</span><br><span class="line"><span class="comment">// 创建shared_ptr时，可以传递一个（可选的）指向删除器函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;connection, <span class="keyword">decltype</span>(end_connection)*&gt; </span><br><span class="line">        p(&amp;c, end_connection);</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 当f退出时（即使时因为异常而退出），connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>decltype(end_connection)</code> 返回一个函数类型，所以我们必须添加一个 <code>*</code> 来指出我们正在使用该类型的一个指针。</p><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p><code>weak_ptr</code> 是一种不控制所指向对象生存期的智能指针，它指向一个由 <code>shared_ptr</code> 管理的对象。将一个 <code>weak_ptr</code> 绑定到一个 <code>shared_ptr</code> 不会改变 <code>shared_ptr</code> 的引用计数。一旦最后一个指向对象的 <code>shared_ptr</code> 被销毁，对象就会被释放。</p><img src="/blog/2021/01/20/C-动态内存与智能指针/weak_ptr.png"><p>创建一个 <code>weak_ptr</code> 时，要用一个 <code>shared_ptr</code> 来初始化它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>; <span class="comment">// wp弱共享p，p的引用计数未改变</span></span><br></pre></td></tr></table></figure><p>由于对象可能不存在，不能使用 <code>weak_ptr</code> 直接访问对象，必须调用 <code>lock</code>。如果对象存在， <code>lock</code> 返回一个指向共享对象的 <code>shared_ptr</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; np = wp.lock())&#123; <span class="comment">// 如果np不为空则条件成立</span></span><br><span class="line"><span class="comment">// 在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;shared_ptr&lt;/code&gt; 类&lt;/li&gt;
&lt;li&gt;直接管理内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shared_ptr&lt;/code&gt; 和 &lt;code&gt;new&lt;/code&gt; 结合使用&lt;/li&gt;
&lt;li&gt;智能指针和异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weak_ptr&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="智能指针" scheme="http://www.xingyuzhao.ltd/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>文件管理（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/20/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/20/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-01-20T02:53:35.000Z</published>
    <updated>2021-01-29T15:50:19.943Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>文件的物理结构</li><li>文件存储空间管理</li></ol><a id="more"></a><h4 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h4><p>对非空闲磁盘块的管理。磁盘中的存储单元被划分为一个个的“块、磁盘块、物理块”。<strong>磁盘块的大小与内存块、页面的大小相同</strong>。</p><h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。</p><img src="/blog/2021/01/20/文件管理（二）/连续分配目录.png"><p>优点：</p><ul><li>支持<strong>顺序访问和直接访问（即随机访问）</strong>。</li><li>连续分配的文件在顺序访问时速度最快。</li></ul><p>缺点：</p><ul><li>不方便文件拓展。</li><li>存储空间利用率低，会产生磁盘碎片。</li></ul><h5 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h5><p>链接分配采取<strong>离散</strong>分配的方式，可以为文件分配离散的磁盘块。分为<strong>隐式链接</strong>和显示链接。</p><h6 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h6><p>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p><img src="/blog/2021/01/20/文件管理（二）/隐式链接.png" style="zoom:80%;"><p>优点：</p><ul><li>方便文件拓展，不会有碎片问题，外存利用率高。</li></ul><p>缺点：</p><ul><li>只能顺序访问，查找效率低，指向下一个盘块的指针也需要消耗少量的存储空间。</li></ul><h6 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h6><p>把用于链接文件各物理块的指针显式地存放在一张表中，即<strong>文件分配表（FAT，File Allocation Table）</strong>。</p><img src="/blog/2021/01/20/文件管理（二）/显式链接.png" style="zoom:80%;"><p><em>一个磁盘仅设置一张FAT，开机时，将FAT读入内存，并常驻内存</em>。</p><p>优点：</p><ul><li>方便文件拓展，不会有碎片问题，外存利用率高，并且支持<strong>随机访问</strong>。</li><li>相比于隐式链接，地址转换不需要访问磁盘，因此文件的访问效率更高。</li></ul><p>缺点：</p><ul><li>文件分配表需要占用一定的存储空间。</li></ul><h5 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h5><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为<strong>每个文件</strong>建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</p><img src="/blog/2021/01/20/文件管理（二）/索引分配.png" style="zoom:80%;"><h6 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h6><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p><img src="/blog/2021/01/20/文件管理（二）/索引分配-链接方案.png" style="zoom:80%;"><p>缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，导致磁盘 I/O 过多，查找效率低下。</p><h6 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h6><p>建立多层索引（类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p><img src="/blog/2021/01/20/文件管理（二）/索引分配-多层索引.png" style="zoom:80%;"><p><em>采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操作</em>。</p><p>缺点：即使是小文件，访问一个数据块依然需要 K + 1 次读磁盘。</p><h6 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h6><p>多种索引分配方式的结合。例如，一个文件的顶级索引中，既包含<strong>直接地址索引（直接指向数据块）</strong>，又包含<strong>一级、二级间接索引</strong>。</p><img src="/blog/2021/01/20/文件管理（二）/索引分配-混合索引.png" style="zoom:80%;"><p>优点：对于小文件来说，访问要给数据块所需的读磁盘次数更少。</p><h5 id="文件的物理结构小结"><a href="#文件的物理结构小结" class="headerlink" title="文件的物理结构小结"></a>文件的物理结构小结</h5><img src="/blog/2021/01/20/文件管理（二）/文件的物理结构小结.png"><h4 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h4><p>对空闲磁盘块的管理。</p><p>存储空间的初始化：将各个文件卷划分为目录区、文件区。</p><ul><li>目录区存放文件目录信息（FCB）、用于词牌存储空间管理的信息。</li><li>文件区用于存放文件数据。</li></ul><h5 id="存储空间管理——空闲表法"><a href="#存储空间管理——空闲表法" class="headerlink" title="存储空间管理——空闲表法"></a>存储空间管理——空闲表法</h5><p>适用于连续分配方式。</p><p><strong>如何分配连续的存储空间</strong>：与内存管理中的动态分区分配类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p><p><strong>如何回收磁盘块</strong>：</p><ol><li>回收区前后都没有相邻空闲区。</li><li>回收区的前后都是空闲区。</li><li>回收区前面是空闲区。</li><li>回收区后面是空闲区。</li></ol><p><em>回收时注意表项的合并问题</em>。</p><h5 id="存储空间管理——空闲链表法"><a href="#存储空间管理——空闲链表法" class="headerlink" title="存储空间管理——空闲链表法"></a>存储空间管理——空闲链表法</h5><h6 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h6><img src="/blog/2021/01/20/文件管理（二）/空闲盘块链.png" style="zoom:80%;"><p>操作系统保存着<strong>链头、链尾指针</strong>。</p><p><strong>如何分配</strong>：若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针。</p><p><strong>如何回收</strong>：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p><h6 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h6><img src="/blog/2021/01/20/文件管理（二）/空闲盘区链.png" style="zoom:80%;"><p><strong>如何分配</strong>：若某文件申请 K 个盘块，可采用首次适应、最佳适应等算法从链头开始检索，找到符合的一个空闲盘区；若没有合适的连续空闲块，可将不同盘区的盘块分配给文件。</p><p><strong>如何回收</strong>：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为一个单独的空闲盘区挂到链尾。</p><h5 id="存储空间管理——位示图法"><a href="#存储空间管理——位示图法" class="headerlink" title="存储空间管理——位示图法"></a>存储空间管理——位示图法</h5><img src="/blog/2021/01/20/文件管理（二）/位示图法.png"><p><strong>位示图</strong>：每个二进制位对应一个盘号，空闲为 0，已分配为 1。位示图用<strong>字</strong>来表示，上图字长为16。可以用<strong>（字号，位号）</strong>对应一个盘块号。</p><ul><li><p>$（字号，位号）=(i,j)$ 的<strong>二进制位</strong>对应的<strong>盘块号</strong> $b=n\times i + j$。</p></li><li><p>$b$ 号<strong>盘块</strong>对应的<strong>字号</strong> $i=b/n$，位号 $j=b%n$。</p></li></ul><p><strong>如何分配</strong>：若文件需要 K 个块：</p><ol><li>顺序扫描位示图，找到 K 个相邻或不相邻的 0。</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件。</li><li>将相应位设置为 1。</li></ol><p><strong>如何回收</strong>：</p><ol><li>根据回收的盘块号计算出对应的字号、位号。</li><li>将相应的二进制位设为 0。</li></ol><h5 id="存储空间管理——成组链接法"><a href="#存储空间管理——成组链接法" class="headerlink" title="存储空间管理——成组链接法"></a>存储空间管理——成组链接法</h5><p>文件卷目录区用一个磁盘块作为<strong>超级块</strong>，系统启动时将其调入内存，并保证内外存超级块数据一致。</p><img src="/blog/2021/01/20/文件管理（二）/超级块.png"><p><strong>超级块（空闲盘块号栈）</strong></p><p>① 存放下一组空闲盘块的<strong>盘块号</strong>（不超过100）。</p><p>② 此组空闲盘的<strong>空闲块总数</strong> N。</p><p><strong>我的理解</strong>：超级块大小等于其他块中的第一个空闲块。都是用来存储下一组空闲块信息的，主要针对<strong>分配时只剩下一个空闲块</strong>（此空闲块存储了下一组空闲块信息）或<strong>回收时已经回收够100个空闲块</strong>的特殊情况。<strong>类似于链表中的哑节点</strong>。</p><img src="/blog/2021/01/20/文件管理（二）/超级块1.png" style="zoom:120%;"><p>最后一组的 <code>s.free[0] = -1</code>，表示空闲盘块链的结尾标志。</p><p><strong>N 兼做栈顶指针</strong></p><p>例如，当 <code>N = 100</code> 时，它指向<code>s.free(99)</code>，即 N 指向 <code>s.free(N - 1)</code>。</p><h6 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h6><p>将盘块 <code>4</code> 分配给文件，先将 <code>4</code> 出栈，再将 N 减1。同理再将 <code>3</code> 分配给文件，可得：</p><img src="/blog/2021/01/20/文件管理（二）/超级块2.png" style="zoom:120%;"><p>如果此时还要将 <code>2</code> 分配给文件（<code>2</code> 保存了下一个盘块的信息），需要进行以下操作：</p><ol><li>将 <code>2</code> 的信息保存到超级块中，将 <code>2</code> 分配给文件。</li><li>更新指针。</li></ol><img src="/blog/2021/01/20/文件管理（二）/超级块3.png" style="zoom:120%;"><h6 id="空间回收"><a href="#空间回收" class="headerlink" title="空间回收"></a>空间回收</h6><p>假如回收盘块 <code>4</code>，先将 <code>4</code> 压入栈中，再更新 N：</p><img src="/blog/2021/01/20/文件管理（二）/超级块4.png" style="zoom:120%;"><p>当栈满时，<strong>会将超级块的内容复制到新回收的块中</strong>，再更新指针，假如新回收的盘块为 <code>3</code>，可以得到下图:</p><img src="/blog/2021/01/20/文件管理（二）/超级块5.png" style="zoom:120%;"><p>再根据磁盘块 <code>3</code> 更新超级块中的栈和 N，显然 N 为1，超级块指向的下一个盘块只有 <code>3</code>，将 <code>3</code> 压入栈中，此时新回收盘块 <code>2</code>，将其压入栈中，N 再加1即可：</p><img src="/blog/2021/01/20/文件管理（二）/超级块6.png" style="zoom:120%;"><h5 id="文件的存储空间管理小结"><a href="#文件的存储空间管理小结" class="headerlink" title="文件的存储空间管理小结"></a>文件的存储空间管理小结</h5><img src="/blog/2021/01/20/文件管理（二）/文件的存储空间管理小结.png"><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>成组链接法bilibili：<a href="https://www.bilibili.com/video/av71840093/" target="_blank" rel="noopener">https://www.bilibili.com/video/av71840093/</a></p><p>实例讲解成组链接法：<a href="https://blog.csdn.net/smartab/article/details/81285353" target="_blank" rel="noopener">https://blog.csdn.net/smartab/article/details/81285353</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;文件的物理结构&lt;/li&gt;
&lt;li&gt;文件存储空间管理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode1584-连接所有点的最小费用</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/19/LeetCode1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/19/LeetCode1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/</id>
    <published>2021-01-19T09:16:42.000Z</published>
    <updated>2021-01-19T09:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个 <code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi]</code> 。</p><p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>|xi - xj| + |yi - yj|</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p><a id="more"></a><img src="/blog/2021/01/19/LeetCode1584-连接所有点的最小费用/1584.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>points</code> 数组中两两节点相连构成一个完全图，根据 <code>Kruskal</code> 算法（并查集）找到完全图中的最小生成树，这棵树上的权值之和就是题目要求的最小费用。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Edge(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> weight) : v(v), w(w), weight(weight)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> f = [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) -&gt; <span class="keyword">int</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(v1[<span class="number">0</span>] - v2[<span class="number">0</span>]) + <span class="built_in">abs</span>(v1[<span class="number">1</span>] - v2[<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(points.size())</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.size(); ++j)&#123;</span><br><span class="line">                edges.emplace_back(i, j, f(points[i], points[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 记录最小生成树边的个数</span></span><br><span class="line">        <span class="comment">// 每条边按照权值排序</span></span><br><span class="line">        sort(edges.begin(), edges.end(), [](Edge &amp;a, Edge &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v, w, weight] : edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uf.isConnected(v, w)) <span class="keyword">continue</span>;</span><br><span class="line">            res += weight;</span><br><span class="line">            num++;</span><br><span class="line">            uf.unionElem(v, w);</span><br><span class="line">            <span class="keyword">if</span>(num == points.size() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/lian-jie-suo-you-dian-de-zui-xiao-fei-yo-kcx7/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/lian-jie-suo-you-dian-de-zui-xiao-fei-yo-kcx7/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>$\text{Kruskal}$ 算法是一种常见并且好写的最小生成树算法，由 $\text{Kruskal}$ 发明。该算法的基本思想是根据边的权值从小到大加入边，是一个贪心算法。</p><p>其算法流程为：</p><ol><li><p>将图 $G={V,E}$ 中的所有边按照长度由小到大进行排序，等长的边可以按任意顺序。</p></li><li><p>初始化图 $G’$ 初始化为 ${V,\varnothing}$，从前向后扫描排序后的边，如果扫描到的边 $e$ 在 $G’$ 中连接了两个不同的连通块,则将它插入 $G’$ 中。</p></li><li><p>最后得到的图 $G’$ 就是图 $G$ 的最小生成树。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个 &lt;code&gt;points&lt;/code&gt; 数组，表示 2D 平面上的一些点，其中 &lt;code&gt;points[i] = [xi, yi]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;连接点 &lt;code&gt;[xi, yi]&lt;/code&gt; 和点 &lt;code&gt;[xj, yj]&lt;/code&gt; 的费用为它们之间的 &lt;strong&gt;曼哈顿距离&lt;/strong&gt; ：&lt;code&gt;|xi - xj| + |yi - yj|&lt;/code&gt; ，其中 &lt;code&gt;|val|&lt;/code&gt; 表示 &lt;code&gt;val&lt;/code&gt; 的绝对值。&lt;/p&gt;
&lt;p&gt;请你返回将所有点连接的最小总费用。只有任意两点之间 &lt;strong&gt;有且仅有&lt;/strong&gt; 一条简单路径时，才认为所有点都已连接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小生成树" scheme="http://www.xingyuzhao.ltd/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode721-合并账户</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/18/LeetCode721-%E5%90%88%E5%B9%B6%E8%B4%A6%E6%88%B7/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/18/LeetCode721-%E5%90%88%E5%B9%B6%E8%B4%A6%E6%88%B7/</id>
    <published>2021-01-18T03:16:01.000Z</published>
    <updated>2021-01-25T15:09:30.317Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code> 是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code> 是 名称 <em>(name)*，其余元素是 *emails</em> 表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。</p><a id="more"></a><img src="/blog/2021/01/18/LeetCode721-合并账户/721.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据邮箱之间的连通性可以找到同一名字下的所有邮箱地址。可以将字符串映射到数字域方便建立并查集，同时需要建立反向哈希表，可以从数字得到字符串（数字必须唯一）。</p><p><strong>算法如下</strong>：</p><ul><li><p>使用并查集将同一名字下的邮箱地址进行合并。</p></li><li><p>再次遍历 <code>accounts</code>，找到每个邮箱地址对应的根节点，根据根节点建立节点间的连通关系。</p></li><li><p>从根节点邮箱找到对应的名字，然后再根据上一步的连通关系找到所有邮箱。</p></li></ul><p>细节详见代码。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(qRoot == pRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">accountsMerge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; <span class="built_in">map</span>; <span class="comment">// 建立邮箱对名字的映射</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; stoi; <span class="comment">// 将邮箱映射为数字，方便并查集处理</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; itos; <span class="comment">// 将上面的数字映射为邮箱，反向映射</span></span><br><span class="line">        <span class="comment">// 邮箱与数字之间的相互映射</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;account : accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stoi.count(account[i]))&#123;</span><br><span class="line">                    stoi[account[i]] = cnt;</span><br><span class="line">                    itos[cnt++] = account[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 邮箱对名字的映射</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;account : accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">map</span>.count(account[i]))&#123;</span><br><span class="line">                    <span class="built_in">map</span>[account[i]] = account[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建立并查集，对同一名字下的所有邮箱进行合并</span></span><br><span class="line">        <span class="comment">// 使不同的accounts之间，有相同的名字时必定在一个集合中</span></span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(stoi.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;account : accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; account.size(); ++i)&#123;</span><br><span class="line">                uf.unionElem(stoi[account[i]], stoi[account[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到邮箱对应的根节点，建立根节点与所有相连节点的映射</span></span><br><span class="line">        <span class="comment">// 此处根节点是数字，下一步需要转换为相应的邮箱（itos），再根据邮箱得到名字（map）</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; fin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;account : accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); ++i)&#123;</span><br><span class="line">                <span class="comment">// 找到当前邮箱的根节点</span></span><br><span class="line">                <span class="keyword">int</span> root = uf.find(stoi[account[i]]);</span><br><span class="line">                <span class="comment">// 根据根节点建立连通关系</span></span><br><span class="line">                fin[root].insert(account[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m = fin.begin(); m != fin.end(); ++m)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; buf;</span><br><span class="line">            <span class="comment">// 根节点数字-&gt;根节点字符串-&gt;根节点对应的名字</span></span><br><span class="line">            buf.push_back(<span class="built_in">map</span>[itos[m-&gt;first]]);</span><br><span class="line">            <span class="comment">// 将根节点相连通的所有邮箱加入答案中，set已经进行排序</span></span><br><span class="line">            <span class="keyword">auto</span> vec = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(m-&gt;second.begin(), m-&gt;second.end());</span><br><span class="line">            buf.insert(buf.end(), vec.begin(), vec.end());</span><br><span class="line">            res.push_back(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个列表 &lt;code&gt;accounts&lt;/code&gt;，每个元素 &lt;code&gt;accounts[i]&lt;/code&gt; 是一个字符串列表，其中第一个元素 &lt;code&gt;accounts[i][0]&lt;/code&gt; 是 名称 &lt;em&gt;(name)*，其余元素是 *emails&lt;/em&gt; 表示该账户的邮箱地址。&lt;/p&gt;
&lt;p&gt;现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。&lt;/p&gt;
&lt;p&gt;合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>文件管理（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/16/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/16/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-01-16T03:17:11.000Z</published>
    <updated>2021-01-29T15:50:27.098Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>初识文件管理</li><li>文件的逻辑结构</li><li>文件目录</li></ol><a id="more"></a><h4 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h4><p>文件：一组有意义的信息/数据集合。</p><h5 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h5><p>文件名：由创建文件的用户决定，同一目录下不允许有重名文件。</p><p>标识符：操作系统用于区分各个文件（文件名相同更应如此）的一种内部名称。</p><p>类型：指明文件的类型。</p><p>位置：文件存放的路径、在外存中的地址。</p><p>大小：指明文件的大小。</p><p>创建时间、上次修改时间、文件所有者信息。</p><p>保护信息：对文件进行保护的访问控制信息。</p><h5 id="文件内部数据的组织"><a href="#文件内部数据的组织" class="headerlink" title="文件内部数据的组织"></a>文件内部数据的组织</h5><img src="/blog/2021/01/16/文件管理（一）/文件内部数据的组织.png"><h5 id="操作系统应该向上提供的功能"><a href="#操作系统应该向上提供的功能" class="headerlink" title="操作系统应该向上提供的功能"></a>操作系统应该向上提供的功能</h5><img src="/blog/2021/01/16/文件管理（一）/操作系统应该向上提供的功能.png"><ul><li><p>创建文件：新建后，图形化交互进程调用了<strong>create系统调用</strong>。</p></li><li><p>读文件：使用<strong>read系统调用</strong>，将文件数据从外存读入内存。</p></li><li><p>写文件：使用<strong>write系统调用</strong>，将文件数据从内存写回外存。</p></li><li><p>删除文件：删除后，图形化交互进程调用了<strong>delete系统调用</strong>。</p></li><li><p>打开文件：读/写文件之前，需要打开文件，使用<strong>open系统调用</strong>。</p></li><li><p>关闭文件：读/写文件结束之后，需要关闭文件，使用<strong>close系统调用</strong>。</p></li></ul><h5 id="从上往下看，文件应如何存放在外存？"><a href="#从上往下看，文件应如何存放在外存？" class="headerlink" title="从上往下看，文件应如何存放在外存？"></a>从上往下看，文件应如何存放在外存？</h5><p>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址。每个存储单元对应一个物理地址。</p><h5 id="其他需要由操作系统实现的功能"><a href="#其他需要由操作系统实现的功能" class="headerlink" title="其他需要由操作系统实现的功能"></a>其他需要由操作系统实现的功能</h5><ul><li>文件共享：使多个用户可以共享使用要给文件。</li><li>文件保护：不同的用户对文件有不同的操作权限。</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/16/文件管理（一）/初识文件管理小结.png"><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><img src="/blog/2021/01/16/文件管理（一）/文件的逻辑结构.png" style="zoom:80%;"><h5 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h5><p>文件内部的数据就是一系列的二进制流或字符流组成。又称<strong>流式文件</strong>。如 <code>txt</code> 文件。</p><h5 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h5><p>由一组相似的记录组成，又称<strong>记录式文件</strong>。每条记录由若干个数据项组成，如数据库表文件。一般每条记录有一个数据项可作为<strong>关键字</strong>。根据各条记录的长度是否相等，可分为<strong>定长记录</strong>和<strong>可变长记录</strong>。</p><h5 id="有结构文件的逻辑结构"><a href="#有结构文件的逻辑结构" class="headerlink" title="有结构文件的逻辑结构"></a>有结构文件的逻辑结构</h5><img src="/blog/2021/01/16/文件管理（一）/有结构文件的逻辑结构.png" style="zoom:80%;"><h6 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h6><p>文件中记录连续排列（逻辑上），记录可以是<strong>定长</strong>或<strong>可变长</strong>的。各个记录再物理上可以是<strong>顺序存储</strong>或<strong>链式存储</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/顺序文件存储方式.png"><ul><li>串结构：记录之间的顺序与关键字无关。</li><li>顺序结构：记录之间的顺序按关键字顺序排列。</li></ul><img src="/blog/2021/01/16/文件管理（一）/顺序文件存储方式+结构.png" style="zoom:80%;"><p>结论：定长记录的顺序文件，若物理上采用顺序存储，可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索。</p><h6 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h6><p><strong>可变长记录</strong>文件时查找第 <code>i</code> 个记录必须先查找前 <code>i-1</code> 个记录，如何解决这个问题？</p><hr><p>索引表：<strong>定长记录</strong>的<strong>顺序文件</strong>，可以快速找到第 <code>i</code> 个记录对应的索引项。应用于对信息处理的及时性要求比较好的场合。</p><img src="/blog/2021/01/16/文件管理（一）/索引表.png" style="zoom:80%;"><h6 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h6><p>与索引文件不同的是，不对每个记录都建立索引表项，而是<strong>一组记录对应一个索引表项</strong>。下图中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不许眼按关键字排序。<strong>索引顺序文件指索引表中的项是按关键字排列的</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/索引顺序文件.png" style="zoom:80%;"><p><strong>多级索引顺序文件</strong></p><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。</p><img src="/blog/2021/01/16/文件管理（一）/多级索引顺序文件.png" style="zoom:80%;"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/16/文件管理（一）/文件的逻辑结构小结.png"><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><img src="/blog/2021/01/16/文件管理（一）/文件目录.png" style="zoom:80%;"><h5 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h5><img src="/blog/2021/01/16/文件管理（一）/文件控制块FCB.png" style="zoom:80%;"><p><strong>FCB</strong>的有序集合称为“文件目录”，一个<strong>FCB</strong>就是一个文件<strong>目录项</strong>。</p><p><strong>FCB</strong>包含了文件的基本信息（文件名、物理地址、逻辑地址、物理结构等），存储控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（文件的建立时间、修改时间等）。</p><p><strong>最基本的是</strong>：文件名、文件存放的物理地址。</p><p>对目录进行的操作：</p><ul><li>搜索：系统根据文件名搜索目录，找到该文件对应的目录项。</li><li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项。</li><li>删除文件：当删除一个文件时，需要在目录中删除对应的目录项。</li><li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性。</li><li>修改目录：目录中保存了某些文件属性，这些属性变化时需要修改相应的目录项（如文件重命名）。</li></ul><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><h6 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h6><p>实现了<strong>按名存取</strong>，但是<strong>不允许文件重名</strong>。不适合多用户操作系统</p><img src="/blog/2021/01/16/文件管理（一）/单级目录结构.png" style="zoom:80%;"><h6 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h6><p>分为<strong>主文件目录</strong>和<strong>用户文件目录</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/两级目录结构.png" style="zoom:80%;"><h6 id="多级目录结构（树形目录结构）"><a href="#多级目录结构（树形目录结构）" class="headerlink" title="多级目录结构（树形目录结构）"></a>多级目录结构（树形目录结构）</h6><p>文件路径名是个字符串，各级目录之间用”/“隔开， 从根目录出发的路径称为<strong>绝对路径</strong>。系统根据绝对路径一层一层的找到下一级目录。树形结构<strong>不利于实现文件共享</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/多级目录结构.png" style="zoom:80%;"><p><code>自拍.jpg</code>的绝对路径为<code>/照片/2015-0/自拍.jpg</code>。找到此文件需要3次读磁盘I/O操作。</p><p>每次从根目录查找很低效，可以设置<strong>当前目录</strong>，当用户访问某个文件时，可以使用<strong>从当前目录出发</strong>的<strong>相对路径</strong>。</p><h6 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h6><img src="/blog/2021/01/16/文件管理（一）/无环图目录结构.png" style="zoom:80%;"><p>用户提出删除节点时，只删除该用户的PCB，并使共享计数器减1，不会直接删去共享节点。只要共有计数器减为0时才删除节点。</p><h5 id="索引节点（FCB的改进）"><a href="#索引节点（FCB的改进）" class="headerlink" title="索引节点（FCB的改进）"></a>索引节点（FCB的改进）</h5><p>一般查找只需要用到<strong>文件名</strong>这个信息，文件名匹配时才需要读出文件的其他信息，所以可以使目录表包含最有用的信息来提高效率，如下图：</p><img src="/blog/2021/01/16/文件管理（一）/索引节点.png" style="zoom:80%;"><p>存放在<strong>外存</strong>的索引节点称为<strong>磁盘索引节点</strong>，当索引节点<strong>放入内存</strong>后称为<strong>内存索引节点</strong>。内存索引节点需要增加一些信息，如：文件是否被修改，此时有几个进程在访问该文件等。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/16/文件管理（一）/文件目录小结.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;初识文件管理&lt;/li&gt;
&lt;li&gt;文件的逻辑结构&lt;/li&gt;
&lt;li&gt;文件目录&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode947-移除最多的同行或同列石头</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/15/LeetCode947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/15/LeetCode947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/</id>
    <published>2021-01-15T14:06:08.000Z</published>
    <updated>2021-01-15T14:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p><p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p><p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [xi, yi]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p><a id="more"></a><img src="/blog/2021/01/15/LeetCode947-移除最多的同行或同列石头/947.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这个题的意思是：某行或者某列上最多只能存在一个石头，求移除的石头总数。</p><p>对于 <code>stones</code> 中任意两个位置，如果相对应的位置有一个相等，说明两个位置存在<strong>相同的</strong>行或者列，可以合并为一个集合。根据上述条件，使用双重循环将 <code>stones</code> 两两结合，最终合并的次数就是移除的石头个数，可以由 <code>stones</code> 的长度减去并查集中连通分量个数得到。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stones[i][<span class="number">0</span>] == stones[j][<span class="number">0</span>] || stones[i][<span class="number">1</span>] == stones[j][<span class="number">1</span>])</span><br><span class="line">                    uf.unionElem(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones.size() - uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为 <code>O(n^2)</code>。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>如果将 <code>stones</code> 中的位置与其相应的行或者列绑定，那么可以将二维降为一维，将行和列当作一个数字，降低了时间复杂度。</p><ul><li>当遍历到点 <code>[x,y]</code> 时，直接将 <code>x</code> 和 <code>y</code> 进行合并，表示该行和该列的点属于同一个并查集（根节点相同）。</li><li><code>x</code> 和 <code>y</code> 的值可能相等，相等时不能进行合并（一维情况下，行与列需要区分开），根据题目范围，将 <code>y</code> 加上10001，两者不会重合。</li></ul><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind():count(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当不存在p时，创建p并且指向自身，根节点数加1</span></span><br><span class="line">        <span class="keyword">if</span>(!parent.count(p))&#123;</span><br><span class="line">            parent[p] = p;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        unionFind uf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;stone : stones)&#123;</span><br><span class="line">            uf.unionElem(stone[<span class="number">0</span>], stone[<span class="number">1</span>] + <span class="number">10001</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones.size() - uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>题解：<a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。&lt;/p&gt;
&lt;p&gt;如果一块石头的 &lt;strong&gt;同行或者同列&lt;/strong&gt; 上有其他石头存在，那么就可以移除这块石头。&lt;/p&gt;
&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;stones&lt;/code&gt; ，其中 &lt;code&gt;stones[i] = [xi, yi]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 块石头的位置，返回 &lt;strong&gt;可以移除的石子&lt;/strong&gt; 的最大数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode684-冗余连接</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/13/LeetCode684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/13/LeetCode684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-01-13T03:10:42.000Z</published>
    <updated>2021-01-15T14:45:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对 <code>[u, v]</code>，满足 <code>u &lt; v</code>，表示连接顶点 <code>u</code> 和 <code>v</code> 的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p><a id="more"></a><img src="/blog/2021/01/13/LeetCode684-冗余连接/684.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>并查集中使用 <code>count</code> 记录当前还有多少个根节点，如果<strong>上一次的根节点数等于本次的根节点数</strong>，说明本次的合并无效，记录当前坐标即可。一次遍历结束后，找到了不需要进行合并的最后一个边。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 合并一次，根节点数减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(edges.size())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> pre; <span class="comment">// 上一次根节点数</span></span><br><span class="line">        <span class="keyword">int</span> index; <span class="comment">// 不需要合并的最后一个边的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            pre = uf.getCount();</span><br><span class="line">            uf.unionElem(edges[i][<span class="number">0</span>] - <span class="number">1</span>, edges[i][<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 上次根节点数等于本次合并后根节点数，更新index</span></span><br><span class="line">            <span class="keyword">if</span>(pre == uf.getCount()) index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在本问题中, 树指的是一个连通且无环的无向图。&lt;/p&gt;
&lt;p&gt;输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。&lt;/p&gt;
&lt;p&gt;结果图是一个以边组成的二维数组。每一个边的元素是一对 &lt;code&gt;[u, v]&lt;/code&gt;，满足 &lt;code&gt;u &amp;lt; v&lt;/code&gt;，表示连接顶点 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 的无向图的边。&lt;/p&gt;
&lt;p&gt;返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 &lt;code&gt;[u, v]&lt;/code&gt; 应满足相同的格式 &lt;code&gt;u &amp;lt; v&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1203-项目管理</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/12/LeetCode1203-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/12/LeetCode1203-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2021-01-12T14:53:37.000Z</published>
    <updated>2021-01-12T15:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>公司共有 <code>n</code> 个项目和  <code>m</code> 个小组，每个项目要不无人接手，要不就由 <code>m</code> 个小组之一负责。</p><p><code>group[i]</code> 表示第 <code>i</code> 个项目所属的小组，如果这个项目目前无人接手，那么 <code>group[i]</code> 就等于 <code>-1</code>。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。</p><p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p><p>同一小组的项目，排序后在列表中彼此相邻。<br>项目之间存在一定的依赖关系，我们用一个列表 <code>beforeItems</code> 来表示，其中 <code>beforeItems[i]</code> 表示在进行第 <code>i</code> 个项目前（位于第 <code>i</code> 个项目左侧）应该完成的所有项目。<br>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 <strong>空列表</strong> 。</p><a id="more"></a><img src="/blog/2021/01/12/LeetCode1203-项目管理/1203.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题是真的难，看了别人的题解才勉强写出来。</p><h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><p>在有向无环图（DAG）问题中，如果节点之间含有<strong>依赖关系</strong>，比如要完成 <code>B</code> 工作，必须先完成 <code>A</code> 工作，考虑进行<strong>拓扑排序</strong>，有关知识点参考<a href="https://www.cnblogs.com/bigsai/p/11489260.html" target="_blank" rel="noopener">这里</a>。</p><p><strong>C++模板</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图，节点入度，节点编号</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inDegree, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;id)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : id)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>; <span class="comment">// 记录已经出队多少个点，小于节点数说明有环</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; afterSort;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">// 取出第一个入度为0的点</span></span><br><span class="line">        <span class="keyword">int</span> cur = q.front();</span><br><span class="line">        afterSort.push_back(cur);</span><br><span class="line">        q.pop();</span><br><span class="line">        times++;</span><br><span class="line">        <span class="comment">// 遍历图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); ++i)&#123;</span><br><span class="line">            inDegree[G[cur][i]]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[G[cur][i]] == <span class="number">0</span>)</span><br><span class="line">                q.push(G[cur][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(times &lt; id.size()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> afterSort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关于本题"><a href="#关于本题" class="headerlink" title="关于本题"></a>关于本题</h5><p>从宏观来看，本题要求同一小组所处理的项目是相邻的，<strong>小组与小组之间</strong>是有依赖关系的，根据 <code>Before</code> 得到。同时，<strong>项目与项目之间</strong>也是有依赖关系的，也是由 <code>Before</code> 得到。以示例1为例：</p><ul><li>项目与项目之间：对于小组0，3必须在6之后，4必须在3和6之后。</li><li>小组与小组之间：小组-1中的1必须在小组0中的6之后。</li></ul><p>根据以上两条信息，可以先对所有小组进行拓扑排序，再对排好序的小组集合中的每个小组进行一个拓扑排序，就可以得到结果了。<strong>所有小组号为-1的表示当前未进行处理，可以给其分配一个新的组号，从m开始递增</strong>，只要拓扑排序时无环，所有的项目都会被处理掉。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortItems</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; group, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; beforeItems)</span></span>&#123;      </span><br><span class="line">        <span class="comment">// 将同一组的放一起</span></span><br><span class="line">        <span class="comment">// 比如3, 4, 6分组为0，则sameGroup[0] = &#123;3,4,6&#125;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">sameGroup</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> samegroup = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(group[i] == <span class="number">-1</span>) group[i] = samegroup++;</span><br><span class="line">            sameGroup[group[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最多会有n + m个小组（比如m=2, 所有分组都为-1）</span></span><br><span class="line">        <span class="comment">// n + m个小组的序号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; groupid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m; ++i) groupid.push_back(i);</span><br><span class="line">        <span class="comment">// 建立group图和item图及其入度</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">itemGraph</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">groupGraph</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">itemIndegree</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">groupIndegree</span><span class="params">(n + m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; beforeItems.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curId = group[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : beforeItems[i])&#123;</span><br><span class="line">                <span class="comment">// 如果是同一个组，那么有item-&gt;i</span></span><br><span class="line">                <span class="comment">// i入度+1，同时节点item可达i</span></span><br><span class="line">                <span class="keyword">if</span>(group[item] == curId)&#123; </span><br><span class="line">                    itemIndegree[i]++;</span><br><span class="line">                    itemGraph[item].push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不同组，有小组group[item]-&gt;curId</span></span><br><span class="line">                <span class="comment">// 小组curId入度+1，同时小组group[item]可达curId</span></span><br><span class="line">                <span class="keyword">else</span>&#123; </span><br><span class="line">                    groupIndegree[curId]++;</span><br><span class="line">                    groupGraph[group[item]].push_back(curId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对group图进行topSort，得到小组之间的拓扑关系</span></span><br><span class="line">        <span class="keyword">auto</span> outGroup = topSort(groupGraph, groupIndegree, groupid);</span><br><span class="line">        <span class="comment">// 对每个小组进行topSort，得到组内的拓扑关系</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;g : outGroup)&#123;</span><br><span class="line">            <span class="keyword">auto</span> id = sameGroup[g];</span><br><span class="line">            <span class="keyword">if</span>(id.empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> res = topSort(itemGraph, itemIndegree, id);</span><br><span class="line">            <span class="keyword">if</span>(res.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r : res)</span><br><span class="line">                ret.push_back(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数：图，入度，当前的节点集合</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inDegree, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;id)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : id)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>; <span class="comment">// 记录已经出队多少个点，小于id数说明有环</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; afterSort;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="comment">// 取出第一个入度为0的点</span></span><br><span class="line">            <span class="keyword">int</span> cur = q.front();</span><br><span class="line">            afterSort.push_back(cur);</span><br><span class="line">            q.pop();</span><br><span class="line">            times++;</span><br><span class="line">            <span class="comment">// 遍历图</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); ++i)&#123;</span><br><span class="line">                inDegree[G[cur][i]]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[G[cur][i]] == <span class="number">0</span>)</span><br><span class="line">                    q.push(G[cur][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times &lt; id.size()) <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 有环，返回空</span></span><br><span class="line">        <span class="keyword">return</span> afterSort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>题解：<a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/chao-xiang-xi-shuang-ceng-tuo-bu-pai-xu-5cyuc/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/chao-xiang-xi-shuang-ceng-tuo-bu-pai-xu-5cyuc/</a></p><p>拓扑排序：<a href="https://www.cnblogs.com/bigsai/p/11489260.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigsai/p/11489260.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;公司共有 &lt;code&gt;n&lt;/code&gt; 个项目和  &lt;code&gt;m&lt;/code&gt; 个小组，每个项目要不无人接手，要不就由 &lt;code&gt;m&lt;/code&gt; 个小组之一负责。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;group[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个项目所属的小组，如果这个项目目前无人接手，那么 &lt;code&gt;group[i]&lt;/code&gt; 就等于 &lt;code&gt;-1&lt;/code&gt;。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。&lt;/p&gt;
&lt;p&gt;请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：&lt;/p&gt;
&lt;p&gt;同一小组的项目，排序后在列表中彼此相邻。&lt;br&gt;项目之间存在一定的依赖关系，我们用一个列表 &lt;code&gt;beforeItems&lt;/code&gt; 来表示，其中 &lt;code&gt;beforeItems[i]&lt;/code&gt; 表示在进行第 &lt;code&gt;i&lt;/code&gt; 个项目前（位于第 &lt;code&gt;i&lt;/code&gt; 个项目左侧）应该完成的所有项目。&lt;br&gt;如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 &lt;strong&gt;空列表&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="拓扑排序" scheme="http://www.xingyuzhao.ltd/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1202-交换字符串中的元素</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/11/LeetCode1202-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/11/LeetCode1202-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2021-01-11T02:27:01.000Z</published>
    <updated>2021-01-11T03:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 <code>s</code>，以及该字符串中的一些「索引对」数组 <code>pairs</code>，其中 <code>pairs[i] = [a, b]</code> 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 <strong>任意多次交换</strong> 在 <code>pairs</code> 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，<code>s</code> 可以变成的按字典序最小的字符串。</p><a id="more"></a><img src="/blog/2021/01/11/LeetCode1202-交换字符串中的元素/1202.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><del>不看提示我都没想到用并查集去解决这个问题</del>。</p><p>以示例三为例：<code>s = &quot;cba&quot;, pairs = [[0,1],[1,2]]</code>，输出为 <code>&quot;abc&quot;</code>。可以看出 <code>pairs</code> 中 <code>0,1,2</code> 三个点是相连的。相连的点在 <code>s</code> 中对应的元素 <code>&quot;cba&quot;</code> 可以任意排序，我们需要让这些元素的组合字典序最小，可以得到 <code>&quot;abc&quot;</code>。</p><p>将上述例子扩充，<code>s = &quot;cbafd&quot;, pairs = [[0,1],[1,2],[4,3]]</code>，输出为 <code>&quot;abcdf&quot;</code>。其中 <code>0,1,2</code> 相连，<code>4,3</code> 相连，分别将两个集合中对应的位置<strong>升序排序</strong>得到 <code>0,1,2</code> 和 <code>3,4</code>，再将 <code>s</code> 中对应位置元素取出来按照<strong>字典序排序</strong>，再根据对应位置修改 <code>s</code> 中的元素。所以<strong>一共需要进行两次排序</strong>。</p><hr><p>我们将 <code>pairs</code> 中的<strong>每一个</strong>元素想象成一个孤立的点，对于 <code>pairs</code> 中的<strong>每一对</strong>元素，表示两个点相连，所有相连的点构成不同的集合（只需要知道是否相连，不需要知道如何相连），所以使用并查集即可。</p><p><strong>算法如下</strong>：</p><ul><li>将 <code>pairs</code> 中的<strong>每一对</strong>元素进行 <code>union</code> 操作，再将它们根据共同祖先分为<strong>若干集合</strong>。</li><li>将每个集合中的序列<strong>升序排列</strong>，再找到 <code>s</code> 中对应的元素，将这些元素按<strong>字典序</strong>排序。</li><li>将按字典序排列的元素按照集合中序列的顺序依次修改 <code>s</code>。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 未用到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>; <span class="comment">// 未用到</span></span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            rank[pRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pairs.size() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); ++i)&#123;</span><br><span class="line">            uf.unionElem(pairs[i][<span class="number">0</span>], pairs[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> rootIdx = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(s.size());</span><br><span class="line">        <span class="comment">// 如果祖先相同，代表在同一个集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> root = uf.find(i);</span><br><span class="line">            rootIdx[root].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rootIdx.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rootIdx[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将同一个祖先的序列升序排列</span></span><br><span class="line">            sort(rootIdx[i].begin(), rootIdx[i].end());</span><br><span class="line">            <span class="built_in">string</span> buf;</span><br><span class="line">            <span class="comment">// 根据排好序的序列取出s中的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : rootIdx[i])&#123;</span><br><span class="line">                buf += s[v];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再将取出的元素按照字典序排列</span></span><br><span class="line">            sort(buf.begin(), buf.end());</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将排好序的字符串根据排好序的序列修改s中相应的位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : rootIdx[i])&#123;</span><br><span class="line">                s[v] = buf[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，以及该字符串中的一些「索引对」数组 &lt;code&gt;pairs&lt;/code&gt;，其中 &lt;code&gt;pairs[i] = [a, b]&lt;/code&gt; 表示字符串中的两个索引（编号从 0 开始）。&lt;/p&gt;
&lt;p&gt;你可以 &lt;strong&gt;任意多次交换&lt;/strong&gt; 在 &lt;code&gt;pairs&lt;/code&gt; 中任意一对索引处的字符。&lt;/p&gt;
&lt;p&gt;返回在经过若干次交换后，&lt;code&gt;s&lt;/code&gt; 可以变成的按字典序最小的字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
