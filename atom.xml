<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>工欲善其事，必先利其器</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2022-07-17T13:20:14.270Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Zxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022-开始工作！</title>
    <link href="http://www.xingyuzhao.ltd/blog/2022/07/17/2022-%E5%BC%80%E5%A7%8B%E5%B7%A5%E4%BD%9C%EF%BC%81/"/>
    <id>http://www.xingyuzhao.ltd/blog/2022/07/17/2022-%E5%BC%80%E5%A7%8B%E5%B7%A5%E4%BD%9C%EF%BC%81/</id>
    <published>2022-07-17T13:02:59.000Z</published>
    <updated>2022-07-17T13:20:14.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="新的征程"><a href="#新的征程" class="headerlink" title="新的征程"></a>新的征程</h4><p>离开校园两周有余，步入工作已经一周了，不过只是进行培训，还未经受真正的“考验”。后半年是关键的半年，需要做好充分的计划并加以实施。</p><p>PS：博客已经半年多没更新了，这段时间也经历很多事，以后慢慢在写。</p><a id="more"></a><h4 id="大致轮廓"><a href="#大致轮廓" class="headerlink" title="大致轮廓"></a>大致轮廓</h4><p><strong>关于工作</strong></p><p>这个是目前最重要的，需要尽快的熟悉工作流程，熟悉相关知识等，还需要通过相应的考试，目标心里有底，在这里就不多说了，主要方面有：</p><ol><li>工作必备知识；</li><li>各种网课；</li><li>C语言；</li><li><strong>听从指挥</strong>。</li></ol><p>注意每种课程的规定时间，<strong>必须</strong>提前完成（在规定时间一半时完成80%及以上，3/4时完成）！如果回去晚了是自己的原因，不过也要安排好每日的任务，在每天早上制定相应的计划，完不成就别计划。</p><p><strong>关于学习</strong></p><p>与工作也不冲突，半年多没怎么刷题，还是懈怠了，虽然还是有一些客观原因影响，还是得抓起来，计划如下：</p><ol><li>年底力扣刷题数量1000+，每日一题尽量做（实在做不出来就算了）；</li><li>每两周至少参加一次周赛，锻炼限制时间做题的能力；</li><li>力扣积分冲到9000，换个东西去。</li></ol><p>后面想到什么再补充，今天写这些刚好熟悉一下上传的过程。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;新的征程&quot;&gt;&lt;a href=&quot;#新的征程&quot; class=&quot;headerlink&quot; title=&quot;新的征程&quot;&gt;&lt;/a&gt;新的征程&lt;/h4&gt;&lt;p&gt;离开校园两周有余，步入工作已经一周了，不过只是进行培训，还未经受真正的“考验”。后半年是关键的半年，需要做好充分的计划并加以实施。&lt;/p&gt;
&lt;p&gt;PS：博客已经半年多没更新了，这段时间也经历很多事，以后慢慢在写。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活随笔" scheme="http://www.xingyuzhao.ltd/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="计划" scheme="http://www.xingyuzhao.ltd/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>C++学习路线</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/11/24/C-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/11/24/C-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2021-11-24T15:51:27.000Z</published>
    <updated>2021-11-24T15:56:20.183Z</updated>
    
    <content type="html"><![CDATA[<p>这一年学习C++的路线，供参考。</p><a id="more"></a><h3 id="C-学习路线"><a href="#C-学习路线" class="headerlink" title="C++学习路线"></a>C++学习路线</h3><h4 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h4><ol><li>C++ Primer</li><li>Effective C++</li><li>STL 源码剖析（建议视频课程结合）</li></ol><h4 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h4><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><ol><li>基础部分：玩转数据结构，从入门到进阶（Java）</li><li>进阶：算法与数据结构（C++）</li><li>面试：玩转算法面试（C++）</li></ol><p>网址：<a href="https://www.imooc.com/t/108955" target="_blank" rel="noopener">https://www.imooc.com/t/108955</a></p><p>参考书籍：算法 4。</p><h5 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h5><p><strong>LeetCode 专栏（先思考最多20分钟，再看答案，主要是实现思路）</strong></p><ol><li>数组</li><li>链表</li><li>队列 &amp; 栈（包括深度优先搜索 DFS 和广度优先搜索 BFS）</li><li>二分查找</li><li>递归（包括回溯算法）</li><li>二叉树</li><li>哈希表</li></ol><p><strong>LeetCode 剑指offer</strong></p><p><strong>LeetCode Top100</strong></p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><ol><li><p>计算机网络，谢希仁（主要是 TCP/IP）</p></li><li><p>图解 HTTP</p></li><li><p>TCP-IP 详解卷一：协议*</p></li></ol><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>王道操作系统考研课：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=58" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1YE411D7nH?p=58</a></p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ol><li>尚硅谷数据库：<a href="https://www.bilibili.com/video/BV12b411K7Zu?from=search&amp;seid=11827868485839167645&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12b411K7Zu?from=search&amp;seid=11827868485839167645&amp;spm_id_from=333.337.0.0</a></li><li>知识点：<a href="https://space.bilibili.com/526653251/video?tid=0&amp;page=1&amp;keyword=&amp;order=pubdate" target="_blank" rel="noopener">https://space.bilibili.com/526653251/video?tid=0&amp;page=1&amp;keyword=&amp;order=pubdate</a></li><li>MySQL技术内幕  InnoDB存储引擎  第2版</li><li>MySQL必知必会（当一个查询手册使用）</li></ol><h4 id="LINUX及网络编程"><a href="#LINUX及网络编程" class="headerlink" title="LINUX及网络编程"></a>LINUX及网络编程</h4><ol><li>Linux 高性能服务器编程（必看）</li><li>鸟哥的 LINUX 私房菜（挑需要的看）</li><li>常用的命令</li></ol><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><p>WebServer：<a href="https://gitee.com/settlezxy/web-server" target="_blank" rel="noopener">https://gitee.com/settlezxy/web-server</a></p><ol><li>原始版本 ：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxNzU2MzcwMw==&action=getalbum&album_id=1339230165934882817&scene=173&from_msgid=2649274288&from_itemidx=4&count=3&nolastread=1#wechat_redirect" target="_blank" rel="noopener">#Web服务器-原始版本 (qq.com)</a></li><li>C++11 版本：见 gitee</li></ol><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程*"></a>多线程*</h4><p>C++ 并发编程实战</p><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式*"></a>设计模式*</h4><p><a href="https://blog.csdn.net/a834595603/article/details/92706657" target="_blank" rel="noopener">https://blog.csdn.net/a834595603/article/details/92706657</a></p><p>常用的几个：</p><ol><li>单例模式（饱汉（线程安全/不安全），饿汉）</li><li>工厂模式</li></ol><h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><p>链接：<a href="https://pan.baidu.com/s/1qjBpgHIxMQmbSKKN2jnvDQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1qjBpgHIxMQmbSKKN2jnvDQ</a><br>提取码：3du5</p><p>更多：<a href="https://github.com/iamshuaidi/CS-Book" target="_blank" rel="noopener">https://github.com/iamshuaidi/CS-Book</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一年学习C++的路线，供参考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器编程（16-17）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/10/08/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BC%8816-17%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/10/08/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BC%8816-17%EF%BC%89/</id>
    <published>2021-10-08T01:51:45.000Z</published>
    <updated>2021-10-08T02:02:19.947Z</updated>
    
    <content type="html"><![CDATA[<p>Linux高性能服务器编程（16-17）</p><a id="more"></a><h3 id="第16章-服务器调制、调试和测试"><a href="#第16章-服务器调制、调试和测试" class="headerlink" title="第16章 服务器调制、调试和测试"></a>第16章 服务器调制、调试和测试</h3><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/16章概述.png"><h4 id="16-1-最大文件描述符数"><a href="#16-1-最大文件描述符数" class="headerlink" title="16.1 最大文件描述符数"></a>16.1 最大文件描述符数</h4><p>Linux 对应用程序能打开的最大文件描述符数量有两个层次的限制：</p><ol><li>用户级限制：目标用户运行的所有进程总共能打开的文件描述符数。</li><li>系统级限制：所有用户总共能打开的文件描述符数。</li></ol><p>最常用的查看用户级文件描述符限制的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n</span><br></pre></td></tr></table></figure><p>可以通过以下方式临时将用户级文件描述符限制设定为 <code>max-file-number</code>，仅在当前 session 有效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -SHn max-file-number // max-file-number是一个自己定的数</span><br></pre></td></tr></table></figure><p>如果要永久修改用户级文件描述符数限制，可以在 <code>/etc/security/limits.conf</code> 文件中加入如下两项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* hard nofile max-file-number // 系统的硬限制</span><br><span class="line">* soft nofile max-file-number // 软限制</span><br></pre></td></tr></table></figure><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/修改系统级文件描述符限制.png"><h4 id="16-2-调整内核参数"><a href="#16-2-调整内核参数" class="headerlink" title="16.2 调整内核参数"></a>16.2 调整内核参数</h4><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/内核参数.png"><h5 id="16-2-1-proc-sys-fs-目录下的部分文件"><a href="#16-2-1-proc-sys-fs-目录下的部分文件" class="headerlink" title="16.2.1 /proc/sys/fs 目录下的部分文件"></a>16.2.1 /proc/sys/fs 目录下的部分文件</h5><p>该目录下的内核参数都与文件系统相关。对于服务器来说，其中最重要的是如下两个参数：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/fs修改.png"><h5 id="16-2-2-proc-sys-net-目录下的部分文件"><a href="#16-2-2-proc-sys-net-目录下的部分文件" class="headerlink" title="16.2.2 /proc/sys/net 目录下的部分文件"></a>16.2.2 /proc/sys/net 目录下的部分文件</h5><p>该目录下是内核中网络模块的相关参数，其中 TCP/IP 协议相关的参数主要位于如下三个子目录中：core、ipv4、ipv6。现在再总结以下和服务器性能相关的部分参数：<br><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/内核网络模块参数.png"></p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/内核网络模块参数1.png" style="zoom:95%;"><p>也可以用 <code>sysctl</code> 命令来修改它们。（SYN风暴）</p><p>以上两种修改方式都是临时的。永久的修改方法是在 <code>/etc/sysctl.conf</code> 文件中加入相应网络参数及其数值，并执行 <code>sysctl -p</code> 使之生效，就像修改系统最大允许打开的文件描述符那样。</p><h4 id="16-3-gdb-调试"><a href="#16-3-gdb-调试" class="headerlink" title="16.3 gdb 调试"></a>16.3 gdb 调试</h4><h5 id="16-3-1-用-gdb-调试多进程程序"><a href="#16-3-1-用-gdb-调试多进程程序" class="headerlink" title="16.3.1 用 gdb 调试多进程程序"></a>16.3.1 用 gdb 调试多进程程序</h5><p>如果一个进程通过 <code>fork</code> 系统调用创建了子进程，gdb 会继续调试原来的进程，子进程则正常运行。调试子进程常用的方法有如下两种：</p><ol><li>单点调试子进程</li></ol><p>如果要调试一个子进程，我们可以先运行服务器，然后找到目标子进程的 PID，再将其附加（attach）到 gdb 调试器上，具体操作见 P327。</p><ol start="2"><li>使用调试器选项 follow-fork-mode</li></ol><p>gdb 调试器的选项 follow-fork-mode 允许为我们选择程序再执行 <code>fork</code> 系统调用后是继续调试父进程还是调试子进程。其使用方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set follow-fork-mode mode</span><br></pre></td></tr></table></figure><p>其中，mode 的可选值是 parent 和 child，分别表示调试父进程和子进程。</p><h5 id="16-3-2-用-gdb-调试多线程程序"><a href="#16-3-2-用-gdb-调试多线程程序" class="headerlink" title="16.3.2 用 gdb 调试多线程程序"></a>16.3.2 用 gdb 调试多线程程序</h5><p>gdb 有一组命令可辅助多线程程序的调试。下面是一些常用的命令：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/gdb多线程.png"><h4 id="16-4-压力测试"><a href="#16-4-压力测试" class="headerlink" title="16.4 压力测试"></a>16.4 压力测试</h4><p>单纯的 I/O 复用方式的施压程度是最高的，因为线程和进程的调度本身也是要占用一定 CPU 时间的。</p><h3 id="第17章-系统监测工具"><a href="#第17章-系统监测工具" class="headerlink" title="第17章 系统监测工具"></a>第17章 系统监测工具</h3><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/系统监测工具.png"><h4 id="17-1-tcpdump"><a href="#17-1-tcpdump" class="headerlink" title="17.1 tcpdump"></a>17.1 tcpdump</h4><p>tcpdump 给使用者提供了大量的选项，用以过滤数据包或者定制输出格式。现在我们把常见的选项总结如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/tcpdump.png"><p>除了使用选项外，tcpdump  还支持用表达式来进一步过滤数据包。tcpdump 表达式的操作数分为 3 种：类型（type）、方向（dir）和协议（proto）。如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/tcpdump操作数.png"><ul><li>还可以使用逻辑操作符来组织上述操作数以创建更复杂的表达式，tcpdump 支持的逻辑操作符和编程语言中的逻辑操作符完全相同，如 <code>&amp;&amp;,||,!</code> 等。</li><li>如果表达式比较复杂，可以使用括号将它们分组。在使用括号时，要么使用反斜杠 ”\“ 对它转义，要么用单引号将其括住，以避免它被 shell 所解释。</li><li>此外，tcpdump 还允许直接使用数据包中的部分协议字段的内容来过滤数据包。比如，仅抓取 TCP 同步报文段，可使用 <code>tcpdump &#39;tcp[13] &amp; 2 != 0&#39;</code>，这是因为 TCP 头部的第 14 个字节的第 2 个位正式同步标志。</li></ul><h4 id="17-2-lsof"><a href="#17-2-lsof" class="headerlink" title="17.2 lsof"></a>17.2 lsof</h4><p>lsof（list open file）是一个列出当前系统打开的文件描述符的工具。通过它我们可以了解感兴趣的进程打开了哪些文件描述符，或者我们感兴趣的文件描述符被哪些进程打开了。</p><p>lsof 命令常用的选项包括：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/lsof.png"><h4 id="17-3-nc"><a href="#17-3-nc" class="headerlink" title="17.3 nc"></a>17.3 nc</h4><p>nc（netcat）主要用来快速构建网络连接。我们可以让它以服务器方式运行，监听某个端口并接收客户连接，因此它可用来调试客户端程序。</p><p>我们也可以使之以客户端方式运行，向服务器发起连接并收发数据，因此它可以用来调试服务器程序，此时它有点像 telnet 程序。</p><p>nc 命令常用的选项包括：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/nc.png"><h4 id="17-4-strace"><a href="#17-4-strace" class="headerlink" title="17.4 strace"></a>17.4 strace</h4><p>strace 是测试服务器性能的重要工具。它跟踪程序运行过程中执行的系统调用和接收到的信号，并将系统调用名、参数、返回值及信号名输出到标准输出或者指定的文件。</p><p>strace 命令常用的选项包括：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/strace.png"><h4 id="17-5-netstat"><a href="#17-5-netstat" class="headerlink" title="17.5 netstat"></a>17.5 netstat</h4><p>netstat 是一个功能很强大的网络信息统计工具。它可以打印本地网卡接口上的全部连接、路由表信息、网卡接口信息等。本书主要是利用上述功能的第一个。因为要获得路由表信息和网卡接口信息，我们可以使用输出内容更丰富的 route 和 ifconfig 命令。</p><p>netstat 命令常用的选项包括：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/netstat1.png"><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/netstat2.png"><h4 id="17-6-vmstat"><a href="#17-6-vmstat" class="headerlink" title="17.6 vmstat"></a>17.6 vmstat</h4><p>vmstat（virtual memory statistics），它能实时输出系统的各种资源的使用情况，比如进程信息、内存使用、CPU 使用率以及 I/O 使用情况。</p><p>vmstat 命令常用的选项和参数包括：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/vmstat.png"><p>默认情况下，vmstat 输出的内容相当丰富，示例如下：<br><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/vmstat示例.png"></p><h4 id="17-7-ifstat"><a href="#17-7-ifstat" class="headerlink" title="17.7 ifstat"></a>17.7 ifstat</h4><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/ifstat.png"><p>举例来说，我们在测试机器 ernest-laptop 上执行如下命令：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/ifstat示例.png"><h4 id="17-8-mpstat"><a href="#17-8-mpstat" class="headerlink" title="17.8 mpstat"></a>17.8 mpstat</h4><p>mpstat（multi-processer statistics），它能实时检测多处理器系统上每个 CPU 的使用情况。mpstat 命令和 iostat 命令通常都继承在包 sysstat 中，安装 sysstat 即可获得这两个命令。mpstat 命令的典型用法是：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（16-17）/mpstat.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux高性能服务器编程（16-17）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.xingyuzhao.ltd/categories/Linux/"/>
    
    
      <category term="高性能服务器" scheme="http://www.xingyuzhao.ltd/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器编程（13-15）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/10/08/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BC%8813-15%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/10/08/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BC%8813-15%EF%BC%89/</id>
    <published>2021-10-08T01:51:33.000Z</published>
    <updated>2021-10-08T02:21:24.647Z</updated>
    
    <content type="html"><![CDATA[<p>Linux高性能服务器编程（13-15）</p><a id="more"></a><h3 id="第13章-多进程编程"><a href="#第13章-多进程编程" class="headerlink" title="第13章 多进程编程"></a>第13章 多进程编程</h3><p>本章包括以下内容：</p><ul><li>复制进程映像的 fork 系统调用和替换进程映像的 exec 系列系统调用。</li><li>僵尸进程以及如何避免僵尸进程。</li><li>进程间通信（Inter-Process Communication，IPC）最简单的方式：管道。</li><li>3 种 System V 进程间通信方式：信号量、消息队列和共享内存。</li><li>在进程间传递文件描述符的通用方法：通过 UNIX 本地域 socket 传递特殊的辅助数据。</li></ul><h4 id="13-1-fork-系统调用"><a href="#13-1-fork-系统调用" class="headerlink" title="13.1 fork 系统调用"></a>13.1 fork 系统调用</h4><p>Linux 下创建新进程的系统调用是 fork。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的每次调用都返回两次：</p><ul><li>在父进程中返回的是子进程的 PID</li><li>在子进程中则返回 0</li></ul><p>该返回值是后续代码判断当前进程是父进程还是子进程的依据。fork 调用失败时返回 -1，并设置 errno。</p><h4 id="13-2-exec-系列系统调用"><a href="#13-2-exec-系列系统调用" class="headerlink" title="13.2 exec 系列系统调用"></a>13.2 exec 系列系统调用</h4><p> 有时需要在子进程中执行其他程序，即替换当前进程映像，这就需要使用如下 exec 系列函数之一：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/exec.png"><h4 id="13-4-处理僵尸进程"><a href="#13-4-处理僵尸进程" class="headerlink" title="13.4 处理僵尸进程"></a>13.4 处理僵尸进程</h4><p>多进程程序中，父进程一般需要跟踪子进程的退出状态。<strong>因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项</strong>，以满足父进程后续对该子进程退出信息的查询（如果父进程还在运行）。<strong>在子进程结束运行之后，父进程读取其退出状态之前，我们称该子进程处于僵尸态</strong>。</p><p>另一种使子进程进入僵尸态的情况是：<strong>父进程结束或异常终止，而子进程继续运行。</strong>此时子进程的 <code>PPID</code> 将被操作系统设置为 1，<strong>即 <code>init</code> 进程</strong>。<code>init</code> 进程接管了该子继承，并等待它结束。<strong>在父进程退出之后，子进程退出之前，该子进程处于僵尸态（孤儿进程）。</strong></p><p>下面这对函数在父进程中调用，以等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程的产生，或者使子进程的僵尸态立即结束：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">( <span class="keyword">int</span>* stat_loc )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">( <span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* stat_loc, <span class="keyword">int</span> options )</span></span>;</span><br></pre></td></tr></table></figure><p><code>wait</code> 函数将阻塞进程，直到该进程的某个子进程结束运行为止，它返回结束运行的子进程的 PID，并将该子进程的退出状态信息存储于 stat_loc 参数指向的内存中，以下是几个宏定义帮助解释子进程退出状态信息：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/子进程状态信息.png" style="zoom:80%;"><p><strong>waitpid</strong></p><p><code>wait</code> 函数的阻塞特性不是服务器程序所期望的，而 <code>waitpid</code> 解决了这个问题。</p><p><code>waitpid</code> 只等待由 pid 参数指定的子进程，如果 pid 取值为 -1，那么它就和 <code>wait</code> 函数相同，即等待任意一个子进程结束。stat_loc 参数的含义和 <code>wait</code> 函数的 stat_loc 参数相同。 options 参数可以控制 <code>waitpid</code> 的行为。<strong>当 options 取值为 WNOHANG 时，<code>waitpid</code> 调用将是非阻塞的：</strong></p><ul><li>如果 pid 指定的目标子进程还没有结束或意外终止，则 <code>waitpid</code> 立即返回 0；</li><li>如果目标子进程确实正常退出，则 <code>waitpid</code> 但会该子进程的 PID；</li><li><code>waitpid</code> 调用失败时返回 -1，并设置 errno。</li></ul><p><strong>当一个进程结束时，它将给其父进程发送一个 SIGCHLD 信号。</strong>因此，我们可以在父进程中捕获 SIGCHLD 信号，并在信号处理函数中调用 <code>waitpid</code> 函数以”彻底结束“一个子进程。如下代码清单：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/SIGCHLD信号的典型处理函数.png"><h4 id="13-4-管道"><a href="#13-4-管道" class="headerlink" title="13.4 管道"></a>13.4 管道</h4><p>管道能在父、子进程间传递数据，利用的是 fork 调用之后两个管道文件描述符都保持打开。一对描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须有一个关闭 <code>fd[0]</code>，一个关闭 <code>fd[1]</code>。比如：父进程通过管道向子进程写数据，如下图：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/父进程通过管道向子进程写数据.png"><p>不过，<strong>管道只能用于有关联的两个进程间的通信。</strong>而 3 种类 System V IPC 能用于无关联的多个进程之间的通信。</p><p>还有一种特殊的管道称为 FIFO，也成为<strong>命名管道</strong>，可用于无关联进程之间的通信。网络编程中用的不多。</p><h4 id="13-5-信号量"><a href="#13-5-信号量" class="headerlink" title="13.5 信号量"></a>13.5 信号量</h4><h5 id="13-5-1-信号量原语"><a href="#13-5-1-信号量原语" class="headerlink" title="13.5.1 信号量原语"></a>13.5.1 信号量原语</h5><p>临界区/关键代码区：任一时刻只有一个进程可以进入。</p><p>假设有信号量 SV，则对它的 P（wait）、V（signal） 操作含义如下：</p><ul><li>P(SV)：如果 SV 的值大于 0，就将其减 1；如果 SV 的值为 0，则挂起进程的执行。</li><li>V(SV)：如果有其他进程因为等待 SV 而挂起，则唤醒之；如果没有，则将 SV 加1。</li></ul><h5 id="13-5-2-semget-系统调用"><a href="#13-5-2-semget-系统调用" class="headerlink" title="13.5.2 semget 系统调用"></a>13.5.2 semget 系统调用</h5><p><code>semget</code> 系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>key：键值，<strong>用来标识一个全局唯一的信号量集</strong>，就像文件名全局唯一地标识一个文件一样。要通过信号量通信的进程需要使用相同地键值来创建/获取该信号量。</li><li>num_sems：指定要创建/获取的信号量集中<strong>信号量的数目</strong>。如果是创建信号量，则该值必须被指定；如果是获取已经存在的信号量，则可以把它设置成 0。</li><li>sem_flag：指定一组标志。它低端的 9 个比特是该信号量的权限，其格式和含义都与系统调用 open 和 mode 参数相同。</li></ul><p><code>semget</code> 成功时返回一个正整数值，它时信号量集的标识符；<code>semget</code> 失败时返回 -1，并设置 errno。</p><h5 id="13-5-3-semop-系统调用"><a href="#13-5-3-semop-系统调用" class="headerlink" title="13.5.3 semop 系统调用"></a>13.5.3 semop 系统调用</h5><p><code>semop</code> 系统调用改变信号量的值，即执行P、V操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">( <span class="keyword">int</span> sem_id, struct sembuf* sem_ops, <span class="keyword">size_t</span> num_sem_ops )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>sem_id：由 <code>semget</code> 调用返回的信号量集标识符，用以指定被操作的目标信号量集。</p></li><li><p>sem_ops：指向一个 <code>sembuf</code> 结构体类型的数组，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> short <span class="keyword">int</span> sem_num; <span class="comment">// 信号量集合中信号量的编号，0是第一个</span></span><br><span class="line">short <span class="keyword">int</span> sem_op; <span class="comment">// 指定操作类型，其可选值为正整数、0和负整数。每种类型的操作的行为又收到sem_flag 成员的影响。</span></span><br><span class="line">short <span class="keyword">int</span> sem_flg; <span class="comment">// IPC_NOWAIT/SEM_UNDO</span></span><br><span class="line">    <span class="comment">// IPC_NOWAIT：无论信号量操作是否成功，semop调用都将立即返回，类似于非阻塞I/O操作</span></span><br><span class="line">    <span class="comment">// SEM_UNDO：当进程退出时取消正在进行的semop操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>num_sem_ops：指定要执行的操作个数，即 sem_ops 数组中元素的个数。</p></li></ul><p><code>semop</code> 成功时返回 0，失败在返回 -1 并设置 errno。失败时 sem_ops 数组中指定的所有操作都不被执行。</p><h5 id="13-5-4-semctl-系统调用"><a href="#13-5-4-semctl-系统调用" class="headerlink" title="13.5.4 semctl 系统调用"></a>13.5.4 semctl 系统调用</h5><p><code>semctl</code> 系统调用允许调用者对信号量进行直接控制。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">( <span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ... )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sem_id：由 <code>semget</code> 调用返回的信号量集标识符，用以指定被操作的目标信号量集。</li><li>sem_num：指定被操作的信号量在信号量几种的编号。</li><li>command：指定要执行的命令。</li><li>第四个参数的类型由用户自己定义，但 <code>sys/sem.h</code> 头文件给出了它的推荐格式。</li></ul><h5 id="13-5-5-特殊键值-IPC-PRIVATE"><a href="#13-5-5-特殊键值-IPC-PRIVATE" class="headerlink" title="13.5.5 特殊键值 IPC_PRIVATE"></a>13.5.5 特殊键值 IPC_PRIVATE</h5><p><code>semget</code>调用者可给其 key 参数传递 IPC_PRIVATE（其值为 0），无论该信号量是否已经存在，<code>semget</code> 都将创建一个新的信号量。此名称具有误导性，非进程私有。其他进程，尤其是子进程也有方法来访问这个信号量。</p><h4 id="13-6-共享内存"><a href="#13-6-共享内存" class="headerlink" title="13.6 共享内存"></a>13.6 共享内存</h4><p><strong>共享内存是最高效的 IPC 机制，</strong>因为其不涉及进程之间的任何数据传输。不过其通常和其他进程间通信方式一起使用，否则会缠身竞态条件。</p><p>Linux 共享内存的 API 都定义在 <code>sys/shm.h</code> 头文件中，包括 4 个系统调用：<code>shmget</code>、<code>shmat</code>、<code>shmdt</code> 和 <code>shmctl</code>。</p><h5 id="13-6-1-shmget-系统调用"><a href="#13-6-1-shmget-系统调用" class="headerlink" title="13.6.1 shmget 系统调用"></a>13.6.1 shmget 系统调用</h5><p><code>shmget</code> 系统调用创建一段新的共享内存，或者获取一段已经存在的共享内存。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span> <span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>key：键值，用来标识一段全局唯一的共享内存。</p></li><li><p>size：指定共享内存的大小，单位是字节。如果是创建新的共享内存，则 size 值必须指定。如果是获取已经存在的共享内存，则可以把 size 设置为 0。</p></li><li><p>shmflg：与 <code>semget</code> 系统调用的 <code>sem_flg</code> 参数相同，成功是返回一个正整数，它是共享内存的标识符，<code>shmget</code> 失败时返回 -1，并设置 errno。不过 <code>shmget</code> 支持两个额外的标志，如下所示：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shmget额外标志.png"></li></ul><p>如果 <code>shmget</code> 用于创建共享内存，则这段共享内存的所有字节都被初始化为 0，与之关联的内核数据结构 <code>shmid_ds</code> 将被创建并初始化，其结构体定义如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shmid_ds0.png"><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shmid_ds1.png"><p><code>shmget</code> 对 <code>shmid_ds</code> 结构体的初始化包括：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shmid_ds初始化.png" style="zoom:80%;"><h5 id="13-6-2-shmat-和-shmdt-系统调用"><a href="#13-6-2-shmat-和-shmdt-系统调用" class="headerlink" title="13.6.2 shmat 和 shmdt 系统调用"></a>13.6.2 shmat 和 shmdt 系统调用</h5><p>共享内存被创建/获取之后，我们不能立即访问它，而是①需要先将它关联到进程的地址空间中。②使用完共享内存之后，需要将它从进程地址空间中分离。使用如下两个系统调用实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">shmat</span><span class="params">( <span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span>* shm_addr, <span class="keyword">int</span> shmflg )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span>* shm_addr )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>shm_id：<code>shmget</code> 调用返回的共享内存标识符。</p></li><li><p>shm_addr：指定将共享内存关联到进程的哪块地址空间，最终的效果还受到 <code>shmflg</code> 参数的可选标志 SHM_RND 的影响：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/SHM_RND.png"></li></ul><p>除了 SHM_END 标志外，<code>shmget</code> 参数还支持如下标志：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shmflg1.png"><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shmflg2.png"><p><strong>shmat</strong></p><p>成功返回共享内存被关联到的地址，失败时返回 <code>(void*)-1</code> 并设置 errno，<code>shmat</code> 成功时，将修改内核数据结构 <code>shmid_ds</code> 的部分字段，如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shmat.png"><p><strong>shmdt</strong></p><p>将关联到 shm_addr 处的共享内存从进程中分离。它成功时返回 0，失败时返回 -1 并设置 errno。<code>shmdt</code> 在成功调用时将修改内核数据结构 <code>shmid_ds</code> 的部分字段，如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shmdt.png"><h5 id="13-6-3-shmctl-系统调用"><a href="#13-6-3-shmctl-系统调用" class="headerlink" title="13.6.3 shmctl 系统调用"></a>13.6.3 shmctl 系统调用</h5><p><code>shmctl</code> 系统调用控制共享内存的某些属性。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">( <span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds* buf )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>shm_id：<code>shmget</code> 调用返回的共享内存标识符。</li><li>command：指定要执行的命令。如下表：</li></ul><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shmctl命令.png"><p><code>shmctl</code> 成功时的返回值取决于 command 参数，如上表所示。失败时返回 -1，并设置 errno。</p><h5 id="13-6-4-共享内存的-POSIX-方法"><a href="#13-6-4-共享内存的-POSIX-方法" class="headerlink" title="13.6.4 共享内存的 POSIX 方法"></a>13.6.4 共享内存的 POSIX 方法</h5><p>通过打开同一个文件，<code>mmap</code> 可以实现无关进程之间的内存共享。Linux 提供了另外一种利用 <code>mmap</code> 在无关进程之间共享内存的方式，这种方式无须任何文件的支持，但它需要先使用如下函数来创建或打开一个 POSIX 共享内存对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#inculde <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#inculde <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_open</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode )</span></span>;</span><br></pre></td></tr></table></figure><p><code>shm_open</code> 的使用方法与 <code>open</code> 系统调用完全相同。</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/shm_open.png"><p><code>shm_open</code> 调用成功时返回一个文件描述符。该文件描述符可用于后续的 <code>mmap</code> 调用，从而将共享内存关联到调用进程。<code>shm_open</code> 失败时返回 -1，并设置 errno。</p><p><strong><code>shm_open</code> 创建的共享内存对象使用完之后也需要被删除</strong>。这个过程是通过如下函数实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#inculde <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#inculde <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_unlink</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure><p>该函数将 name 参数指定的共享内存对象标记为等待删除。当所有使用该共享内存对象的进程都使用 ummap 将它从进程种分离之后，系统将销毁这个共享内存对象所占据的资源。</p><p><strong>如果代码中使用了上述 POSIX 共享内存函数，则编译时候需要指定链接选项 -lrt 。</strong></p><h5 id="13-6-5-共享内存示例"><a href="#13-6-5-共享内存示例" class="headerlink" title="13.6.5 共享内存示例"></a>13.6.5 共享内存示例</h5><h4 id="13-7-消息队列"><a href="#13-7-消息队列" class="headerlink" title="13.7 消息队列"></a>13.7 消息队列</h4><p>消息队列是在两个进程之间传递二进制数据的一种简单有效的方式。<strong>每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据</strong>，而不一定像管道和命名管道那样必须以先进先出地方式接收数据。</p><p>Linux 消息队列的 API 都定义在 <code>sys/msg.h</code> 头文件中，包括 4 个系统调用：<code>msgget</code>、<code>msgsnd</code>、<code>msgrcv</code> 和 <code>msgctl</code> 。</p><h5 id="13-7-1-msgget-系统调用"><a href="#13-7-1-msgget-系统调用" class="headerlink" title="13.7.1 msgget 系统调用"></a>13.7.1 msgget 系统调用</h5><p><code>msgget</code> 系统调用创建一个消息队列，或者获取一个已有的消息队列。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">( <span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>key：键值，用来标识一个全局唯一的消息队列。</li><li>msgflag：与 <code>semget</code> 系统调用的 sem_flag 参数相同。</li></ul><p><code>msgget</code> 成功时返回一个正整数值，它是消息队列的标识符。<code>msgget</code> 失败时返回 -1，并设置 errno。</p><p>如果 <code>msgget</code> 用于创建消息队列，则与之关联的内核数据结构 <code>msqid_ds</code> 将被创建并初始化。<code>msqid_ds</code> 结构体的定义如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/msqid_ds.png"><h5 id="13-7-2-msgsnd-系统调用"><a href="#13-7-2-msgsnd-系统调用" class="headerlink" title="13.7.2 msgsnd 系统调用"></a>13.7.2 msgsnd 系统调用</h5><p><code>msgsnd</code> 系统调用把一条消息添加到消息队列中。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">( <span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span>* msg_ptr, <span class="keyword">size_t</span> msg_sz, <span class="keyword">int</span> msgflg )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>msqid：由 <code>msgget</code> 调用返回的消息队列标识符。</li><li>msg_ptr：指向一个准备发送的消息，消息必须被定义为如下类型：<img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/msgbuf.png" style="zoom:120%;">* mtype：指定消息的类型，正整数。* mtext：消息数据。</li><li>msg_sz：消息的数据部分（mtext）的长度。为 0 表示无数据。</li><li>msgflag：控制 <code>msgsnd</code> 行为，通常只支持 IPC_NOWAIT 标志，即以非阻塞的方式发送消息。</li></ul><p>默认情况下，发送消息时如果消息队列满了，则 <code>msgsnd</code> 将阻塞。若 IPC_NOWAIT 标志被指定，则 <code>msgsnd</code> 将立即返回并设置 errno 为 EAGAIN。</p><p>处于阻塞状态的 <code>msgsnd</code> 调用可能被如下两种异常情况所中断：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/msgsnd阻塞.png"><h5 id="13-7-3-msgrcv-系统调用"><a href="#13-7-3-msgrcv-系统调用" class="headerlink" title="13.7.3 msgrcv 系统调用"></a>13.7.3 msgrcv 系统调用</h5><p><code>msgrcv</code> 系统调用从消息队列中获取消息。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">( <span class="keyword">int</span> msqid, <span class="keyword">void</span>* msg_ptr, <span class="keyword">size_t</span> msg_sz, <span class="keyword">long</span> <span class="keyword">int</span> msgtype, <span class="keyword">int</span> msgflg )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>msqid：由 <code>msgget</code> 调用返回的消息队列标识符。</li><li>msg_ptr：用于存储接收的消息。</li><li>msg_sz：消息数据部分的长度。</li><li>msgtype：指定接收何种类型的消息。</li></ul><h5 id="13-7-4-msgctl-系统调用"><a href="#13-7-4-msgctl-系统调用" class="headerlink" title="13.7.4 msgctl 系统调用"></a>13.7.4 msgctl 系统调用</h5><p><code>msgctl</code> 系统调用控制消息队列的某些属性，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">( <span class="keyword">int</span> msqid, <span class="keyword">int</span> command, struct msqid_ds* buf )</span></span>;</span><br></pre></td></tr></table></figure><ul><li>msqid：由 <code>msgget</code> 调用返回的消息队列标识符。</li><li>command：指定要执行的命令，支持命令在 P266 表 13-4。</li></ul><p><code>msgctl</code> 成功时返回值取决于 command参数，如 P266 表 13-4 所示。失败时返回 -1，并设置 errno。</p><h4 id="13-8-IPC命令"><a href="#13-8-IPC命令" class="headerlink" title="13.8 IPC命令"></a>13.8 IPC命令</h4><p>Linux 提供 <strong>ipcs</strong> 命令，以观察当前系统上拥有哪些共享资源实例。此外，可以使用 <strong>ipcrm</strong> 命令来删除遗留在系统中的共享资源。</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/IPC命令.png"><h4 id="13-9-在进程间传递文件描述符"><a href="#13-9-在进程间传递文件描述符" class="headerlink" title="13.9 在进程间传递文件描述符"></a>13.9 在进程间传递文件描述符</h4><p>需要注意的是，传递一个文件描述符并不是传递一个文件描述符的值，而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。</p><h3 id="第-14-章-多线程编程"><a href="#第-14-章-多线程编程" class="headerlink" title="第 14 章 多线程编程"></a>第 14 章 多线程编程</h3><p>本章线程（NPTL）相关的内容都属于 POSIX 线程（简称 <code>pthread</code> ）标准，具体包括：</p><ol><li>创建线程和结束线程。</li><li>读取和设置线程属性。</li><li>POSIX 线程同步方式：<strong>POSIX 信号量、互斥锁和条件变量。</strong></li></ol><h4 id="14-1-Linux-线程概述"><a href="#14-1-Linux-线程概述" class="headerlink" title="14.1 Linux 线程概述"></a>14.1 Linux 线程概述</h4><h5 id="14-1-1-线程模型"><a href="#14-1-1-线程模型" class="headerlink" title="14.1.1 线程模型"></a>14.1.1 线程模型</h5><p>线程可分为内核线程和用户线程：</p><ul><li>内核线程：也被称为 LWP（Light Weight Process，轻量级线程），运行在内核空间，由内核来调度。</li><li>用户线程：运行在用户空间，由线程库调度。</li></ul><p>当进程的一个内核线程获得 CPU 的使用权时，它就加载并运行一个用户线程。可见，<strong>内核线程相当于用户线程运行的“容器”。</strong></p><p>一个进程可以拥有 M 个内核线程和 N 个用户线程，其中 $M \leq N$。且在一个系统的所有进程中，M 和 N 的比值是<strong>固定的</strong>。</p><p>线程的实现方式分为三种模式：</p><ul><li>完全在用户空间实现，多对一。</li><li>完全由内核调度，一对一。</li><li>双层调度，多对多。</li></ul><h5 id="14-1-2-Linux-线程库"><a href="#14-1-2-Linux-线程库" class="headerlink" title="14.1.2 Linux 线程库"></a>14.1.2 Linux 线程库</h5><p>现代 Linux 上默认使用的线程库是 NPTL，可以用如下命令查看当前系统上所使用的线程库：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/NPTL.png"><p>相比于 LinuxThreads，NPTL 的主要优势在于：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/NPTL优势.png"><h4 id="14-2-创建进程和结束进程"><a href="#14-2-创建进程和结束进程" class="headerlink" title="14.2 创建进程和结束进程"></a>14.2 创建进程和结束进程</h4><p>创建和结束线程的基础 API，Linux 上它们都定义在 <code>pthread.h</code> 头文件中。</p><ol><li><p><code>pthread_create</code>，创建一个线程：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_create.png"></li></ol><ul><li><p>thread 参数是新线程的标识符，后续 <code>pthread_*</code> 函数通过它来引用新线程。其类型 <code>pthread_t</code> 的定义如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_t.png"></li><li><p>attr 参数用于设置新线程的属性。给它传递 NULL 标识使用默认线程属性。</p></li><li><p>start_routine 和 arg 指定新线程运行的函数及其参数。</p></li></ul><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_create_flag.png"><ol start="2"><li><p><code>pthread_exit</code>，线程结束时最好调用此函数，以确保安全、干净的退出：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_exit.png"></li></ol><p><code>pthread_exit</code> 函数通过 retval 参数向线程的回收者传递其退出信息。它执行完之后不回返回到调用者，而且永远不会失败。</p><ol start="3"><li><p><code>pthread_join</code>，一个进程中的所有线程都可以调用 <code>pthread_join</code> 函数来回收<strong>其他线程</strong>（前提是目标线程是可回收的，见后文），即等待<strong>其他线程</strong>结束，类似于回收进程的 <code>wait</code> 和 <code>waitpid</code> 系统调用。定义如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_join.png"></li></ol><p><code>thread</code> 参数是目标线程的标识符，retval 参数是目标线程返回的退出信息。该函数会一直阻塞，直到被回收的线程结束为止。该函数成功时返回 0，失败则返回错误码。可能的错误码如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_join函数可能引发的错误码.png"><ol start="4"><li><p><code>pthread_cancel</code>，有时候希望异常终止一个线程，即取消线程，通过以下函数实现：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_cancel.png"></li></ol><ul><li>thread 参数是目标线程的标识符。</li></ul><p>该函数成功时返回 0，失败则返回错误码。接收到取消请求的目标线程可以决定是否允许被取消以及如何取消，通过以下函数：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_cancel_.png"><p>具体参数详见 P273。</p><h4 id="14-3-线程属性※"><a href="#14-3-线程属性※" class="headerlink" title="14.3 线程属性※"></a>14.3 线程属性※</h4><p><code>pthread_attr_t</code> 结构体定义了一套完整的线程属性，如下所示：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_attr_t结构体.png"><p>可见，各种线程属性全部包含在一个字符数组中。线程库定义了一系列函数来操作 <code>pthread_attr_t</code> 类型的变量，以方便我们获取和设置线程属性。这些函数在 P273。</p><p><strong>脱离线程</strong>：脱离了与其他线程同步的线程称为”脱离线程“。脱离线程在退出时将自行释放其占用的系统资源。可以设置 <code>detachstate</code> 设置为 <code>PTHREAD_CREATE_DETACH</code>，也可以使用 <code>pthread_detach</code> 函数直接将线程设置为脱离线程。</p><h4 id="14-4-POSIX-信号量"><a href="#14-4-POSIX-信号量" class="headerlink" title="14.4 POSIX 信号量"></a>14.4 POSIX 信号量</h4><p>Linux 上信号量 API 有两组。一组是第 13 章讨论过的 System V IPC 信号量，另外一组是现在要讨论的 POSIX 信号量。这两组接口很相似，但不保证能互换。</p><p>POSIX 信号量函数的名字都以 <code>sem_</code> 开头，并不像大多数线程函数那样以 <code>pthread_</code> 开头。常用的 POSIX 信号量是下面 5 个：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/POSIX信号量.png"><ul><li>sem：指向被操作的信号量。</li><li>sem_init：用于初始化一个未命名的信号量；pshared 参数指定信号量的类型，如果为 0，表示这个信号量是当前进程的局部信号量；value 参数指定信号量的初始值。<strong>此外，初始化一个已经被初始化的信号量将导致不可预期的结果。</strong></li><li>sem_destroy：用于销毁信号量，以释放其占用的内核资源。<strong>如果销毁一个正被其他线程等待的信号量，则将导致不可于其的结果。</strong></li><li>sem_wait：以原子操作的方式将信号量的值减 1，如果信号量的值为 0，则 sem_wait 将被阻塞，直到这个信号量具有非 0 值。</li><li>sem_trywait：与 sem_wait 类似，不过它始终立即返回，而不论操作的信号量是否具有非 0 值，相当于 sem_wait 的非阻塞版本。</li><li>sem_post：以原子操作的方式将信号量的值加 1。当信号量的值大于 0 时，其他正在调用 sem_wait 等待信号量的线程将被唤醒。</li></ul><p>以上函数成功时返回 0，失败则返回 -1 并设置 errno。</p><h4 id="14-5-互斥锁"><a href="#14-5-互斥锁" class="headerlink" title="14.5 互斥锁"></a>14.5 互斥锁</h4><p>互斥锁可以用于保护关键代码段，以确保其独占式的访问。当进入关键代码段时，我们需要获得互斥锁并将其加锁，类似于二进制信号量的 P 操作；当离开关键代码段时，我们需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程，等价于二进制信号量的 V 操作。</p><h5 id="14-5-1-互斥锁基础-API"><a href="#14-5-1-互斥锁基础-API" class="headerlink" title="14.5.1 互斥锁基础 API"></a>14.5.1 互斥锁基础 API</h5><p>POSIX 互斥锁的相关函数主要有如下 5 个：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/POSIX互斥锁.png"><ul><li>mutex：指向要操作的目标互斥锁，互斥锁的类型是 <code>pthread_mutex_t</code> 结构体。</li></ul><p><strong>pthread_mutex_init</strong></p><p>用于初始化互斥锁。mutexattr 参数指定互斥锁的属性。如果将它设置为 NULL，则表示使用默认属性。也可以使用如下方式初始化一个互斥锁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p><strong>pthread_mutex_destroy</strong></p><p>用于销毁互斥锁，以释放其占用的内核资源。<strong>销毁一个已经加锁的互斥锁将导致不可预期的后果。</strong></p><p><strong>pthread_mutex_lock</strong></p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_mutex_lock.png"><p><strong>pthread_mutex_trylock</strong></p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_mutex_trylock.png"><p><strong>pthread_mutex_unlock</strong></p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_mutex_unlock.png"><p>上面这些函数成功时返回 0，失败则返回错误码。</p><h5 id="14-5-2-互斥锁属性"><a href="#14-5-2-互斥锁属性" class="headerlink" title="14.5.2 互斥锁属性"></a>14.5.2 互斥锁属性</h5><p><code>pthread_mutexattr_t</code> 结构体定义了一套完整的互斥锁属性。线程库提供了一系列函数类操作 <code>pthread_mutexattr_t</code> 类型的变量以方便我们获取和设置互斥锁属性。如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/互斥锁属性.png"><p>最主要两种是：<code>pshared</code> 和 <code>type</code>。</p><p>互斥锁 <code>pshared</code> 指定是否允许跨进程共享互斥锁，其可选值有两个：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pshared.png"><p>互斥锁属性 <code>type</code> 指定互斥锁的类型。Linux 支持如下 4 种类型的互斥锁：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/type.png"><h5 id="14-5-3-死锁举例"><a href="#14-5-3-死锁举例" class="headerlink" title="14.5.3 死锁举例"></a>14.5.3 死锁举例</h5><p>P278。</p><h4 id="14-6-条件变量"><a href="#14-6-条件变量" class="headerlink" title="14.6 条件变量"></a>14.6 条件变量</h4><p>互斥锁：同步线程对共享数据的访问。</p><p>条件变量：线程之间同步共享数据的值。</p><p><strong>条件变量</strong>提供了一种线程间的通知机制：<strong>当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。</strong>条件变量的相关函数主要有如下 5 个：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/条件变量.png"><ul><li>cond：指向要操作的目标条件变量，类型为 <code>pthread_cond_t</code> 结构体。</li></ul><p><strong>pthread_cond_init</strong></p><p>用于初始化条件变量。cond_attr 参数执行条件变量的属性，设置为 NULL，表示使用默认属性。除了使用 <code>init</code> 函数，还可以用如下方式初始化：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_cond_init.png"><p>宏实际上是把条件变量的各个字段都初始化为 0。</p><p><strong>pthread_cond_destroy</strong></p><p>用于销毁条件变量，以释放其占用的内核资源。销毁一个正在被等待的条件变量将失败并返回 EBUSY。</p><p><strong>pthread_cond_broadcast</strong></p><p>以广播的方式唤醒所有等待目标条件变量的线程。</p><p><strong>pthread_cond_signal</strong></p><p>用于唤醒一个等待目标条件变量的线程。至于哪个线程将被唤醒，则取决于线程的优先级和调度策略。</p><p><strong>pthread_cond_wait</strong></p><p>用于等待目标条件变量。mutex 参数是用于保护条件变量的互斥锁，以确保 <code>pthread_cond_wait</code> 的原子性。详细信息 P280。</p><h4 id="14-7-线程同步机制包装类"><a href="#14-7-线程同步机制包装类" class="headerlink" title="14.7 线程同步机制包装类"></a>14.7 线程同步机制包装类</h4><p>三种线程同步方式封装。P280-P282。</p><h4 id="14-8-多线程环境"><a href="#14-8-多线程环境" class="headerlink" title="14.8 多线程环境"></a>14.8 多线程环境</h4><h5 id="14-8-1-可重入函数"><a href="#14-8-1-可重入函数" class="headerlink" title="14.8.1 可重入函数"></a>14.8.1 可重入函数</h5><p>如果一个函数能被多个线程<strong>同时调用</strong>且<strong>不发生竞态条件</strong>，则我们称它是<strong>线程安全</strong>的，或者<strong>可重入函数</strong>。Linux 库函数只有一小部分是不可重入的，比如 <code>inet_ntoa</code> 函数。不过 Linux 对很多不可重入的库函数提供了对应的可重入版本，这些可重入版本的函数名是在原函数名尾部加上 _r。如 <code>localtime</code> 对应的可重入函数是 <code>localtime_r</code>。</p><h5 id="14-8-2-线程和进程"><a href="#14-8-2-线程和进程" class="headerlink" title="14.8.2 线程和进程"></a>14.8.2 线程和进程</h5><p>如果一个多线程程序的某个线程调用了 <code>fork</code> 函数，那么新创建的子进程只拥有一个执行线程，它是调用 <code>fork</code> 的哪个线程的完整复制，并且子进程将自动继承父进程种互斥锁。关于可能造成死锁的详情见 P283。</p><h5 id="14-8-3-线程和信号"><a href="#14-8-3-线程和信号" class="headerlink" title="14.8.3 线程和信号"></a>14.8.3 线程和信号</h5><p>每个线程都可以独立地设置信号掩码，多线程环境下应使用 <code>pthread</code> 版本的 <code>sigprocmask</code> 函数来设置线程信号掩码：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/sigprocmask.png"><p>该函数的参数的含义与 <code>sigprocmask</code> 完全相同，成功返回 0，失败返回错误码。</p><p>我们应该定义一个专门的线程来处理所有的信号，通过以下两个步骤来实现：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/处理信号的线程.png"><ul><li>set：执行需要等待的信号的集合。</li><li>sig：指向的整数用于存储该函数返回的信号值</li></ul><p><code>sigwait</code> 成功时返回 0，失败时返回错误码。</p><p>最后，<code>pthread</code> 还提供以下方法，明确将一个信号发送给指定的线程：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/pthread_kill.png"><ul><li>thread：指定目标线程。</li><li>sig：指定待发送的信号。</li></ul><p><code>pthread_kill</code> 成功时返回 0，失败时返回错误码。</p><h3 id="第-15-章"><a href="#第-15-章" class="headerlink" title="第 15 章"></a>第 15 章</h3><h4 id="15-1-进程池和线程池概述"><a href="#15-1-进程池和线程池概述" class="headerlink" title="15.1 进程池和线程池概述"></a>15.1 进程池和线程池概述</h4><ul><li>进程池是由服务器预先创建的一组子进程，典型情况数目为 3~10 个之间。而线程池中的线程数量应该和 CPU 数量差不多。</li><li>进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、PGID等。</li><li>当有新任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。</li></ul><p>相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。</p><p>主进程选择哪个子进程来为新任务服务，则有<strong>两种方式</strong>：</p><ul><li><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/主进程选择子进程1.png"></li><li><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/主进程选择子进程2.png"></li></ul><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/进程池模型.png"><p>通知机制：</p><ul><li>父子进程：最简单的方法是通过管道。</li><li>父子线程：全局变量。</li></ul><h4 id="15-2-处理多客户"><a href="#15-2-处理多客户" class="headerlink" title="15.2 处理多客户"></a>15.2 处理多客户</h4><img src="/blog/2021/10/08/Linux高性能服务器编程（13-15）/处理多客户.png"><h4 id="15-3-半同步-半异步进程池实现"><a href="#15-3-半同步-半异步进程池实现" class="headerlink" title="15.3 半同步/半异步进程池实现"></a>15.3 半同步/半异步进程池实现</h4><p>P289-P297</p><h4 id="15-4-用进程池实现的简单-CGI-服务器"><a href="#15-4-用进程池实现的简单-CGI-服务器" class="headerlink" title="15.4 用进程池实现的简单 CGI 服务器"></a>15.4 用进程池实现的简单 CGI 服务器</h4><p>P298-P301</p><h4 id="15-5-半同步-半反应堆线程池的实现"><a href="#15-5-半同步-半反应堆线程池的实现" class="headerlink" title="15.5 半同步/半反应堆线程池的实现"></a>15.5 半同步/半反应堆线程池的实现</h4><p>相比于 15.3 半同步/半异步进程池实现，该线程池使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。</p><p>如果要将该线程池应用到实际服务器程序中，那么我们必须保证客户请求都是无状态的，因为同一个连接上的不同请求可能会由不同的线程处理。</p><p>P301-P304</p><h4 id="15-6-用线程池实现的简单-Web-服务器"><a href="#15-6-用线程池实现的简单-Web-服务器" class="headerlink" title="15.6 用线程池实现的简单 Web 服务器"></a>15.6 用线程池实现的简单 Web 服务器</h4><h5 id="15-6-1-http-conn-类"><a href="#15-6-1-http-conn-类" class="headerlink" title="15.6.1 http_conn 类"></a>15.6.1 http_conn 类</h5><p>P304-P318s</p><h5 id="15-6-2-main-函数"><a href="#15-6-2-main-函数" class="headerlink" title="15.6.2 main 函数"></a>15.6.2 main 函数</h5><p>P318-P321</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux高性能服务器编程（13-15）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.xingyuzhao.ltd/categories/Linux/"/>
    
    
      <category term="高性能服务器" scheme="http://www.xingyuzhao.ltd/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器编程（7-12）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/10/08/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BC%887-12%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/10/08/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%EF%BC%887-12%EF%BC%89/</id>
    <published>2021-10-08T01:51:22.000Z</published>
    <updated>2021-10-08T01:57:39.731Z</updated>
    
    <content type="html"><![CDATA[<p>Linux高性能服务器编程（7-12）</p><a id="more"></a><h3 id="第-7-章-Linux-服务器程序规范"><a href="#第-7-章-Linux-服务器程序规范" class="headerlink" title="第 7 章 Linux 服务器程序规范"></a>第 7 章 Linux 服务器程序规范</h3><p>服务器程序规范如下：</p><ul><li>Linux 服务器程序一般以后台形式运行。后台程序又称为<strong>守护进程</strong>。它没有控制终端，因而也不会意外接收到用户输入。守护进程的父进程通常是 <strong>init</strong> 进程（PID 为 1 的进程）。</li><li>Linux 服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的 UDP 服务器。大部分后台进程都在 /var/log 目录下拥有自己的日志目录。</li><li>Linux 服务器程序一般以某个专门的非 root 身份运行。比如 mysqld、httpd、syslogd 等后台进程，分别拥有自己的运行账户 mysql、apache 和 syslog。</li><li>Linux 服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件，并存放在 /etc 目录下。</li><li>Linux 服务器进程通常会在启动的时候生成一个 PID 文件并存入 /var/run 目录中，以记录该后台进程的 PID。比如 syslogd 的 PID 文件是 /var/run/syslogd.pid。</li><li>Linux 服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。</li></ul><h4 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h4><h5 id="7-1-1-Linux-系统日志"><a href="#7-1-1-Linux-系统日志" class="headerlink" title="7.1.1 Linux 系统日志"></a>7.1.1 Linux 系统日志</h5><p>Linux 提供一个守护进程来处理系统日志——syslogd，不过现在的 Linux 系统上使用的都是它的升级版——rsyslogd。</p><p>rsyslogd 守护进程既能接收用户进程输出的日志，又能接收内核日志。</p><ul><li>用户进程是通过调用 syslog 函数生成系统日志的。该函数将日志输出到一个 UNIX 本地域 socket 类型（AF_UNIX）的文件 /dev/log 中，rsyslogd 则监听该文件以获取用户进程的输出。</li><li>内核日志由 printk 等函数打印至内核的环状缓存（ring buffer）中。环状缓存的内容直接映射到 /proc/kmsg 文件中。rsyslogd 则通过读取该文件获得内核日志。</li></ul><h5 id="7-1-2-syslog-函数"><a href="#7-1-2-syslog-函数" class="headerlink" title="7.1.2 syslog 函数"></a>7.1.2 syslog 函数</h5><p>应用程序通过使用 syslog 函数与 rsyslogd 守护进程通信。syslog 函数的定义如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/syslog.png"><p>priority 参数是所谓的设施值与日志级别的按位或。设施值的默认值是 LOG_USER，下面讨论的也只限于这一种设施值。日志级别有如下几个：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/日志级别.png"><p>下面这个函数可以改变 syslog 的默认输出方式，进一步结构化日志内容：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/openlog.png"><ul><li>ident：指定的字符串将被添加到日志消息的日期和时间之后，通常被设置为程序的名字。</li><li>logopt：对后续的 syslog 调用的行为进行配置，它可取下列值的按位或：</li></ul><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/openlog-logopt.png"><ul><li>facility：用来修改 syslog 函数中的默认设施值。</li></ul><p><strong>日志过滤</strong></p><p>P116</p><h4 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h4><h5 id="7-2-1-UID、EUID、GID-和-EGID※"><a href="#7-2-1-UID、EUID、GID-和-EGID※" class="headerlink" title="7.2.1 UID、EUID、GID 和 EGID※"></a>7.2.1 UID、EUID、GID 和 EGID※</h5><p>用户信息对于服务器程序的安全性来说很重要，大部分服务器就必须以 root 身份启动，但不能以 root 身份运行。下面这一组函数可以获取和设置当前进程的真实用户 ID（UID）、有效用户 ID（EUID）、真实组 ID（GID）和有效组 ID（EGID）:</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/UID等.png"><p>需要指出的是，<strong>一个进程有两个用户 ID</strong>：UID 和 EUID。EUID 存在的目的是方便资源访问：<strong>它使得运行程序的用户拥有该程序的有效用户的权限。</strong></p><h5 id="7-2-2-切换用户"><a href="#7-2-2-切换用户" class="headerlink" title="7.2.2 切换用户"></a>7.2.2 切换用户</h5><h4 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h4><h5 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h5><p>Linux 下每个进程都隶属于一个进程组，因此它们除了 PID 信息外，还有进程组 ID（PGID）。可以用如下函数来获得指定进程的 PGID：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/getpgid.png"><p>每个进程组都有一个首领进程，其 PGID 和 PID 相同。进程组将一直存在，直到其中所有进程都退出，或者加入其他进程组。</p><p>下面的函数用于设置 PGID：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/setpgid.png"><h5 id="7-3-2-会话"><a href="#7-3-2-会话" class="headerlink" title="7.3.2 会话"></a>7.3.2 会话</h5><p>一些有关联的进程组将形成一个会话（session）。下面的函数用于创建一个会话：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/setsid.png"><p>该函数不能由首领进程调用，否则将产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：<br><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/新会话.png"></p><p>Linux 进程<strong>并未提供所谓会话 ID（SID）</strong>的概念，<strong>但 Linux 系统认为它等于会话首领所在的进程组的 PGID</strong>，并提供了如下函数来读取 SID：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/getsid.png"><h5 id="7-3-3-用-ps-命令查看进程关系※"><a href="#7-3-3-用-ps-命令查看进程关系※" class="headerlink" title="7.3.3 用 ps 命令查看进程关系※"></a>7.3.3 用 ps 命令查看进程关系※</h5><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/ps.png"><h4 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h4><p>Linux 系统资源限制可以通过如下一对函数来读取和设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource,h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">( <span class="keyword">int</span> resource, struct rlimit *rlim )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">( <span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim )</span></span>;</span><br></pre></td></tr></table></figure><p>rlim 参数是 rlimit 结构体类型的指针，rlimit 结构体的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span>&#123;</span></span><br><span class="line"><span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line"><span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rlim_t 是一个整数类型，它描述资源级别。</p><ul><li>rlim_cur 成员指定资源的软限制（建议性、最好不要超越的限制）</li><li>rlim_max 成员指定资源的硬限制（软限制的上限）</li></ul><p><strong>resource</strong> 参数指定资源限制类型，如下表：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/资源限制类型.png"><h4 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h4><ol><li>获取进程当前工作目录和改变进程工作目录的函数分别是：<img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/getcwd-chdir.png"></li></ol><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/改变工作目录和跟目录.png"><ol start="2"><li>改变进程根目录的函数是 chroot，其定义如下：<img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/chroot.png"></li></ol><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/改变工作目录和跟目录1.png"><h4 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h4><p>在代码中让一个进程以守护进程的方式运行。</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/后台化.png"><h3 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h3><h4 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h4><h5 id="8-1-1-C-S模型"><a href="#8-1-1-C-S模型" class="headerlink" title="8.1.1 C/S模型"></a>8.1.1 C/S模型</h5><h5 id="8-1-2-P2P模型"><a href="#8-1-2-P2P模型" class="headerlink" title="8.1.2 P2P模型"></a>8.1.2 P2P模型</h5><h4 id="8-2-服务器编程框架"><a href="#8-2-服务器编程框架" class="headerlink" title="8.2 服务器编程框架"></a>8.2 服务器编程框架</h4><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/服务器基本框架.png"><h4 id="8-3-I-O模型"><a href="#8-3-I-O模型" class="headerlink" title="8.3 I/O模型"></a>8.3 I/O模型</h4><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/IO模型.png"><ul><li>同步 IO：同步 IO 模型包括阻塞 IO，非阻塞 IO 和 IO 多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。 <ul><li><strong>阻塞</strong>：调用 IO 操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到 IO 可用并完成数据拷贝。</li><li><strong>非阻塞</strong>：调用 IO 操作的时候，内核会马上返回结果，如果 IO 不可用，会返回错误，这种方式下进程需要不断轮询直到 IO 可用为止，但是当进程从内核拷贝数据时是阻塞的。</li><li><strong>IO 多路复用</strong>：同时监听多个描述符，一旦某个描述符 IO 就绪（读就绪或者写就绪），就能够通知进程进行相应的 IO 操作，否则就将进程阻塞在 select 或者 epoll 语句上。</li><li><strong>信号驱动 I/O</strong>：进程在 IO 访问时，先通过 sigaction 系统调用，提交一个信号处理函数，立即返回，进程不阻塞。当内核准备好数据后，产生一个 SIGIO 信号并投递给信号处理函数，可以在此函数中调用读写函数操作数据，这段过程阻塞。</li></ul></li><li>异步 IO：在检测 IO 是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当 IO 完成后内核会给进程发送一个信号。</li></ul><p><strong>IO复用</strong>：应用程序通过 I/O 复用函数向<strong>内核</strong>注册一组事件，内核通过 I/O 复用函数把其中就绪的事件通知给应用程序。Linux 上常用的 I/O 复用函数是 select、poll、epoll。I/O 复用函数本身是<strong>阻塞</strong>的，他们能提高程序效率的原因是它们具有同时监听多个 I/O 事件的能力。</p><p><strong>共有 5 种 I/O模型。</strong></p><p>下图来自于 UNIX 网络编程卷1。前四种为<strong>同步 I/O。</strong></p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/5种IO模型.png" style="zoom:80%;"><h4 id="8-4-两种高效的事件处理模式※"><a href="#8-4-两种高效的事件处理模式※" class="headerlink" title="8.4 两种高效的事件处理模式※"></a>8.4 两种高效的事件处理模式※</h4><h5 id="8-4-1-Reactor模式"><a href="#8-4-1-Reactor模式" class="headerlink" title="8.4.1 Reactor模式"></a>8.4.1 Reactor模式</h5><p>主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。<strong>读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</strong></p><p>使用同步 I/O 模型（epoll_wait为例）实现的 Reactor 模式工作流程：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/Reactor.png"><h5 id="8-4-2-Proactor模式"><a href="#8-4-2-Proactor模式" class="headerlink" title="8.4.2 Proactor模式"></a>8.4.2 Proactor模式</h5><p>与 Reactor 模式不同，Proactor 模式将所有 I/O 操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p><p>使用异步 I/O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/Procator.png"><p>主线程中的 epoll_wait 调用<strong>仅能</strong>用来检测监听 socket 上的<strong>连接请求</strong>事件，而<strong>不能</strong>用来检测连接 socket 上的<strong>读写事件</strong>。</p><h5 id="8-4-3-模拟-Proactor-模式"><a href="#8-4-3-模拟-Proactor-模式" class="headerlink" title="8.4.3 模拟 Proactor 模式"></a>8.4.3 模拟 Proactor 模式</h5><p>原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写结果进行逻辑处理。</p><p>使用同步 I/O 模型（仍然以 epoll_wait 为例）模拟出的 Proactor 模式的工作流程如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/模拟Proactor.png"><h4 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h4><p>并发模式是指 I/O 处理单元和多个逻辑单元之间协调完成任务的方法。</p><h5 id="8-5-1-半同步-半异步模式"><a href="#8-5-1-半同步-半异步模式" class="headerlink" title="8.5.1 半同步/半异步模式"></a>8.5.1 半同步/半异步模式</h5><p>并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。如下图：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/异步.png"><p>半同步/半异步模式中，同步线程用于处理客户逻辑，相当于逻辑单元；异步线程用于处理 I/O 事件，相当于处理单元。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该对象请求：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/半同步-半异步.png"><p>一种变体—半同步/半反应堆模型：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/半同步-半反应堆模型.png"><p>其存在以下缺点：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/半同步-半反应堆.png"><p>一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/高效的半同步-半异步模式.png"><h5 id="8-5-2-领导者-追随者模式"><a href="#8-5-2-领导者-追随者模式" class="headerlink" title="8.5.2 领导者/追随者模式"></a>8.5.2 领导者/追随者模式</h5><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/领导者-追随者.png"><h4 id="8-6-有限状态机"><a href="#8-6-有限状态机" class="headerlink" title="8.6 有限状态机"></a>8.6 有限状态机</h4><p>解析 HTTP。</p><h4 id="8-7-提高服务器性能的其他建议"><a href="#8-7-提高服务器性能的其他建议" class="headerlink" title="8.7 提高服务器性能的其他建议"></a>8.7 提高服务器性能的其他建议</h4><h5 id="8-7-1-池"><a href="#8-7-1-池" class="headerlink" title="8.7.1 池"></a>8.7.1 池</h5><p>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。</p><p><strong>内存池</strong>常用于 socket 的接收缓存和发送缓存。对于某些长度有限的客户请求，比如 HTTP 请求，预先分配一个大小足够（比如5000字节）的接收缓存区是合理的。超过时可选择丢弃请求和动态扩大接收缓冲区。</p><p><strong>进程池</strong>和<strong>线程池</strong>作为工作进程或工作线程来处理新到来的客户请求时，我们可以直接从池中取得一个执行实体，而无须动态的调用 <code>fork</code> 或 <code>pthread_create</code> 等函数来创建进程或线程。</p><p><strong>连接池</strong>时服务器预先和数据库程序建立的一组连接的集合，当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用之，待完成数据库的访问之后，逻辑单元将该连接返回给连接池。</p><h5 id="8-7-2-数据复制"><a href="#8-7-2-数据复制" class="headerlink" title="8.7.2 数据复制"></a>8.7.2 数据复制</h5><p>高性能服务器应该避免不必要的数据复制，尤其是当数据复制发生在用户代码和内核之间的时候。</p><ol><li>如果内核可以直接处理（应用程序不关心这些数据的内容）从 socket 或者文件读入的数据，则应用程序就没西药将这些数据从内核缓冲区复制到应用程序缓冲区中。</li><li>避免用户代码内部（不访问内核）的数据复制也是应该避免的，例如两个工作进程之间需要传递大量数据时，应考虑使用共享内存来在它们之间传送数据，而不是用管道或消息队列来传递。</li></ol><h5 id="8-7-3-上下文切换和锁"><a href="#8-7-3-上下文切换和锁" class="headerlink" title="8.7.3 上下文切换和锁"></a>8.7.3 上下文切换和锁</h5><p>并发程序必须考虑上下文切换的问题，即<strong>进程切换或线程切换导致的系统开销</strong>。多线程服务器的一个优点是不同的线程可以同时运行在不同的 CPU 上，当线程的数量不大于 CPU 的数目时，上下文的切换就不是问题了。</p><p>并发程序需要考虑的另外一个问题就是共享资源的<strong>加锁保护</strong>，如果服务器有更好的解决方案，就应该避免使用锁。如果服务器必须使用锁，则可以考虑减小锁的粒度，比如使用读写锁。半同步/半异步模式就比半同步/半反应堆模式要好。</p><h3 id="第9章-I-O-复用"><a href="#第9章-I-O-复用" class="headerlink" title="第9章 I/O 复用"></a>第9章 I/O 复用</h3><h4 id="9-1-select-系统调用"><a href="#9-1-select-系统调用" class="headerlink" title="9.1 select 系统调用"></a>9.1 select 系统调用</h4><h5 id="9-1-1-select-api"><a href="#9-1-1-select-api" class="headerlink" title="9.1.1 select api"></a>9.1.1 select api</h5><h5 id="9-1-2-文件描述符就绪条件"><a href="#9-1-2-文件描述符就绪条件" class="headerlink" title="9.1.2 文件描述符就绪条件"></a>9.1.2 文件描述符就绪条件</h5><h5 id="9-1-3-处理带外数据"><a href="#9-1-3-处理带外数据" class="headerlink" title="9.1.3 处理带外数据"></a>9.1.3 处理带外数据</h5><h4 id="9-2-poll-系统调用"><a href="#9-2-poll-系统调用" class="headerlink" title="9.2 poll 系统调用"></a>9.2 poll 系统调用</h4><h4 id="9-3-epoll系列系统调用"><a href="#9-3-epoll系列系统调用" class="headerlink" title="9.3 epoll系列系统调用"></a>9.3 epoll系列系统调用</h4><h5 id="9-3-1-内核事件表"><a href="#9-3-1-内核事件表" class="headerlink" title="9.3.1 内核事件表"></a>9.3.1 内核事件表</h5><h5 id="9-3-2-epoll-wait-函数"><a href="#9-3-2-epoll-wait-函数" class="headerlink" title="9.3. 2 epoll_wait 函数"></a>9.3. 2 epoll_wait 函数</h5><h5 id="9-3-3-lt-和-et-模式"><a href="#9-3-3-lt-和-et-模式" class="headerlink" title="9.3.3 lt 和 et 模式"></a>9.3.3 lt 和 et 模式</h5><p>epoll 对文件描述符的操作有两种模式：LT（Level Trigger，电平出发）模式和 ET（Edge Trigger，边沿触发）模式。</p><ul><li>LT 模式是默认的工作模式，这种模式下 epoll 相当于一个效率较高的 poll。对于采用 LT 工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。当应用程序下一次调用 epoll_wait 时，epoll_wait 还会再次向应用程序通告此事件，直到该事件被处理。</li><li>ET 模式时 epoll 高效的工作模式，对于采用 ET 工作模式的文件描述符，当 epoll_wait 检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的 epoll_wait 调用将不再向应用程序通知这一事件。</li></ul><p>由此可见，ET 模式降低了同一个 epoll 事件被重复触发的次数，因此效率比 LT 模式高。</p><p><strong>注意：</strong>每个使用 ET 模式的文件都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一致处于阻塞状态（饥渴状态）。</p><h5 id="9-3-4-epolloneshot-事件"><a href="#9-3-4-epolloneshot-事件" class="headerlink" title="9.3.4 epolloneshot 事件"></a>9.3.4 epolloneshot 事件</h5><h4 id="9-4-三组-I-O-复用函数的比较"><a href="#9-4-三组-I-O-复用函数的比较" class="headerlink" title="9.4 三组 I/O 复用函数的比较"></a>9.4 三组 I/O 复用函数的比较</h4><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/三种复用的区别.png"><h4 id="9-5-I-O-复用的高级应用一：非阻塞-connect"><a href="#9-5-I-O-复用的高级应用一：非阻塞-connect" class="headerlink" title="9.5 I/O 复用的高级应用一：非阻塞 connect"></a>9.5 I/O 复用的高级应用一：非阻塞 connect</h4><h4 id="9-6-I-O-复用的高级应用二：聊天室程序"><a href="#9-6-I-O-复用的高级应用二：聊天室程序" class="headerlink" title="9.6 I/O 复用的高级应用二：聊天室程序"></a>9.6 I/O 复用的高级应用二：聊天室程序</h4><h5 id="9-6-1-客户端"><a href="#9-6-1-客户端" class="headerlink" title="9.6.1 客户端"></a>9.6.1 客户端</h5><h5 id="9-6-2-服务器"><a href="#9-6-2-服务器" class="headerlink" title="9.6.2 服务器"></a>9.6.2 服务器</h5><h4 id="9-7-I-O-复用的高级应用三：同时处理-TCP-和-UDP-服务"><a href="#9-7-I-O-复用的高级应用三：同时处理-TCP-和-UDP-服务" class="headerlink" title="9.7 I/O 复用的高级应用三：同时处理 TCP 和 UDP 服务"></a>9.7 I/O 复用的高级应用三：同时处理 TCP 和 UDP 服务</h4><h3 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h3><p>信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。Linux 信号可由如下条件产生：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/信号.png"><h4 id="10-1-Linux-信号概述"><a href="#10-1-Linux-信号概述" class="headerlink" title="10.1 Linux 信号概述"></a>10.1 Linux 信号概述</h4><h5 id="10-1-1-发送信号"><a href="#10-1-1-发送信号" class="headerlink" title="10.1.1 发送信号"></a>10.1.1 发送信号</h5><p>Linux 下，一个进程给其他进程发送信号的 API 是 kill 函数，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">( <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig )</span></span>;</span><br></pre></td></tr></table></figure><p>该函数把信号 sig 发送给目标进程：目标进程由 pid 参数指定，其可能的取值及含义如下：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/kill.png"><h5 id="10-1-2-信号处理方式"><a href="#10-1-2-信号处理方式" class="headerlink" title="10.1.2 信号处理方式"></a>10.1.2 信号处理方式</h5><p>目标进程收到信号后，需要定义一个接收函数来处理，信号处理函数的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">_sighandler_t</span>)</span> <span class="params">( <span class="keyword">int</span> )</span></span>;</span><br></pre></td></tr></table></figure><h5 id="10-1-3-Linux-信号"><a href="#10-1-3-Linux-信号" class="headerlink" title="10.1.3 Linux 信号"></a>10.1.3 Linux 信号</h5><p>Linux 可用信号都定义在 <code>bits/signum.h</code> 头文件中，其中包括标准信号和 POSIX 实时信号。表在 P180。</p><h5 id="10-1-4-中断系统调用"><a href="#10-1-4-中断系统调用" class="headerlink" title="10.1.4 中断系统调用"></a>10.1.4 中断系统调用</h5><h4 id="10-2-信号函数"><a href="#10-2-信号函数" class="headerlink" title="10.2 信号函数"></a>10.2 信号函数</h4><h5 id="10-2-1-signal-系统调用"><a href="#10-2-1-signal-系统调用" class="headerlink" title="10.2.1 signal 系统调用"></a>10.2.1 signal 系统调用</h5><p>要为一个信号设置处理函数，可以使用下面的 signal 系统调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">_sighandler_t</span> <span class="title">signal</span> <span class="params">( <span class="keyword">int</span> sig, _sighandler_ _handler )</span></span></span><br></pre></td></tr></table></figure><ul><li><code>sig</code>：要捕获的信号类型</li><li><code>_handler</code>：_sighandler_t 类型的函数指针，用于指定信号 sig 的处理函数</li></ul><p>signal 函数成功返回前一次调用 signal 函数时传入的函数指针，或者是信号 sig 对应的默认处理函数指针 SIG_DEF（如果是第一次调用 signal 的话）。</p><p>signal 系统调用出错时返回 SIG_ERR，并设置 errno。</p><h5 id="10-2-2-sigaction-系统调用"><a href="#10-2-2-sigaction-系统调用" class="headerlink" title="10.2.2 sigaction 系统调用"></a>10.2.2 sigaction 系统调用</h5><p>设置信号处理函数的更健壮的接口是如下的系统调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">( <span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction* act, struct sigaction* oact)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>sig</code>：要捕获的信号类型</li><li><code>act</code>：指定新的信号处理方式</li><li><code>oact</code>：输出信号先前的处理方式（如果不为 NULL 的话）</li></ul><p>sigaction 结构体描述了信号处理的细节，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_POSIX199309</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">_sighandler_t</span> sa_handler;</span><br><span class="line"><span class="keyword">void</span> (*sa_sigaction) ( <span class="keyword">int</span>, <span class="keyword">siginfo_t</span>*, <span class="keyword">void</span>* );</span><br><span class="line">&#125; </span><br><span class="line">_sigaction_handler;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_handler__sigaction_handler.sa_handler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_sigcation__sigaction_handler.sa_sigaction</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">_sighandler_t</span> sa_handler;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">_sigset_t</span> sa_mask;</span><br><span class="line"><span class="keyword">int</span> sa_flags;</span><br><span class="line"><span class="keyword">void</span> (*sa_restorer) (<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参数的详细介绍在 P182。</p><h4 id="10-3-信号集"><a href="#10-3-信号集" class="headerlink" title="10.3 信号集"></a>10.3 信号集</h4><h5 id="10-3-1-信号集函数"><a href="#10-3-1-信号集函数" class="headerlink" title="10.3.1 信号集函数"></a>10.3.1 信号集函数</h5><p>Linux 使用数据结构 sigset_t 来表示一组信号。定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/sigset.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __val[_SIGSET_NWORDS];</span><br><span class="line">&#125; <span class="keyword">__sigset_t</span>;</span><br></pre></td></tr></table></figure><p>sigset_t 实际上是一个长整型数组，数组中的每个元素的每个位表示一个信号。Linux 提供了如下一组函数来设置、修改、删除和查询信号集：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/信号集.png"><h5 id="10-3-2-进程信号掩码"><a href="#10-3-2-进程信号掩码" class="headerlink" title="10.3.2 进程信号掩码"></a>10.3.2 进程信号掩码</h5><h5 id="10-3-3-被挂起的信号"><a href="#10-3-3-被挂起的信号" class="headerlink" title="10.3.3 被挂起的信号"></a>10.3.3 被挂起的信号</h5><h4 id="10-4-统一事件源"><a href="#10-4-统一事件源" class="headerlink" title="10.4 统一事件源"></a>10.4 统一事件源</h4><p>信号是一种异步事件：信号处理函数和程序的主循环是两条不同的执行路线。显然，信号处理函数需要尽可能快的执行完毕，以确保该信号不被屏蔽太久。一种典型的解决方案是 P184。</p><h4 id="10-5-网络编程相关信号"><a href="#10-5-网络编程相关信号" class="headerlink" title="10.5 网络编程相关信号"></a>10.5 网络编程相关信号</h4><h5 id="10-5-1-SIGHUP"><a href="#10-5-1-SIGHUP" class="headerlink" title="10.5.1 SIGHUP"></a>10.5.1 SIGHUP</h5><p>当挂起进程的控制终端时，SIGHUP 信号将被出发。对于没有控制终端的网络后台程序而言，它们通常利用 SIGHUP 信号来强制服务器重读配置文件。一个典型的例子时 xinetd 超级服务程序。</p><h5 id="10-5-2-SIGPIPE"><a href="#10-5-2-SIGPIPE" class="headerlink" title="10.5.2 SIGPIPE"></a>10.5.2 SIGPIPE</h5><p>默认情况下，往一个读端关闭的通道或 socket 连接中写数据将引发 SIGPIPE 信号。我们需要在代码中捕获并处理该信号，或者至少忽略它。因为程序接收到 SIGPIPE 信号的默认行为是结束进程，我们不希望因为错误的写操作而导致程序退出。引起 SIGPIPE 信号的写操作将设置 errno 为 EPIPE。</p><h5 id="10-5-3-SIGURG"><a href="#10-5-3-SIGURG" class="headerlink" title="10.5.3 SIGURG"></a>10.5.3 SIGURG</h5><p>Linux 下内核通知应用程序带外数据到达主要有两种办法：</p><ol><li>I/O 复用计数</li><li>使用 SIGURG 信号</li></ol><p><strong>TCP带外数据相关知识</strong></p><ul><li>3.8 节 TCP 带外数据的基本知识</li><li>5.8.1 小节 如何在应用程序中使用带 MSG_OOB 标志的 send/recv 系统调用来发送/接收带外数据</li><li>9.1.3 10.5.3 小节 检测带外数据是否到达的两种方法</li></ul><h3 id="第11章-定时器"><a href="#第11章-定时器" class="headerlink" title="第11章 定时器"></a>第11章 定时器</h3><p>Linux 提供了三种定时方法，它们是：</p><ul><li>socket 选项 SO_RCVTIMEO 和 SO_SNDTIMEO。</li><li>SIGALRM 信号。</li><li>I/O 复用系统调用的超时参数。</li></ul><h4 id="11-1-socket-选项-SO-RCVTIMEO-和-SO-SNDTIMEO"><a href="#11-1-socket-选项-SO-RCVTIMEO-和-SO-SNDTIMEO" class="headerlink" title="11.1 socket 选项 SO_RCVTIMEO 和 SO_SNDTIMEO"></a>11.1 socket 选项 SO_RCVTIMEO 和 SO_SNDTIMEO</h4><p>SO_RCVTIMEO：设置 socket 接收数据超时时间。</p><p> SO_SNDTIMEO：设置 socket 接收数据超时时间。</p><p>仅对数据接收和发送相关的 socket 的 API 有效，包括 <code>send</code>、<code>sendmsg</code>、<code>recv</code>、<code>resvmsg</code>、<code>accept</code>和 <code>connect</code>。</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/SO_REVTIMEO和SO_SNDTIMEO调用.png"><h4 id="11-2-SIGALRM-信号"><a href="#11-2-SIGALRM-信号" class="headerlink" title="11.2 SIGALRM 信号"></a>11.2 SIGALRM 信号</h4><p>由 <code>alarm</code> 和 <code>setitimer</code> 函数设置的实时闹钟一旦超时，将出发 SIGALRM 信号。</p><h5 id="11-2-1-基于升序链表的定时器"><a href="#11-2-1-基于升序链表的定时器" class="headerlink" title="11.2.1 基于升序链表的定时器"></a>11.2.1 基于升序链表的定时器</h5><p>定时器通常至少包含两个成员：一个超时时间（相对时间或者绝对时间）和一个任务回调函数。</p><h5 id="11-2-2-处理非活动连接"><a href="#11-2-2-处理非活动连接" class="headerlink" title="11.2.2 处理非活动连接"></a>11.2.2 处理非活动连接</h5><p>可以考虑在应用层实现类似于 KEEPALIVE 的机制，以管理所有长时间处于非活动状态的连接。</p><h4 id="11-3-I-O-复用系统调用的超时参数"><a href="#11-3-I-O-复用系统调用的超时参数" class="headerlink" title="11.3 I/O 复用系统调用的超时参数"></a>11.3 I/O 复用系统调用的超时参数</h4><p>Linux 下的 3 组 I/O 复用系统调用都带有超时参数，因此它们不仅能统一处理信和 I/O 时间，也能统一处理定时事件。但是由于 I/O 复用系统调用可能在超时事件到期之前就返回（有 I/O 事件发生），所以如果我们要利用它们来定时，就需要不断更新定时参数以反应剩余的时间。</p><h4 id="11-4-高性能定时器"><a href="#11-4-高性能定时器" class="headerlink" title="11.4 高性能定时器"></a>11.4 高性能定时器</h4><h5 id="11-4-1-时间轮"><a href="#11-4-1-时间轮" class="headerlink" title="11.4.1 时间轮"></a>11.4.1 时间轮</h5><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/时间轮.png"><h5 id="11-4-2-时间堆"><a href="#11-4-2-时间堆" class="headerlink" title="11.4.2 时间堆"></a>11.4.2 时间堆</h5><p>将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数 tick 被调用，超时时间最小的定时器必然到期，我们就可以在 tick 函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。<strong>最小堆</strong>适合处理此种方案。</p><h3 id="第12章-高性能I-O框架库libevent"><a href="#第12章-高性能I-O框架库libevent" class="headerlink" title="第12章 高性能I/O框架库libevent"></a>第12章 高性能I/O框架库libevent</h3><h4 id="12-1-I-O-框架库概述"><a href="#12-1-I-O-框架库概述" class="headerlink" title="12.1 I/O 框架库概述"></a>12.1 I/O 框架库概述</h4><p>基于 Reactor 模式的 I/O 框架库包含如下几个组件：句柄（handle）、事件多路分发器（EventDemultiplexer）、事件处理器（EventHander）和具体的事件处理器（ConcreteEventHandler）、Reactor。这些组件关系如图所示：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/IO框架库组件.png"><p><strong>句柄</strong></p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/句柄.png"><p><strong>事件多路分发器</strong></p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/事件多路分发器.png"><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/事件多路分发器1.png"><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/事件多路分发器2.png" style="zoom:80%;"><p><strong>事件处理器和具体事件处理器</strong></p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/事件处理器和具体事件处理器.png"><p><strong>Reactor</strong></p><p>Reactor 是 I/O 框架库的核心，它提供的几个主要方法是：</p><ul><li><code>handle_events</code>：该方法执行事件循环。它重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器。</li><li><code>register_handler</code>：该方法调用事件多路分发器的 <code>register_event</code> 方法来往事件多路分发器中注册一个事件。</li><li><code>remove_handler</code>：该方法掉调用事件多路分发器的 <code>remove_event</code> 方法来删除事件多路分发器中的一个事件。</li></ul><p>下图是 I/O 框架库的工作时序：</p><img src="/blog/2021/10/08/Linux高性能服务器编程（7-12）/IO框架库的工作时序.png"><h4 id="12-2-Libevent-源码分析"><a href="#12-2-Libevent-源码分析" class="headerlink" title="12.2 Libevent 源码分析"></a>12.2 Libevent 源码分析</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux高性能服务器编程（7-12）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.xingyuzhao.ltd/categories/Linux/"/>
    
    
      <category term="高性能服务器" scheme="http://www.xingyuzhao.ltd/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/10/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/10/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-10-08T01:49:03.000Z</published>
    <updated>2021-10-08T02:09:32.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目前已经整理的设计模式</strong></p><ol><li>单例模式</li><li>简单工厂模式</li></ol><a id="more"></a><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><p>创建对象时，不由我们直接实例化对象，而是根据特殊场景，<strong>由程序来确定创建对象的方式</strong>，从而保证更大的性能、更好的架构优势。</p><p>创建型模式主要有：</p><ul><li><strong>简单工厂模式</strong></li><li><strong>工厂方法</strong></li><li><strong>抽象工厂模式</strong></li><li><strong>单例模式</strong></li><li>生成器模式</li><li>原型模式</li></ul><h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><p><strong>用于帮助将多个对象组织成更大的结构。</strong></p><p>结构型模式主要有：</p><ul><li>适配器模式</li><li><strong>桥接模式</strong></li><li>组合器模式</li><li>装饰器模式</li><li><strong>门面模式</strong></li><li>享元模式</li><li><strong>代理模式</strong></li></ul><h4 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h4><p><strong>用于帮助系统间各对象的通信，以及如何控制复杂系统中流程。</strong></p><p>行为型模式主要有：</p><ul><li><strong>命令模式</strong></li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li><strong>观察者模式</strong></li><li>状态模式</li><li><strong>策略模式</strong></li><li>模板模式</li><li>访问者模式</li></ul><h3 id="常见的设计模式介绍"><a href="#常见的设计模式介绍" class="headerlink" title="常见的设计模式介绍"></a>常见的设计模式介绍</h3><h4 id="创建型-1"><a href="#创建型-1" class="headerlink" title="创建型"></a>创建型</h4><h5 id="单例模式（singleton）"><a href="#单例模式（singleton）" class="headerlink" title="单例模式（singleton）"></a>单例模式（singleton）</h5><p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>主要解决：一个全局使用的类频繁地创建与销毁。</p><p>何时使用：想控制实例数目，节省系统资源的时候。</p><p>如何解决：判断系统是否已存在单例，如果有则返回，没有则创建。</p><p>关键代码：私有构造函数。</p><p>实现方法：懒汉与饿汉。</p><h6 id="懒汉"><a href="#懒汉" class="headerlink" title="懒汉"></a><strong>懒汉</strong></h6><p>不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式，线程不安全</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建新的实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(Singleton &amp;obj) = <span class="keyword">delete</span>; <span class="comment">// 明确拒绝</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 明确拒绝</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//SINGLETON_SINGLETON_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Singleton.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton *s1 = Singleton::getInstance();</span><br><span class="line">    Singleton *s2 = Singleton::getInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式，线程安全</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_SINGLETON_MT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_SINGLETON_MT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton_mt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton_mt* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            mt.lock();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建新的实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton_mt();</span><br><span class="line">            mt.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton_mt(Singleton_mt &amp;obj) = <span class="keyword">delete</span>; <span class="comment">// 明确拒绝</span></span><br><span class="line">    Singleton_mt&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton_mt&amp;) = <span class="keyword">delete</span>; <span class="comment">// 明确拒绝</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton_mt() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton_mt* instance;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex mt;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton_mt* Singleton_mt::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton_mt::mt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Singleton_mt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callSingleton</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    Singleton_mt *s = Singleton_mt::getInstance();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"线程编号为："</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Sleep(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    thread th[THREAD_NUM];</span><br><span class="line">    <span class="comment">// 线程编号</span></span><br><span class="line">    <span class="keyword">int</span> threadNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(threadNum &lt; THREAD_NUM)&#123;</span><br><span class="line">        th[threadNum] = thread(callSingleton, threadNum);</span><br><span class="line">        threadNum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : th)&#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a><strong>饿汉</strong></h6><p>在单例类定义的时候就进行实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉模式，线程安全</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_SINGLETON_EHAN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_SINGLETON_EHAN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton_ehan</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton_ehan* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton_ehan(<span class="keyword">const</span> Singleton_ehan&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton_ehan&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton_ehan&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton_ehan* instance;</span><br><span class="line">    Singleton_ehan()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建新的实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton_ehan* Singleton_ehan::instance = <span class="keyword">new</span> Singleton_ehan();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Singleton_ehan.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton_ehan *s1 = Singleton_ehan::getInstance();</span><br><span class="line">    Singleton_ehan *s2 = Singleton_ehan::getInstance();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何选择</strong></p><p>由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能，以空间换时间；在访问量较小时，采用懒汉实现。这是以时间换空间。</p><h5 id="简单工厂模式（Factory）"><a href="#简单工厂模式（Factory）" class="headerlink" title="简单工厂模式（Factory）"></a>简单工厂模式（Factory）</h5><p><strong>实现流程</strong>：</p><ul><li>设计一个抽象类，它包含一些公共方法的实现</li><li>从抽象产品类中派生出多个具体产品类</li><li>设计一个工厂类，工厂类中提供一个生产各种产品的工厂方法，该方法根据传入参数（产品名称）创建不同的具体产品类对象</li><li>客户只需要调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象</li></ul><p><strong>简单工厂定义：</strong></p><p>定义一个简单工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p><strong>简单工厂模式结构</strong></p><p>大体上分为 3 个角色。</p><ul><li>工厂（Factory）：根据客户提供的具体产品类的参数，创建具体产品实例。</li><li>抽象产品（AbstractProduct）：具体产品类的基类，包含创建产品的公共方法。</li><li>具体产品（ConcreteProduct）：抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。</li></ul><p>简单工厂模式 UML 类图如下：</p><img src="/blog/2021/10/08/设计模式/简单工厂模式.png"><p><strong>实现</strong>：</p><p><a href="https://gitee.com/settlezxy/design-pattern.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/design-pattern.git</a></p><p><strong>优点：</strong></p><ul><li>工厂类提供创建具体产品的方法，并包含一定的逻辑，客户不必参与产品的创建过程。</li><li>客户只需要知道对应产品的参数即可，参数一般简单好记。</li></ul><p><strong>缺点：</strong></p><ul><li>增加新的具体产品违反<strong>开闭原则</strong>（对扩展开放，对修改关闭），即在扩展功能时修改了既有的代码。</li><li>简单工厂模式所有的判断逻辑都在工厂类中实现，一旦工厂类设计故障，则整个系统受之影响。</li></ul><h4 id="行为型-1"><a href="#行为型-1" class="headerlink" title="行为型"></a>行为型</h4><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>一个对象行为的改变，其相关联的对象都会得到通知，并自动产生相应的行为。这在软件设计模式中，即是<strong>观察者模式。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;目前已经整理的设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;简单工厂模式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://www.xingyuzhao.ltd/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="简单工厂模式" scheme="http://www.xingyuzhao.ltd/tags/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://www.xingyuzhao.ltd/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP（7-11）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/10/08/%E5%9B%BE%E8%A7%A3HTTP%EF%BC%887-11%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/10/08/%E5%9B%BE%E8%A7%A3HTTP%EF%BC%887-11%EF%BC%89/</id>
    <published>2021-10-08T01:38:49.000Z</published>
    <updated>2021-10-08T02:09:57.136Z</updated>
    
    <content type="html"><![CDATA[<p>图解HTTP（7-11）</p><a id="more"></a><h3 id="第-7-章-确保-Web-安全的-HTTPS"><a href="#第-7-章-确保-Web-安全的-HTTPS" class="headerlink" title="第 7 章 确保 Web 安全的 HTTPS"></a>第 7 章 确保 Web 安全的 HTTPS</h3><h4 id="7-1-HTTP-的缺点"><a href="#7-1-HTTP-的缺点" class="headerlink" title="7.1 HTTP 的缺点"></a>7.1 HTTP 的缺点</h4><ul><li>通信使用明文，内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul><h5 id="7-1-1-通信使用明文可能会被窃听"><a href="#7-1-1-通信使用明文可能会被窃听" class="headerlink" title="7.1.1 通信使用明文可能会被窃听"></a>7.1.1 通信使用明文可能会被窃听</h5><ul><li><p>TCP/IP 是可能被窃听的网络</p></li><li><p>加密处理防止被窃听</p><ul><li>SSL（Secure Socket Layer，安全套接层）</li><li>TLC（Transport Layer Security，安全层传输协议）</li></ul><p>与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。</p></li><li><p>内容的加密，内容有被窜改的风险</p></li></ul><h5 id="7-1-2-不验证通信方的身份就可能遭遇伪装"><a href="#7-1-2-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="7.1.2 不验证通信方的身份就可能遭遇伪装"></a>7.1.2 不验证通信方的身份就可能遭遇伪装</h5><ul><li>任何人都可发起请求，DOS 攻击</li><li>查明对手的证书<ul><li>虽然使用 HTTP 协议无法确定通信方，但使用 SSL 可以。SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。</li></ul></li></ul><h5 id="7-1-3-无法证明报文完整性，可能已遭篡改"><a href="#7-1-3-无法证明报文完整性，可能已遭篡改" class="headerlink" title="7.1.3 无法证明报文完整性，可能已遭篡改"></a>7.1.3 无法证明报文完整性，可能已遭篡改</h5><ul><li>接收到的内容可能有误。请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）</li><li>如何防止篡改。使用 HTTPS。</li></ul><h4 id="7-2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护=HTTPS"></a>7.2 HTTP+加密+认证+完整性保护=HTTPS</h4><h5 id="7-2-1-HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS"><a href="#7-2-1-HTTP-加上加密处理和认证以及完整性保护后即是-HTTPS" class="headerlink" title="7.2.1 HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS"></a>7.2.1 HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS</h5><p>我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。</p><img src="/blog/2021/10/08/图解HTTP（7-11）/使用HTTPS通信.png"><h5 id="7-2-2-HTTPS-是身披-SSL-外壳的-HTTP"><a href="#7-2-2-HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="7.2.2 HTTPS 是身披 SSL 外壳的 HTTP"></a>7.2.2 HTTPS 是身披 SSL 外壳的 HTTP</h5><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p><img src="/blog/2021/10/08/图解HTTP（7-11）/HTTP-HTTPS.png"><p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p><ul><li>SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是当今世界上应用最为广泛的网络安全技术。</li></ul><h5 id="7-2-3-相互交换密钥的公开密钥加密技术"><a href="#7-2-3-相互交换密钥的公开密钥加密技术" class="headerlink" title="7.2.3 相互交换密钥的公开密钥加密技术"></a>7.2.3 相互交换密钥的公开密钥加密技术</h5><p>SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p><p>近代加密方法中<strong>加密算法</strong>是<strong>公开</strong>的，而<strong>密钥</strong>却是保密的，通过这种方式得以保持加密方法的安全性。</p><p>加密和解密都会用到密钥，任何持有密钥的人都可以解密，如果被攻击者获得，则加密失去意义。</p><ul><li><p><strong>共享密钥加密</strong>的困境</p><ul><li>加密和解密同用一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密。发送密钥就有被窃听的风险，但不发送，对方就不能解密。再说，密钥若能够安全发送，那数据也应该能安全到达。</li></ul></li><li><p>使用<strong>两把</strong>密钥的<strong>公开密钥加密</strong>，很好的解决了共享密钥加密的困难</p><ul><li>公开密钥加密使用一对非对称的密钥，一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。私钥不能让其他人知道，而公钥任何人都可以获得。</li><li>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</li></ul></li><li><p>HTTPS 采用<strong>混合加密机制</strong></p><ul><li>在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</li></ul><img src="/blog/2021/10/08/图解HTTP（7-11）/混合加密机制.png"></li></ul><h5 id="7-2-4-证明公开密钥正确性的证书"><a href="#7-2-4-证明公开密钥正确性的证书" class="headerlink" title="7.2.4 证明公开密钥正确性的证书"></a>7.2.4 证明公开密钥正确性的证书</h5><p>公开密钥加密方式还是存在一些问题的。那就是无法证明<strong>公开密钥本身就是货真价实的公开密钥。</strong></p><p>为了解决上述问题，可以使用由<strong>数字证书认证机构</strong>（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。</p><p><strong>流程</strong></p><p>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后将已签名的公开密钥分配，并将该公开密钥放入公钥证书后绑定在一起。</p><p>多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p><img src="/blog/2021/10/08/图解HTTP（7-11）/SSL流程.png"><ul><li>可证明组织真实性的 EV SSL 证书<ol><li>证明作为通信一方的服务器是否规范</li><li>确认服务器背后运营的企业是否真实存在</li></ol></li><li>用来确认客户端的客户端证书</li><li>认证机构信誉第一，SSL 机制中介入认证机构之所以可行，是因为建立在其信用绝对可靠这一大前提下的。</li><li>由自认证机构办法的证书称为自签名证书，浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。</li></ul><h5 id="7-2-5-HTTPS-的安全通信机制"><a href="#7-2-5-HTTPS-的安全通信机制" class="headerlink" title="7.2.5 HTTPS 的安全通信机制"></a>7.2.5 HTTPS 的安全通信机制</h5><ul><li><p>SSL 和 TLS，HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security）这两个协议。</p><ul><li>SSL 技术起初由网景开发，直到 SSL3.0，后转移至 IETF 手中；</li><li>IETF 以 SSL3.0 为基准，制定了 TLS1.0、TLS1.1 和 TLS1.2。有时候统称该协议为 SSL；</li><li>当前主流版本为 SSL3.0 和 TLS1.0。</li></ul></li><li><p>SSL 速度慢吗？</p><ul><li>HTTPS 比 HTTP 慢 2 到 100倍</li></ul></li></ul><h3 id="第-8-章-确认访问用户身份的认证"><a href="#第-8-章-确认访问用户身份的认证" class="headerlink" title="第 8 章 确认访问用户身份的认证"></a>第 8 章 确认访问用户身份的认证</h3><p>某些 Web 页面只想让特定的人浏览，或者干脆仅本人可见。为达到这个目标，必不可少的就是认证功能。</p><h4 id="8-1-何为认证"><a href="#8-1-何为认证" class="headerlink" title="8.1 何为认证"></a>8.1 何为认证</h4><p>核对的信息通常是以下这些：</p><ul><li>密码：只有本人才会知道的字符串信息。 </li><li>动态令牌：仅限本人持有的设备内显示的一次性密码。 </li><li>数字证书：仅限本人（终端）持有的信息。 </li><li>生物认证：指纹和虹膜等本人的生理信息。</li><li>IC 卡等：仅限本人持有的信息。</li></ul><p><strong>HTTP 使用的认证方式</strong></p><p>HTTP/1.1 使用的认证方式如下所示：</p><ul><li>BASIC 认证（基本认证） </li><li>DIGEST 认证（摘要认证）</li><li>SSL 客户端认证 </li><li>FormBase 认证（基于表单认证）</li></ul><h4 id="8-2-BASIC-认证"><a href="#8-2-BASIC-认证" class="headerlink" title="8.2 BASIC 认证"></a>8.2 BASIC 认证</h4><p>BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。</p><p>BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。 </p><p>另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。</p><h4 id="8-3-DIGEST-认证"><a href="#8-3-DIGEST-认证" class="headerlink" title="8.3 DIGEST 认证"></a>8.3 DIGEST 认证</h4><p>为了克服 BASIC 弱点，从 HTTP/1.1 起就有了 DIGEST 认证。</p><p>DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。</p><h4 id="8-4-SSL-客户端认证"><a href="#8-4-SSL-客户端认证" class="headerlink" title="8.4 SSL 客户端认证"></a>8.4 SSL 客户端认证</h4><h5 id="8-4-1-SSL客户端认证的认证步骤"><a href="#8-4-1-SSL客户端认证的认证步骤" class="headerlink" title="8.4.1 SSL客户端认证的认证步骤"></a>8.4.1 SSL客户端认证的认证步骤</h5><p>步骤 1： 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。</p><p>步骤 2： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</p><p>步骤 3： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</p><h5 id="8-4-2-SSL-客户端认证采用双因素认证"><a href="#8-4-2-SSL-客户端认证采用双因素认证" class="headerlink" title="8.4.2 SSL 客户端认证采用双因素认证"></a>8.4.2 SSL 客户端认证采用双因素认证</h5><p>第一个认证因素的 SSL客户端证书用来认证客户端计算机， 另一个认证因素的密码则用来确定这是用户本人的行为。</p><h5 id="8-4-3-SSL-客户端认证必要的费用"><a href="#8-4-3-SSL-客户端认证必要的费用" class="headerlink" title="8.4.3 SSL 客户端认证必要的费用"></a>8.4.3 SSL 客户端认证必要的费用</h5><h4 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h4><p>基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。</p><h5 id="8-5-1-认证多半为基于表单认证"><a href="#8-5-1-认证多半为基于表单认证" class="headerlink" title="8.5.1 认证多半为基于表单认证"></a>8.5.1 认证多半为基于表单认证</h5><h5 id="8-5-2-Session-管理及-Cookie-应用"><a href="#8-5-2-Session-管理及-Cookie-应用" class="headerlink" title="8.5.2 Session 管理及 Cookie 应用"></a>8.5.2 Session 管理及 Cookie 应用</h5><p>基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session（会话）。</p><img src="/blog/2021/10/08/图解HTTP（7-11）/Session管理及Cookie状态管理.png"><p>你可以把 Session ID 想象成一种用以区分不同用户的等位号。</p><h3 id="第-9-章-基于-HTTP-的功能追加协议"><a href="#第-9-章-基于-HTTP-的功能追加协议" class="headerlink" title="第 9 章 基于 HTTP 的功能追加协议"></a>第 9 章 基于 HTTP 的功能追加协议</h3><h4 id="9-1-基于-HTTP-的协议"><a href="#9-1-基于-HTTP-的协议" class="headerlink" title="9.1 基于 HTTP 的协议"></a>9.1 基于 HTTP 的协议</h4><p>HTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃 HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了新的功能。</p><h4 id="9-2-消除-HTTP-瓶颈的-SPDY"><a href="#9-2-消除-HTTP-瓶颈的-SPDY" class="headerlink" title="9.2 消除 HTTP 瓶颈的 SPDY"></a>9.2 消除 HTTP 瓶颈的 SPDY</h4><p>Google 在 2010 年发布了 SPDY（取自 SPeeDY，发音同 speedy），其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。</p><h5 id="9-2-1-HTTP-的瓶颈"><a href="#9-2-1-HTTP-的瓶颈" class="headerlink" title="9.2.1 HTTP 的瓶颈"></a>9.2.1 HTTP 的瓶颈</h5><p>若想在现有 Web 实现所需的功能，以下这些 HTTP 标准就会成为瓶颈：</p><ul><li>一条连接上只可发送一个请求。 </li><li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。 </li><li>请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较 多。</li><li>可任意选择数据压缩格式。非强制压缩发送。</li></ul><img src="/blog/2021/10/08/图解HTTP（7-11）/从前的HTTP.png" style="zoom:80%;"><p><strong>Ajax 的解决方法</strong></p><p>Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。</p><p><strong>Comet 的解决方法</strong></p><p>一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。</p><h5 id="9-2-2-SPDY-的设计与功能"><a href="#9-2-2-SPDY-的设计与功能" class="headerlink" title="9.2.2 SPDY 的设计与功能"></a>9.2.2 SPDY 的设计与功能</h5><p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过<strong>新加会话层</strong>的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。</p><p>SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方法、 Cookie 以及 HTTP 报文等。</p><img src="/blog/2021/10/08/图解HTTP（7-11）/SPDY.png"><p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p><ul><li>多路复用流，单一 TCP 连接可以无限制处理多个 HTTP 请求，提高 TCP 处理效率。</li><li>赋予请求优先级，在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li><li>压缩 HTTP 请求和响应的头部，通信产生的数据包数量和发送的字节数就更少了。</li><li>推送功能，支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</li><li>服务器提示功能，服务器可以主动提示客户端请求所需的资源。</li></ul><h5 id="9-2-3-SPDY-消除-Web-瓶颈了吗"><a href="#9-2-3-SPDY-消除-Web-瓶颈了吗" class="headerlink" title="9.2.3 SPDY 消除 Web 瓶颈了吗"></a>9.2.3 SPDY 消除 Web 瓶颈了吗</h5><p>因为 SPDY 基本上只是将单个域名（ IP 地址）的通信多路复用，所 以当一个 Web 网站上使用多个域名下的资源，改善效果就会受到限制。</p><p>SPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致。</p><h4 id="9-3-使用浏览器进行全双工通信的-WebSocket"><a href="#9-3-使用浏览器进行全双工通信的-WebSocket" class="headerlink" title="9.3 使用浏览器进行全双工通信的 WebSocket"></a>9.3 使用浏览器进行全双工通信的 WebSocket</h4><p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。</p><h5 id="9-3-1-WebSocket-的设计与功能"><a href="#9-3-1-WebSocket-的设计与功能" class="headerlink" title="9.3.1 WebSocket 的设计与功能"></a>9.3.1 WebSocket 的设计与功能</h5><p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。</p><h5 id="9-3-2-WebSocket-协议"><a href="#9-3-2-WebSocket-协议" class="headerlink" title="9.3.2 WebSocket 协议"></a>9.3.2 WebSocket 协议</h5><p>特点：</p><ul><li><p>推送功能，服务器向客户端推送数据。</p></li><li><p>减少通信量，只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。在 HTTP 连接建立之后，需要完成一 次“握手”（Handshaking）的步骤。</p><ul><li>握手-请求，为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。</li></ul><img src="/blog/2021/10/08/图解HTTP（7-11）/websocket1.png"><ul><li>握手-响应，对于之前的请求，返回状态码 101 Switching Protocols 的响应。</li></ul><img src="/blog/2021/10/08/图解HTTP（7-11）/websocket2.png"><p>成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p><ul><li>WebSocket API</li></ul></li></ul><h4 id="9-4-期盼已久的-HTTP-2-0"><a href="#9-4-期盼已久的-HTTP-2-0" class="headerlink" title="9.4 期盼已久的 HTTP/2.0"></a>9.4 期盼已久的 HTTP/2.0</h4><p><strong>HTTP/2.0 的 特点</strong></p><img src="/blog/2021/10/08/图解HTTP（7-11）/HTTP2.0特点.png"><h5 id="9-5-Web-服务器管理文件的-WebDAV"><a href="#9-5-Web-服务器管理文件的-WebDAV" class="headerlink" title="9.5 Web 服务器管理文件的 WebDAV"></a>9.5 Web 服务器管理文件的 WebDAV</h5><p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。它作为扩展 HTTP/1.1 的协议定义在 RFC4918。</p><p>使用 HTTP/1.1 的 PUT 方法和 DELETE 方法，就可以对 Web 服务器上的文件进行创建和删除操作。可是出于安全性及便捷性等考虑，一 般不使用。</p><h5 id="9-5-1-扩展-HTTP-1-1-的-WebDAV"><a href="#9-5-1-扩展-HTTP-1-1-的-WebDAV" class="headerlink" title="9.5.1 扩展 HTTP/1.1 的 WebDAV"></a>9.5.1 扩展 HTTP/1.1 的 WebDAV</h5><p>针对服务器上的资源，WebDAV 新增加了一些概念，如下所示：</p><ul><li>集合：是一种统一管理多个资源的概念。</li><li>资源：把文件或集合称为资源。</li><li>属性：定义资源的属性。格式为“名称=值”。</li><li>锁：把文件设置成无法编辑状态。</li></ul><h5 id="9-5-2-WebDAV-内新增的方法及状态码"><a href="#9-5-2-WebDAV-内新增的方法及状态码" class="headerlink" title="9.5.2 WebDAV 内新增的方法及状态码"></a>9.5.2 WebDAV 内新增的方法及状态码</h5><p>WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。</p><ul><li>PROPFIND ：获取属性</li><li>PROPPATCH ：修改属性 </li><li>MKCOL ：创建集合 </li><li>COPY ：复制资源及属性 </li><li>MOVE ：移动资源 </li><li>LOCK ：资源加锁 </li><li>UNLOCK ：资源解锁</li></ul><p>为配合扩展的方法，状态码也随之扩展。</p><ul><li>102 Processing ：可正常处理请求，但目前是处理中状态 </li><li>207 Multi-Status ：存在多种状态 </li><li>422 Unprocessible Entity ：格式正确，内容有误 </li><li>423 Locked ：资源已被加锁 </li><li>424 Failed Dependency ：处理与某请求关联的请求失败，因此不再维持依赖关系 </li><li>507 Insufficient Storage ：保存空间不足</li></ul><h3 id="第-10-章-构建-Web-内容的技术"><a href="#第-10-章-构建-Web-内容的技术" class="headerlink" title="第 10 章 构建 Web 内容的技术"></a>第 10 章 构建 Web 内容的技术</h3><h4 id="10-1-HTML"><a href="#10-1-HTML" class="headerlink" title="10.1 HTML"></a>10.1 HTML</h4><h5 id="10-1-1-Web-页面几乎全由-HTML-构建"><a href="#10-1-1-Web-页面几乎全由-HTML-构建" class="headerlink" title="10.1.1 Web 页面几乎全由 HTML 构建"></a>10.1.1 Web 页面几乎全由 HTML 构建</h5><p>HTML（HyperText Markup Language，超文本标记语言）是为了发送 Web 上的超文本（Hypertext）而开发的标记语言。</p><h5 id="10-1-2-HTML-的版本"><a href="#10-1-2-HTML-的版本" class="headerlink" title="10.1.2 HTML 的版本"></a>10.1.2 HTML 的版本</h5><p>目前的最新版本是 HTML4.01 标准，1999 年 12 月 W3C（World Wide Web Consortium）组织推荐使用这一版本。下一个版本，预计会在 2014 年左右正式推荐使用 HTML5 标准。</p><p>HTML5 标准不仅解决了浏览器之间的兼容性问题，并且可把文本作为数据对待，更容易复用，动画等效果也变得更生动。</p><h5 id="10-1-3-设计应用-CSS"><a href="#10-1-3-设计应用-CSS" class="headerlink" title="10.1.3 设计应用 CSS"></a>10.1.3 设计应用 CSS</h5><p>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML 内的各种元素，属于样式表标准之一。即使是相同的 HTML 文档， 通过改变应用的 CSS，用浏览器看到的页面外观也会随之改变。CSS 的理念就是让文档的结构和设计分离，达到解耦的目的。</p><h4 id="10-2-动态-HTML"><a href="#10-2-动态-HTML" class="headerlink" title="10.2 动态 HTML"></a>10.2 动态 HTML</h4><h5 id="10-2-1-让-Web-页面动起来的动态-HTML"><a href="#10-2-1-让-Web-页面动起来的动态-HTML" class="headerlink" title="10.2.1 让 Web 页面动起来的动态 HTML"></a>10.2.1 让 Web 页面动起来的动态 HTML</h5><p>动态 HTML技术是通过调用客户端脚本语言 JavaScript，实现对 HTML 的 Web 页面的动态改造。利用 DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的 HTML 元素。</p><h5 id="10-2-2-更易控制-HTML-的-DOM"><a href="#10-2-2-更易控制-HTML-的-DOM" class="headerlink" title="10.2.2 更易控制 HTML 的 DOM"></a>10.2.2 更易控制 HTML 的 DOM</h5><p>DOM 是用以操作 HTML 文档和 XML 文档的 API（Application Programming Interface，应用编程接口）。使用 DOM 可以将 HTML 内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。</p><h4 id="10-3-Web-应用"><a href="#10-3-Web-应用" class="headerlink" title="10.3 Web 应用"></a>10.3 Web 应用</h4><h5 id="10-3-1-通过-web-提供功能的-Web-应用"><a href="#10-3-1-通过-web-提供功能的-Web-应用" class="headerlink" title="10.3.1 通过 web 提供功能的 Web 应用"></a>10.3.1 通过 web 提供功能的 Web 应用</h5><p>原本应用 HTTP 协议的 Web 的机制就是对客户端发来的请求，返回事前准备好的内容。随着 Web 越来越普及，仅靠这样的做法已不足以应对所有的需求。</p><p>引入由程序创建 HTML 内容的做法，称为动态内容，而事先准备好的内容称为静态内容。web应用则作用于动态内容之上。</p><h5 id="10-3-2-与-Web-服务器及程序协作的-CGI※"><a href="#10-3-2-与-Web-服务器及程序协作的-CGI※" class="headerlink" title="10.3.2 与 Web 服务器及程序协作的 CGI※"></a>10.3.2 与 Web 服务器及程序协作的 CGI※</h5><p>CGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建 HTML 等动态内容。</p><img src="/blog/2021/10/08/图解HTTP（7-11）/CGI.png"><h5 id="10-3-3-因-JAVA-而普及的-Servlet"><a href="#10-3-3-因-JAVA-而普及的-Servlet" class="headerlink" title="10.3.3 因 JAVA 而普及的 Servlet"></a>10.3.3 因 JAVA 而普及的 Servlet</h5><p>之前提及的 CGI，由于每次接到请求，程序都要跟着启动一次。因此一旦访问量过大，Web 服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中，因此受到的负载较小 2。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。</p><h4 id="10-4-数据发布的格式及语言"><a href="#10-4-数据发布的格式及语言" class="headerlink" title="10.4 数据发布的格式及语言"></a>10.4 数据发布的格式及语言</h4><h5 id="10-4-1-可扩展标记语言"><a href="#10-4-1-可扩展标记语言" class="headerlink" title="10.4.1 可扩展标记语言"></a>10.4.1 可扩展标记语言</h5><p>XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数据共享变得更容易。 XML和 HTML都是从标准通用标记语言 SGML（Standard Generalized Markup Language）简化而成。与 HTML相比，它对数据的记录方式做了特殊处理。</p><h5 id="10-4-2-发布更新信息的-RSS-Atom"><a href="#10-4-2-发布更新信息的-RSS-Atom" class="headerlink" title="10.4.2 发布更新信息的 RSS/Atom"></a>10.4.2 发布更新信息的 RSS/Atom</h5><p>RSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。</p><h5 id="10-4-3-JavaScript-衍生的轻量级易用-JSON"><a href="#10-4-3-JavaScript-衍生的轻量级易用-JSON" class="headerlink" title="10.4.3 JavaScript 衍生的轻量级易用 JSON"></a>10.4.3 JavaScript 衍生的轻量级易用 JSON</h5><p>JSON（JavaScript Object Notation）是一种以 JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符 串，这 7 种类型。</p><img src="/blog/2021/10/08/图解HTTP（7-11）/JSON.png"><p>JSON 让数据更轻更纯粹，并且 JSON 的字符串形式可被 JavaScript 轻易地读入。</p><h3 id="第-11-章-Web-的攻击技术"><a href="#第-11-章-Web-的攻击技术" class="headerlink" title="第 11 章 Web 的攻击技术"></a>第 11 章 Web 的攻击技术</h3><h4 id="11-1-针对-Web-的攻击技术"><a href="#11-1-针对-Web-的攻击技术" class="headerlink" title="11.1 针对 Web 的攻击技术"></a>11.1 针对 Web 的攻击技术</h4><h5 id="11-1-1-HTTP-不具备必要的安全功能"><a href="#11-1-1-HTTP-不具备必要的安全功能" class="headerlink" title="11.1.1 HTTP 不具备必要的安全功能"></a>11.1.1 HTTP 不具备必要的安全功能</h5><h5 id="11-1-2-在客户端即可篡改请求"><a href="#11-1-2-在客户端即可篡改请求" class="headerlink" title="11.1.2 在客户端即可篡改请求"></a>11.1.2 在客户端即可篡改请求</h5><h5 id="11-1-3-针对-Web-应用的攻击模式"><a href="#11-1-3-针对-Web-应用的攻击模式" class="headerlink" title="11.1.3 针对 Web 应用的攻击模式"></a>11.1.3 针对 Web 应用的攻击模式</h5><p>对 Web 应用的攻击模式有以下两种。</p><ul><li>主动攻击</li><li>被动攻击</li></ul><p><strong>以服务器为目标的主动攻击</strong></p><p>主动攻击模式里具有代表性的攻击是 SQL注入攻击和 OS 命令注入攻击。</p><img src="/blog/2021/10/08/图解HTTP（7-11）/主动攻击.png"><p><strong>以服务器为目标的被动攻击</strong></p><p>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</p><img src="/blog/2021/10/08/图解HTTP（7-11）/被动攻击.png" style="zoom:120%;"><p><strong>利用用户的身份攻击企业内部网络（被动攻击）</strong></p><img src="/blog/2021/10/08/图解HTTP（7-11）/被动攻击2.png"><h4 id="11-2-因输出值转义不完全引发的安全漏洞"><a href="#11-2-因输出值转义不完全引发的安全漏洞" class="headerlink" title="11.2 因输出值转义不完全引发的安全漏洞"></a>11.2 因输出值转义不完全引发的安全漏洞</h4><p>实施 Web 应用的安全对策大致分为以下两种：</p><ul><li>客户端的验证</li><li>Web 应用端（服务器端）的验证<ul><li>输入值验证</li><li>输出值转义</li></ul></li></ul><img src="/blog/2021/10/08/图解HTTP（7-11）/验证数据的几个位置.png"><p>从数据库或文件系统、HTML、邮件等输出 Web 应用处理的数据之际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。</p><h5 id="11-2-1-跨站脚本攻击"><a href="#11-2-1-跨站脚本攻击" class="headerlink" title="11.2.1 跨站脚本攻击"></a>11.2.1 跨站脚本攻击</h5><p>跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。动态创建的 HTML 部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。</p><p>跨站脚本攻击有可能造成以下影响。：</p><ul><li>利用虚假输入表单骗取用户个人信息。 </li><li>利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下， 帮助攻击者发送恶意请求。 </li><li>显示伪造的文章或图片。</li></ul><h5 id="11-2-2-SQL-注入攻击"><a href="#11-2-2-SQL-注入攻击" class="headerlink" title="11.2.2 SQL 注入攻击"></a>11.2.2 SQL 注入攻击</h5><p><strong>会执行非法 SQL 的 SQL 注入攻击</strong></p><p>SQL注入攻击有可能会造成以下等影响：</p><ul><li>非法查看或篡改数据库内的数据 </li><li>规避认证 </li><li>执行和数据库服务器业务关联的程序等</li></ul><p><strong>SQL 注入攻击案例</strong></p><p>P211</p><h5 id="11-2-3-OS-命令注入攻击"><a href="#11-2-3-OS-命令注入攻击" class="headerlink" title="11.2.3 OS 命令注入攻击"></a>11.2.3 OS 命令注入攻击</h5><p>OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。</p><h5 id="11-2-4-HTTP-首部注入攻击"><a href="#11-2-4-HTTP-首部注入攻击" class="headerlink" title="11.2.4 HTTP 首部注入攻击"></a>11.2.4 HTTP 首部注入攻击</h5><p>HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。</p><p>HTTP 首部注入攻击有可能会造成以下一些影响：</p><ul><li>设置任何 Cookie 信息 </li><li>重定向至任意 URL </li><li>显示任意的主体（HTTP 响应截断攻击）</li></ul><p><strong>HTTP 响应截断攻击</strong></p><p>HTTP 响应截断攻击是用在 HTTP 首部注入的一种攻击。攻击顺 相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送。利用这两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的。这样的攻击叫做 HTTP 响应截断攻击。</p><h5 id="11-2-5-邮件首部注入攻击"><a href="#11-2-5-邮件首部注入攻击" class="headerlink" title="11.2.5 邮件首部注入攻击"></a>11.2.5 邮件首部注入攻击</h5><p>邮件首部注入（Mail Header Injection）是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告邮件或病毒邮件。</p><h5 id="11-2-6-目录遍历攻击"><a href="#11-2-6-目录遍历攻击" class="headerlink" title="11.2.6 目录遍历攻击"></a>11.2.6 目录遍历攻击</h5><p>目录遍历（Directory Traversal）攻击是指对本<strong>无意公开</strong>的文件目录， 通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。</p><h5 id="11-2-7-远程文件包含漏洞"><a href="#11-2-7-远程文件包含漏洞" class="headerlink" title="11.2.7 远程文件包含漏洞"></a>11.2.7 远程文件包含漏洞</h5><p>远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文 件，让脚本读取之后，就可运行任意脚本的一种攻击。</p><h4 id="11-3-因设置或设计上的缺陷引发的安全漏洞"><a href="#11-3-因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="11.3 因设置或设计上的缺陷引发的安全漏洞"></a>11.3 因设置或设计上的缺陷引发的安全漏洞</h4><h5 id="11-3-1-强制浏览"><a href="#11-3-1-强制浏览" class="headerlink" title="11.3.1 强制浏览"></a>11.3.1 强制浏览</h5><p>强制浏览（Forced Browsing）安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。</p><p>强制浏览有可能会造成以下一些影响：</p><ul><li>泄露顾客的个人信息等重要情报</li><li>泄露原本需要具有访问权限的用户才可查阅的信息内容 </li><li>泄露未外连到外界的文件</li></ul><h5 id="11-3-2-不正确的错误消息处理"><a href="#11-3-2-不正确的错误消息处理" class="headerlink" title="11.3.2 不正确的错误消息处理"></a>11.3.2 不正确的错误消息处理</h5><p>不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web 应用的错误信息内包含对攻击者有用的信息。与 Web 应用有关的主要错误信息如下所示。</p><ul><li>Web 应用抛出的错误消息 </li><li>数据库等系统抛出的错误消息</li></ul><h5 id="11-3-3-开放重定向"><a href="#11-3-3-开放重定向" class="headerlink" title="11.3.3 开放重定向"></a>11.3.3 开放重定向</h5><p>开放重定向（Open Redirect）是一种对指定的任意 URL作重定向跳转的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。</p><h4 id="11-4-因会话管理疏忽引发的安全漏洞"><a href="#11-4-因会话管理疏忽引发的安全漏洞" class="headerlink" title="11.4 因会话管理疏忽引发的安全漏洞"></a>11.4 因会话管理疏忽引发的安全漏洞</h4><h5 id="11-4-1-会话劫持"><a href="#11-4-1-会话劫持" class="headerlink" title="11.4.1 会话劫持"></a>11.4.1 会话劫持</h5><p>会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</p><p>下面列举了几种攻击者可获得会话 ID 的途径：</p><ul><li>通过非正规的生成方法推测会话 ID </li><li>通过窃听或 XSS 攻击盗取会话 ID </li><li>通过会话固定攻击（Session Fixation）强行获取会话 ID</li></ul><h5 id="11-4-2-会话固定攻击"><a href="#11-4-2-会话固定攻击" class="headerlink" title="11.4.2 会话固定攻击"></a>11.4.2 会话固定攻击</h5><p>对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击。</p><h5 id="11-4-3-跨站点请求伪造"><a href="#11-4-3-跨站点请求伪造" class="headerlink" title="11.4.3 跨站点请求伪造"></a>11.4.3 跨站点请求伪造</h5><p>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</p><p>跨站点请求伪造有可能会造成以下等影响：</p><ul><li>利用已通过认证的用户权限更新设定信息等 </li><li>利用已通过认证的用户权限购买商品 </li><li>利用已通过认证的用户权限在留言板上发表言论</li></ul><h4 id="11-5-其他安全漏洞"><a href="#11-5-其他安全漏洞" class="headerlink" title="11.5 其他安全漏洞"></a>11.5 其他安全漏洞</h4><h5 id="11-5-1-密码破解"><a href="#11-5-1-密码破解" class="headerlink" title="11.5.1 密码破解"></a>11.5.1 密码破解</h5><p>密码破解攻击（Password Cracking）即算出密码，突破认证。攻击不仅限于 Web 应用，还包括其他的系统（如 FTP 或 SSH 等），本节将会讲解对具备认证功能的 Web 应用进行的密码破解。</p><p>密码破解有以下两种手段。 </p><ul><li>通过网络的密码试错 <ul><li>穷举法</li><li>字典攻击</li></ul></li><li>对已加密密码的破解（指攻击者入侵系统，已获得加密或散列处理的密码数据的情况）</li></ul><h5 id="11-5-2-点击劫持"><a href="#11-5-2-点击劫持" class="headerlink" title="11.5.2 点击劫持"></a>11.5.2 点击劫持</h5><p>点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖 在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。</p><h5 id="11-5-3-Dos-攻击"><a href="#11-5-3-Dos-攻击" class="headerlink" title="11.5.3 Dos 攻击"></a>11.5.3 Dos 攻击</h5><p>DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。</p><p>主要有以下两种 Dos 攻击方式：</p><ul><li>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈通知状态</li><li>通过攻击安全漏洞使服务停止</li></ul><p>多台计算机发起的 DoS 攻击称为 DDoS 攻击（Distributed Denial of Service attack）。DDoS 攻击通常利用那些感染病毒的计算机作为攻 击者的攻击跳板。</p><h5 id="11-5-4-后门程序"><a href="#11-5-4-后门程序" class="headerlink" title="11.5.4 后门程序"></a>11.5.4 后门程序</h5><p>后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。</p><p>通常的后门程序分为以下 3 种类型。 </p><ul><li>开发阶段作为 Debug 调用的后门程序 </li><li>开发者为了自身利益植入的后门程序 </li><li>攻击者通过某种方法设置的后门程序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图解HTTP（7-11）&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://www.xingyuzhao.ltd/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://www.xingyuzhao.ltd/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP（1-6）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/10/08/%E5%9B%BE%E8%A7%A3HTTP%EF%BC%881-6%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/10/08/%E5%9B%BE%E8%A7%A3HTTP%EF%BC%881-6%EF%BC%89/</id>
    <published>2021-10-08T01:38:25.000Z</published>
    <updated>2021-10-08T02:10:09.095Z</updated>
    
    <content type="html"><![CDATA[<p>图解HTTP（1-6）</p><a id="more"></a><h3 id="第-1-章-了解-web-及网络基础"><a href="#第-1-章-了解-web-及网络基础" class="headerlink" title="第 1 章 了解 web 及网络基础"></a>第 1 章 了解 web 及网络基础</h3><h4 id="1-6-各种协议与-HTTP-协议的关系"><a href="#1-6-各种协议与-HTTP-协议的关系" class="headerlink" title="1.6 各种协议与 HTTP 协议的关系"></a>1.6 各种协议与 HTTP 协议的关系</h4><p>IP协议、TCP协议和DNS服务在使用HTTP协议的通信过程中各自发挥了哪些作用。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/各种协议与HTTP协议的关系.png"><h4 id="1-7-URI-和-URL"><a href="#1-7-URI-和-URL" class="headerlink" title="1.7 URI 和 URL"></a>1.7 URI 和 URL</h4><p>URI（Uniform Resource Identifier）：统一资源标识符。</p><p>URL（Uniform Resource Locator）：统一资源定位符。</p><p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见<strong>URL 是 URI 的子集</strong>。URL 是通过定位方式实现的 URI。</p><p>总的来说，<strong>locators are also identifiers</strong>, so every URL is also a URI, but there are URIs which are not URLs.</p><p>参考：<a href="https://www.zhihu.com/question/21950864%E3%80%82" target="_blank" rel="noopener">https://www.zhihu.com/question/21950864。</a></p><h3 id="第-2-章-简单的-HTTP-协议"><a href="#第-2-章-简单的-HTTP-协议" class="headerlink" title="第 2 章 简单的 HTTP 协议"></a>第 2 章 简单的 HTTP 协议</h3><h4 id="2-1-HTTP-协议用于客户端和服务器端之间的通信"><a href="#2-1-HTTP-协议用于客户端和服务器端之间的通信" class="headerlink" title="2.1 HTTP 协议用于客户端和服务器端之间的通信"></a>2.1 HTTP 协议用于客户端和服务器端之间的通信</h4><h4 id="2-2-通过请求和响应的交换达成通信"><a href="#2-2-通过请求和响应的交换达成通信" class="headerlink" title="2.2 通过请求和响应的交换达成通信"></a>2.2 通过请求和响应的交换达成通信</h4><img src="/blog/2021/10/08/图解HTTP（1-6）/2.2-1.png"><p><strong>请求报文的构成</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/2.2-2.png"><p><strong>响应报文的构成</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/2.2-3.png"><h4 id="2-3-HTTP-是不保存状态的协议"><a href="#2-3-HTTP-是不保存状态的协议" class="headerlink" title="2.3 HTTP 是不保存状态的协议"></a>2.3 HTTP 是不保存状态的协议</h4><p>HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。</p><h4 id="2-4-请求-URI-定位资源"><a href="#2-4-请求-URI-定位资源" class="headerlink" title="2.4 请求 URI 定位资源"></a>2.4 请求 URI 定位资源</h4><p>以 <code>http://hackr.jp/index.htm</code> 为例： </p><img src="/blog/2021/10/08/图解HTTP（1-6）/请求例子.png"><p>查询 HTTP 服务器端支持的 HTTP 方法种类：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS * HTTP/1.1</span><br></pre></td></tr></table></figure><h4 id="2-5-告知服务器意图的-HTTP-方法※"><a href="#2-5-告知服务器意图的-HTTP-方法※" class="headerlink" title="2.5 告知服务器意图的 HTTP 方法※"></a>2.5 告知服务器意图的 HTTP 方法※</h4><p><strong>GET</strong>：获取资源。</p><p>使用 GET 方法请求-响应的例子：</p><img src="/blog/2021/10/08/图解HTTP（1-6）/2.5-1.png"><p><strong>POST</strong>：传输实体主体。</p><p>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。使用 POST 方法的请求-响应的例子：</p><img src="/blog/2021/10/08/图解HTTP（1-6）/2.5-2.png"><p><strong>PUT</strong>：传输文件。</p><p>就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。一般配合 Web 验证机制使用。使用 PUT 方法的请求-响应的例子：</p><img src="/blog/2021/10/08/图解HTTP（1-6）/2.5-3.png"><p><strong>HEAD</strong>：获得报文首部。</p><p><strong>DELETE</strong>：删除文件。</p><p><strong>OPTIONS</strong>：询问支持的方法。</p><p><strong>TRACE</strong>：追踪路径。</p><p><strong>CONNECT</strong>：要求用隧道协议连接代理。</p><h4 id="2-6-使用方法下达命令"><a href="#2-6-使用方法下达命令" class="headerlink" title="2.6 使用方法下达命令"></a>2.6 使用方法下达命令</h4><p>向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/2.6.png"><h4 id="2-7-持久连接节省通信量"><a href="#2-7-持久连接节省通信量" class="headerlink" title="2.7 持久连接节省通信量"></a>2.7 持久连接节省通信量</h4><h5 id="2-7-1-持久连接"><a href="#2-7-1-持久连接" class="headerlink" title="2.7.1 持久连接"></a>2.7.1 持久连接</h5><p>持久连接的特点是：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p><strong>在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。</strong></p><h5 id="2-7-2-管线化"><a href="#2-7-2-管线化" class="headerlink" title="2.7.2 管线化"></a>2.7.2 管线化</h5><p>持久连接使得多数请求以<strong>管线化</strong>（pipelining）方式发送成为可能。</p><p>从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p><h5 id="2-8-使用-Cookie-的状态管理"><a href="#2-8-使用-Cookie-的状态管理" class="headerlink" title="2.8 使用 Cookie 的状态管理"></a>2.8 使用 Cookie 的状态管理</h5><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制<strong>客户端</strong>的状态。</p><ul><li><p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。 </p></li><li><p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p></li></ul><p>发生 Cookie 交互，HTTP 请求报文和响应报文的内容如下：</p><img src="/blog/2021/10/08/图解HTTP（1-6）/2.8.png"><h3 id="第-3-章-HTTP-报文内的-HTTP-信息"><a href="#第-3-章-HTTP-报文内的-HTTP-信息" class="headerlink" title="第 3 章 HTTP 报文内的 HTTP 信息"></a>第 3 章 HTTP 报文内的 HTTP 信息</h3><h4 id="3-1-HTTP-报文"><a href="#3-1-HTTP-报文" class="headerlink" title="3.1 HTTP 报文"></a>3.1 HTTP 报文</h4><p>客户端：请求报文。</p><p>服务器端：响应报文。</p><p>HTTP 报文大致可分为<strong>报文首部</strong>和<strong>报文主体</strong>两块。两者由最初出现的<strong>空行（CR+LF）</strong>来划分。通常，并不一定要有报文主体。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/HTTP报文的结构.png"><h4 id="3-2-请求报文及响应报文的结构"><a href="#3-2-请求报文及响应报文的结构" class="headerlink" title="3.2 请求报文及响应报文的结构"></a>3.2 请求报文及响应报文的结构</h4><img src="/blog/2021/10/08/图解HTTP（1-6）/请求报文和响应报文的结构.png"><p>请求行：包含用于请求的方法，请求 URI 和 HTTP 版本。</p><p>状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本。</p><p>首部字段：包含表示请求和响应的各种条件和属性的各类首部。</p><h4 id="3-3-编码提升传输速率"><a href="#3-3-编码提升传输速率" class="headerlink" title="3.3 编码提升传输速率"></a>3.3 编码提升传输速率</h4><h5 id="3-3-1-报文主体和实体主体的差异"><a href="#3-3-1-报文主体和实体主体的差异" class="headerlink" title="3.3.1 报文主体和实体主体的差异"></a>3.3.1 报文主体和实体主体的差异</h5><ul><li>报文（message） 是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。 </li><li>实体（entity） 作为请求或响应的有效载荷数据（补充项）被传输，其内容由<strong>实体首部</strong>和<strong>实体主体</strong>组成。</li></ul><p>HTTP 报文的主体用于传输请求或响应的实体主体。</p><p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p><p>未编码的原始数据是实体主体，当不进行编码传输时，报文主体和实体主体等价，而原始数据经过编码再传输时，报文主体就不再是实体主体了，而是实体首部+实体主体的编码数据。</p><h5 id="3-3-2-压缩传输的内容编码"><a href="#3-3-2-压缩传输的内容编码" class="headerlink" title="3.3.2 压缩传输的内容编码"></a>3.3.2 压缩传输的内容编码</h5><p>常用的内容编码有以下几种：</p><ul><li>gzip(GNU zip)</li><li>compress(UNIX 系统的标准压缩)</li><li>deflate(zlib)</li><li>identity(不进行编码)</li></ul><h5 id="3-3-3-分割发送的分块传输编码"><a href="#3-3-3-分割发送的分块传输编码" class="headerlink" title="3.3.3 分割发送的分块传输编码"></a>3.3.3 分割发送的分块传输编码</h5><img src="/blog/2021/10/08/图解HTTP（1-6）/分块传输编码.png"><h4 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h4><p>MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）。在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。相应地，HTTP 协议中也采纳了<strong>多部分对象集合</strong>，发送的一份报文主体内可含有多类型实体。</p><h4 id="3-5-获取部分内容的范围请求"><a href="#3-5-获取部分内容的范围请求" class="headerlink" title="3.5 获取部分内容的范围请求"></a>3.5 获取部分内容的范围请求</h4><img src="/blog/2021/10/08/图解HTTP（1-6）/获取部分内容的范围请求.png"><p>byte 范围的指定形式如下：</p><img src="/blog/2021/10/08/图解HTTP（1-6）/byte范围.png"><p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。</p><p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。</p><h4 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h4><p>比如浏览器默认语言不同，访问相同 URI 的 Web 页面时，则会显示对应的语言版本的 web 页面。</p><p>服务器驱动协商。</p><p>客户端驱动协商。</p><p>透明协商。</p><h3 id="第-4-章-返回结果的-HTTP-状态"><a href="#第-4-章-返回结果的-HTTP-状态" class="headerlink" title="第 4 章 返回结果的 HTTP 状态"></a>第 4 章 返回结果的 HTTP 状态</h3><h4 id="4-1-状态码告知从服务器端返回的请求结果"><a href="#4-1-状态码告知从服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知从服务器端返回的请求结果"></a>4.1 状态码告知从服务器端返回的请求结果</h4><img src="/blog/2021/10/08/图解HTTP（1-6）/状态码.png"><h4 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 2XX 成功</h4><p>2XX 的响应结果表名请求被正常处理了。</p><h5 id="4-2-1-200-OK"><a href="#4-2-1-200-OK" class="headerlink" title="4.2.1 200 OK"></a>4.2.1 200 OK</h5><p>表示从客户端发来的请求在服务器端被正常处理了。</p><h5 id="4-2-2-204-No-Content"><a href="#4-2-2-204-No-Content" class="headerlink" title="4.2.2 204 No Content"></a>4.2.2 204 No Content</h5><p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。</p><h5 id="4-2-3-206-Partial-Content"><a href="#4-2-3-206-Partial-Content" class="headerlink" title="4.2.3 206 Partial Content"></a>4.2.3 206 Partial Content</h5><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p><h4 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 3XX 重定向</h4><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><h5 id="4-3-1-301-Moved-Permanently"><a href="#4-3-1-301-Moved-Permanently" class="headerlink" title="4.3.1 301 Moved Permanently"></a>4.3.1 301 Moved Permanently</h5><p>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</p><h5 id="4-3-3-302-Found"><a href="#4-3-3-302-Found" class="headerlink" title="4.3.3 302 Found"></a>4.3.3 302 Found</h5><p>临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问。</p><h5 id="4-3-3-303-See-Other"><a href="#4-3-3-303-See-Other" class="headerlink" title="4.3.3 303 See Other"></a>4.3.3 303 See Other</h5><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 <strong>GET</strong> 方法定向获取请求的资源。</p><h5 id="4-3-4-304-Not-Modified"><a href="#4-3-4-304-Not-Modified" class="headerlink" title="4.3.4 304 Not Modified"></a>4.3.4 304 Not Modified</h5><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。</p><p>附带条件的请求是指采用 GET方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。</p><h5 id="4-3-5-307-Temporary-Redirect"><a href="#4-3-5-307-Temporary-Redirect" class="headerlink" title="4.3.5 307 Temporary Redirect"></a>4.3.5 307 Temporary Redirect</h5><p>临时重定向。该状态码与 302 Found 有着相同的含义。但是 307 会遵照浏览器标准，不会从 POST 变成 GET。</p><h4 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 4XX 客户端错误</h4><h5 id="4-4-1-400-Bad-Request"><a href="#4-4-1-400-Bad-Request" class="headerlink" title="4.4.1 400 Bad Request"></a>4.4.1 400 Bad Request</h5><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</p><h5 id="4-4-2-401-Unauthorized"><a href="#4-4-2-401-Unauthorized" class="headerlink" title="4.4.2 401 Unauthorized"></a>4.4.2 401 Unauthorized</h5><p>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。</p><h5 id="4-4-3-403-Forbidden"><a href="#4-4-3-403-Forbidden" class="headerlink" title="4.4.3 403 Forbidden"></a>4.4.3 403 Forbidden</h5><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由。</p><h5 id="4-4-4-404-Not-Found"><a href="#4-4-4-404-Not-Found" class="headerlink" title="4.4.4 404 Not Found"></a>4.4.4 404 Not Found</h5><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p><h4 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 5XX 服务器错误</h4><p>5XX 的响应结果表明服务器本身发生错误。</p><h5 id="4-5-1-500-Internal-Server-Error"><a href="#4-5-1-500-Internal-Server-Error" class="headerlink" title="4.5.1 500 Internal Server Error"></a>4.5.1 500 Internal Server Error</h5><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p><h5 id="4-5-2-503-Service-Unavailable"><a href="#4-5-2-503-Service-Unavailable" class="headerlink" title="4.5.2 503 Service Unavailable"></a>4.5.2 503 Service Unavailable</h5><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p><h3 id="第-5-章-与-HTTP-协作的-Web-服务器"><a href="#第-5-章-与-HTTP-协作的-Web-服务器" class="headerlink" title="第 5 章 与 HTTP 协作的 Web 服务器"></a>第 5 章 与 HTTP 协作的 Web 服务器</h3><h4 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h4><h4 id="5-2-通信数据转发程序：代理、网关、隧道"><a href="#5-2-通信数据转发程序：代理、网关、隧道" class="headerlink" title="5.2 通信数据转发程序：代理、网关、隧道"></a>5.2 通信数据转发程序：代理、网关、隧道</h4><h4 id="5-3-保存资源的缓存"><a href="#5-3-保存资源的缓存" class="headerlink" title="5.3 保存资源的缓存"></a>5.3 保存资源的缓存</h4><h3 id="第-6-章-HTTP-首部"><a href="#第-6-章-HTTP-首部" class="headerlink" title="第 6 章 HTTP 首部"></a>第 6 章 HTTP 首部</h3><h4 id="6-1-HTTP-报文首部"><a href="#6-1-HTTP-报文首部" class="headerlink" title="6.1 HTTP 报文首部"></a>6.1 HTTP 报文首部</h4><p><strong>HTTP 请求报文</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/请求报文.png"><p><strong>HTTP 响应报文</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/响应报文.png"><h4 id="6-2-HTTP-首部字段"><a href="#6-2-HTTP-首部字段" class="headerlink" title="6.2 HTTP 首部字段"></a>6.2 HTTP 首部字段</h4><h5 id="6-2-1-HTTP-首部字段传递重要信息"><a href="#6-2-1-HTTP-首部字段传递重要信息" class="headerlink" title="6.2.1 HTTP 首部字段传递重要信息"></a>6.2.1 HTTP 首部字段传递重要信息</h5><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p><h5 id="6-2-2-HTTP-首部字段结构"><a href="#6-2-2-HTTP-首部字段结构" class="headerlink" title="6.2.2 HTTP 首部字段结构"></a>6.2.2 HTTP 首部字段结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首部字段名: 字段值</span><br></pre></td></tr></table></figure><h5 id="6-2-3-4-种-HTTP-首部字段类型"><a href="#6-2-3-4-种-HTTP-首部字段类型" class="headerlink" title="6.2.3 4 种 HTTP 首部字段类型"></a>6.2.3 4 种 HTTP 首部字段类型</h5><p><strong>通用首部字段</strong></p><p>请求报文和响应报文两方都会使用的首部。</p><p><strong>请求首部字段</strong></p><p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p><p><strong>响应首部字段</strong></p><p>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p><p><strong>实体首部字段</strong></p><p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p><h5 id="6-2-5-HTTP-1-1-首部字段一览"><a href="#6-2-5-HTTP-1-1-首部字段一览" class="headerlink" title="6.2.5 HTTP/1.1 首部字段一览"></a>6.2.5 HTTP/1.1 首部字段一览</h5><p><strong>通用首部字段</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/通用首部字段.png"><p><strong>请求首部字段</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/请求首部字段.png"><p><strong>响应首部字段</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/响应首部字段.png"><p><strong>实体首部字段</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/实体首部字段.png"><h5 id="6-2-5-非-HTTP-1-1-首部字段"><a href="#6-2-5-非-HTTP-1-1-首部字段" class="headerlink" title="6.2.5 非 HTTP/1.1 首部字段"></a>6.2.5 非 HTTP/1.1 首部字段</h5><p>如 Cookie、Set-Cookie 和 Content-Disposition 等。</p><h5 id="6-2-6-End-to-end-首部和-Hop-by-hop-首部"><a href="#6-2-6-End-to-end-首部和-Hop-by-hop-首部" class="headerlink" title="6.2.6 End-to-end 首部和 Hop-by-hop 首部"></a>6.2.6 End-to-end 首部和 Hop-by-hop 首部</h5><p><strong>端到端首部（End-to-end Header）</strong></p><p>分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p><p><strong>逐跳首部（Hop-by-hop Header）</strong></p><p>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。</p><p>下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外， 其他所有字段都属于端到端首部。</p><ul><li>Connerction</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade</li></ul><h4 id="6-3-HTTP-1-1-通用首部字段"><a href="#6-3-HTTP-1-1-通用首部字段" class="headerlink" title="6.3 HTTP/1.1 通用首部字段"></a>6.3 HTTP/1.1 通用首部字段</h4><p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p><h5 id="6-3-1-Cache-Control"><a href="#6-3-1-Cache-Control" class="headerlink" title="6.3.1 Cache-Control"></a>6.3.1 Cache-Control</h5><p>通过指定首部字段 Cache-Control 指令，就能操作缓存的工作机制。</p><p>指令的参数是可选的，多个指令之间通过 “,” 分隔。首部字段 Cache-Control 的指令可用于<strong>请求</strong>及<strong>响应</strong>时。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private, max-age=0, no-cache</span><br></pre></td></tr></table></figure><p><strong>缓存请求指令</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/缓存请求指令.png"><p><strong>缓存响应指令</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/缓存响应指令.png"><p><strong>表示是否能缓存的指令</strong></p><ul><li>public：当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</li><li>private：当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。</li><li>no-cache：防止从缓存中返回过期的资源，不是不缓存，是不缓存过期的资源。</li><li>no-store：暗示请求（和对应的响应）或响应中包含机密信息，真正的不缓存。</li></ul><p><strong>指定缓存期限和认证的指令</strong></p><ul><li>s-maxage：<code>Cache-Control: s-maxage=604800</code>，（单位 ：秒）。与 max-age 指令相同，不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。</li><li>max-age：<code>Cache-Control: max-age=604800</code>，（单位：秒）。</li><li>min-fresh：令要求缓存服务器返回至少还未过指定时间的缓存资源。</li><li>max-stale：可指示缓存资源，即使过期也照常接收。</li><li>only-if-cached：该指令要求缓存服务器不重新 加载响应，也不会再次确认资源有效性。</li><li>must-revalidate：代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。</li><li>proxy-revalidate：要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。</li><li>no-transform：规定无论是在请求还是响应中，缓存都不能改 变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</li></ul><p><strong>Cache-Control扩展</strong></p><p>cache-extension token：通过 cache-extension 标记（token），可以扩展 Cache-Control 首部 段内的指令。仅对能理解它的缓存服务器来说是有意义的。</p><h5 id="6-3-2-Connection※"><a href="#6-3-2-Connection※" class="headerlink" title="6.3.2 Connection※"></a>6.3.2 Connection※</h5><p>Connection 首部字段具备如下两个作用：</p><ul><li>控制不再转发给代理的首部字段</li></ul><img src="/blog/2021/10/08/图解HTTP（1-6）/控制不再转发给代理的首部字段.png"><ul><li>管理持久连接</li></ul><img src="/blog/2021/10/08/图解HTTP（1-6）/管理持久连接.png"><p>HTTP/1.1 默认<strong>持久连接</strong>。客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。</p><p>HTTP/1.1 之前的版本 HTTP 版本默认连接都是<strong>非持久连接</strong>，为此需要指定 Connection 首部字段的值为 Keep-Alive。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/持久连接.png"><p>如上图①所示，客户端发送请求给服务器时，服务器端会像上图 ② 那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回响应。</p><h5 id="6-3-3-Date"><a href="#6-3-3-Date" class="headerlink" title="6.3.3 Date"></a>6.3.3 Date</h5><p>首部字段 Date 表明创建 HTTP 报文的日期和时间。</p><p><strong>HTTP/1.1 RFC1123</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03 Jul 2012 04:40:59 GMT</span><br></pre></td></tr></table></figure><p><strong>HTTP/1.1 之前的 RFC580</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03-Jul-12 04:40:59 GMT</span><br></pre></td></tr></table></figure><p><strong>C 标准库 asctime()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue Jul 03 04:40:59 2012</span><br></pre></td></tr></table></figure><h5 id="6-3-4-Pragma"><a href="#6-3-4-Pragma" class="headerlink" title="6.3.4 Pragma"></a>6.3.4 Pragma</h5><p>Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。只用在客户端发送的请求中。要整体掌握全部中间服务器使用的 HTTP 协议版本是不现实的。因此，发送的请求会同时含有下面两个首部字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><h5 id="6-3-5-Trailer"><a href="#6-3-5-Trailer" class="headerlink" title="6.3.5 Trailer"></a>6.3.5 Trailer</h5><p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。</p><h5 id="6-3-6-Transfer-Encoding"><a href="#6-3-6-Transfer-Encoding" class="headerlink" title="6.3.6 Transfer-Encoding"></a>6.3.6 Transfer-Encoding</h5><img src="/blog/2021/10/08/图解HTTP（1-6）/Transfer-Encoding.png"><p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。</p><h5 id="6-3-7-Upgrade"><a href="#6-3-7-Upgrade" class="headerlink" title="6.3.7 Upgrade"></a>6.3.7 Upgrade</h5><p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。</p><h5 id="6-3-8-Via"><a href="#6-3-8-Via" class="headerlink" title="6.3.8 Via"></a>6.3.8 Via</h5><p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p><h5 id="6-3-9-Warning"><a href="#6-3-9-Warning" class="headerlink" title="6.3.9 Warning"></a>6.3.9 Warning</h5><p>HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。</p><h4 id="6-4-请求首部字段"><a href="#6-4-请求首部字段" class="headerlink" title="6.4 请求首部字段"></a>6.4 请求首部字段</h4><h5 id="6-4-1-Accept"><a href="#6-4-1-Accept" class="headerlink" title="6.4.1 Accept"></a>6.4.1 Accept</h5><p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/请求首部字段-文本-图片-视频-应用程序等.png"><p>若想要给显示的媒体类型增加优先级，则使用 q = 权重值，用分号进行分隔。</p><p>权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q = 1.0。</p><h5 id="6-4-2-Accept-Charset"><a href="#6-4-2-Accept-Charset" class="headerlink" title="6.4.2 Accept-Charset"></a>6.4.2 Accept-Charset</h5><p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/Accept-Charset.png"><h5 id="6-4-3-Accept-Encoding"><a href="#6-4-3-Accept-Encoding" class="headerlink" title="6.4.3 Accept-Encoding"></a>6.4.3 Accept-Encoding</h5><p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。可一次性指定多种内容编码。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/Accept-Encoding.png"><p>下面是几个内容编码的例子：</p><img src="/blog/2021/10/08/图解HTTP（1-6）/内容编码.png"><h5 id="6-4-4-Accept-Language"><a href="#6-4-4-Accept-Language" class="headerlink" title="6.4.4 Accept-Language"></a>6.4.4 Accept-Language</h5><p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/Accept-Language.png"><h5 id="6-4-5-Authorization"><a href="#6-4-5-Authorization" class="headerlink" title="6.4.5 Authorization"></a>6.4.5 Authorization</h5><p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/Authorization.png"><h5 id="6-4-6-Expect"><a href="#6-4-6-Expect" class="headerlink" title="6.4.6 Expect"></a>6.4.6 Expect</h5><p>客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。</p><img src="/blog/2021/10/08/图解HTTP（1-6）/Expect.png"><h5 id="6-4-7-From"><a href="#6-4-7-From" class="headerlink" title="6.4.7 From"></a>6.4.7 From</h5><p>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。</p><h5 id="6-4-8-Host"><a href="#6-4-8-Host" class="headerlink" title="6.4.8 Host"></a>6.4.8 Host</h5><p>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个<strong>必须被包含在请求内的首部字段</strong>。</p><h5 id="6-4-9-If-Match"><a href="#6-4-9-If-Match" class="headerlink" title="6.4.9 If-Match"></a>6.4.9 If-Match</h5><p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p><p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。</p><p>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。</p><h5 id="6-4-10-If-Modified-Since"><a href="#6-4-10-If-Modified-Since" class="headerlink" title="6.4.10 If-Modified-Since"></a>6.4.10 If-Modified-Since</h5><p>首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。 </p><p>If-Modified-Since 用于<strong>确认代理或客户端拥有的本地资源的有效性</strong>。 获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。</p><h5 id="6-4-11-If-None-Match"><a href="#6-4-11-If-None-Match" class="headerlink" title="6.4.11 If-None-Match"></a>6.4.11 If-None-Match</h5><p>首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。 可用于 PUT 指令。</p><p>在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。</p><h5 id="6-4-12-If-Range"><a href="#6-4-12-If-Range" class="headerlink" title="6.4.12 If-Range"></a>6.4.12 If-Range</h5><p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</p><h5 id="6-4-13-If-Unmodified-Since"><a href="#6-4-13-If-Unmodified-Since" class="headerlink" title="6.4.13 If-Unmodified-Since"></a>6.4.13 If-Unmodified-Since</h5><p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定 的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应 返回。</p><h5 id="6-4-14-Max-Forwards"><a href="#6-4-14-Max-Forwards" class="headerlink" title="6.4.14 Max-Forwards"></a>6.4.14 Max-Forwards</h5><p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。</p><h5 id="6-4-15-Proxy-Authorization"><a href="#6-4-15-Proxy-Authorization" class="headerlink" title="6.4.15 Proxy-Authorization"></a>6.4.15 Proxy-Authorization</h5><p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</p><h5 id="6-4-16-Range"><a href="#6-4-16-Range" class="headerlink" title="6.4.16 Range"></a>6.4.16 Range</h5><p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。</p><h5 id="6-4-17-Referer"><a href="#6-4-17-Referer" class="headerlink" title="6.4.17 Referer"></a>6.4.17 Referer</h5><p>首部字段 Referer 会告知服务器请求的原始资源的 URI。</p><h5 id="6-4-18-TE"><a href="#6-4-18-TE" class="headerlink" title="6.4.18 TE"></a>6.4.18 TE</h5><p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于<strong>传输编码</strong>。</p><h5 id="6-4-19-User-Agent"><a href="#6-4-19-User-Agent" class="headerlink" title="6.4.19 User-Agent"></a>6.4.19 User-Agent</h5><p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p><h4 id="6-5-响应头部字段"><a href="#6-5-响应头部字段" class="headerlink" title="6.5 响应头部字段"></a>6.5 响应头部字段</h4><h5 id="6-5-1-Accept-Ranges"><a href="#6-5-1-Accept-Ranges" class="headerlink" title="6.5.1 Accept-Ranges"></a>6.5.1 Accept-Ranges</h5><p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</p><h5 id="6-5-2-Age"><a href="#6-5-2-Age" class="headerlink" title="6.5.2 Age"></a>6.5.2 Age</h5><p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</p><h5 id="6-5-3-ETag"><a href="#6-5-3-ETag" class="headerlink" title="6.5.3 ETag"></a>6.5.3 ETag</h5><p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做<strong>唯一性</strong>标识的方式。<strong>服务器会为每份资源分配对应的 ETag 值</strong>。另外，<strong>当资源更新时，ETag 值也需要更新</strong>。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。</p><p><strong>强 ETag 和 弱 ETag</strong></p><img src="/blog/2021/10/08/图解HTTP（1-6）/强ETag和弱ETag.png"><h5 id="6-5-4-Location"><a href="#6-5-4-Location" class="headerlink" title="6.5.4 Location"></a>6.5.4 Location</h5><p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</p><p>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。</p><h5 id="6-5-5-Proxy-Authenticate"><a href="#6-5-5-Proxy-Authenticate" class="headerlink" title="6.5.5 Proxy-Authenticate"></a>6.5.5 Proxy-Authenticate</h5><p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。</p><p>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与<strong>代理</strong>之间进行的。</p><h5 id="6-5-6-Retry-After"><a href="#6-5-6-Retry-After" class="headerlink" title="6.5.6 Retry-After"></a>6.5.6 Retry-After</h5><p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。</p><h5 id="6-5-7-Server"><a href="#6-5-7-Server" class="headerlink" title="6.5.7 Server"></a>6.5.7 Server</h5><p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。</p><h5 id="6-5-8-Vary"><a href="#6-5-8-Vary" class="headerlink" title="6.5.8 Vary"></a>6.5.8 Vary</h5><p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</p><h5 id="6-5-9-WWW-Authenticate"><a href="#6-5-9-WWW-Authenticate" class="headerlink" title="6.5.9 WWW-Authenticate"></a>6.5.9 WWW-Authenticate</h5><p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。</p><h4 id="6-6-实体首部字段"><a href="#6-6-实体首部字段" class="headerlink" title="6.6 实体首部字段"></a>6.6 实体首部字段</h4><p>实体首部字段是包含在请求报文和响应报文中的<strong>实体部分</strong>所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p><h5 id="6-6-1-Allow"><a href="#6-6-1-Allow" class="headerlink" title="6.6.1 Allow"></a>6.6.1 Allow</h5><p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</p><h5 id="6-6-2-Content-Encoding"><a href="#6-6-2-Content-Encoding" class="headerlink" title="6.6.2 Content-Encoding"></a>6.6.2 Content-Encoding</h5><p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的<strong>内容编码</strong>方式。使用方式参考 6.4.3节。</p><h5 id="6-6-3-Content-Language"><a href="#6-6-3-Content-Language" class="headerlink" title="6.6.3 Content-Language"></a>6.6.3 Content-Language</h5><p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p><h5 id="6-6-4-Content-Length"><a href="#6-6-4-Content-Length" class="headerlink" title="6.6.4 Content-Length"></a>6.6.4 Content-Length</h5><p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。</p><h5 id="6-6-5-Content-Location"><a href="#6-6-5-Content-Location" class="headerlink" title="6.6.5 Content-Location"></a>6.6.5 Content-Location</h5><p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p><h5 id="6-6-6-Content-MD5"><a href="#6-6-6-Content-MD5" class="headerlink" title="6.6.6 Content-MD5"></a>6.6.6 Content-MD5</h5><p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><h5 id="6-6-7-Content-Range"><a href="#6-6-7-Content-Range" class="headerlink" title="6.6.7 Content-Range"></a>6.6.7 Content-Range</h5><p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p><h5 id="6-6-8-Content-Type"><a href="#6-6-8-Content-Type" class="headerlink" title="6.6.8 Content-Type"></a>6.6.8 Content-Type</h5><p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。</p><h5 id="6-6-9-Expires"><a href="#6-6-9-Expires" class="headerlink" title="6.6.9 Expires"></a>6.6.9 Expires</h5><p>首部字段 Expires 会将资源失效的日期告知客户端。</p><h5 id="6-6-10-Last-Modified"><a href="#6-6-10-Last-Modified" class="headerlink" title="6.6.10 Last-Modified"></a>6.6.10 Last-Modified</h5><p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个 值就是 Request-URI 指定资源被修改的时间。</p><h4 id="6-7-为-Cookie-服务的首部字段"><a href="#6-7-为-Cookie-服务的首部字段" class="headerlink" title="6.7 为 Cookie 服务的首部字段"></a>6.7 为 Cookie 服务的首部字段</h4><img src="/blog/2021/10/08/图解HTTP（1-6）/为Cookie服务的首部字段.png"><h5 id="6-7-1-Set-Cookie"><a href="#6-7-1-Set-Cookie" class="headerlink" title="6.7.1 Set-Cookie"></a>6.7.1 Set-Cookie</h5><p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p><p>Set-Cookie 的字段值：</p><img src="/blog/2021/10/08/图解HTTP（1-6）/Set-Cookie字段的属性.png"><p><strong>expires 属性</strong></p><p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。</p><p><strong>path 属性</strong></p><p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。</p><p><strong>domain 属性</strong></p><p>通过 Cookie 的 domain 属性指定的域名可做到与<strong>结尾匹配一致</strong>。</p><p><strong>secure 属性</strong></p><p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p><p><strong>HttpOnly 属性</strong></p><p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，<strong>它使 JavaScript 脚本无法获得 Cookie。</strong>其主要目的为<strong>防止跨站脚本攻击</strong>（Cross-site scripting，XSS）对 Cookie 的信息窃取。</p><h5 id="6-7-2-Cookie"><a href="#6-7-2-Cookie" class="headerlink" title="6.7.2 Cookie"></a>6.7.2 Cookie</h5><p>首部字段 Cookie 会告知服务器，<strong>当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。</strong>接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p><h4 id="6-8-其他首部字段"><a href="#6-8-其他首部字段" class="headerlink" title="6.8 其他首部字段"></a>6.8 其他首部字段</h4><h5 id="6-8-1-X-Frame-Options"><a href="#6-8-1-X-Frame-Options" class="headerlink" title="6.8.1 X-Frame-Options"></a>6.8.1 X-Frame-Options</h5><p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防 止点击劫持（clickjacking）攻击。</p><h5 id="6-8-2-X-XSS-Protection"><a href="#6-8-2-X-XSS-Protection" class="headerlink" title="6.8.2 X-XSS-Protection"></a>6.8.2 X-XSS-Protection</h5><p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。</p><h5 id="6-8-3-DNT※"><a href="#6-8-3-DNT※" class="headerlink" title="6.8.3 DNT※"></a>6.8.3 DNT※</h5><p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。</p><h5 id="6-8-4-P3P"><a href="#6-8-4-P3P" class="headerlink" title="6.8.4 P3P"></a>6.8.4 P3P</h5><p>首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，<strong>可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式</strong>，以达到保护用户隐私的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图解HTTP（1-6）&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://www.xingyuzhao.ltd/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://www.xingyuzhao.ltd/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件系统</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/10/08/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/10/08/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-10-08T01:36:04.000Z</published>
    <updated>2021-10-08T02:10:41.843Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结 Linux 文件系统</p><a id="more"></a><h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><h4 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h4><p>主要有三个部分：</p><ul><li>超级区块：记录此文件系统的总体信息，包括 inode 与数据区块的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li><li>inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的区块号码；</li><li>数据区块：实际记录文件的内容，若文件太大，会占用多个区块。</li></ul><p>文件系统先格式化出 inode 和数据区块，根据 inode 记录可以找到文件数据的实际放置点，之后可以按顺序读出，这种方法称为<strong>索引式文件系统</strong>。类比于 FAT（文件分配表，U 盘中常用），基本不用进行碎片整理。</p><h4 id="Linux-的-ext2-文件系统（inode）"><a href="#Linux-的-ext2-文件系统（inode）" class="headerlink" title="Linux 的 ext2 文件系统（inode）"></a>Linux 的 ext2 文件系统（inode）</h4><img src="/blog/2021/10/08/Linux文件系统/ext2.png"><p>文件系统最前面有一个启动扇区（Boot Sector），这个启动扇区可以安装启动引导程序。</p><h5 id="数据区块（data-block）"><a href="#数据区块（data-block）" class="headerlink" title="数据区块（data block）"></a>数据区块（data block）</h5><p>数据区块是用来放置文件数据的地方，在 ext2 文件系统中所支持的区块大小有 1K，2K 和 4K 三种。</p><table><thead><tr><th align="center">Block大小</th><th align="center">1KB</th><th align="center">2KB</th><th align="center">4KB</th></tr></thead><tbody><tr><td align="center">最大单一文件限制</td><td align="center">16GB</td><td align="center">256GB</td><td align="center">2TB</td></tr><tr><td align="center">最大文件系统总容量</td><td align="center">2TB</td><td align="center">8TB</td><td align="center">16TB</td></tr></tbody></table><p>注意：虽然 ext2 已经能够支持大于 2GB 以上的单一文件容量，不过某些应用程序只能够识别小于 2GB 的文件。</p><p>除此之外，ext2 文件系统区块的限制还有：</p><ol><li>原则上，区块的大小与数量在格式化完就不能够再修改</li><li>每个区块内最多只能够放置一个文件的数据</li><li>承上，如果文件小于区块的大小，则一个文件会占用多个区块数量</li><li>承上，若文件小于区块，则该区块的剩余容量就不能够再被使用了</li></ol><h5 id="inode-table（inode-表）"><a href="#inode-table（inode-表）" class="headerlink" title="inode table（inode 表）"></a>inode table（inode 表）</h5><p>inode 记录的数据至少有下面这些：</p><ul><li>该文件的读写属性（read、write、excute）；</li><li>该文件的拥有者与用户组（owner、group）；</li><li>该文件的大小；</li><li>该文件建立或状态改变的时间（ctime）；</li><li>最近一次的读取时间（atime）；</li><li>最近修改的时间（mtime）；</li><li>定义文件特性的标识（flag），如 SetUID；</li><li>该文件真正内容的指向（pointer）。</li></ul><p>inode 的数量与大小在格式化时就已经固定了，除此之外 inode 还有什么特色？</p><ul><li>每个 inode 大小均固定为 128B（新的 ext4 和 xfs 可设置到 256B）；</li><li>每个文件都仅会占用一个 inode 而已；</li><li>承上，因此文件系统能够创建的文件数量与 inode 的数量有关；</li><li>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，如符合才能够读取区块的内容。</li></ul><p>inode 记录一个数据区块需要使用 4B，假设一个文件有 400MB 且每个区块为 4K 时，至少需要十万个数据块。为此系统将 inode 记录区块号码的区域定义为 12 个直接、一个间接、一个双间接与一个三间接记录区。假设区块大小为 1KB。</p><ul><li>12 个直接：12 × 1K = 12K；</li><li>间接：256 × 1K = 256K，因为 1K 的大小能记录 256 条记录；</li><li>双间接：256 × 256 × 1K = 256^2 K；</li><li>三间接：256 × 256 × 256 × 1K = 256^3 K；</li></ul><p>总额：12 + 256 + 256 × 256 + 256 × 256 × 256（K）= 16GB。</p><p>可以看到区块格式化为 1K 时，能够容纳的最大文件为 16GB，与文件系统限制表的结果一致，但此方法不能应用在 2K 和 4K 区块大小的计算中，因为大于 2K 的区块将会受到 ext2 文件系统本身的限制。</p><h5 id="Superblock（超级区块）"><a href="#Superblock（超级区块）" class="headerlink" title="Superblock（超级区块）"></a>Superblock（超级区块）</h5><p>超级区块是记录整个文件系统相关信息的地方，没有超级块，就没有这个文件系统，它记录的主要信息有：</p><ul><li>数据区块与 inode 的总量；</li><li>未使用与已使用的 inode 与数据区块的数量；</li><li>数据区块与 inode 的大小（block 为 1、2、4K，inode 为 128B 或 256B）；</li><li>文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘的时间等文件系统相关信息；</li><li>一个有效位数值，若此文件已被挂载，则有效位为 0，若未被挂载，则有效位为 1。</li></ul><h5 id="Filesystem-Description（文件系统描述说明）"><a href="#Filesystem-Description（文件系统描述说明）" class="headerlink" title="Filesystem Description（文件系统描述说明）"></a>Filesystem Description（文件系统描述说明）</h5><p>这个区段可以描述每个<strong>区块群组</strong>的开始与结束的区块，以及说明每个区段（超级区块、对照表、inode 对照表，数据区块）分别介于哪一个区块之间，这一部分也能够用 dumpe2fs 来观察。</p><h5 id="区块对照表（block-bitmap）"><a href="#区块对照表（block-bitmap）" class="headerlink" title="区块对照表（block bitmap）"></a>区块对照表（block bitmap）</h5><p>从区块对照表中可以知道哪些区块是空的，因此我们的系统就能够很快速的找到可使用的空间来处理文件。</p><p>在删除文件时，那些文件原本占用的区块号码就要释放出来，此时在区块对照表中对应到该区块号码的标志就要修改为【未使用中】，这就是对照表的功能。</p><h5 id="inode-对照表"><a href="#inode-对照表" class="headerlink" title="inode 对照表"></a>inode 对照表</h5><p>inode 对照表记录使用与未使用的 inode 号码。</p><h5 id="dumpe2fs"><a href="#dumpe2fs" class="headerlink" title="dumpe2fs"></a>dumpe2fs</h5><p>查询 ext 系列超级区块信息的命令。</p><ol><li><code>sudo blkid</code>：显示出目前系统被格式化的设备；</li><li><code>dumpe2fs 文件目录</code>：查看超级块。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结 Linux 文件系统&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.xingyuzhao.ltd/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL学习</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/10/08/MySQL%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/10/08/MySQL%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-10-08T01:32:21.000Z</published>
    <updated>2021-10-08T02:11:02.922Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql架构介绍</p><a id="more"></a><h3 id="Mysql逻辑结构"><a href="#Mysql逻辑结构" class="headerlink" title="Mysql逻辑结构"></a>Mysql逻辑结构</h3><p><strong>数据文件</strong></p><ol><li>Myisam<ol><li>frm 文件（framework）：存放表结构</li><li>myd 文件（data）：存放表数据</li><li>myi 文件（index）：存放表索引</li></ol></li><li>innodb<ol><li>ibdata1：Innodb 引擎将所有表的的数据都存在这里面 /usr/share/mysql/ibdata1</li><li>frm 文件：存放表结构</li><li>单独存放</li></ol></li></ol><h5 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h5><img src="/blog/2021/10/08/MySQL学习/mysql逻辑结构.png"><h5 id="每一层的功能"><a href="#每一层的功能" class="headerlink" title="每一层的功能"></a>每一层的功能</h5><img src="/blog/2021/10/08/MySQL学习/mysql每层功能.png" style="zoom: 100%;"><h4 id="Mysql存储引擎"><a href="#Mysql存储引擎" class="headerlink" title="Mysql存储引擎"></a>Mysql存储引擎</h4><p>查看引擎命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><h5 id="InnoDB和MyISAM对比"><a href="#InnoDB和MyISAM对比" class="headerlink" title="InnoDB和MyISAM对比"></a>InnoDB和MyISAM对比</h5><table><thead><tr><th align="center">————————-</th><th align="center">——————————-</th><th align="center">——————————-</th></tr></thead><tbody><tr><td align="center">对比项</td><td align="center">MyISAM</td><td align="center">InnoDB</td></tr><tr><td align="center">主外键</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">事务</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">行表锁</td><td align="center">表锁，即使操作一条记录也会锁住整个表，不适合高并发操作</td><td align="center">行锁，操作时只锁某一行，不对其他行有影响，<strong>适合高并发操作</strong></td></tr><tr><td align="center">缓存</td><td align="center">只缓存索引，不缓存真实数据</td><td align="center">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td align="center">表空间</td><td align="center">小</td><td align="center">大</td></tr><tr><td align="center">关注点</td><td align="center">性能</td><td align="center">事务</td></tr><tr><td align="center">默认安装</td><td align="center">Y</td><td align="center">Y</td></tr></tbody></table><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="性能下降的原因"><a href="#性能下降的原因" class="headerlink" title="性能下降的原因"></a>性能下降的原因</h4><ol><li>SQL 写的不好</li><li>索引失效<ol><li>单值</li><li>复合</li></ol></li><li>关联查询太多 join</li><li>服务器调优及各个参数设置（缓冲、线程数等）</li></ol><h4 id="常见通用的join查询"><a href="#常见通用的join查询" class="headerlink" title="常见通用的join查询"></a>常见通用的join查询</h4><h5 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h5><p>手写-机读（先从 FROM 开始）。</p><img src="/blog/2021/10/08/MySQL学习/sql解析.png"><h5 id="join图"><a href="#join图" class="headerlink" title="join图"></a>join图</h5><img src="/blog/2021/10/08/MySQL学习/join.png" style="zoom: 80%;"><h5 id="建表SQL"><a href="#建表SQL" class="headerlink" title="建表SQL"></a>建表SQL</h5><h5 id="7种join"><a href="#7种join" class="headerlink" title="7种join"></a>7种join</h5><p>mysql 不支持全外连接，可以使用 union 合并并去重。</p><p>倒数第二种情况，A B 全有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> A t1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">TABLE</span> B t2</span><br><span class="line"><span class="keyword">ON</span> t1.id = t2.id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> A t1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="keyword">TABLE</span> B t2</span><br><span class="line"><span class="keyword">ON</span> t1.id = t2.id</span><br></pre></td></tr></table></figure><p>最后一种情况，A B 独有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> A t1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">TABLE</span> B t2</span><br><span class="line"><span class="keyword">ON</span> t1.id = t2.id</span><br><span class="line"><span class="keyword">WHERE</span> t2.id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TABLE</span> A t1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="keyword">TABLE</span> B t2</span><br><span class="line"><span class="keyword">ON</span> t1.id = t2.id</span><br><span class="line"><span class="keyword">WHERE</span> t1.id <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h4><p>官方定义：索引是帮助 MySQL 高效获得数据的<strong>数据结构</strong>。</p><p>总之，索引就是<strong>排好序的快速查找数据结构</strong>。排序 + 快速查找。</p><p><strong>优势</strong></p><ol><li>类似大学图书馆建书目索引，<strong>提高数据检索的效率</strong>，降低数据库的IO成本</li><li>通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，降低了CPU的消耗</li></ol><p><strong>劣势</strong></p><ol><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li><li>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句</li></ol><h5 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h5><h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><p>设定为主键后数据库会自动建立索引，innodb 为聚簇索引。</p><h6 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h6><p>即一个索引只包含单个列，一个表可以有多个单列索引。</p><h6 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h6><p>索引列的值必须唯一，但允许有空值。</p><h6 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h6><p>即一个索引包含多个列。</p><h5 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h5><p>B+树。</p><h5 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h5><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引(where 后面的语句)</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，who？(在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ol><h5 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h5><ol><li>表记录太少</li><li>经常增删改的表</li><li>where 条件里用不到的字段不创建索引</li><li>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li></ol><img src="/blog/2021/10/08/MySQL学习/重复.png" style="zoom:80%;"><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><h5 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h5><ol><li>CPU：SQL中对大量数据进行比较、关联、排序、分组</li><li>IO：<ol><li>实例内存满足不了缓存数据或排序等需要，导致产生大量 物理 IO</li><li>查询执行效率低，扫描过多数据行</li></ol></li><li>锁：<ol><li>不适宜的锁的设置，导致线程阻塞，性能下降</li><li>死锁，线程之间交叉调用资源，导致死锁，程序卡住</li></ol></li><li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat 来查看系统的性能状态</li></ol><h5 id="Explain※"><a href="#Explain※" class="headerlink" title="Explain※"></a>Explain※</h5><p>使用 EXPLAIN关 键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Explain + SQL语句</span><br></pre></td></tr></table></figure><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><ol><li>表的读取顺序</li><li>哪些索引可以使用</li><li>数据读取操作的操作类型</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ol><h6 id="包含信息"><a href="#包含信息" class="headerlink" title="包含信息"></a>包含信息</h6><img src="/blog/2021/10/08/MySQL学习/explain.png" style="zoom:80%;"><p><strong>id</strong></p><ol><li>select 查询的序列号,包含一组数字，表示查询中执行 select 子句或操作表的顺序</li><li>三种情况<ol><li>id 相同，执行顺序由上至下</li><li>id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</li><li><del>id 相同 table 不同，同时存在，衍生表</del></li></ol></li></ol><p><strong>select_type</strong></p><img src="/blog/2021/10/08/MySQL学习/select_type.png" style="zoom: 80%;"><p>查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p><ol><li>SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION</li><li>PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</li><li>SUBQUERY：在SELECT或WHERE列表中包含了子查询</li><li>DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询, 把结果放在临时表里。</li><li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</li><li>UNION RESULT：从UNION表获取结果的SELECT</li></ol><p><strong>table</strong></p><p>显示这一行的数据是关于哪张表的。</p><p><strong>type</strong></p><p>显示查询使用了何种类型。</p><img src="/blog/2021/10/08/MySQL学习/type.png"><p><strong>从最好到最差依次是：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure><p>一般来说查询至少达到 range 级别，最好能到 ref。</p><ol><li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。</li><li>const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</li><li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</li><li>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li><li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）。</li><li>all：Full Table Scan，将遍历全表以找到匹配的行。</li></ol><p><strong>possible_keys</strong></p><p>显示可能应用在这张表中的索引，一个或多个。<br>查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用。</strong></p><p><strong>key</strong></p><ol><li>实际使用的索引。如果为NULL，则没有使用索引</li><li>查询中若使用了覆盖索引，则该索引仅出现在key列表中。<strong>建立的索引和要查询的列个数和顺序刚好一致。</strong></li></ol><p><strong>key_len</strong></p><ol><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。 </li><li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出来的。</li></ol><p><strong>ref</strong></p><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p><p><strong>rows</strong></p><p>rows列显示MySQL认为它执行查询时必须检查的行数。<strong>越少越好</strong>。</p><p><strong>Extra</strong></p><p>包含不适合在其他列中显示但十分重要的额外信息。</p><ol><li><p>Using filesort ：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。</p></li><li><p>Using temporary ：使了用<strong>临时表</strong>保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</p></li><li><p>USING index：</p><ol><li><p>表示相应的select操作中使用了<strong>覆盖索引</strong>(Covering Index)，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</p></li><li><p><strong>覆盖索引</strong>(Covering Index)：就是 select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回 select 列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</p><blockquote><p>注意：<br>如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p></blockquote></li></ol></li><li><p>Using where：表明使用了where过滤</p></li><li><p>Using join buffer：使用了连接缓存</p></li><li><p>impossible where：where子句的值总是false，不能用来获取任何元组</p></li><li><p>select tables optimized away（了解）：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p></li></ol><h5 id="一个case"><a href="#一个case" class="headerlink" title="一个case"></a>一个case</h5><img src="/blog/2021/10/08/MySQL学习/Desktop/待上传/mysql高级/case查询.png" style="zoom: 135%;"><img src="/blog/2021/10/08/MySQL学习/case.png"><h4 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h4><h5 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h5><h6 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h6><h6 id="双表"><a href="#双表" class="headerlink" title="双表"></a>双表</h6><p>左连接：LEFT JOIN 条件用于确定如何从右表搜索行，左边一定都有，所以右边是我们的关键点，一定需要在右边建立索引。右连接类似，左边建立索引。</p><h6 id="三表"><a href="#三表" class="headerlink" title="三表"></a>三表</h6><p>类似双表。索引最好设置在需要经常查询的字段中。</p><h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>join 语句的优化：</p><ol><li>尽可能减少 join 语句中的循环总次数，<strong>永远用小结果驱动大的数据集</strong></li><li>保证 join 语句中被驱动表上 join 条件字段已经被索引</li><li>inner join 时，mysql 会自动把小结果集的表选为驱动表</li><li>当无法保证被驱动表的 join 条件字段被索引且内存资源充足的前提下，不要太吝惜 joinbuffer 的设置</li><li>子查询尽量不要放在被驱动表，有可能使用不到索引</li></ol><p>子查询优化：</p><ol><li>有索引的情况下用 inner join 时最好的，其次是 in，exists 最糟糕</li></ol><p>ORDER BY 关键字优化：</p><ol><li>ORDER BY 子句，尽量使用 index 方式排序，避免使用 filesort 方式排序</li><li>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</li></ol><p>分页查询优化 limit：</p><ol><li><p>order by 后的字段（XXX）有索引，sql 中有 limit 时</p><blockquote><p>当 select id 或 XXX字段索引包含字段时 ，显示 using index<br>当 select 后的字段含有 bouder by 字段索引不包含的字段时，将显示 using filesort</p></blockquote></li></ol><p>GROUP BY 关键字优化</p><ol><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了。</li></ol><p>去重优化：</p><ol><li>尽量不要使用 distinct 关键字去重，可以使用 GROUP BY 去利用索引。</li></ol><h5 id="索引失效（应该避免）"><a href="#索引失效（应该避免）" class="headerlink" title="索引失效（应该避免）"></a>索引失效（应该避免）</h5><ol><li><p>全值匹配</p></li><li><p>最佳左前缀法则：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且<strong>不跳过索引中的列</strong>（<strong>带头的必须在，中间兄弟不能断，</strong>如果断了还会继续用到之前的索引，后面的不能用到）。</p></li><li><p>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</p></li><li><p>存储引擎不能使用索引中范围条件右边的列</p><blockquote><p>index 为 idx_name_age_pos，如果查询中出现 age &gt; 某个值，执行了索引 age 的范围查询，则 pos 索引失效。</p></blockquote></li><li><p>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *</p></li><li><p>mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</p></li><li><p>is not null 也无法使用索引,但是is null是可以使用索引的</p></li><li><p>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作 </p><blockquote><p>like % 写右边</p><p>问题，解决like ‘%字符串%’ 时索引不被使用的方法？使用覆盖索引</p></blockquote></li><li><p>字符串不加单引号索引失效少用or，用它来连接时会索引失效</p></li></ol><p>口诀：带头大哥不能死，中间兄弟不能断，索引列上无计算，like%加右边，范围之后全失效，字符串里有引号。</p><img src="/blog/2021/10/08/MySQL学习/索引失效.png"><p><strong>面试题讲解</strong></p><p>定值、范围还是排序，一般 order by 是给个范围。</p><p>group by 基本上都需要进行排序，会有临时表产生。</p><h5 id="一般建议"><a href="#一般建议" class="headerlink" title="一般建议"></a>一般建议</h5><ol><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。(避免索引过滤性好的索引失效)</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li></ol><h3 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h3><p>总结：</p><ol><li>慢查询的开启并捕获</li><li>explain + 慢 SQL 分析</li><li>show profile 查询 SQL 在 Mysql 服务区里面的执行细节和声明周期情况</li><li>SQL 数据库服务器的参数调优</li></ol><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><h5 id="永远小表驱动大表"><a href="#永远小表驱动大表" class="headerlink" title="永远小表驱动大表"></a>永远小表驱动大表</h5><img src="/blog/2021/10/08/MySQL学习/exists_in.png"><ul><li>EXISTS：SELECT … FROM table WHERE EXISTS(subquery)，可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE 或 FALSE）来决定查询的数据结果是否得以保留。<ul><li>EXISTS(subquery)只返回 TRUE 或者 FALSE，子查询中的 SELECT * 也可以是 SELECT 1 或其他，官方说法是实际执行会忽略 SELECT 清单，因此效果一样。</li></ul></li></ul><h5 id="ORDER-BY-优化"><a href="#ORDER-BY-优化" class="headerlink" title="ORDER BY 优化"></a>ORDER BY 优化</h5><ol><li>ORDER BY 子句，尽量使用 index 方式排序，避免使用 filesort 方式排序<ol><li>Mysql 支持两种排序：filesort 和 index，后者效率高，后者指 Mysql 扫面索引本身完成排序。</li><li>ORDER BY 满足两情况，会使用 index 方式排序<ol><li>ORDER BY 语句使用索引最左前列</li><li>使用 where 子句与 ORDER BY 子句条件列组合满足索引最左前列</li></ol></li></ol></li><li>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</li><li>如果不在索引列上，filesort有两种算法：mysql就要启动双路排序（2次 IO）和单路排序（一般为 1 次）<ol><li>增大sort_buffer_size参数的设置</li><li>增大max_length_for_sort_data参数的设置</li><li>尽量不使用 SELECT *</li></ol></li></ol><p><strong>总结</strong></p><img src="/blog/2021/10/08/MySQL学习/为排序使用索引.png" alt="image-20210720171055191"><h5 id="GROUP-BY-关键字优化"><a href="#GROUP-BY-关键字优化" class="headerlink" title="GROUP BY 关键字优化"></a>GROUP BY 关键字优化</h5><ol><li>group by 实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了</li></ol><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</li><li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。</li><li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</li></ul><p>默认情况下，MySQL数据库<strong>没有开启</strong>慢查询日志，需要我们手动来设置这个参数。</p><p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</p><h4 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h4><h4 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h4><h4 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h4><h3 id="Mysql锁机制"><a href="#Mysql锁机制" class="headerlink" title="Mysql锁机制"></a>Mysql锁机制</h3><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>从对数据操作的类型分：</p><ol><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li></ol><p>从对数据操作的粒度分：</p><ol><li>表锁</li><li>行锁</li></ol><p>查看哪些表被加锁了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><h4 id="MySQL表级锁有两种模式"><a href="#MySQL表级锁有两种模式" class="headerlink" title="MySQL表级锁有两种模式"></a>MySQL表级锁有两种模式</h4><h5 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h5><p>偏向 MyISAM 存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p><p>session1 可以读取自己锁的表，不能修改锁的表，不能读取其他表；</p><p>session2 可以读取被锁的表，可以修改被锁的表，但是会阻塞等待直到 session 1 解锁。</p><p>session1 可以读取自己锁的表，可以修改锁的表，不能读取其他表；</p><p>session2 可以读取，但是会阻塞等待直到 session 1 解锁。</p><p><strong>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都堵塞。</strong></p><h5 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h5><p>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p><p>InnoDB与MyISAM的最大不同有两点：一是<strong>支持事务</strong>（TRANSACTION）；二是采用了行级锁</p><h6 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h6><ol><li>脏读：事务A读取到了事务B已修改但尚未提交的的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</li><li>不可重复读：一个事务范围内两个相同的查询却返回了不同数据（另外一个事务修改并提交了）。不符合隔离性。</li><li>幻读：事务A读取到了事务B提交的新增数据，不符合隔离性。 </li></ol><img src="/blog/2021/10/08/MySQL学习/事务的隔离级别.png" alt="image-20210720195513006"><h6 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a><strong>无索引行锁升级为表锁</strong></h6><p>比如 varchar 忘记加单引号了。</p><h6 id="间隙锁的危害"><a href="#间隙锁的危害" class="headerlink" title="间隙锁的危害"></a>间隙锁的危害</h6><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；<strong>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁</strong>，这种锁机制就是所谓的间隙锁（GAP Lock）。</p><p>比如 a 有 1 3 4 5，此时 session1 更新 a &gt; 1 and a &lt; 5 的数据，但是 session2 想要插入 2 的数据，此时 session2 会阻塞，因为 session1 会把 2 3 4 都锁住，即使键值不存在。</p><h6 id="锁定某一行（悲观锁）"><a href="#锁定某一行（悲观锁）" class="headerlink" title="锁定某一行（悲观锁）"></a>锁定某一行（悲观锁）</h6><p>select xxx for update 锁定某一行后，其他的操作会被阻塞，直到锁定行的会话提交 commit。</p><h6 id="查看行锁状态"><a href="#查看行锁状态" class="headerlink" title="查看行锁状态"></a>查看行锁状态</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'innodb_row_lock%'</span>;</span><br></pre></td></tr></table></figure><ul><li>Innodb_row_lock_time_avg（等待平均时长）</li><li>Innodb_row_lock_waits（等待总次数）</li><li>Innodb_row_lock_time（等待总时长）</li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><p>slave会从master读取binlog来进行数据同步</p><img src="/blog/2021/10/08/MySQL学习/主从复制.png"><p> MySQL复制过程分成三步：</p><ol><li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events</li><li>slave将master的binary log events拷贝到它的中继日志（relay log）</li><li>slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的</li></ol><h4 id="复制规则"><a href="#复制规则" class="headerlink" title="复制规则"></a>复制规则</h4><ol><li>每个slave只有一个master</li><li>每个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个salve</li></ol><h4 id="一主一从常见配置"><a href="#一主一从常见配置" class="headerlink" title="一主一从常见配置"></a>一主一从常见配置</h4><ol><li>mysql版本一致且后台以服务运行</li><li>主从都配置在[mysqld]结点下，都是小写</li><li>主机修改my.ini配置文件</li><li>从机修改my.cnf配置文件</li><li>因修改过配置文件，请主机+从机都重启后台mysql服务</li><li>主机从机都关闭防火墙</li><li>在Windows主机上建立帐户并授权slave</li><li>在Linux从机上配置需要复制的主机</li><li>主机新建库、新建表、insert记录，从机复制</li><li>如何停止从服务复制功能（stop slave）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mysql架构介绍&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.xingyuzhao.ltd/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义优先队列</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/10/08/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/10/08/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2021-10-08T01:29:47.000Z</published>
    <updated>2021-10-08T02:11:34.843Z</updated>
    
    <content type="html"><![CDATA[<p>三种方法自定义 C++ 中的优先队列</p><a id="more"></a><h3 id="自定义优先队列"><a href="#自定义优先队列" class="headerlink" title="自定义优先队列"></a>自定义优先队列</h3><h4 id="方法一：运算符重载"><a href="#方法一：运算符重载" class="headerlink" title="方法一：运算符重载"></a>方法一：运算符重载</h4><p><strong>友元函数</strong></p><p>使用非友元函数也行，但要放在结构体之外。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    Pair(<span class="keyword">int</span> fi, <span class="keyword">int</span> sec): first(fi), second(sec)&#123;&#125;;</span><br><span class="line">    <span class="comment">// 友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pair &amp;p1, <span class="keyword">const</span> Pair &amp;p2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.first == p2.first)&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p1.first &lt; p2.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Pair&gt; pq;</span><br></pre></td></tr></table></figure><p><strong>成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    Pair(<span class="keyword">int</span> fi, <span class="keyword">int</span> sec): first(fi), second(sec)&#123;&#125;;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pair &amp;p2) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;first == p2.first)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;second &lt; p2.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;first &lt; p2.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Pair&gt; pq;</span><br></pre></td></tr></table></figure><h4 id="方法二：函数对象（仿函数）"><a href="#方法二：函数对象（仿函数）" class="headerlink" title="方法二：函数对象（仿函数）"></a>方法二：函数对象（仿函数）</h4><p><strong>概念</strong></p><ul><li>重载了函数调用操作符 () 的类，其对象称为函数对象。</li><li>函数对象使用重载的 () 时，行为类似函数调用，也叫仿函数。</li></ul><p><strong>本质</strong></p><ul><li>函数对象（仿函数）是一个类，不是函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Pair &amp;p1, <span class="keyword">const</span> Pair &amp;p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.first == p2.first)&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p1.first &lt; p2.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Pair, <span class="built_in">vector</span>&lt;Pair&gt;, cmp&gt; pq1;</span><br></pre></td></tr></table></figure><h4 id="方法三：lambda-function"><a href="#方法三：lambda-function" class="headerlink" title="方法三：lambda/function"></a>方法三：lambda/function</h4><p><code>lambda</code> 表达式也是一种函数对象，不过需要结合 <code>decltype</code> 运算符一同使用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">const</span> Pair &amp;p1, <span class="keyword">const</span> Pair &amp;p2) -&gt; <span class="keyword">bool</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.first == p2.first)&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p1.first &lt; p2.first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// function&lt;bool(const Pair&amp;, const Pair&amp;) 可用 decltype(f) 替换</span></span><br><span class="line">priority_queue&lt;Pair, vector&lt;Pair&gt;, function&lt;bool(const Pair&amp;, const Pair&amp;)&gt;&gt; pq2(f);</span><br></pre></td></tr></table></figure><p>除此之外，C++ 11 还可以使用 <code>function</code>  模板来指明一个<strong>可调用对象</strong>，包括函数指针、<code>lambda</code> 或者函数对象在内。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">bool</span>(<span class="keyword">const</span> Pair&amp;, <span class="keyword">const</span> Pair&amp;)&gt; f = [](<span class="keyword">const</span> Pair &amp;p1, <span class="keyword">const</span> Pair &amp;p2) -&gt; <span class="keyword">bool</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.first == p2.first)&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p1.first &lt; p2.first;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Pair, vector&lt;Pair&gt;, decltype(f)&gt; pq(f);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三种方法自定义 C++ 中的优先队列&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++中的左值和右值</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/08/06/C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/08/06/C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</id>
    <published>2021-08-06T14:47:30.000Z</published>
    <updated>2021-08-06T14:54:00.658Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ol><li>C++ 中左值和右值是什么？</li><li>移动构造函数是什么， 如何实现完美转发？</li></ol><a id="more"></a><h4 id="左值和右值的基本概念"><a href="#左值和右值的基本概念" class="headerlink" title="左值和右值的基本概念"></a>左值和右值的基本概念</h4><p>在 C++11 中可以取地址的、有名字的就是左值；反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。</p><blockquote><p>左值：int a = b + c；其有变量名 a，通过 &amp;a 可以获取该变量的地址。</p><p>右值：表达式 b + c，函数 int func() 的返回值，在其被赋值给某一变量前，不能通过变量名找到它，&amp;(b + c) 操作无法通过编译。</p></blockquote><p><strong>C++11 中的右值</strong></p><ol><li>纯右值：临时变量值、不跟对象关联的字面值</li><li>将亡值：C++11 中新增的与右值引用相关的表达式，这样的表达式通常是将要被移动的对象，如右值引用 T&amp;&amp;、std::move 返回值、或者转换为 T&amp;&amp; 的类型转换函数的返回值。后面涉及一个叫<strong>完美转发</strong>的概念。</li></ol><p><strong>左值引用、右值引用</strong></p><p>左值引用就是对一个左值进行引用的类型，右值引用就是对一个右值进行引用的类型。无论声明一个左值引用还是右值引用，都必须立即进行初始化。左值引用是具有名字的变量值的别名，右值引用时匿名变量的别名。</p><p>最重要的一点是，<strong>常量左值引用</strong>是个<strong>万能</strong>的引用类型，它可以接受非常量左值、常量左值、右值对其进行初始化。</p><img src="/blog/2021/08/06/C-中的左值和右值/引用类型及其可以引用的值类型.png"><h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>移动构造函数是参数类型为<strong>右值引用</strong>的拷贝构造函数。一般应用于即将销毁的对象资源的转移。</p><p>假如有一个 <code>Integer</code> 类，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *ptr_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数为常量左值引用的深拷贝构造函数，不能改变source.ptr_的值</span></span><br><span class="line">    Integer(<span class="keyword">const</span> Integer&amp; source): ptr_(<span class="keyword">new</span> <span class="keyword">int</span>(*source.ptr_))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Call Integer(const Integer&amp; source)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数为左值引用的深拷贝构造函数，转移堆内存资源所有权，改变source.ptr_的值</span></span><br><span class="line">    Integer(Integer&amp; source): ptr_(source.ptr_)&#123;</span><br><span class="line">        <span class="comment">// 需要保证销毁是无害的，移动完成，源对象必须不再指向被移动的资源</span></span><br><span class="line">        source.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Call Integer(Integer&amp; source)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Integer(<span class="keyword">int</span> value): ptr_(<span class="keyword">new</span> <span class="keyword">int</span>(value))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数 Integer(int value)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    Integer(Integer&amp;&amp; source) = delete;</span></span><br><span class="line">    Integer(Integer&amp;&amp; source): ptr_(source.ptr_)&#123;</span><br><span class="line">        source.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Call Integer(Integer&amp;&amp; source)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Integer()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用析构函数 ~Integer()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">a</span><span class="params">(Integer(<span class="number">100</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a_value = a.GetValue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Integer <span class="title">temp</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line">    <span class="function">Integer <span class="title">b</span><span class="params">(temp)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> b_value = b.GetValue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数 Integer(int value)</span><br><span class="line">100</span><br><span class="line">--------------------</span><br><span class="line">调用构造函数 Integer(int value)</span><br><span class="line">Call Integer(Integer&amp; source)</span><br><span class="line">10000</span><br><span class="line">--------------------</span><br><span class="line">调用析构函数 ~Integer()</span><br><span class="line">调用析构函数 ~Integer()</span><br><span class="line">调用析构函数 ~Integer()</span><br></pre></td></tr></table></figure><p>在主函数中，<code>Integer(100)</code> 产生了一个匿名对象，使用了<strong>常量左值引用的深拷贝构造函数</strong>构造对象 <code>a</code>（但是在 GCC 8.1.0 下并没有显式的打印里面的内容，不知道原因），对象 <code>b</code> 调用了拷贝构造函数。<strong>前者把对象的内容都复制了一份，而后者相当于将对象的资源进行了转移。</strong></p><p>由运行结果可以看出，当同时存在参数类型为常量左值引用和左值引用的深拷贝构造函数时，匿名对象 <code>Integer(100)</code> 只能选择前者，非匿名对象 <code>temp</code> 可以选择后者，这是因为<strong>常量左值引用可以接受左值、右值、常量左值、常量右值，而左值引用只能接受左值</strong>。</p><p>如果将<strong>常量左值引用的深拷贝构造函数</strong>注释掉，那么会直接报错，原因是<strong>无法将右值绑定在非常量左值的上</strong>：</p><img src="/blog/2021/08/06/C-中的左值和右值/左值右值.png"><p><strong>使用移动构造函数实现完美转发</strong></p><p>如果要使用移动构造函数，可以使用标准库 <code>std::move</code> 将左值转换为右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">a</span><span class="params">(Integer(<span class="number">100</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a_value = a.GetValue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Integer <span class="title">temp</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line">    <span class="function">Integer <span class="title">b</span><span class="params">(<span class="built_in">std</span>::move(temp))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> b_value = b.GetValue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b_value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数 Integer(int value)</span><br><span class="line">100</span><br><span class="line">--------------------</span><br><span class="line">调用构造函数 Integer(int value)</span><br><span class="line">Call Integer(Integer&amp;&amp; source)</span><br><span class="line">10000</span><br><span class="line">--------------------</span><br><span class="line">调用析构函数 ~Integer()</span><br><span class="line">调用析构函数 ~Integer()</span><br><span class="line">调用析构函数 ~Integer()</span><br></pre></td></tr></table></figure><p>此时就显示的调用了移动构造函数，实现<strong>完美转发</strong>（temp -&gt; b）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;C++ 中左值和右值是什么？&lt;/li&gt;
&lt;li&gt;移动构造函数是什么， 如何实现完美转发？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="左值" scheme="http://www.xingyuzhao.ltd/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="移动构造函数" scheme="http://www.xingyuzhao.ltd/tags/%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer_61_68</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/07/31/%E5%89%91%E6%8C%87offer-61-68/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/07/31/%E5%89%91%E6%8C%87offer-61-68/</id>
    <published>2021-07-31T14:31:23.000Z</published>
    <updated>2021-08-06T14:46:57.766Z</updated>
    
    <content type="html"><![CDATA[<p>剑指 Offer 61~68</p><a id="more"></a><h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 61. 扑克牌中的顺子</a></h4><h5 id="题目描述※"><a href="#题目描述※" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><strong>示例1：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>只要数组中的最大值和最小值相差不超过 5 即可且不存在重复的牌（0 除外）。先进行排序，有重复的可以提前跳出。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> numOfzero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) numOfzero++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size() - <span class="number">1</span>] - nums[numOfzero] &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><h5 id="题目描述※-1"><a href="#题目描述※-1" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>数学推导。</p><img src="/blog/2021/07/31/剑指offer-61-68/约瑟夫环.png"><p>把 n = 1 的情况加上，可以得到递推公式：<br>$$<br>f(x)=<br>\begin{cases}<br>0&amp; \text{n = 1}\<br>[f(n-1,m)+m]%n&amp; \text{n &gt; 1}<br>\end{cases}<br>$$</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            pos = (pos + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</a></p><h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>动态规划。</p><p>当前天如果持有股票，那么前一天也持有股票或者当天购买了新的股票，针对后一种情况，利润就是负的，值的大小为当天股票的购买价格。</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第二维，第一个代表未持有，第二个代表持有时的最大利润</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(-prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">剑指 Offer 64. 求1+2+…+n</a></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>替代 <code>if(n == 1)</code> 条件。</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> x = n &gt; <span class="number">1</span> &amp;&amp; sumNums(n - <span class="number">1</span>) &gt; <span class="number">0</span>;</span><br><span class="line">        res += n;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> a[n][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(a) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">剑指 Offer 65. 不用加减乘除做加法</a></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>与运算+左移为进位，或运算得到<strong>不进位</strong>的求和结果。</p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无符号，负数右移</span></span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : add(a ^ b, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">剑指 Offer 66. 构建乘积数组</a></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是数组 <code>A</code> 中除了下标 <code>i</code> 以外的元素的积，即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><ol><li>将当前元素左边的所有元素进行累乘并存储；</li><li>当前元素右边的所有元素进行累乘并与上一步存储的结果进行相乘。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++i)&#123;</span><br><span class="line">            ans[i] *= left;</span><br><span class="line">            left *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            ans[i] *= right;</span><br><span class="line">            right *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><img src="/blog/2021/07/31/剑指offer-61-68/二叉搜索树.png"><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><ul><li>如果两个节点的值都小于根节点值，那么它们都在根节点的左子树上</li><li>如果两个节点的值都大于根节点值，那么它们都在根节点的右子树上</li><li>除了以上两种情况，它们的最近公共祖先就是跟节点，以为满足的二叉搜索树的条件。</li></ul><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><h5 id="题目描述※-2"><a href="#题目描述※-2" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><img src="/blog/2021/07/31/剑指offer-61-68/offer-68.png"><ul><li>节点 5 和节点 1 的最近公共祖先是节点 3。</li><li>节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</li></ul><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>递归。</p><p>如果 p，q 不在一棵子树上（ <code>left</code> 或 <code>right</code> 都不为 <code>nullptr</code> ），则根节点就是公共祖先。如果 <code>left</code> 或者 <code>right</code> 其中一个为空，表示非空的那个指针指向 p 或者 q 或者最近公共节点，直接返回即可。如果两个都为空，则 <code>root</code> 左右子树都不包含 p，q ，返回 <code>nullptr</code>。</p><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, p , q);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 67. 把字符串转换成整数</a></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p><img src="/blog/2021/07/31/剑指offer-61-68/offer-67.png"><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><ol><li>找到第一个非空字符，如果非数字或 + - 则直接返回；</li><li>记录符号位，如果是 - ，则需要特判 - + 这种情况；</li><li>从符号位后寻找连续的数字字符，并求得相应的数字保存在 long long 中；</li><li>int 的大小为 -2^31 ~ 2^31- 1，注意数字是否越界，越界了则进行相应处理；</li><li>根据符号位返回结果。</li></ol><h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = str.find_first_not_of(<span class="string">' '</span>);</span><br><span class="line">        <span class="comment">// 全空</span></span><br><span class="line">        <span class="keyword">if</span>(pos == str.npos) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断+-或数字</span></span><br><span class="line">        <span class="keyword">int</span> negFlag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[pos] == <span class="string">'+'</span>)</span><br><span class="line">            pos++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[pos] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            pos++;</span><br><span class="line">            negFlag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[pos] &gt;= <span class="string">'0'</span> &amp;&amp; str[pos] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + str[pos] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; INT_MAX)&#123;</span><br><span class="line">                <span class="keyword">if</span>(negFlag)&#123;</span><br><span class="line">                    ans = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ans = INT_MAX;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(negFlag) <span class="keyword">return</span> -ans;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指 Offer 61~68&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer_41_60</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/07/25/%E5%89%91%E6%8C%87offer-41-60/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/07/25/%E5%89%91%E6%8C%87offer-41-60/</id>
    <published>2021-07-25T14:31:04.000Z</published>
    <updated>2021-08-06T14:45:06.651Z</updated>
    
    <content type="html"><![CDATA[<p>剑指 Offer 41~60</p><a id="more"></a><h4 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 41. 数据流中的中位数</a></h4><h5 id="题目描述※"><a href="#题目描述※" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p><strong>使用一个小顶堆存储较大的一半数，大顶堆存储较小的一半数</strong>，需要考虑当前元素总数是奇数还是偶数。奇数情况下大顶堆比小顶堆多一个数，这个数就是中位数；偶数情况下两个堆中的元素个数一致，两个堆顶元素和的一半就是中位数。我们记大顶堆为 A，小顶堆为 B，下面是需要添加一个元素时的两种情况。</p><p><strong>添加元素</strong></p><p><strong>奇数</strong></p><p>如果 A 长度和 B 不同，说明此时元素总数为奇数，需要向 B 中继续添加元素。这时应先将此元素添加至 A 中，再将 A 的堆顶元素弹出，放入 B 中，保证两个堆的约束。如果直接将数加入 B 中，无法保证此时的 B 所有元素都小于等于 A 中的所有元素。</p><p><strong>偶数</strong></p><p>如果 A 长度和 B 一致，说明此时元素总数为偶数，需要向 A 中继续添加元素。这时应先将此元素添加至 B 中，再将 B 的堆顶元素弹出，放入 A 中，保证两个堆的约束。如果直接将数加入 A 中，无法保证此时的 A 所有元素都大于等于 B 中的所有元素。</p><p><strong>返回中位数</strong></p><p><strong>奇数</strong>：返回大堆顶的堆顶。</p><p><strong>偶数</strong>：返回两个堆，堆顶元素的均值。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pqs; <span class="comment">// 小顶堆，放大的一半</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; pql; <span class="comment">// 大顶堆， 放小的一半</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 长度相等，要使大顶堆多一个</span></span><br><span class="line">        <span class="comment">// 先放小顶堆里</span></span><br><span class="line">        <span class="keyword">if</span>(pqs.size() == pql.size())&#123;</span><br><span class="line">            pqs.push(num);</span><br><span class="line">            pql.push(pqs.top());</span><br><span class="line">            pqs.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 总数为奇数</span></span><br><span class="line">        <span class="comment">// 大顶堆比小顶堆多一个</span></span><br><span class="line">        <span class="comment">// 先放大顶堆里</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pql.push(num);</span><br><span class="line">            pqs.push(pql.top());</span><br><span class="line">            pql.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pqs.size() == pql.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(pqs.top() + pql.top()) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)pql.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>动态规划，<code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的子数组的最大和。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 以i结尾的连续数组的最大和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            dp[i] = max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">            ans = max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><h5 id="题目描述※-1"><a href="#题目描述※-1" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>以 345 [d] XX 为例：</p><ol><li>考虑 d 之前的数小于 345，d 只能取 1。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  000  1   00</span><br><span class="line">  001  1   01</span><br><span class="line">  ...  1   ...</span><br><span class="line">  344  1   99</span><br><span class="line">(344 + 1) * 100</span><br></pre></td></tr></table></figure><ol start="2"><li>考虑 d 之前的数等于 345。</li></ol><p>（2.1）d &gt; 1，XX 可以取 0 到 99。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">345 =&gt; 1 * 100</span><br></pre></td></tr></table></figure><p>（2.2）d == 1，XX 可以取 0 到 XX</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">345 =&gt; (XX + 1) * 1</span><br></pre></td></tr></table></figure><p>（2.3）d == 0，XX 都不可以取到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">345 =&gt; 0</span><br></pre></td></tr></table></figure><p><strong>只考虑会经过 d 为 1 的组合。假如 d = 3，只考虑经过 1 后面对应的 0~99 共100 个数，不考虑经过 2 和 3 后面产生 1的可能，因为之前已经计算过了。</strong>  </p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(n);</span><br><span class="line">        reverse(str.begin(), str.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= str.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = n / (<span class="keyword">long</span>)<span class="built_in">pow</span>(<span class="number">10</span>, i);</span><br><span class="line">            count += v * (<span class="keyword">long</span>)<span class="built_in">pow</span>(<span class="number">10</span>, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(str[i - <span class="number">1</span>] - <span class="string">'0'</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                count += (<span class="keyword">long</span>)<span class="built_in">pow</span>(<span class="number">10</span>, i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i - <span class="number">1</span>] - <span class="string">'0'</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                count += n % (<span class="keyword">long</span>)<span class="built_in">pow</span>(<span class="number">10</span>, i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count += <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://www.bilibili.com/video/BV1uJ411573j/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1uJ411573j/</a></p><h4 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 44. 数字序列中某一位的数字</a></h4><h5 id="题目描述※-2"><a href="#题目描述※-2" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>当 $n&lt;10$ 时，数字长度都为 1，一共有 10 个数，输出的结果就是 n；</p><p>当 $10\leq n\leq 99$ 时，数字长度都为 2，一共有 90 个数，分别是 10 ~ 99，长度为 180；</p><p>当 $100\leq n\leq 999$ 时，数字长度都为 3，一共有 900 个数，分别是 100 ~ 999，长度为 1800；</p><p>$…$</p><p>观察以上规律，当 n 小于 10 时，直接输出 n 即可。当 n 大于等于 10 时，需要知道 n 具体位于哪个区间（如 $[10,99]$ 还是 $[100,999]$ 等）。</p><p>算法如下：</p><ol><li>n 小于 10 时，直接输出；</li><li>n 大于等于 10 时，先减去 10；此时起始值 <code>start</code> 为 10，在此区间的每个数长度 <code>len</code> 为 2，区间总长 <code>cnt</code> 为 $9\times start\times len$ 为 180；</li><li>在 n 大于 cnt 时执行循环：<ol><li>n 减去 cnt，表示进入下一个区间，且位于下一个区间的第 n 个位置；</li><li>同时 <code>len</code> ，<code>start</code> 和 <code>cnt</code> 更新为新区间的值。</li></ol></li><li>跳出循环后，此时可以得到 n 所处的值为 $start+n/len$，n 在值中的位置为 $n %len$。换成字符串输出即可。</li></ol><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">        n -= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">2</span>; <span class="comment">// n所在数字的位数，从2开始</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">10</span>; <span class="comment">// 起始的数，从10开始</span></span><br><span class="line">        <span class="keyword">long</span> cnt = <span class="number">9</span> * start * len; <span class="comment">// 位的总长，比如10-99，总长为9*10*2=180</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; cnt)&#123;</span><br><span class="line">            n -= cnt;</span><br><span class="line">            len++;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            cnt = <span class="number">9</span> * start * len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> num = start + n / len;</span><br><span class="line">        <span class="keyword">int</span> pos = n % len;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(num);</span><br><span class="line">        <span class="keyword">return</span> str[pos] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/comments/</a></p><h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 45. 把数组排成最小的数</a></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>设数组 $nums$ 中任意两数字的字符串为 $x$ 和 $y$ ，则规定<strong>排序判断规则</strong>为：</p><ul><li>若拼接字符串 $x+y&gt;y+x$ ，则 $x$ “大于” $y$；</li><li>反之，若 $x+y&lt;y+x$ ，则 $x$ “小于” $y$ ；</li></ul><p><strong>另一种思路</strong></p><p>快排思想。</p><h5 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="built_in">string</span> s1 = to_string(x);</span><br><span class="line">            <span class="built_in">string</span> s2 = to_string(y);</span><br><span class="line">            <span class="keyword">return</span> s1 + s2 &lt; s2 + s1;</span><br><span class="line">        &#125;;</span><br><span class="line">        sort(nums.begin(), nums.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : nums)&#123;</span><br><span class="line">            ans += to_string(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            strs.push_back(to_string(nums[i]));</span><br><span class="line">        quickSort(strs, <span class="number">0</span>, strs.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(strs[j] + strs[l] &gt;= strs[l] + strs[j] &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>(strs[i] + strs[l] &lt;= strs[l] + strs[i] &amp;&amp; i &lt; j) i++;</span><br><span class="line">            swap(strs[i], strs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(strs[i], strs[l]);</span><br><span class="line">        quickSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/</a></p><h4 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 46. 把数字翻译成字符串</a></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>长度为 1 必然是一种选择，长度为 2 时看字符串转整数后是否在 10 到 25 之间，在此区间内也是一种选择，使用深搜找到所有的可能组合。</p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == s.size() || pos == s.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s, pos + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> str = s.substr(pos, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> val = stoi(str);</span><br><span class="line">        <span class="keyword">if</span>(val &gt;= <span class="number">10</span> &amp;&amp; val &lt;= <span class="number">25</span>)&#123;</span><br><span class="line">            dfs(s, pos + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 47. 礼物的最大价值</a></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><p>动态规划，类似于<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a>。</p><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><h5 id="题目描述※-3"><a href="#题目描述※-3" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><ol><li>使用双指针，start 表示字符串起始位置，i 表示当前所处字符串位置；</li><li>用哈希表记录<strong>当前遍历过的字符最后一次出现的位置</strong>，当此字符再次出现时，将 start 更新为当前字符最后一次出现位置的下一个，作为新的起始位置；</li><li>每轮循环都更新最大长度 ans。</li></ol><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lastPos</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lastPos[s[i]] != <span class="number">-1</span> &amp;&amp; lastPos[s[i]] &gt;= start)&#123;</span><br><span class="line">                ans = max(ans, i - start);</span><br><span class="line">                start = lastPos[s[i]] + <span class="number">1</span>;</span><br><span class="line">                lastPos[s[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                lastPos[s[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 更新最后一次</span></span><br><span class="line">        ans = max(ans, len - start);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 49. 丑数</a></h4><h5 id="题目描述※-4"><a href="#题目描述※-4" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>最小堆。</p><p>每次取出最小的丑数，放进去它的2倍，3倍，5倍，同时用一个 set 去重。</p><h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span>&gt;&gt; pq;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        pq.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            v = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">set</span>.count(v * <span class="number">2</span>))&#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(v * <span class="number">2</span>);</span><br><span class="line">                pq.push(v * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">set</span>.count(v * <span class="number">3</span>))&#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(v * <span class="number">3</span>);</span><br><span class="line">                pq.push(v * <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">set</span>.count(v * <span class="number">5</span>))&#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(v * <span class="number">5</span>);</span><br><span class="line">                pq.push(v * <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>一种动态规划的解法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>, n3 = dp[b] * <span class="number">3</span>, n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = min(min(n2, n3), n5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2) a++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3) b++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n5) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/%E8%AF%84%E8%AE%BA" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/评论</a></p><h4 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对</a></h4><h5 id="题目描述※-5"><a href="#题目描述※-5" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>归并排序。</p><p>在进行归并排序的同时，当遇到 $nums[i] &gt; nums[j]$ 时更新逆序对的数量，参考下图：</p><img src="/blog/2021/07/25/剑指offer-41-60/分治.png" style="zoom: 67%;"><p>以 $[3,7|2,6]$ 为例，其中左右两部分已经排好序，当取 3 &gt; 2 时，左半部分大于 3 的剩余部分都都大于 3，都可与后面构成逆序对，故可得到逆序对数计算公式（ mid = 1，i = 0​ ）：<br>$$<br>res = mid-i+1 = 2<br>$$<br>结果为 2，同时根据归并排序对原数组赋值。</p><p>每当出现上述情况时，更新 res 即可。</p><h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        buf = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size(), <span class="number">0</span>);</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, left, mid);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(nums, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">            buf[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = left; k &lt;= right; ++k)&#123;</span><br><span class="line">            <span class="comment">// 前半部分小于后半部分任意一个数</span></span><br><span class="line">        <span class="comment">// 排序后的数组中元素的位置不变</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid)&#123;</span><br><span class="line">                nums[k] = buf[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前半部分数大于后半部分任意一个数</span></span><br><span class="line">        <span class="comment">// 排序后的数组中前面的元素后移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; right)&#123;</span><br><span class="line">                nums[k] = buf[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(buf[i] &lt;= buf[j])&#123;</span><br><span class="line">                nums[k] = buf[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[k] = buf[j];</span><br><span class="line">                j++;</span><br><span class="line">                res += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>归并排序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums) <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, l, mid);</span><br><span class="line">    mergeSort(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    merge(nums, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">aux</span><span class="params">(r - l + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 将原数组挪到以0为起点的数组上</span></span><br><span class="line">    <span class="comment">// 如果不在乎空间消耗，直接给新数组开一个大小等于原数组的空间</span></span><br><span class="line">    <span class="comment">// 就不用进行挪动了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)&#123;</span><br><span class="line">        aux[i - l] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt;= r; ++k)&#123;</span><br><span class="line">        <span class="comment">// 前半部分小于后半部分任意一个数</span></span><br><span class="line">        <span class="comment">// 排序后的数组中元素的位置不变</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid)&#123;</span><br><span class="line">            nums[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前半部分数大于后半部分任意一个数</span></span><br><span class="line">        <span class="comment">// 排序后的数组中前面的元素后移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; r)&#123;</span><br><span class="line">            nums[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(aux[i - l] &lt;= aux[j - l])&#123;</span><br><span class="line">            nums[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nums[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-pvn2h/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-pvn2h/</a></p><h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入两个链表，找出它们的第一个公共节点。</p><h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h5><img src="/blog/2021/07/25/剑指offer-41-60/offer-52.png"><p>链表 A 相交之前的部分为 a，链表 B 为 b，相交部分为 c。</p><p>则有 $(a + c) + b = (b + c) + a$，最终在交点处相遇。对于无相交的情况，视 NULL 为两个链表的交点。</p><h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *l1 = headA; </span><br><span class="line">        ListNode *l2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(l1 != l2)&#123;</span><br><span class="line">            l1 = l1 != <span class="literal">nullptr</span> ? l1-&gt;next : headB;</span><br><span class="line">            l2 = l2 != <span class="literal">nullptr</span> ? l2-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><h5 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h5><p>二分搜索。</p><h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><h5 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h5 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h5><p>中序遍历，返回倒数第 K 个节点。</p><h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() || node)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node)&#123;</span><br><span class="line">                st.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                node = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                vec.push_back(node-&gt;val);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec[vec.size() - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - I. 二叉树的深度</a></h4><h5 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3。</p><h5 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h5><p>最大深度 = max（左子树最大深度，右子树最大深度）+ 1。</p><h5 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - II. 平衡二叉树</a></h4><h5 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><strong>示例1：</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 true 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><pre><code>       1      / \     2   2    / \   3   3  / \ 4   4返回 false 。</code></pre><h5 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h5><p>如果左右子树的高度差大于 1，直接返回 false，否则，递归保证左右子树的左右子树的高度差要小于等于 1。当递归到空节点时，直接返回 true，因为左右子树高度都是 0。</p><h5 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(maxDepth(root-&gt;left) - maxDepth(root-&gt;right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(node-&gt;left), maxDepth(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><h5 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h5><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><h5 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h5><p>位运算，一个数异或自己得到的结果为 0，可以找到 $x\oplus y$。<br>$$<br>a\oplus a \oplus b \oplus b \oplus x \oplus y = x \oplus y<br>$$<br>如果 x 和 y 的某一位（二进制）不同，则那一位异或后为 1。根据这一位并使用<strong>与运算</strong>将数组分为两部分，其中一部分包括 x，一部分包括 y，再分别进行异或得到 x 和 y。<br>$$<br>a\oplus a \oplus b \oplus b \oplus x = x<br>$$</p><p>$$<br>a\oplus a \oplus b \oplus b \oplus y = y<br>$$</p><h5 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x^x = 0;</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到x^y</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums)&#123;</span><br><span class="line">            ret = ret ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到xy二进制位不同的的首位</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((m &amp; ret) == <span class="number">0</span>)&#123;</span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组分成两部分分别计算出现一次的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &amp; m) x ^= num;</span><br><span class="line">            <span class="keyword">else</span> y ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><h5 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h5><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h5 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h5><p>位运算。</p><p>将 <code>nums</code> 数组中所有数的每一位求和，再对 3 取余，可以得到只出现一次的那个数的每一位，然后再将其恢复为十进制数。</p><h5 id="代码一-1"><a href="#代码一-1" class="headerlink" title="代码一"></a>代码一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 得到每一位二进制求和结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)&#123;</span><br><span class="line">                cnt[j] += (nums[i] &amp; <span class="number">1</span>);</span><br><span class="line">                nums[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : cnt) <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="comment">// 取出取余后的每一位</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            res |= (cnt[<span class="number">31</span> - i] % <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="代码二-1"><a href="#代码二-1" class="headerlink" title="代码二"></a>代码二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums)&#123;</span><br><span class="line">                <span class="keyword">int</span> v = num &amp; m;</span><br><span class="line">                cnt[i] += v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] % <span class="number">3</span>)&#123;</span><br><span class="line">                ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/</a>      </p><h4 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 57. 和为s的两个数字</a></h4><h5 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><h5 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h5><p>双指针。因为数组有序，收缩边界即可找到 target。</p><h5 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;nums[left], nums[right]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                sum -= nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                sum += nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">                sum += nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><h5 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><h5 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h5><p>双指针。右边界最大不超过 (target + 1) / 2。循环中的 j 不包含在结果中，所以最大值要比右边界多 1。</p><h5 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> end = (target + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= end + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m = i; m &lt; j; ++m)&#123;</span><br><span class="line">                    buf.push_back(m);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(buf.size() &gt;= <span class="number">2</span>) ans.push_back(buf);</span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                sum += j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">剑指 Offer 58 - I. 翻转单词顺序</a></h4><h5 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><h5 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h5><p>见代码。</p><h5 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">str</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> buf;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span>(str &gt;&gt; buf)&#123;</span><br><span class="line">            vec.push_back(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : vec)&#123;</span><br><span class="line">            ans += v;</span><br><span class="line">            ans += <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.pop_back();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 58 - II. 左旋转字符串</a></h4><h5 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h5><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure><h5 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h5><p>无。随你怎么写。</p><h5 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> str = s.substr(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size() - n; ++i)&#123;</span><br><span class="line">            s[i] = s[i + n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - n; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            s[i] = str[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a></h4><h5 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><h5 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h5><p>首先使用优先队列存储 <code>nums</code> 的前 <code>k</code> 个值，队首就是第一个窗口最大的值。</p><p>接着从第 <code>k</code> 个位置开始，将序列入队，每次最大的值都出现在队首。但是<strong>当前的队首不一定是当前窗口中的元素</strong>，此时队列的长度可能大于 <code>k</code>。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = &#123;3,1,1&#125;, k = 2;</span><br><span class="line">1. &#123;3,1&#125; max = 3; // 队列中元素为3,1</span><br><span class="line">2. &#123;1,1&#125; max = 1; // 队列中元素为3,1,1，此时需要将3出队</span><br></pre></td></tr></table></figure><p>如果不是当前窗口中的元素，只有可能是上一个窗口中的最大值，它一定是在当前窗口左端点的左侧，就需要将队首出队，直到队首元素在当前窗口内。</p><p>所以优先队列需要同时存储当前序列的值和坐标。</p><h5 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            q.push(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans&#123;q.top().first&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            q.push(&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="comment">// 队首元素不在当前窗口内</span></span><br><span class="line">            <span class="keyword">while</span>(q.top().second &lt;= i - k)&#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值</a></h4><h5 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h5><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的<strong>均摊</strong>时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: </span><br><span class="line">[null,null,null,2,1,2]</span><br></pre></td></tr></table></figure><h5 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h5><p>主要是实现 max_value 的时间复杂度为 -1。</p><p>使用一个队列存当前的所有元素；使用一个双端队列存非严格单调递减的元素，则最大值就是双端队列的首部。</p><p>其中，当有新元素到来时，如果此元素的值大于双端队列的尾部，则将双端队列尾部持续出队，直到找到第一个大于等于新元素的元素，在这个元素之后将新元素入队。队列的入队和出队不受影响。</p><p><strong>插入的值表示，到插入这个值之后队列里面的最大值。</strong></p><h5 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dq.empty() ? <span class="number">-1</span> : dq.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        q.push(value);</span><br><span class="line">        <span class="keyword">if</span>(dq.empty()) dq.push_back(value);</span><br><span class="line">        <span class="comment">// 当value大于双端队列的尾部元素时，持续将双端队列的尾部出队</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; value &gt; dq.back())&#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.push_back(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 出队一个最大元素即可</span></span><br><span class="line">        <span class="keyword">if</span>(!dq.empty() &amp;&amp; v == dq.front())&#123;</span><br><span class="line">            dq.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="参考-6"><a href="#参考-6" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/jian-zhi-offer-59-ii-dui-lie-de-zui-da-z-0pap/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/jian-zhi-offer-59-ii-dui-lie-de-zui-da-z-0pap/</a></p><h4 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 60. n个骰子的点数</a></h4><h5 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h5><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span></span><br><span class="line">输出: [<span class="number">0.16667</span>,<span class="number">0.16667</span>,<span class="number">0.16667</span>,<span class="number">0.16667</span>,<span class="number">0.16667</span>,<span class="number">0.16667</span>]</span><br></pre></td></tr></table></figure><h5 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h5><p>动态规划。</p><p><strong>定义</strong></p><p><code>dp[i][j]</code> 表示 i 个骰子点数 j 出现的次数。</p><p><strong>转移方程</strong></p><p>第 i 个骰子点数 j 出现的次数根据第 i - 1 个骰子 j - 1，j - 2，j - 3，j - 4，j - 5，j - 6 出现的次数求和得到：<br>$$<br>dp[i][j] = \sum \limits_{i=1}^{6}dp[i-1][j-i]<br>$$<br><strong>初始化</strong></p><p>第 1 个骰子出现的点数我们是已知的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i)</span><br><span class="line">dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：i 个骰子最小的点数是 i，最大的点数是 6 * i，一共有 5 * i + 1 个可能出现的点数。</p><h5 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 表示有i个筛子时摇出j的次数</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span> * <span class="number">11</span> + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i)</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= i * <span class="number">6</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= <span class="number">6</span>; ++m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - m &gt; <span class="number">0</span>) dp[i][j] += dp[i - <span class="number">1</span>][j - m];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">6</span> * n - n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span> * n; i++)&#123;</span><br><span class="line">            <span class="comment">// n个骰子，出现的点数是n~n+5*n</span></span><br><span class="line">            ans[i] = (<span class="keyword">double</span>)dp[n][i + n] / <span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考-7"><a href="#参考-7" class="headerlink" title="参考"></a><strong>参考</strong></h5><p><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/nge-tou-zi-de-dian-shu-dong-tai-gui-hua-ji-qi-yo-3/#comment" target="_blank" rel="noopener">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/nge-tou-zi-de-dian-shu-dong-tai-gui-hua-ji-qi-yo-3/#comment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指 Offer 41~60&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer_21_40</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/07/18/%E5%89%91%E6%8C%87offer-21-40/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/07/18/%E5%89%91%E6%8C%87offer-21-40/</id>
    <published>2021-07-18T14:30:39.000Z</published>
    <updated>2021-08-06T14:43:02.108Z</updated>
    
    <content type="html"><![CDATA[<p>剑指 Offer 21~40</p><a id="more"></a><h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><h5 id="题目描述※"><a href="#题目描述※" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>遍历一遍数组，如果遇到奇数，就和 <code>nums[k]</code> 进行交换。其中，k 初始值为 0，经过交换后，<code>num[k]</code> 一定是奇数。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                swap(nums[i], nums[k]);</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 22. 链表中倒数第k个节点</a></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>先用一个指针 <code>cur</code> 指向 <code>head</code>，然后后移 <code>k</code> 个单位。此时，让 <code>head</code> 和 <code>cur</code> 同时后移直到 <code>cur</code> 为空，<code>head</code> 的位置就是倒数第 <code>k</code> 个节点的位置。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 24. 反转链表</a></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>存储当前节点的下一个节点和前一个节点（头节点的上一个节点为 <code>nullptr</code>）。令当前节点指向前一个节点，将前一个节点更新为当前节点（也就是下一个节点的前一个节点），再将当前节点更新为新的下一个节点。</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 反转双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleListNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">DoubleListNode* next;</span><br><span class="line">DoubleListNode* last;</span><br><span class="line">DoubleListNode(<span class="keyword">int</span> m_value, DoubleListNode* nextl = <span class="literal">nullptr</span>, DoubleListNode* last1 = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">value = m_value;</span><br><span class="line">next = nextl;</span><br><span class="line">last = last1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DoubleListNode *<span class="title">reverseList</span><span class="params">(DoubleListNode*  head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DoubleListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">DoubleListNode *cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="comment">// 1.记录下一个位置</span></span><br><span class="line">DoubleListNode *tmp = cur-&gt;next; </span><br><span class="line">        <span class="comment">// 2.交换当前节点和前一个的值</span></span><br><span class="line">cur-&gt;next = pre;   </span><br><span class="line">cur-&gt;last = tmp;</span><br><span class="line">pre = cur;</span><br><span class="line">        <span class="comment">// 3.当前节点后移</span></span><br><span class="line">cur = tmp;       </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 25. 合并两个排序的链表</a></h4><h5 id="题目描述※-1"><a href="#题目描述※-1" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>每次挑两个链表中较小的的续到新链表的后面。</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">剑指 Offer 26. 树的子结构</a></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>从 A 中找到与 B 根节点值相同的结点进行递归对比，直到 B 至末尾时完全匹配，表示 B 是 A 的子结构。需要察看三个方面 B 是否可以构成 A 的子结构：</p><ol><li>A 的根节点与 B 的根节点直接递归；</li><li>A 的左子树与 B 的根节点进行递归；</li><li>A 的右子树与 B 的根节点进行递归；</li></ol><p>上述三个满足一个就表示 B 是 A 的子结构。同时根据题目要求：<strong>空树不是任意一个树的子结构</strong>，如果 A 或 B 结点一个为空，那么直接返回 false。如果在递归中，A 已为空而 B 非空，返回 false。</p><p><strong>另外一种思路</strong></p><p>对 A 进行任意一种遍历，对遍历到的每个节点与 B 进行对。见代码二。</p><h5 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B || !A) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 调用自身而不调用isSubTree是因为isSubTree的返回值是&amp;&amp;的关系</span></span><br><span class="line">        <span class="comment">// 如果出现A的某子树包含B，另一子树不包含B，那么返回false，实际上应返回true</span></span><br><span class="line">        <span class="keyword">return</span> isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B) || isSubTree(A, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubTree</span><span class="params">(TreeNode *node1, TreeNode *node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node1) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node1-&gt;val == node2-&gt;val &amp;&amp; isSubTree(node1-&gt;left, node2-&gt;left) &amp;&amp; isSubTree(node1-&gt;right, node2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">nullptr</span> || B == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(A);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode *tmp = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(tmp, B)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                st.push(tmp-&gt;right);</span><br><span class="line">                st.push(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *node1, TreeNode *node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// node2不为空且node1为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都不为空</span></span><br><span class="line">        <span class="keyword">if</span>(node1-&gt;val == node2-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(node1-&gt;left, node2-&gt;left) &amp;&amp; dfs(node1-&gt;right, node2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code>       4    /   \   2     7  / \   / \ 1   3 6   9</code></pre><p>镜像输出：</p><pre><code>       4    /   \   7     2  / \   / \ 9   6 3   1</code></pre><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>由上至下，交换同一根节点下的两个指针。</p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode *left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = mirrorTree(right);</span><br><span class="line">        root-&gt;right = mirrorTree(left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>    1   / \  2   2   \   \   3    3</code></pre><p> <strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><p>由上至下，对比<strong>左子树的左节点和右子树的右节点</strong>，<strong>左子树的右节点和右子树的左节点</strong>是否相等。两者都相等时返回 true。</p><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *left, TreeNode *right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val == right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> dfs(left-&gt;left, right-&gt;right) &amp;&amp; dfs(left-&gt;right, right-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">剑指 Offer 29. 顺时针打印矩阵</a></h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>模拟一下遍历的顺序，然后逐步缩减边界，直到完全遍历。具体顺序如下：</p><ol><li>向右，遍历到最右边时，上边界加 1，下一步向下；</li><li>向下，遍历到最下边时，右边界减 1，下一步向左；</li><li>向左，遍历到最左边时，下边界减 1，下一步向上；</li><li>向上，遍历到最上边时，左边界加 1，下一步继续向右，即返回 1。</li></ol><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        dfs(matrix, <span class="number">0</span>, matrix[<span class="number">0</span>].size() - <span class="number">1</span>, <span class="number">0</span>, matrix.size() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0 right</span></span><br><span class="line">    <span class="comment">// 1 down</span></span><br><span class="line">    <span class="comment">// 2 left</span></span><br><span class="line">    <span class="comment">// 3 up</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> up, <span class="keyword">int</span> down, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 注意返回条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right || up &gt; down)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">                ans.push_back(matrix[up][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(matrix, left, right, up + <span class="number">1</span>, down, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = up; i &lt;= down; ++i)&#123;</span><br><span class="line">                ans.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(matrix, left, right - <span class="number">1</span>, up, down, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right; i &gt;= left; --i)&#123;</span><br><span class="line">                ans.push_back(matrix[down][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(matrix, left, right, up, down - <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = down; i &gt;= up; --i)&#123;</span><br><span class="line">                ans.push_back(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(matrix, left + <span class="number">1</span>, right, up, down, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">剑指 Offer 30. 包含min函数的栈</a></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>使用两个栈，第一个栈存储每个元素；第二个栈存储单调递增的元素，即栈顶就是到目前为止最小的元素（为空时直接存储当前元素）。</p><p>出栈时，第一个栈正常出栈，第二个栈如果和第一个栈出栈的元素相同，才进行出栈。</p><h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st2;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(st2.empty() || x &lt;= st2.top())&#123;</span><br><span class="line">            st2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = st1.top();</span><br><span class="line">        <span class="keyword">if</span>(val == st2.top())&#123;</span><br><span class="line">            st2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></h4><h5 id="题目描述※-2"><a href="#题目描述※-2" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>由于所有数组中的数不是重复的，用一个栈来模拟 <code>pushed</code> 数组对应的入栈出栈过程。</p><ul><li>当栈顶元素等于 <code>poped</code> 数组的第一个元素时，说明要进行出栈，同时 <code>poped</code> 数组坐标增加；</li><li>出栈后的新栈顶与数组第二个元素比较，如果相等则持续出栈；</li><li>如果不相等则继续将 <code>poped</code> 的下一个元素入栈，再进行比较。直到完全遍历 <code>pushed</code>。</li></ul><p>如果最后栈为空，说明 <code>poped</code> 数组是 <code>pushed</code> 数组某种压栈序列的弹出序列。</p><h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> popPos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.size(); ++i)&#123;</span><br><span class="line">            st.push(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; st.top() == popped[popPos])&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                popPos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> st.empty();                                                                                                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><h5 id="题目描述※-3"><a href="#题目描述※-3" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h5><p>后序遍历二叉树得到的结果是：左子树、右子树、根节点。</p><p>根据二叉搜索树的特性，左子树值全部小于根节点的值，右子树的值全部大于根节点的值，可以根据根节点将序列分为两个部分，当这两个部分都满足二叉搜索树性质时，当前的后序遍历序列就是二叉搜索树的后续遍历序列。通过递归，来实现左右子树和根节点的分离。</p><h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// left 子树起始位置</span></span><br><span class="line">    <span class="comment">// right 根节点位置</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当节点只剩下一个时，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 使用变量p遍历当前序列</span></span><br><span class="line">        <span class="keyword">int</span> p = left;</span><br><span class="line">        <span class="keyword">while</span>(vec[p] &lt; vec[right]) p++;</span><br><span class="line">        <span class="comment">// 左子树的结束位置</span></span><br><span class="line">        <span class="keyword">int</span> m = p - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(vec[p] &gt; vec[right]) p++;</span><br><span class="line">        <span class="comment">// 当遍历完成后，p应处于根节点位置</span></span><br><span class="line">        <span class="keyword">return</span> p == right &amp;&amp; check(vec, left, m) &amp;&amp; check(vec, m + <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/cchao-100de-di-gui-jie-fa-by-ffreturn-42w4/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/cchao-100de-di-gui-jie-fa-by-ffreturn-42w4/</a></p><h4 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><h5 id="题目描述※-4"><a href="#题目描述※-4" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><strong>示例：</strong></p><p>给定如下二叉树，以及目标和 <code>target = 20</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h5><p><strong>本题最主要的是把根节点先加入数组中。</strong></p><p>使用 DFS + 回溯 可以很好的解决这个问题，算法如下：</p><ol><li>是否存在根节点？不存在直接返回空，否则，进行2；</li><li>设置一个数组 buf 存储当前路径，首先将根节点的值放入数组中，同时使用一个变量 sum 记录当前的路径和，sum 初始值为根节点的值。接下来进行递归；</li><li>递归的结束条件为：当前节点为叶子节点，如果此时的 sum 等于 target，那么就将此条路径加入答案数组中，然后返回；否则，直接返回；</li><li>在递归中，如果当前节点存在左节点或者右节点：<ol><li>存在左节点，将左节点的值加到 buf 中，同时 sum 加上此值，再进行递归，递归完成后，进行回溯（也就是弹出 buf 的最后一个值，并用 sum 减去此值，恢复原值）；</li><li>存在右节点，将右节点的值加到 buf 中，同时 sum 加上此值，再进行递归，递归完成后，进行回溯（也就是弹出 buf 的最后一个值，并用 sum 减去此值，恢复原值）；</li><li>同时存在，上述两条都执行；</li></ol></li></ol><h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        buf.push_back(root-&gt;val);</span><br><span class="line">        dfs(root, root-&gt;val, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *node, <span class="keyword">int</span> sum, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                ans.push_back(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">            buf.push_back(node-&gt;left-&gt;val);</span><br><span class="line">            dfs(node-&gt;left, sum + node-&gt;left-&gt;val, target);</span><br><span class="line">            buf.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">            buf.push_back(node-&gt;right-&gt;val);</span><br><span class="line">            dfs(node-&gt;right, sum + node-&gt;right-&gt;val, target);</span><br><span class="line">            buf.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 35. 复杂链表的复制</a></h4><h5 id="题目描述※-5"><a href="#题目描述※-5" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><img src="/blog/2021/07/18/剑指offer-21-40/offer-35.png"><h5 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h5><ol><li>将原始链表复制一份，新节点续在原始节点之后；</li><li>构建新节点的 <code>random</code> 指针，<code>cur-&gt;next-&gt;random = cur-&gt;random-&gt;next</code>；</li><li>将链表拆分为原始链表和新链表，返回新链表的头指针。</li></ol><h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 复制各节点，跟随在原节点之后</span></span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            Node *tmp = <span class="keyword">new</span> Node(cur-&gt;val);</span><br><span class="line">            tmp-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建复制节点的random指针</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;random)&#123;</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拆分原链表与新链表</span></span><br><span class="line">        cur = head-&gt;next;</span><br><span class="line">        Node *res = cur;</span><br><span class="line">        Node *pre = head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">            pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理原链表尾节点</span></span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回新链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/</a></p><h4 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 36. 二叉搜索树与双向链表</a></h4><h5 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><img src="/blog/2021/07/18/剑指offer-21-40/offer-36.png"><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><img src="/blog/2021/07/18/剑指offer-21-40/offer-36-1.png"><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h5 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h5><p>二叉搜索树<strong>中序遍历</strong>时可以得到<strong>升序的序列</strong>。根据这个性质，对二叉搜索树进行中序遍历，同时按照题目要求构建为循环链表。</p><p>需要注意：</p><ol><li>如果根节点为空则返回空</li><li>除了链表的首节点外，构建其他节点时，需要记录上一节点，从而构建双向的关系。</li><li>遍历完所有节点后，最后一个节点和首节点需要构建双向关系。</li></ol><h5 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; st;</span><br><span class="line">        Node *last;</span><br><span class="line">        Node *head;</span><br><span class="line">        Node *node = root;</span><br><span class="line">        <span class="keyword">int</span> headFlag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() || node)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node)&#123;</span><br><span class="line">                st.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                node = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span>(!headFlag)&#123;</span><br><span class="line">                    headFlag = <span class="number">1</span>;</span><br><span class="line">                    last = node;</span><br><span class="line">                    head = last;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    last-&gt;right = node;</span><br><span class="line">                    node-&gt;left = last;</span><br><span class="line">                    last = node; <span class="comment">// 注意更新</span></span><br><span class="line">                &#125;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last-&gt;right = head;</span><br><span class="line">        head-&gt;left = last;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h5><p><a href="http://www.xingyuzhao.ltd/blog/2020/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89/">二叉树的三种遍历方式（迭代法）</a></p><h4 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></h4><h5 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h5><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示：</strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><img src="/blog/2021/07/18/剑指offer-21-40/offer-37.png"><h5 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h5><p><strong>序列化</strong></p><p>使用层次遍历的思想，但是每个 <code>null</code> 节点也需要加入队列，同时使用 <code>string</code> 来记录已经得到的节点。</p><p><strong>反序列化</strong></p><p>先对输入进来的 data 按照 <code>,</code> 进行划分，将划分结果分别存入 <code>vector&lt;string&gt;</code> 中，得到的结果可能是数字，也可能是 <code>null</code>。</p><p>继续使用层次遍历的思想，构建二叉树，具体的，<code>string</code> 数组只有不为 <code>null</code> 时才构造新的节点，先构造左子树，再构造右子树，两个子树的根节点位置分别为当前节点位置 +1 和 +2。</p><h5 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">   <span class="comment">// 输入：[1,2,3,null,null,4,5]</span></span><br><span class="line">    <span class="comment">// 输出：[1,2,3,null,null,4,5,null,null,null,null]</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"["</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode *node;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(node)&#123;</span><br><span class="line">                    s += to_string(node-&gt;val);</span><br><span class="line">                    s += <span class="string">","</span>;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    s += <span class="string">"null"</span>;</span><br><span class="line">                    s += <span class="string">","</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.pop_back();</span><br><span class="line">        s += <span class="string">"]"</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="string">"[null]"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        data = data.substr(<span class="number">1</span>);</span><br><span class="line">        data.pop_back();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">str</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> buf;</span><br><span class="line">        <span class="keyword">while</span>(getline(str, buf, <span class="string">','</span>))</span><br><span class="line">            vec.push_back(buf);</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(stoi(vec[<span class="number">0</span>]));</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode *node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(vec[pos] != <span class="string">"null"</span>)&#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> TreeNode(stoi(vec[pos]));</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">if</span>(vec[pos] != <span class="string">"null"</span>)&#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> TreeNode(stoi(vec[pos]));</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 38. 字符串的排列</a></h4><h5 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h5 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h5><p>回溯 + 哈希表。</p><h5 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(s.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> buf;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(s, buf + s[i], vis);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(<span class="built_in">set</span>.begin(), <span class="built_in">set</span>.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="built_in">string</span> buf, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf.size() == s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">set</span>.count(buf))&#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(s, buf + s[i], vis);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4><h5 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h5><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h5 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h5><p>哈希表计数。</p><h5 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[fir, sec] : <span class="built_in">map</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sec &gt; len)</span><br><span class="line">                <span class="keyword">return</span> fir;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></h4><h5 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><h5 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h5><p>TOP K 问题，使用优先队列。</p><h5 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">// 大顶堆</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            pq.push(arr[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; pq.top())&#123;</span><br><span class="line">                pq.pop();</span><br><span class="line">                pq.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            ans.push_back(pq.top());</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指 Offer 21~40&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer_1_20</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/07/12/%E5%89%91%E6%8C%87offer-1-20/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/07/12/%E5%89%91%E6%8C%87offer-1-20/</id>
    <published>2021-07-12T02:30:12.000Z</published>
    <updated>2021-07-12T02:38:47.445Z</updated>
    
    <content type="html"><![CDATA[<p>剑指 Offer 01~20</p><a id="more"></a><h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指 Offer 04. 二维数组中的查找</a></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例：</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>从右上角往左下角看，是一棵二叉搜索树。从右上角开始遍历，如果当前值小于 <code>target</code> ，那么需要将列递减；如果当前值大于 <code>target</code>，就需要将行递增，直到找到 <code>target</code>。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.size() &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt; target)</span><br><span class="line">                col--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>前序遍历的第一个元素便是二叉树的根节点，由于元素不重复，那么在中序遍历中找到该节点，就可以将中序遍历分为 <strong>「左子树|根节点|右子树」</strong> 三部分，再根据中序遍历中左子树和右子树的元素的个数，将前序遍历分为<strong>「根节点|左子树|右子树」</strong>三部分。建立根节点，再用根节点指向左子树和右子树。</p><p>算法如下：</p><ol><li>根据前序遍历记录根节点在中序遍历中出现的位置；</li><li>在中序遍历中，根据根节点将左右子树分开，使根节点分别指向左子树和右子树；</li><li>根据中序遍历中左子树和右子树的元素长度，将前序遍历分为根节点、左子树、右子树三部分，然后再对左子树和右子树分别建树。</li></ol><p>详见注释。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n  = preorder.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">map</span>[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = build(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序数组，中序数组。左/右子树在前序遍历和中序遍历中起点，终点。</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2, <span class="keyword">int</span> left1, <span class="keyword">int</span> right1, <span class="keyword">int</span> left2, <span class="keyword">int</span> right2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left1 &gt; right1 || left2 &gt; right2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到根节点</span></span><br><span class="line">        <span class="keyword">int</span> root = v1[left1];</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="built_in">map</span>[root];</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        <span class="comment">// 前序遍历左子树起点，终点；中序遍历左子树起点，终点</span></span><br><span class="line">        node-&gt;left = build(v1, v2, left1 + <span class="number">1</span>, left1 + pos - left2, left2, pos - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 前序遍历右子树起点，终点；中序遍历右子树起点，终点</span></span><br><span class="line">        node-&gt;right = build(v1, v2, left1 + pos - left2 + <span class="number">1</span>, right1, pos + <span class="number">1</span>, right2);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>使用 s1 存储新元素。当需要实现出队时，如果 s2 非空，直接出队即可；如果 s2 为空，将 s1 中的所有元素出栈并放入 s2 中，再将 s2 栈顶弹出，保证出队顺序。</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">                s2.push(s1.top());</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> v = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>注意边界。</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> f0 = <span class="number">0</span>, f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fn = f0 % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>) + f1 % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>与上题类似，注意边界。</p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> fn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fn = f1 % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>) + f2 % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 11. 旋转数组的最小数字</a></h4><h5 id="题目描述※"><a href="#题目描述※" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>二分查找。详见注释。</p><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 此条件下说明最小元素坐标i范围是left &lt;= i &lt;= mid</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &lt; numbers[right])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此条件下说明最小元素坐标i范围是mid + 1 &lt;= i &lt;= right </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; numbers[right])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// [1,3,3],[3,3,1,3]等情况，使right处于数组的较小部分</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 12. 矩阵中的路径</a></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><ul><li>找到可以匹配 <code>word</code> 第一个字符的位置，更新 <code>pos</code> 和 <code>vis</code>；</li><li>从匹配的位置进行 DFS，寻找下一个匹配的位置，如果此路不通，需要将 <strong>坐标和是否访问</strong> “归还”（回溯思想）。</li><li>如果 <code>pos == word.size()</code> 说明存在此条路线，记录此时状态。</li></ul><p>其中：</p><ul><li>使用 <code>pos</code> 标记当前 <code>word</code> 中应该对比的字符的位置；</li><li>使用 <code>vis[i][j]</code> bool型数组记录当前坐标是否被访问。</li></ul><h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><ol><li>上述解题思路 2 中，<strong>寻找匹配位置</strong>是一种剪枝方法，避免走其他路线；</li><li>当已经存在一条路线时，就不需要继续找了，设置<strong>全局变量</strong>记录是否存在路线。</li></ol><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">vis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word[<span class="number">0</span>])&#123;</span><br><span class="line">                    vis[i][j] = <span class="number">1</span>;</span><br><span class="line">                    dfs(board, word, <span class="number">1</span>, i, j, vis);</span><br><span class="line">                    vis[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> &amp;word, <span class="keyword">int</span> pos, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.size())&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">4</span>; ++m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> x = i + dx[m];</span><br><span class="line">            <span class="keyword">int</span> y = j + dy[m];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.size() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].size()</span><br><span class="line">                &amp;&amp; board[x][y] == word[pos] &amp;&amp; !vis[x][y])&#123;</span><br><span class="line">                vis[x][y] = <span class="number">1</span>;</span><br><span class="line">                dfs(board, word, pos + <span class="number">1</span>, x, y, vis);</span><br><span class="line">                vis[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指 Offer 13. 机器人的运动范围</a></h4><h5 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h5><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>深度优先搜索。从（0，0）开始，找到所有的可能性。</p><h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">vis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        dfs(m, n, <span class="number">0</span>, <span class="number">0</span>, k, vis);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i1, <span class="keyword">int</span> j1, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;vis)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 主要针对只有初始点是可以进去的</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[i1][j1])&#123;</span><br><span class="line">            vis[i1][j1] = <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i1 + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = j1 + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 数位求和，这里可以简化，懒得弄了就直接转string处理了</span></span><br><span class="line">            <span class="built_in">string</span> x_s = to_string(x);</span><br><span class="line">            <span class="built_in">string</span> y_s = to_string(y);</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : x_s) n1 += ch - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : y_s) n2 += ch - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; !vis[x][y] &amp;&amp; n1 + n2 &lt;= k)&#123;</span><br><span class="line">                vis[x][y] = <span class="number">1</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">                dfs(m, n, x, y, k, vis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一种并查集做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> m, <span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                parent.push_back(i * n + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : p = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        parent[pRoot] = qRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(m, n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isValid(i, j, k)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="number">4</span>; ++idx)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[idx];</span><br><span class="line">                    <span class="keyword">int</span> y = j + dy[idx];</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; isValid(x, y, k))&#123;</span><br><span class="line">                        uf.unionElem(i * n + j, x * n + y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="built_in">map</span>[uf.find(i * n + j)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;m : <span class="built_in">map</span>)&#123;</span><br><span class="line">            ans = max(ans, m.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += y % <span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 14- I. 剪绳子</a></h4><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 14- II. 剪绳子 II</a></p><h5 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><h5 id="思路1：动态规划"><a href="#思路1：动态规划" class="headerlink" title="思路1：动态规划"></a>思路1：动态规划</h5><p><code>dp[i]</code> 表示长度等于 i 时的绳子可获得成绩的最大值，可以拆解为两部分的乘积：<br>$$<br>dp[i] = dp[j] \times dp[i - j]\ \ \ \ \ \ j = 1…i/2<br>$$<br>当 n 小于等于 3 时，返回 <code>n - 1</code>。</p><h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路2：数学方法"><a href="#思路2：数学方法" class="headerlink" title="思路2：数学方法"></a>思路2：数学方法</h5><ol><li>任何大于 1 的数都可以由 2 和 3 相加而成；</li><li>使用 3 作为因数比使用 2 作为因数乘积更大；</li><li>当 n 大于 4 时，将绳子不断减去 3，并进行累乘。</li></ol><p>至于为什么不是 n 大于 3，因为 n 等于 4 时，将绳子切为两段 2 比切为 1 和 3 更优。</p><h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            sum *= <span class="number">3</span>;</span><br><span class="line">            sum %= <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum * n % <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，$x^n$）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>快速幂运算，只需要在奇数时将结果与平方数相乘。</p><h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = n &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> nn = n;</span><br><span class="line">        nn = <span class="built_in">abs</span>(nn);</span><br><span class="line">        <span class="comment">// 快速幂</span></span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(nn)&#123;</span><br><span class="line">            <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">if</span>(nn &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                sum *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            nn &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? <span class="number">1</span> / sum : sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">剑指 Offer 19. 正则表达式匹配</a></h4><h5 id="题目描述※-1"><a href="#题目描述※-1" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>请实现一个函数用来匹配包含 <code>&#39;. &#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式。模式中的字符 <code>&#39;.&#39;</code> 表示任意一个字符，而 <code>&#39;*&#39;</code> 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 <code>&quot;aaa&quot;</code> 与模式 <code>&quot;a.a&quot;</code> 和 <code>&quot;ab*ac*a&quot;</code> 匹配，但与 <code>&quot;aa.a&quot;</code> 和 <code>&quot;ab*a&quot;</code> 均不匹配。</p><img src="/blog/2021/07/12/剑指offer-1-20/offer-19.png"><h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>假设主串为 A，长度为 n；匹配串为 B，长度为 m。关注 B 的<strong>最后一个字符</strong>是什么，有三种可能：正常字符， <code>*</code> 和 <code>.</code>。</p><ol><li>正常字符：看 A[n - 1] 是否等于 B[m - 1]，如果相等则同时前移；</li><li><code>.</code>，可以匹配任意字符，直接看前一个是否匹配；</li><li><code>*</code>，表示 B[m - 2] 可以重复 0 次或多次：<ol><li>表示 0 次，B 最后两个字符无效，比较 B[0 : m - 3] 和 A[0 : n - 1] 是否匹配；</li><li>表示多次，即 B[m - 2] = c 可以出现多次，如果此时 A[n - 1] = c，或者 c = <code>.</code>，则可以匹配，那么 A 向前移动一个，B 不动，再次查看 A[0 : n - 2] 和 B[0 : m - 1] 是否匹配（将 A 从后往前等于 c 的元素都匹配上）。</li></ol></li></ol><h6 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h6><p>$dp[i][j]$ 表示 A 的前 $i$ 个 和 B 的前 $j$ 个能否匹配。</p><ul><li>对于前两种情况，可以合并为 $dp[i][j] = dp[i - 1][j - 1]$</li><li>对于第三种情况，简单记为 c*，分为两种情况<ol><li>表示 0 次，直接砍掉 B 后面两个字符，$dp[i][j] = dp[i][j - 2]$</li><li>表示多次，正则串不动，主串前移一个，$dp[i][j] = dp[i - 1][j]$</li></ol></li></ul><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>正则串为空，如果主串为空，则匹配，否则不匹配：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = i == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = p.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="comment">// i和j表示当前字符串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">                <span class="comment">// 如果正则串空，那么只能匹配空串</span></span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 正则串非空，分为*和非*</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果不为*，则直接比较当前字符是否相等，或正则串字符为.</span></span><br><span class="line">                    <span class="keyword">if</span>(p[j - <span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>))&#123;</span><br><span class="line">                            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 碰到*了，分为*表示0次还是多次</span></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 表示0次，直接砍掉正则串后两个</span></span><br><span class="line">                        <span class="keyword">if</span>(j &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                            dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 表示多次，主串当前和正则串上一位置相等，或正则串的前一位置为.</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>))&#123;</span><br><span class="line">                            dp[i][j] = dp[i][j] | dp[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line"><span class="comment">// 注意：使用 | 表示上述两种情况只要有一种满足即可！！！</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</a></p><h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a></h4><h5 id="题目描述※-2"><a href="#题目描述※-2" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 <strong>小数</strong> 或者 整数</li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li></ul><img src="/blog/2021/07/12/剑指offer-1-20/offer-20.png"><h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h5><p>详见注释。</p><h5 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = s.find_first_not_of(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos1 == s.npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> pos2 = s.find_last_not_of(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">bool</span> numFlag = <span class="number">0</span>, dotFlag = <span class="number">0</span>, eFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos1; i &lt;= pos2; ++i)&#123;</span><br><span class="line">            <span class="comment">// 判定为数字，标记为numFlag</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                numFlag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判定为.，需要没出现过.且没出现过e</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'.'</span> &amp;&amp; !dotFlag &amp;&amp; !eFlag)&#123;</span><br><span class="line">                dotFlag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判定为e，需要没出现过e且出现过数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] == <span class="string">'E'</span> || s[i] == <span class="string">'e'</span>) &amp;&amp; numFlag &amp;&amp; !eFlag)&#123;</span><br><span class="line">                eFlag = <span class="number">1</span>;</span><br><span class="line">                numFlag = <span class="number">0</span>; <span class="comment">// 出现e之后重新判断整数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断为+-，只能出现在第一位或者紧接在e后面</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) &amp;&amp; (i == pos1 || s[i - <span class="number">1</span>] == <span class="string">'e'</span> || s[i - <span class="number">1</span>] == <span class="string">'E'</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他情况非法</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指 Offer 01~20&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>C++中static的用法总结</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/05/26/C-%E4%B8%ADstatic%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/05/26/C-%E4%B8%ADstatic%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-26T14:24:48.000Z</published>
    <updated>2021-05-26T15:22:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>C++ 中 <strong>static</strong> 关键字的作用。</p><a id="more"></a><h5 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h5><p>用于函数体内部修饰变量，这种变量的生存期长于该函数。</p><ol><li>该变量在<strong>全局数据区</strong>分配内存；</li><li>在首次执行到该对象声明处被首次初始化，以后的函数调用不再进行初始化，即：<strong>静态变量只初始化一次</strong>；</li><li><strong>静态局部变量一般在声明处初始化</strong>，如果没有显示初始化，会被程序自动初始化为 0；</li><li>它始终驻留在全局数据区，直到程序运行结束，但是其作用域为局部作用域，在函数体外无法使用。</li></ol><h5 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h5><p>定义在函数体外，用于修饰全局变量，表示该变量只在<strong>本文件</strong>可见。</p><ol><li>静态全局变量<strong>不能被其他文件使用</strong>（全局变量可以）；</li><li>其他文件可以定义同名变量且不会发生冲突。</li></ol><h5 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h5><p>类似于静态全局变量。</p><ol><li>静态函数<strong>不能被其他文件使用</strong>；</li><li>其他文件可以定义同名函数且不会发生冲突。</li></ol><h5 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h5><p>用于修饰类中的数据成员，称为<strong>静态成员</strong>。这种数据成员的生存期大于类的对象。静态数据成员是每个类有一份，普通数据成员每个对象有一份。</p><ol><li>静态成员存储在全局数据区，在定义时需要分配空间，所以不能在类中定义。且只分配一次内存，被类的所有对象共同访问；</li><li><strong>静态成员不占据类的空间，必须在类外进行初始化，且在初始化时与私有或公有无关</strong>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// sizeof(A) = 1，空类大小为1</span></span><br></pre></td></tr></table></figure><h5 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h5><p>用于修饰类的成员函数，可以用 <strong>类名::函数名</strong> 进行访问。</p><ol><li>静态成员函数<strong>可访问</strong>静态数据成员和静态成员函数；</li><li>非静态成员函数<strong>可访问</strong>静态数据成员和静态成员函数；</li><li>静态数据成员<strong>不可访问</strong>非静态数据成员和非静态成员函数；</li><li>调用静态成员函数，可以用成员访问操作符 (.) 和 (-&gt;) 为一个类的对象或指向类对象的指针调用静态成员函数，也可以用 类名::函数名 调用。</li></ol><p>静态成员函数不能声明为 <code>const</code>，因为其不能访问对象的非静态数据成员，无法使用 <code>thiscall</code>。</p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>（1）静态成员函数和非静态成员函数的区别？</p><p>静态成员函数不存在 <code>this</code> 指针，不能访问非静态成员变量。</p><p>（2）为什么要使用静态成员变量和静态成员函数？</p><p>为了实现共享。静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享。</p><p>（3）在头文件把一个变量声明为 static 变量，引用该文件的源文件能访问到该变量吗？</p><p>可以，因为 cpp 文件包含了头文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;C++ 中 &lt;strong&gt;static&lt;/strong&gt; 关键字的作用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="static" scheme="http://www.xingyuzhao.ltd/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>libevent服务端接收连接的代码示例</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/04/27/libevent%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/04/27/libevent%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</id>
    <published>2021-04-27T14:36:01.000Z</published>
    <updated>2021-04-27T15:27:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>libevent服务端接收连接的代码示例。</p><a id="more"></a><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPORT 5001</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listen_cb</span><span class="params">(struct evconnlistener *e, <span class="keyword">evutil_socket_t</span> s, struct sockaddr *a, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"listen_cb"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">// 初始化socket库</span></span><br><span class="line">WSADATA wsa;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsa);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// 忽略管道信号，发送数据给已关闭的socket</span></span><br><span class="line"><span class="comment">// 防止程序down掉</span></span><br><span class="line"><span class="keyword">if</span> (signal(SIGPIPE, SIG_IGN) == SIG_ERR)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test server!\n"</span>;</span><br><span class="line"><span class="comment">// 创建libevent的上下文</span></span><br><span class="line">event_base *base = event_base_new();</span><br><span class="line"><span class="keyword">if</span> (base) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"event_base_new success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line"><span class="comment">// socket，bind，listen在一起做了，绑定事件</span></span><br><span class="line">sockaddr_in <span class="built_in">sin</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(SPORT);</span><br><span class="line"></span><br><span class="line">evconnlistener *ev = evconnlistener_new_bind(base, <span class="comment">// libevent的上下文</span></span><br><span class="line">listen_cb,                <span class="comment">// 接受到连接的回调函数</span></span><br><span class="line">base,  <span class="comment">// 回调函数获取的参数arg</span></span><br><span class="line">LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, <span class="comment">// 地址重用，listen关闭同时关闭socket</span></span><br><span class="line"><span class="number">10</span>, <span class="comment">// 连接队列大小，对应listen函数</span></span><br><span class="line">(sockaddr*)&amp;<span class="built_in">sin</span>, <span class="comment">// 绑定的地址和端口</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">sin</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 事件分发处理</span></span><br><span class="line"><span class="keyword">if</span>(base)</span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"><span class="keyword">if</span>(ev)</span><br><span class="line">evconnlistener_free(ev);</span><br><span class="line"><span class="keyword">if</span>(base)</span><br><span class="line">event_base_free(base);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>在 cmd 中输入：<code>telnet 127.0.0.1 5001</code> 可以看到在控制台输出 <code>listen_cb</code>：</p><img src="/blog/2021/04/27/libevent服务端接收连接的代码示例/1.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;p&gt;libevent服务端接收连接的代码示例。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="libevent" scheme="http://www.xingyuzhao.ltd/tags/libevent/"/>
    
  </entry>
  
  <entry>
    <title>条款43：学习处理模板化基类内的名称</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/04/08/%E6%9D%A1%E6%AC%BE43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/04/08/%E6%9D%A1%E6%AC%BE43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0/</id>
    <published>2021-04-08T13:03:36.000Z</published>
    <updated>2021-04-08T15:29:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p>可在派生类模板内通过 <code>this-&gt;</code> 指出基类模板内的成员名称，或者由一个清晰的<strong>基类资格修饰符</strong>完成。</p><a id="more"></a><h4 id="一个传送信息的模板程序"><a href="#一个传送信息的模板程序" class="headerlink" title="一个传送信息的模板程序"></a>一个传送信息的模板程序</h4><p>我们需要一个程序将加密的信息或者未经加工的文字传到不同的公司去。如果在编译期间我们可知哪一个信息传到哪一家公司，可以使用基于模板的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// 未加工的文本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// 加密的信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyB</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// 未加工的文本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// 加密的信息</span></span><br><span class="line">&#125;;</span><br><span class="line">... <span class="comment">// 针对其他公司设计的class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgInfo</span> &#123;</span> ... &#125;; <span class="comment">// 用来保存及产生信息</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> msg;</span><br><span class="line">根据info产生信息</span><br><span class="line">Company c;</span><br><span class="line">c.sendCleartext(msg);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 类似sendClear，调用sendEncrypted</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123; ... &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们希望在每次发送信息时记录某些信息，可以使用派生类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line">sendClear(info); <span class="comment">// 调用基类函数，代码无法通过编译</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码编译器会提示 <code>sendClear</code> 不存在，原因是编译器不知道类模板 <code>LoggingMsgSender</code> 继承的是什么样的类（ <code>MsgSender&lt;Company&gt;</code> 中的 <code>company</code> 未知），所以更不知道是否有 <code>sendClear</code> 函数。</p><h4 id="模板全特化"><a href="#模板全特化" class="headerlink" title="模板全特化"></a>模板全特化</h4><p>假设有个类 <code>CompanyZ</code> 坚持使用加密通信：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyZ</span>&#123;</span> <span class="comment">// 这个类不提供sendCleartext函数，你懂的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般性的 <code>MsgSender</code> 模板对 <code>CompanyZ</code> 并不合适，因为模板提供了 <code>sendClear</code> 函数，此函数又调用了 <code>sendCleartext</code> 函数，对 <code>CompanyZ</code> 对象来说合理吗？这不合理。针对这个问题，可以产生一个 <code>MsgSender</code> <strong>全特化版</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&lt;CompanyZ&gt;&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> <span class="comment">// 此函数针对加密文档的传送</span></span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="再看派生类LoggingMsgSender"><a href="#再看派生类LoggingMsgSender" class="headerlink" title="再看派生类LoggingMsgSender"></a>再看派生类LoggingMsgSender</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line">sendClear(info); <span class="comment">// 如果Company = CompanyZ，此函数将不存在</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如注释所言，如果基类被指定为 <code>MsgSender&lt;CompanyZ&gt;</code> 必然是不合法的，<strong>编译器知道基类模板有可能被特化</strong>，特化版本可能不提供和一般性模板相同的接口。因此编译器<strong>拒绝在模板化基类中寻找继承而来的名称</strong>（本例中 <code>MsgSender&lt;Company&gt;</code>）。</p><h5 id="令C-可以进入模板化基类"><a href="#令C-可以进入模板化基类" class="headerlink" title="令C++可以进入模板化基类"></a>令C++可以进入模板化基类</h5><ol><li>在基类函数调用动作之前加上 <code>this-&gt;</code>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line"><span class="keyword">this</span>-&gt;sendClear(info); <span class="comment">// 成立，sendClear将被继承</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>using</code> 声明式：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear; <span class="comment">// 告诉编译器，基类中存在sendClear</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line">sendClear(info); <span class="comment">// 成立，sendClear将被继承</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>明白指出被调用的函数位于基类：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line">MsgSender&lt;Company&gt;::sendClear(info); <span class="comment">// 成立，sendClear将被继承</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这种解法如果调用的是虚函数，上述做法会关闭虚函数的绑定行为。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;p&gt;可在派生类模板内通过 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 指出基类模板内的成员名称，或者由一个清晰的&lt;strong&gt;基类资格修饰符&lt;/strong&gt;完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="模板" scheme="http://www.xingyuzhao.ltd/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>条款42：了解typename的双重意义</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/04/06/%E6%9D%A1%E6%AC%BE42%EF%BC%9A%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/04/06/%E6%9D%A1%E6%AC%BE42%EF%BC%9A%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89/</id>
    <published>2021-04-06T07:53:08.000Z</published>
    <updated>2021-04-06T13:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ol><li>声明 template 参数时，前缀关键字 class 和 typename 可互换</li><li>请使用关键字 typename 标识嵌套从属类型名称；但不得在基类列表或成员初始化列表内作为基类的修饰符</li></ol><a id="more"></a><h4 id="从属名称和非从属名称"><a href="#从属名称和非从属名称" class="headerlink" title="从属名称和非从属名称"></a>从属名称和非从属名称</h4><p>以下程序想要实现打印 STL 容器里的第二个元素（STL 里对象为 int 类型）。先不管能否通过编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(container.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ++iter;</span><br><span class="line">        <span class="keyword">int</span> value = *iter;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>变量 iter 的类型是 C::const_iterator，实际是什么类型取决去 template 参数 C。如果 template 内出现的名称依赖于某个 template 参数，称之为从属名称，如果从属名称在 class 中呈嵌套状，称其为嵌套从属名称，C::const_iterator 就是如此；</li><li>变量 value 的类型是 int，int 不依赖任何 template 参数，所以这样的名称是非从属名称。</li></ul><p>如果解析器在 template 中遭遇一个嵌套从属名称，<strong>它便假设这个名称非一种类型，除非你使用 typename 告诉它确实是一种类型</strong>。以下才是合法的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(container.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个例外"><a href="#一个例外" class="headerlink" title="一个例外"></a>一个例外</h4><p>typename 必须作为嵌套从属类型名称的前缀词这一规则的例外是：</p><ul><li>typename 不可以出现在<strong>基类列表</strong>中的嵌套从属类型名称之前，也不可在<strong>成员初始化列表</strong>中作为基类的修饰符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested&#123; <span class="comment">// 基类列表中不允许typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span>: Base&lt;T&gt;::<span class="title">Nested</span><span class="params">(x)</span></span>&#123; <span class="comment">// 成员初始化列表中也不允许typename</span></span><br><span class="line"><span class="keyword">typename</span> Base&lt;T&gt;::Nested temp; <span class="comment">// 不在上述两种情况内且是嵌套从属类型名称，必须加上typename</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="typedef与typename结合"><a href="#typedef与typename结合" class="headerlink" title="typedef与typename结合"></a>typedef与typename结合</h4><p>假设我们正在撰写一个函数模板，它接受一个迭代器，我们要对迭代器所指向的对象做一份局部拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">void</span> workWithIterator&lt;IterT iter)&#123;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::iterator_traits&lt;IterT&gt;::value_type</code> 表示类型为 IterT 之对象所指之物的类型，并将 temp 初始化为 iter 所指物。即：IterT 是 <code>vector&lt;int&gt;::iterator</code>，temp 的类型就是 int，由于 value_type 是一个嵌套从属类型名称，所以我们必须在它之前放置 typename。</p><p>同时可以使用 typedef 减少一遍又一遍的使用 <code>std::iterator_traits&lt;IterT&gt;::value_type</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">void</span> workWithIterator&lt;IterT iter)&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span> value_type</span>;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;声明 template 参数时，前缀关键字 class 和 typename 可互换&lt;/li&gt;
&lt;li&gt;请使用关键字 typename 标识嵌套从属类型名称；但不得在基类列表或成员初始化列表内作为基类的修饰符&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="typename" scheme="http://www.xingyuzhao.ltd/tags/typename/"/>
    
  </entry>
  
</feed>
