<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2021-01-20T02:30:24.000Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件管理（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/16/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/16/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-01-16T03:17:11.000Z</published>
    <updated>2021-01-20T02:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>初识文件管理</li><li>文件的逻辑结构</li><li>文件目录</li></ol><a id="more"></a><h4 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h4><p>文件：一组有意义的信息/数据集合。</p><h5 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h5><p>文件名：由创建文件的用户决定，同一目录下不允许有重名文件。</p><p>标识符：操作系统用于区分各个文件（文件名相同更应如此）的一种内部名称。</p><p>类型：指明文件的类型。</p><p>位置：文件存放的路径、在外存中的地址。</p><p>大小：指明文件的大小。</p><p>创建时间、上次修改时间、文件所有者信息。</p><p>保护信息：对文件进行保护的访问控制信息。</p><h5 id="文件内部数据的组织"><a href="#文件内部数据的组织" class="headerlink" title="文件内部数据的组织"></a>文件内部数据的组织</h5><img src="/blog/2021/01/16/文件管理（一）/文件内部数据的组织.png"><h5 id="操作系统应该向上提供的功能"><a href="#操作系统应该向上提供的功能" class="headerlink" title="操作系统应该向上提供的功能"></a>操作系统应该向上提供的功能</h5><img src="/blog/2021/01/16/文件管理（一）/操作系统应该向上提供的功能.png"><ul><li><p>创建文件：新建后，图形化交互进程调用了<strong>create系统调用</strong>。</p></li><li><p>读文件：使用<strong>read系统调用</strong>，将文件数据从外存读入内存。</p></li><li><p>写文件：使用<strong>write系统调用</strong>，将文件数据从内存写回外存。</p></li><li><p>删除文件：删除后，图形化交互进程调用了<strong>delete系统调用</strong>。</p></li><li><p>打开文件：读/写文件之前，需要打开文件，使用<strong>open系统调用</strong>。</p></li><li><p>关闭文件：读/写文件结束之后，需要关闭文件，使用<strong>close系统调用</strong>。</p></li></ul><h5 id="从上往下看，文件应如何存放在外存？"><a href="#从上往下看，文件应如何存放在外存？" class="headerlink" title="从上往下看，文件应如何存放在外存？"></a>从上往下看，文件应如何存放在外存？</h5><p>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址。每个存储单元对应一个物理地址。</p><h5 id="其他需要由操作系统实现的功能"><a href="#其他需要由操作系统实现的功能" class="headerlink" title="其他需要由操作系统实现的功能"></a>其他需要由操作系统实现的功能</h5><ul><li>文件共享：使多个用户可以共享使用要给文件。</li><li>文件保护：不同的用户对文件有不同的操作权限。</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/16/文件管理（一）/初识文件管理小结.png"><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><img src="/blog/2021/01/16/文件管理（一）/文件的逻辑结构.png" style="zoom:80%;"><h5 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h5><p>文件内部的数据就是一系列的二进制流或字符流组成。又称<strong>流式文件</strong>。如 <code>txt</code> 文件。</p><h5 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h5><p>由一组相似的记录组成，又称<strong>记录式文件</strong>。每条记录由若干个数据项组成，如数据库表文件。一般每条记录有一个数据项可作为<strong>关键字</strong>。根据各条记录的长度是否相等，可分为<strong>定长记录</strong>和<strong>可变长记录</strong>。</p><h5 id="有结构文件的逻辑结构"><a href="#有结构文件的逻辑结构" class="headerlink" title="有结构文件的逻辑结构"></a>有结构文件的逻辑结构</h5><img src="/blog/2021/01/16/文件管理（一）/有结构文件的逻辑结构.png" style="zoom:80%;"><h6 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h6><p>文件中记录连续排列（逻辑上），记录可以是<strong>定长</strong>或<strong>可变长</strong>的。各个记录再物理上可以是<strong>顺序存储</strong>或<strong>链式存储</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/顺序文件存储方式.png"><ul><li>串结构：记录之间的顺序与关键字无关。</li><li>顺序结构：记录之间的顺序按关键字顺序排列。</li></ul><img src="/blog/2021/01/16/文件管理（一）/顺序文件存储方式+结构.png" style="zoom:80%;"><p>结论：定长记录的顺序文件，若物理上采用顺序存储，可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索。</p><h6 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h6><p><strong>可变长记录</strong>文件时查找第 <code>i</code> 个记录必须先查找前 <code>i-1</code> 个记录，如何解决这个问题？</p><hr><p>索引表：<strong>定长记录</strong>的<strong>顺序文件</strong>，可以快速找到第 <code>i</code> 个记录对应的索引项。应用于对信息处理的及时性要求比较好的场合。</p><img src="/blog/2021/01/16/文件管理（一）/索引表.png" style="zoom:80%;"><h6 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h6><p>与索引文件不同的是，不对每个记录都建立索引表项，而是<strong>一组记录对应一个索引表项</strong>。下图中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不许眼按关键字排序。<strong>索引顺序文件指索引表中的项是按关键字排列的</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/索引顺序文件.png" style="zoom:80%;"><p><strong>多级索引顺序文件</strong></p><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。</p><img src="/blog/2021/01/16/文件管理（一）/多级索引顺序文件.png" style="zoom:80%;"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/16/文件管理（一）/文件的逻辑结构小结.png"><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><img src="/blog/2021/01/16/文件管理（一）/文件目录.png" style="zoom:80%;"><h5 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h5><img src="/blog/2021/01/16/文件管理（一）/文件控制块FCB.png" style="zoom:80%;"><p><strong>FCB</strong>的有序集合称为“文件目录”，一个<strong>FCB</strong>就是一个文件<strong>目录项</strong>。</p><p><strong>FCB</strong>包含了文件的基本信息（文件名、物理地址、逻辑地址、物理结构等），存储控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（文件的建立时间、修改时间等）。</p><p><strong>最基本的是</strong>：文件名、文件存放的物理地址。</p><p>对目录进行的操作：</p><ul><li>搜索：系统根据文件名搜索目录，找到该文件对应的目录项。</li><li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项。</li><li>删除文件：当删除一个文件时，需要在目录中删除对应的目录项。</li><li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性。</li><li>修改目录：目录中保存了某些文件属性，这些属性变化时需要修改相应的目录项（如文件重命名）。</li></ul><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><h6 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h6><p>实现了<strong>按名存取</strong>，但是<strong>不允许文件重名</strong>。不适合多用户操作系统</p><img src="/blog/2021/01/16/文件管理（一）/单级目录结构.png" style="zoom:80%;"><h6 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h6><p>分为<strong>主文件目录</strong>和<strong>用户文件目录</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/两级目录结构.png" style="zoom:80%;"><h6 id="多级目录结构（树形目录结构）"><a href="#多级目录结构（树形目录结构）" class="headerlink" title="多级目录结构（树形目录结构）"></a>多级目录结构（树形目录结构）</h6><p>文件路径名是个字符串，各级目录之间用”/“隔开， 从根目录出发的路径称为<strong>绝对路径</strong>。系统根据绝对路径一层一层的找到下一级目录。树形结构<strong>不利于实现文件共享</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/多级目录结构.png" style="zoom:80%;"><p><code>自拍.jpg</code>的绝对路径为<code>/照片/2015-0/自拍.jpg</code>。找到此文件需要3次读磁盘I/O操作。</p><p>每次从根目录查找很低效，可以设置<strong>当前目录</strong>，当用户访问某个文件时，可以使用<strong>从当前目录出发</strong>的<strong>相对路径</strong>。</p><h6 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h6><img src="/blog/2021/01/16/文件管理（一）/无环图目录结构.png" style="zoom:80%;"><p>用户提出删除节点时，只删除该用户的PCB，并使共享计数器减1，不会直接删去共享节点。只要共有计数器减为0时才删除节点。</p><h5 id="索引节点（FCB的改进）"><a href="#索引节点（FCB的改进）" class="headerlink" title="索引节点（FCB的改进）"></a>索引节点（FCB的改进）</h5><p>一般查找只需要用到<strong>文件名</strong>这个信息，文件名匹配时才需要读出文件的其他信息，所以可以使目录表包含最有用的信息来提高效率，如下图：</p><img src="/blog/2021/01/16/文件管理（一）/索引节点.png" style="zoom:80%;"><p>存放在<strong>外存</strong>的索引节点称为<strong>磁盘索引节点</strong>，当索引节点<strong>放入内存</strong>后称为<strong>内存索引节点</strong>。内存索引节点需要增加一些信息，如：文件是否被修改，此时有几个进程在访问该文件等。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/16/文件管理（一）/文件目录小结.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;初识文件管理&lt;/li&gt;
&lt;li&gt;文件的逻辑结构&lt;/li&gt;
&lt;li&gt;文件目录&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="文件的逻辑结构" scheme="http://www.xingyuzhao.ltd/tags/%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/"/>
    
      <category term="文件目录" scheme="http://www.xingyuzhao.ltd/tags/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode947-移除最多的同行或同列石头</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/15/LeetCode947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/15/LeetCode947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/</id>
    <published>2021-01-15T14:06:08.000Z</published>
    <updated>2021-01-15T14:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p><p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p><p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [xi, yi]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p><a id="more"></a><img src="/blog/2021/01/15/LeetCode947-移除最多的同行或同列石头/947.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这个题的意思是：某行或者某列上最多只能存在一个石头，求移除的石头总数。</p><p>对于 <code>stones</code> 中任意两个位置，如果相对应的位置有一个相等，说明两个位置存在<strong>相同的</strong>行或者列，可以合并为一个集合。根据上述条件，使用双重循环将 <code>stones</code> 两两结合，最终合并的次数就是移除的石头个数，可以由 <code>stones</code> 的长度减去并查集中连通分量个数得到。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stones[i][<span class="number">0</span>] == stones[j][<span class="number">0</span>] || stones[i][<span class="number">1</span>] == stones[j][<span class="number">1</span>])</span><br><span class="line">                    uf.unionElem(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones.size() - uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为 <code>O(n^2)</code>。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>如果将 <code>stones</code> 中的位置与其相应的行或者列绑定，那么可以将二维降为一维，将行和列当作一个数字，降低了时间复杂度。</p><ul><li>当遍历到点 <code>[x,y]</code> 时，直接将 <code>x</code> 和 <code>y</code> 进行合并，表示该行和该列的点属于同一个并查集（根节点相同）。</li><li><code>x</code> 和 <code>y</code> 的值可能相等，相等时不能进行合并（一维情况下，行与列需要区分开），根据题目范围，将 <code>y</code> 加上10001，两者不会重合。</li></ul><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind():count(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当不存在p时，创建p并且指向自身，根节点数加1</span></span><br><span class="line">        <span class="keyword">if</span>(!parent.count(p))&#123;</span><br><span class="line">            parent[p] = p;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        unionFind uf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;stone : stones)&#123;</span><br><span class="line">            uf.unionElem(stone[<span class="number">0</span>], stone[<span class="number">1</span>] + <span class="number">10001</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones.size() - uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>题解：<a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。&lt;/p&gt;
&lt;p&gt;如果一块石头的 &lt;strong&gt;同行或者同列&lt;/strong&gt; 上有其他石头存在，那么就可以移除这块石头。&lt;/p&gt;
&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;stones&lt;/code&gt; ，其中 &lt;code&gt;stones[i] = [xi, yi]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 块石头的位置，返回 &lt;strong&gt;可以移除的石子&lt;/strong&gt; 的最大数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode684-冗余连接</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/13/LeetCode684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/13/LeetCode684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-01-13T03:10:42.000Z</published>
    <updated>2021-01-15T14:45:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对 <code>[u, v]</code>，满足 <code>u &lt; v</code>，表示连接顶点 <code>u</code> 和 <code>v</code> 的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p><a id="more"></a><img src="/blog/2021/01/13/LeetCode684-冗余连接/684.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>并查集中使用 <code>count</code> 记录当前还有多少个根节点，如果<strong>上一次的根节点数等于本次的根节点数</strong>，说明本次的合并无效，记录当前坐标即可。一次遍历结束后，找到了不需要进行合并的最后一个边。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 合并一次，根节点数减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(edges.size())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> pre; <span class="comment">// 上一次根节点数</span></span><br><span class="line">        <span class="keyword">int</span> index; <span class="comment">// 不需要合并的最后一个边的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            pre = uf.getCount();</span><br><span class="line">            uf.unionElem(edges[i][<span class="number">0</span>] - <span class="number">1</span>, edges[i][<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 上次根节点数等于本次合并后根节点数，更新index</span></span><br><span class="line">            <span class="keyword">if</span>(pre == uf.getCount()) index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在本问题中, 树指的是一个连通且无环的无向图。&lt;/p&gt;
&lt;p&gt;输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。&lt;/p&gt;
&lt;p&gt;结果图是一个以边组成的二维数组。每一个边的元素是一对 &lt;code&gt;[u, v]&lt;/code&gt;，满足 &lt;code&gt;u &amp;lt; v&lt;/code&gt;，表示连接顶点 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 的无向图的边。&lt;/p&gt;
&lt;p&gt;返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 &lt;code&gt;[u, v]&lt;/code&gt; 应满足相同的格式 &lt;code&gt;u &amp;lt; v&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1203-项目管理</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/12/LeetCode1203-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/12/LeetCode1203-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2021-01-12T14:53:37.000Z</published>
    <updated>2021-01-12T15:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>公司共有 <code>n</code> 个项目和  <code>m</code> 个小组，每个项目要不无人接手，要不就由 <code>m</code> 个小组之一负责。</p><p><code>group[i]</code> 表示第 <code>i</code> 个项目所属的小组，如果这个项目目前无人接手，那么 <code>group[i]</code> 就等于 <code>-1</code>。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。</p><p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p><p>同一小组的项目，排序后在列表中彼此相邻。<br>项目之间存在一定的依赖关系，我们用一个列表 <code>beforeItems</code> 来表示，其中 <code>beforeItems[i]</code> 表示在进行第 <code>i</code> 个项目前（位于第 <code>i</code> 个项目左侧）应该完成的所有项目。<br>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 <strong>空列表</strong> 。</p><a id="more"></a><img src="/blog/2021/01/12/LeetCode1203-项目管理/1203.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题是真的难，看了别人的题解才勉强写出来。</p><h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><p>在有向无环图（DAG）问题中，如果节点之间含有<strong>依赖关系</strong>，比如要完成 <code>B</code> 工作，必须先完成 <code>A</code> 工作，考虑进行<strong>拓扑排序</strong>，有关知识点参考<a href="https://www.cnblogs.com/bigsai/p/11489260.html" target="_blank" rel="noopener">这里</a>。</p><p><strong>C++模板</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图，节点入度，节点编号</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inDegree, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;id)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : id)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>; <span class="comment">// 记录已经出队多少个点，小于节点数说明有环</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; afterSort;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">// 取出第一个入度为0的点</span></span><br><span class="line">        <span class="keyword">int</span> cur = q.front();</span><br><span class="line">        afterSort.push_back(cur);</span><br><span class="line">        q.pop();</span><br><span class="line">        times++;</span><br><span class="line">        <span class="comment">// 遍历图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); ++i)&#123;</span><br><span class="line">            inDegree[G[cur][i]]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[G[cur][i]] == <span class="number">0</span>)</span><br><span class="line">                q.push(G[cur][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(times &lt; id.size()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> afterSort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关于本题"><a href="#关于本题" class="headerlink" title="关于本题"></a>关于本题</h5><p>从宏观来看，本题要求同一小组所处理的项目是相邻的，<strong>小组与小组之间</strong>是有依赖关系的，根据 <code>Before</code> 得到。同时，<strong>项目与项目之间</strong>也是有依赖关系的，也是由 <code>Before</code> 得到。以示例1为例：</p><ul><li>项目与项目之间：对于小组0，3必须在6之后，4必须在3和6之后。</li><li>小组与小组之间：小组-1中的1必须在小组0中的6之后。</li></ul><p>根据以上两条信息，可以先对所有小组进行拓扑排序，再对排好序的小组集合中的每个小组进行一个拓扑排序，就可以得到结果了。<strong>所有小组号为-1的表示当前未进行处理，可以给其分配一个新的组号，从m开始递增</strong>，只要拓扑排序时无环，所有的项目都会被处理掉。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortItems</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; group, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; beforeItems)</span></span>&#123;      </span><br><span class="line">        <span class="comment">// 将同一组的放一起</span></span><br><span class="line">        <span class="comment">// 比如3, 4, 6分组为0，则sameGroup[0] = &#123;3,4,6&#125;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">sameGroup</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> samegroup = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(group[i] == <span class="number">-1</span>) group[i] = samegroup++;</span><br><span class="line">            sameGroup[group[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最多会有n + m个小组（比如m=2, 所有分组都为-1）</span></span><br><span class="line">        <span class="comment">// n + m个小组的序号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; groupid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m; ++i) groupid.push_back(i);</span><br><span class="line">        <span class="comment">// 建立group图和item图及其入度</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">itemGraph</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">groupGraph</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">itemIndegree</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">groupIndegree</span><span class="params">(n + m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; beforeItems.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curId = group[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : beforeItems[i])&#123;</span><br><span class="line">                <span class="comment">// 如果是同一个组，那么有item-&gt;i</span></span><br><span class="line">                <span class="comment">// i入度+1，同时节点item可达i</span></span><br><span class="line">                <span class="keyword">if</span>(group[item] == curId)&#123; </span><br><span class="line">                    itemIndegree[i]++;</span><br><span class="line">                    itemGraph[item].push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不同组，有小组group[item]-&gt;curId</span></span><br><span class="line">                <span class="comment">// 小组curId入度+1，同时小组group[item]可达curId</span></span><br><span class="line">                <span class="keyword">else</span>&#123; </span><br><span class="line">                    groupIndegree[curId]++;</span><br><span class="line">                    groupGraph[group[item]].push_back(curId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对group图进行topSort，得到小组之间的拓扑关系</span></span><br><span class="line">        <span class="keyword">auto</span> outGroup = topSort(groupGraph, groupIndegree, groupid);</span><br><span class="line">        <span class="comment">// 对每个小组进行topSort，得到组内的拓扑关系</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;g : outGroup)&#123;</span><br><span class="line">            <span class="keyword">auto</span> id = sameGroup[g];</span><br><span class="line">            <span class="keyword">if</span>(id.empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> res = topSort(itemGraph, itemIndegree, id);</span><br><span class="line">            <span class="keyword">if</span>(res.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r : res)</span><br><span class="line">                ret.push_back(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数：图，入度，当前的节点集合</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inDegree, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;id)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : id)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>; <span class="comment">// 记录已经出队多少个点，小于id数说明有环</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; afterSort;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="comment">// 取出第一个入度为0的点</span></span><br><span class="line">            <span class="keyword">int</span> cur = q.front();</span><br><span class="line">            afterSort.push_back(cur);</span><br><span class="line">            q.pop();</span><br><span class="line">            times++;</span><br><span class="line">            <span class="comment">// 遍历图</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); ++i)&#123;</span><br><span class="line">                inDegree[G[cur][i]]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[G[cur][i]] == <span class="number">0</span>)</span><br><span class="line">                    q.push(G[cur][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times &lt; id.size()) <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 有环，返回空</span></span><br><span class="line">        <span class="keyword">return</span> afterSort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>题解：<a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/chao-xiang-xi-shuang-ceng-tuo-bu-pai-xu-5cyuc/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/chao-xiang-xi-shuang-ceng-tuo-bu-pai-xu-5cyuc/</a></p><p>拓扑排序：<a href="https://www.cnblogs.com/bigsai/p/11489260.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigsai/p/11489260.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;公司共有 &lt;code&gt;n&lt;/code&gt; 个项目和  &lt;code&gt;m&lt;/code&gt; 个小组，每个项目要不无人接手，要不就由 &lt;code&gt;m&lt;/code&gt; 个小组之一负责。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;group[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个项目所属的小组，如果这个项目目前无人接手，那么 &lt;code&gt;group[i]&lt;/code&gt; 就等于 &lt;code&gt;-1&lt;/code&gt;。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。&lt;/p&gt;
&lt;p&gt;请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：&lt;/p&gt;
&lt;p&gt;同一小组的项目，排序后在列表中彼此相邻。&lt;br&gt;项目之间存在一定的依赖关系，我们用一个列表 &lt;code&gt;beforeItems&lt;/code&gt; 来表示，其中 &lt;code&gt;beforeItems[i]&lt;/code&gt; 表示在进行第 &lt;code&gt;i&lt;/code&gt; 个项目前（位于第 &lt;code&gt;i&lt;/code&gt; 个项目左侧）应该完成的所有项目。&lt;br&gt;如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 &lt;strong&gt;空列表&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="拓扑排序" scheme="http://www.xingyuzhao.ltd/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1202-交换字符串中的元素</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/11/LeetCode1202-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/11/LeetCode1202-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2021-01-11T02:27:01.000Z</published>
    <updated>2021-01-11T03:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 <code>s</code>，以及该字符串中的一些「索引对」数组 <code>pairs</code>，其中 <code>pairs[i] = [a, b]</code> 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 <strong>任意多次交换</strong> 在 <code>pairs</code> 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，<code>s</code> 可以变成的按字典序最小的字符串。</p><a id="more"></a><img src="/blog/2021/01/11/LeetCode1202-交换字符串中的元素/1202.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><del>不看提示我都没想到用并查集去解决这个问题</del>。</p><p>以示例三为例：<code>s = &quot;cba&quot;, pairs = [[0,1],[1,2]]</code>，输出为 <code>&quot;abc&quot;</code>。可以看出 <code>pairs</code> 中 <code>0,1,2</code> 三个点是相连的。相连的点在 <code>s</code> 中对应的元素 <code>&quot;cba&quot;</code> 可以任意排序，我们需要让这些元素的组合字典序最小，可以得到 <code>&quot;abc&quot;</code>。</p><p>将上述例子扩充，<code>s = &quot;cbafd&quot;, pairs = [[0,1],[1,2],[4,3]]</code>，输出为 <code>&quot;abcdf&quot;</code>。其中 <code>0,1,2</code> 相连，<code>4,3</code> 相连，分别将两个集合中对应的位置<strong>升序排序</strong>得到 <code>0,1,2</code> 和 <code>3,4</code>，再将 <code>s</code> 中对应位置元素取出来按照<strong>字典序排序</strong>，再根据对应位置修改 <code>s</code> 中的元素。所以<strong>一共需要进行两次排序</strong>。</p><hr><p>我们将 <code>pairs</code> 中的<strong>每一个</strong>元素想象成一个孤立的点，对于 <code>pairs</code> 中的<strong>每一对</strong>元素，表示两个点相连，所有相连的点构成不同的集合（只需要知道是否相连，不需要知道如何相连），所以使用并查集即可。</p><p><strong>算法如下</strong>：</p><ul><li>将 <code>pairs</code> 中的<strong>每一对</strong>元素进行 <code>union</code> 操作，再将它们根据共同祖先分为<strong>若干集合</strong>。</li><li>将每个集合中的序列<strong>升序排列</strong>，再找到 <code>s</code> 中对应的元素，将这些元素按<strong>字典序</strong>排序。</li><li>将按字典序排列的元素按照集合中序列的顺序依次修改 <code>s</code>。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 未用到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>; <span class="comment">// 未用到</span></span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            rank[pRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pairs.size() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); ++i)&#123;</span><br><span class="line">            uf.unionElem(pairs[i][<span class="number">0</span>], pairs[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> rootIdx = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(s.size());</span><br><span class="line">        <span class="comment">// 如果祖先相同，代表在同一个集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> root = uf.find(i);</span><br><span class="line">            rootIdx[root].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rootIdx.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rootIdx[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将同一个祖先的序列升序排列</span></span><br><span class="line">            sort(rootIdx[i].begin(), rootIdx[i].end());</span><br><span class="line">            <span class="built_in">string</span> buf;</span><br><span class="line">            <span class="comment">// 根据排好序的序列取出s中的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : rootIdx[i])&#123;</span><br><span class="line">                buf += s[v];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再将取出的元素按照字典序排列</span></span><br><span class="line">            sort(buf.begin(), buf.end());</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将排好序的字符串根据排好序的序列修改s中相应的位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : rootIdx[i])&#123;</span><br><span class="line">                s[v] = buf[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，以及该字符串中的一些「索引对」数组 &lt;code&gt;pairs&lt;/code&gt;，其中 &lt;code&gt;pairs[i] = [a, b]&lt;/code&gt; 表示字符串中的两个索引（编号从 0 开始）。&lt;/p&gt;
&lt;p&gt;你可以 &lt;strong&gt;任意多次交换&lt;/strong&gt; 在 &lt;code&gt;pairs&lt;/code&gt; 中任意一对索引处的字符。&lt;/p&gt;
&lt;p&gt;返回在经过若干次交换后，&lt;code&gt;s&lt;/code&gt; 可以变成的按字典序最小的字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode228-汇总区间</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/10/LeetCode228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/10/LeetCode228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</id>
    <published>2021-01-10T09:05:25.000Z</published>
    <updated>2021-01-10T09:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p><p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><a id="more"></a><img src="/blog/2021/01/10/LeetCode228-汇总区间/228.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果序列满足 <code>nums[i] == nums[i - 1]</code> 代表它们是同一个区间。</p><p>需要记录区间的起始位置的终止位置，使用双指针，<code>i</code> 代表当前区间的起始位置， <code>j</code> 代表当前区间的终止位置。</p><p>遍历结束时，还需要<strong>把最后一个区间加入答案中</strong>，如果最后一个区间的 <code>j - i == 1</code>，说明最后一个区间只有一个数，否则，需要再加入一个新的区间。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i + <span class="number">1</span>)&#123;</span><br><span class="line">                    ret.push_back(to_string(nums[i]));</span><br><span class="line">                    j++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ret.push_back(to_string(nums[i]) + <span class="string">"-&gt;"</span> + to_string(nums[j - <span class="number">1</span>]));</span><br><span class="line">                    i = j;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == j - <span class="number">1</span>) ret.push_back(to_string(nums[i]));</span><br><span class="line">        <span class="keyword">if</span>(i != j - <span class="number">1</span>) ret.push_back(to_string(nums[i]) + <span class="string">"-&gt;"</span> + to_string(nums[j - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个无重复元素的有序整数数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;返回 &lt;strong&gt;恰好覆盖数组中所有数字&lt;/strong&gt; 的 &lt;strong&gt;最小有序&lt;/strong&gt; 区间范围列表。也就是说，&lt;code&gt;nums&lt;/code&gt; 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 &lt;code&gt;nums&lt;/code&gt; 的数字 &lt;code&gt;x&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;列表中的每个区间范围 &lt;code&gt;[a,b]&lt;/code&gt; 应该按如下格式输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a-&amp;gt;b&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a != b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a == b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode189-旋转数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/08/LeetCode189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/08/LeetCode189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2021-01-08T15:12:16.000Z</published>
    <updated>2021-01-10T09:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>进阶</strong>：</p><ul><li>尽可能想出更多的解决方案，<del>至少有三种不同的方法可以解决这个问题</del>。</li><li>你可以使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法解决这个问题吗？</li></ul><a id="more"></a><img src="/blog/2021/01/08/LeetCode189-旋转数组/189.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据 <code>k</code> 值，将 <code>nums</code> 数组分为前后两个部分。将后 <code>k</code> 个值截取出来得到的数组，拼接到剩余数组之前即可。空间复杂度为 <code>O(n)</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 99% 9%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size(); <span class="comment">// 如果k大于nums的长度，取余之后再进行处理</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buf1</span><span class="params">(nums.begin() + nums.size() - k, nums.end())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buf2</span><span class="params">(nums.begin(), nums.begin() + nums.size() - k)</span></span>;</span><br><span class="line">        buf1.insert(buf1.end(), buf2.begin(), buf2.end());</span><br><span class="line">        nums = buf1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>上述的空间复杂度为 <code>O(n)</code>，可以进一步压缩空间，使空间复杂度降为 <code>O(1)</code>。</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>具体思路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k = 3;</span><br><span class="line">----&gt;--&gt; 移动后得到 --&gt;----&gt;</span><br><span class="line">可以对原始序列进行如下操作：</span><br><span class="line">----&gt;--&gt; 反转后 &lt;--&lt;----</span><br><span class="line">其中&lt;-- 反转后 --&gt;&lt;----</span><br><span class="line">其中&lt;---- 反转后 --&gt;----&gt;</span><br></pre></td></tr></table></figure><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库函数 50.50% 84.77%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.begin() + k);</span><br><span class="line">        reverse(nums.begin() + k, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 非库函数 50.50% 74.88%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然速度慢了点（实际上为 <code>O(2n) = O(n)</code> ），不过空间使用较之前还是低了很多。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解及其评论区：<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 &lt;code&gt;k&lt;/code&gt; 个位置，其中 &lt;code&gt;k&lt;/code&gt; 是非负数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能想出更多的解决方案，&lt;del&gt;至少有三种不同的方法可以解决这个问题&lt;/del&gt;。&lt;/li&gt;
&lt;li&gt;你可以使用空间复杂度为 O(1) 的 &lt;strong&gt;原地&lt;/strong&gt; 算法解决这个问题吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>内存管理（五）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2021-01-08T09:41:08.000Z</published>
    <updated>2021-01-10T15:32:06.303Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>虚拟内存基本概念</li><li>请求分页管理方式</li><li>页面置换算法</li><li>页面分配策略</li></ol><a id="more"></a><h4 id="虚拟内存基本概念"><a href="#虚拟内存基本概念" class="headerlink" title="虚拟内存基本概念"></a>虚拟内存基本概念</h4><h5 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h5><p>传统存储管理特点：</p><ol><li>一次性：作业必须<strong>一次性全部装入内存</strong>才能开始运行。</li><li>驻留性：一旦作业被装入内存，就<strong>会一直驻留在内存中</strong>。</li></ol><p>很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。</p><h5 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h5><ul><li>时间局部性</li><li>空间局部性</li></ul><h5 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h5><p>虚拟内存：若内存空间不够，由<strong>操作系统</strong>负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong>。虚拟性体现在：实际的物理内存大小没有变，只是在逻辑上进行了扩充。</p><ul><li>虚拟内存最大容量：计算机的地址结构（CPU寻址范围）确定。</li><li>虚拟内存实际容量：<em>min</em>(内存和外存容量之和，CPU寻址范围)。</li></ul><p>虚拟内存有以下三个特征：</p><ol><li>多次性（对应一次性）：允许作业被分成多次调入内存。</li><li>对换性（对应驻留性）：允许作业运行中，将作业换出、换入内存。</li><li>虚拟性：从逻辑上扩充了内存的容量。</li></ol><h5 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h5><img src="/blog/2021/01/08/内存管理（五）/虚拟内存的实现.png"><p>虚拟内存技术基于<strong>离散分配</strong>的内存管理方式。<strong>请求分页存储管理</strong>与<strong>基本分页存储管理</strong>的<strong>主要区别</strong>是：操作系统需要提供<strong>请求调页</strong>和<strong>页面置换</strong>功能。</p><ul><li>请求调页：程序执行过程中，当所访问信息<strong>不在内存中</strong>时，由操作系统负责<strong>将所需信息从外存调入内存</strong>。</li><li>页面置换：若内存空间不够，由操作系统将<strong>内存中暂时用不到的信息换出到外存</strong>。</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/虚拟内存基本概念小结.png" style="zoom:120%;"><h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><img src="/blog/2021/01/08/内存管理（五）/请求分页管理方式.png"><h5 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h5><ul><li>为了实现<strong>请求调页</strong>，操作系统需要知道每个页面是否已经调入内存；如果没调入，那么也需要知道该页面在外存中存放的位置。</li><li>为了实现<strong>内存置换</strong>，操作系统需要通过某些指标来决定到底换出哪个页面。需要记录各个页面是否被修改过，修改过才需要换出，将外存中的旧数据覆盖。</li></ul><img src="/blog/2021/01/08/内存管理（五）/页表机制.png"><h5 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h5><p>请求分页系统中，若访问页面<strong>不在内存中</strong>时，便产生一个<strong>缺页中断</strong>。然后由操作系统的<strong>缺页中断处理程序</strong>处理中断。此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><ul><li><p>如果内存中<strong>有空闲块</strong>，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中对应页表项。</p></li><li><p>如果内存中<strong>无空闲块</strong>，则由<strong>页面置换算法</strong>选择<strong>淘汰</strong>一个页面，若该页面在内存期间被<strong>修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</p></li></ul><p>缺页中断是由于当前指令想要访问的目标页面未调入内存而产生的，因此属于<strong>内中断</strong>。一条指令在执行期间，可能产生<strong>多次</strong>缺页中断。</p><img src="/blog/2021/01/08/内存管理（五）/缺页中断机构.png"><h5 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h5><img src="/blog/2021/01/08/内存管理（五）/地址变化机构.png"><ul><li>新增步骤1：请求调页（查到页表项时进行判断）。</li><li>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）。</li><li>新增步骤3：需要修改请求页表中新增的表项。</li></ul><img src="/blog/2021/01/08/内存管理（五）/地址变化机构步骤.png" style="zoom:120%;"><p>补充：</p><ol><li>换入/换出页面需要启动慢速I/O操作，如果过于频繁，会有很大开销。</li><li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li></ol><p>在具有快表的请求分页系统中，访问一个逻辑地址时，若发生缺页，地址变换步骤为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查快表（未命中）-&gt;查慢表（发现未调入内存）-&gt;调页（调入的页面对应的表项会直接加入快表）</span><br><span class="line">-&gt;查快表（命中）-&gt;访问目标内存单元</span><br></pre></td></tr></table></figure><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/地址变化机构小结.png" style="zoom:120%;"><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><img src="/blog/2021/01/08/内存管理（五）/页面置换算法.png" style="zoom:80%;"><h5 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h5><p>每次选择淘汰的页面<strong>以后永不使用</strong>或<strong>最长时间内不再被访问</strong>，保证最低缺页率。</p><p>缺点：只有进程执行的过程中才能知道接下来会访问到哪个页面，操作系统无法提前预判访问序列。因此，最佳置换算法<strong>无法实现</strong>。</p><h5 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h5><p>每次选择淘汰的页面是<strong>最早进入内存的页面</strong>。</p><p>Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>缺点：只有FIFO算法会产生<strong>Belady异常</strong>，虽然其实现简单，但是与进程实际运行时规律不适应，因为先进入的页面也有可能最经常被访问。因此算法<strong>性能差</strong>。</p><h5 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h5><p>每次选择淘汰的页面是<strong>最近最久未使用的页面</strong>。用每个页面页表项中的<strong>访问字段</strong>记录该页面自上次被访问以来所经历的时间 t 。淘汰时选择 t 最大的页面。</p><p>缺点：实现需要专门的硬件支持，虽然算法性能好，但<strong>实现困难，开销大</strong>。</p><h5 id="时钟置换算法（CLOCK）"><a href="#时钟置换算法（CLOCK）" class="headerlink" title="时钟置换算法（CLOCK）"></a>时钟置换算法（CLOCK）</h5><p>此算法是一种性能和开销较均衡的算法，也称<strong>最近未用算法（NRU，Not Recently Used）</strong>。</p><p>简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个<strong>循环队列</strong>。当某页被访问时，其<strong>访问位置为1</strong>。<strong>当需要淘汰一个页面时，只需检查页的访问位</strong>。</p><img src="/blog/2021/01/08/内存管理（五）/简单clock.png"><ul><li>如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面。</li><li>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）。</li></ul><h6 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h6><p>简单的CLOCK算法<strong>仅考虑一个页面最近是否被访问过</strong>，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过，才需要写回外存</strong>。</p><p>因此，在其他条件都相同时，应<strong>优先淘汰没有修改过的页面</strong>，避免I/O操作。修改位为0时表示没有修改过，修改位为1，表示页面被修改过。</p><p>改进型CLOCK置换算法选择一个淘汰页面最多会进行<strong>四轮扫描</strong>。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/页面置换算法小结.png"><h4 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h4><h5 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h5><p>驻留集：请求分页存储管理中给进程分配的物理块的集合。驻留集大小一般小于进程的总大小。</p><ul><li>若驻留集太小，会导致缺页频繁。</li><li>若驻留集太大，会导致多道程序并发度下降。</li></ul><p>固定分配：操作系统为每个进程分配一组固定数目的物理块。进程运行期间驻留集<strong>大小不变</strong>。</p><p>可变分配：驻留集<strong>大小可变</strong>。</p><p>局部置换：缺页时只能选进程自己的物理块进行置换。</p><p>全局置换：操作系统保留的空闲物理块和别的进程持有的物理块（先置换到外存）都可以分配给缺页进程。</p><img src="/blog/2021/01/08/内存管理（五）/页面置换策略.png"><p>可变分配<strong>全局</strong>置换：只要缺页就给分配新物理块。</p><p>可变分配<strong>局部</strong>置换：根据<strong>缺页的频率</strong>来动态地增加或减少进程的物理块。</p><h5 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h5><ol><li>预调页策略：根据空间局部性，一次调入若干相邻的页面可能比一次调入一个页面更高效。主要用于<strong>进程的首次调入</strong>，由程序员指出（<strong>运行前调入</strong>）。</li><li>请求调页策略：进程在<strong>运行期间</strong>发现缺页时才将所缺页面调入内存。I/O开销较大（每次只能调入一页，每次调页都要进行磁盘I/O）。</li></ol><h5 id="何处调入页面"><a href="#何处调入页面" class="headerlink" title="何处调入页面"></a>何处调入页面</h5><h6 id="系统拥有足够的对换区空间"><a href="#系统拥有足够的对换区空间" class="headerlink" title="系统拥有足够的对换区空间"></a>系统拥有足够的对换区空间</h6><img src="/blog/2021/01/08/内存管理（五）/何处调入1.png"><h6 id="系统缺少足够的对换区空间"><a href="#系统缺少足够的对换区空间" class="headerlink" title="系统缺少足够的对换区空间"></a>系统缺少足够的对换区空间</h6><img src="/blog/2021/01/08/内存管理（五）/何处调入2.png"><h6 id="UNIX方式"><a href="#UNIX方式" class="headerlink" title="UNIX方式"></a>UNIX方式</h6><img src="/blog/2021/01/08/内存管理（五）/何处调入3.png"><h5 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h5><p>刚换出的页面马上要换入内存，或刚换入的需要换出，这种频繁的页面调度行为称为<strong>抖动（颠簸）</strong>。主要原因是进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）。</p><h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合。</p><p>工作集：指在某段时间间隔里，进程实际访问页面的集合。</p><img src="/blog/2021/01/08/内存管理（五）/工作集.png"><p><strong>窗口尺寸为4</strong>。</p><p><strong>工作集大小</strong>可能小于窗口尺寸，一般来说，驻留集大小不能<strong>小于</strong>工作集大小，否则进程运行过程中将频繁缺页。</p><h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/页面分配策略小结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;虚拟内存基本概念&lt;/li&gt;
&lt;li&gt;请求分页管理方式&lt;/li&gt;
&lt;li&gt;页面置换算法&lt;/li&gt;
&lt;li&gt;页面分配策略&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="虚拟内存" scheme="http://www.xingyuzhao.ltd/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode547-省份数量</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/07/LeetCode547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/07/LeetCode547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</id>
    <published>2021-01-07T12:58:59.000Z</published>
    <updated>2021-01-07T13:30:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><a id="more"></a><img src="/blog/2021/01/07/LeetCode547-省份数量/547.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题的核心问题是<strong>节点之间是否相连</strong>。如果找到了这个核心点，就可以想到两种解决方案。一种是图论中，计算<strong>连通分量</strong>的个数；另一种是并查集，找到大家的<strong>公共祖先</strong>的个数。</p><p>考虑到我们并不需要知道节点与节点之间<strong>如何连接</strong>，只需要知道节点与节点之间<strong>是否连接</strong>，所以使用<strong>并查集</strong>来解决这个问题就足够了。</p><p>并查集的相关知识可参考<a href="%5Bhttp://www.xingyuzhao.ltd/blog/2020/09/06/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find/">这里</a>，建议先看！</p><p>输入矩阵的长或者宽（其实就是一个邻接矩阵）的大小就是城市的个数，所以对于并查集的初始化，我们只需要设置长度与城市个数相等的<code>parent</code>数组即可，并且指向自身，同时可以初始化当前祖先的总数，即城市的个数。</p><p>在遍历<code>isconnected</code>矩阵时，遇到<code>isconnected[i][j]</code>为 1 时，代表<code>i, j</code>两节点相连，进行<code>union(i, j)</code>操作。同时祖先数减去 1 。否则不相连，不进行任何操作。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            count++;</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根不同，将其相连，计数减1</span></span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot; <span class="comment">// 随便指一个</span></span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isConnected.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(isConnected)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> m = isConnected.size();</span><br><span class="line">        <span class="keyword">int</span> n = isConnected[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    uf.unionElem(i, j);</span><br><span class="line">                &#125;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个城市，其中一些彼此相连，另一些没有相连。如果城市 &lt;code&gt;a&lt;/code&gt; 与城市 &lt;code&gt;b&lt;/code&gt; 直接相连，且城市 &lt;code&gt;b&lt;/code&gt; 与城市 &lt;code&gt;c&lt;/code&gt; 直接相连，那么城市 &lt;code&gt;a&lt;/code&gt; 与城市 &lt;code&gt;c&lt;/code&gt; 间接相连。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;省份&lt;/strong&gt; 是一组直接或间接相连的城市，组内不含其他没有相连的城市。&lt;/p&gt;
&lt;p&gt;给你一个 &lt;code&gt;n x n&lt;/code&gt; 的矩阵 &lt;code&gt;isConnected&lt;/code&gt; ，其中 &lt;code&gt;isConnected[i][j] = 1&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个城市和第 &lt;code&gt;j&lt;/code&gt; 个城市直接相连，而 &lt;code&gt;isConnected[i][j] = 0&lt;/code&gt; 表示二者不直接相连。&lt;/p&gt;
&lt;p&gt;返回矩阵中 &lt;strong&gt;省份&lt;/strong&gt; 的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode399-除法求值</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/06/LeetCode399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/06/LeetCode399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</id>
    <published>2021-01-06T12:02:07.000Z</published>
    <updated>2021-01-06T13:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。</p><p><strong>注意</strong>：输入总是有效的。你可以假设除法运算中不会出现除数为 <code>0</code> 的情况，且不存在任何矛盾的结果。</p><a id="more"></a><img src="/blog/2021/01/06/LeetCode399-除法求值/399.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先得理解题目意思：</p><ul><li><code>equations</code>和<code>values</code>：<code>equations</code>中每个一维序列表示一对数进行相除（前 / 后），得到的结果就是<code>values</code>中相应位置的值，以上作为已知条件。</li><li><code>queries</code>：包含两个元素，目的是要我们求：第一个元素 / 第二个元素 = ？</li></ul><p>我们可以将其抽象为一个<strong>带权图</strong>问题，对于<code>queries</code>中的两个元素 <code>x</code>, <code>y</code> ，是否有一条路径可以从 <code>x</code> 到 <code>y</code> ，并求出经过这条路径的消耗是多少。由于两个元素的比值是一个常量，所以<strong>如果有多条路径，消耗是一样的</strong>，选其中一条就可以。</p><p>以示例1为例，对于<code>a/c</code>，可以由<code>a/b * b/c</code>得到，也就是<code>a-&gt;b</code>与<code>b-&gt;c</code>两条路径的权值相乘得到，所以路径上的消耗，就是<strong>所走过的每条路径的权值之积</strong>。</p><p>由于每个基本元素类型都是<code>string</code>，所以先对所有的元素映射到数字域，方便查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将equations中的string映射到0，1，2，3...</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : equations)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">map</span>.count(ch)) <span class="built_in">map</span>[ch] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步就是建图，使用邻接表，并且路径之间是<strong>双向</strong>的，权值<strong>互为倒数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; W;</span><br><span class="line">G = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">W = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); ++i)&#123;</span><br><span class="line">    G[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]);</span><br><span class="line">    W[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(values[i]);</span><br><span class="line">    G[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]);</span><br><span class="line">    W[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="number">1</span> / values[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建好图之后，就可以用<strong>深度优先搜索（DFS）</strong>和<strong>回溯算法</strong>来找路了，需要用一个数组记录走过的节点，防止重复走过，还需要一个变量<code>flag</code>表示起点与终点之间是否存在路径：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 初始为0，表示起点与终点之间没有路径。设置为全局变量，在函数中不用调用。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="built_in">map</span>.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; querie : queries) &#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = querie[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">string</span> s2 = querie[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 如果两个元素相同并且存在于map中，结果就是1</span></span><br><span class="line">    <span class="keyword">if</span> (s1 == s2 &amp;&amp; <span class="built_in">map</span>.count(s1)) &#123;</span><br><span class="line">        res.push_back(<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有一个元素不存在于map中，结果就是-1，因为没有这条路径</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">map</span>.count(s1) || !<span class="built_in">map</span>.count(s2)) &#123;</span><br><span class="line">        res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将起点标记为已使用</span></span><br><span class="line">    vis[<span class="built_in">map</span>[s1]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 参数：图，权值，标记数组，起点，终点，当前计算结果（初始为1）</span></span><br><span class="line">    dfs(G, W, vis, <span class="built_in">map</span>[s1], <span class="built_in">map</span>[s2], <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用过后，再次标记为未使用</span></span><br><span class="line">    vis[<span class="built_in">map</span>[s1]] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 没有路径，结果为-1</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">    <span class="comment">// 已经有路径，将flag置为0，结果已经在DFS中记录过，所以不用再次记录了</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS+回溯：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; &amp;W, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;vis, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">        res.push_back(val);</span><br><span class="line">        <span class="comment">// 有路径，flag为1</span></span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[start].size(); ++i)&#123;</span><br><span class="line">        <span class="comment">// 如果flag已经为1了，说明找到一条路径了，就不需要再找了</span></span><br><span class="line">        <span class="comment">// 剩下的就是一般的回溯算法</span></span><br><span class="line">        <span class="keyword">if</span>(vis[G[start][i]] || flag == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        vis[G[start][i]] = <span class="literal">true</span>;</span><br><span class="line">        val *= W[start][i];</span><br><span class="line">        dfs(G, W, vis, G[start][i], end, val);</span><br><span class="line">        val /= W[start][i];</span><br><span class="line">        vis[G[start][i]] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; W;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="comment">// set&lt;pair&lt;int, int&gt;&gt; set;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : equations)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">map</span>.count(ch)) <span class="built_in">map</span>[ch] = cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; map.size();</span></span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        G = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">        W = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">        vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); ++i)&#123;</span><br><span class="line">            G[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; map[equations[i][0]] &lt;&lt; " " &lt;&lt; map[equations[i][1]];</span></span><br><span class="line">            W[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(values[i]);</span><br><span class="line">            G[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]);</span><br><span class="line">            W[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="number">1</span> / values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto &amp;g : G)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;gg : g)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; gg &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; "    ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for(auto &amp;w : W)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;ww : w)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; ww &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; "    ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;querie : queries)&#123;</span><br><span class="line">            <span class="built_in">string</span> s1 = querie[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">string</span> s2 = querie[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s1 == s2 &amp;&amp; <span class="built_in">map</span>.count(s1))&#123;</span><br><span class="line">                res.push_back(<span class="number">1.0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.count(s1) || !<span class="built_in">map</span>.count(s2))&#123;</span><br><span class="line">                res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[<span class="built_in">map</span>[s1]] = <span class="literal">true</span>;</span><br><span class="line">            dfs(G, W, vis, <span class="built_in">map</span>[s1], <span class="built_in">map</span>[s2], <span class="number">1</span>);</span><br><span class="line">            vis[<span class="built_in">map</span>[s1]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>) res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int count = queries.size() - res.size();</span></span><br><span class="line">        <span class="comment">// while(count--)&#123;</span></span><br><span class="line">        <span class="comment">//     res.insert(res.begin(), -1.0);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; &amp;W, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;vis, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            res.push_back(val);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; val &lt;&lt; " ";</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[start].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[G[start][i]] || flag == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            vis[G[start][i]] = <span class="literal">true</span>;</span><br><span class="line">            val *= W[start][i];</span><br><span class="line">            dfs(G, W, vis, G[start][i], end, val);</span><br><span class="line">            val /= W[start][i];</span><br><span class="line">            vis[G[start][i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h4><p>可以使用并查集解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个变量对数组 &lt;code&gt;equations&lt;/code&gt; 和一个实数值数组 &lt;code&gt;values&lt;/code&gt; 作为已知条件，其中 &lt;code&gt;equations[i] = [Ai, Bi]&lt;/code&gt; 和 &lt;code&gt;values[i]&lt;/code&gt; 共同表示等式 &lt;code&gt;Ai / Bi = values[i]&lt;/code&gt; 。每个 &lt;code&gt;Ai&lt;/code&gt; 或 &lt;code&gt;Bi&lt;/code&gt; 是一个表示单个变量的字符串。&lt;/p&gt;
&lt;p&gt;另有一些以数组 &lt;code&gt;queries&lt;/code&gt; 表示的问题，其中 &lt;code&gt;queries[j] = [Cj, Dj]&lt;/code&gt; 表示第 &lt;code&gt;j&lt;/code&gt; 个问题，请你根据已知条件找出 &lt;code&gt;Cj / Dj = ?&lt;/code&gt; 的结果作为答案。&lt;/p&gt;
&lt;p&gt;返回 所有问题的答案 。如果存在某个无法确定的答案，则用 &lt;code&gt;-1.0&lt;/code&gt; 替代这个答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：输入总是有效的。你可以假设除法运算中不会出现除数为 &lt;code&gt;0&lt;/code&gt; 的情况，且不存在任何矛盾的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="DFS" scheme="http://www.xingyuzhao.ltd/tags/DFS/"/>
    
      <category term="图" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE/"/>
    
      <category term="回溯算法" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode830-较大分组的位置</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/05/LeetCode830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/05/LeetCode830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-01-05T10:08:58.000Z</published>
    <updated>2021-01-05T12:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p><p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p><a id="more"></a><img src="/blog/2021/01/05/LeetCode830-较大分组的位置/830.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>寻找每个重复字符出现的起始位置和终止位置，如果长度大于等于3，记录一下结果就可以了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">largeGroupPositions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = s[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="comment">// 此位置的前一个位置就是上一个重复字符的终止位置</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] != ch)&#123;</span><br><span class="line">                ch = s[i];</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> - start + <span class="number">1</span> &gt;= <span class="number">3</span>) res.push_back(&#123;start, i - <span class="number">1</span>&#125;);</span><br><span class="line">                <span class="comment">// 更新起始位置</span></span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 字符重复</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> - start + <span class="number">1</span> &gt;= <span class="number">3</span>) res.push_back(&#123;start, i - <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一个由小写字母构成的字符串 &lt;code&gt;s&lt;/code&gt; 中，包含由一些连续的相同字符所构成的分组。&lt;/p&gt;
&lt;p&gt;例如，在字符串 &lt;code&gt;s = &amp;quot;abbxxxxzyy&amp;quot;&lt;/code&gt; 中，就含有 &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;bb&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;z&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;yy&amp;quot;&lt;/code&gt; 这样的一些分组。&lt;/p&gt;
&lt;p&gt;分组可以用区间 &lt;code&gt;[start, end]&lt;/code&gt; 表示，其中 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 分别表示该分组的起始和终止位置的下标。上例中的 &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt; 分组用区间表示为 &lt;code&gt;[3,6]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;我们称所有包含大于或等于三个连续字符的分组为 &lt;strong&gt;较大分组&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;找到每一个 &lt;strong&gt;较大分组&lt;/strong&gt; 的区间，&lt;strong&gt;按起始位置下标递增顺序排序后&lt;/strong&gt;，返回结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode509-斐波那契数</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/04/LeetCode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/04/LeetCode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2021-01-04T10:08:27.000Z</published>
    <updated>2021-01-05T12:21:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>斐波那契数，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><a id="more"></a><img src="/blog/2021/01/04/LeetCode509-斐波那契数/509.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这个算是动态规划的入门题目。给定 $F(0)$ 和 $F(1)$ 之后，后面的数都是前面两个数之和。比如 $F(2)=F(0)+F(1)$，$F(3)=F(1)+F(2)$…</p><p>基于此，其实已经告诉了我们状态转移方程：<br>$$<br>dp[i]=dp[i-1]+dp[i-2]\quad i\geq2<br>$$<br>当 $i=0,1$ 时，函数值已经给定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上只用三个变量就可以表示每种状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        <span class="keyword">int</span> fin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i - 2]</span></span><br><span class="line">        <span class="keyword">int</span> fir = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="keyword">int</span> sec = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fin = fir + sec;</span><br><span class="line">            fir = sec;</span><br><span class="line">            sec = fin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;斐波那契数，通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示，形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) = 0，F(1) = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(n) = F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;给你 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>内存管理（四）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2021-01-04T09:36:59.000Z</published>
    <updated>2021-01-10T15:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>基本分段存储管理方式</li><li>段页式管理方式</li></ol><a id="more"></a><h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><p>与分页存储管理方式区别为：离散分配时所分配地址空间的基本单位不同。</p><h5 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h5><p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系划分为若干个段，每个段都有一个段名，每段从0开始编址。</p><p>内存分配规则：以段位单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><img src="/blog/2021/01/04/内存管理（四）/分段-逻辑编程.png"><p>分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）组成：</p><img src="/blog/2021/01/04/内存管理（四）/分段逻辑地址.png"><ul><li>段号的位数决定每个进程最多可分几个段。</li><li>段内地址位数决定了每个段的最大长度是多少。</li></ul><h5 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h5><img src="/blog/2021/01/04/内存管理（四）/段表.png"><h5 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h5><img src="/blog/2021/01/04/内存管理（四）/地址变换.png"><p>④处与<strong>分页存储</strong>不同。</p><h5 id="分段、分页管理对比"><a href="#分段、分页管理对比" class="headerlink" title="分段、分页管理对比"></a>分段、分页管理对比</h5><h6 id="基本单位"><a href="#基本单位" class="headerlink" title="基本单位"></a>基本单位</h6><ul><li><strong>页是信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要,完全是系统行为，<strong>对用户是不可见的</strong>。</li><li><strong>段是信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li></ul><h6 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h6><ul><li>页的大小<strong>固定</strong>且由<strong>系统</strong>决定。</li><li>段的长度却<strong>不固定</strong>，决定于<strong>用户编写的程序</strong>。</li></ul><h6 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h6><ul><li>分页的用户进程地址空间是<strong>一维</strong>的，程序员只需给出一个记忆符即可表示一个地址。</li><li>分段的用户进程地址空间是<strong>二维</strong>的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li></ul><p>分段比分页<strong>更容易实现信息的共享和保护</strong>。不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（不属于临界资源），这样的代码可以共享，可修改的代码不可共享。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/04/内存管理（四）/分段存储管理小结.png" style="zoom:120%;"><h4 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h4><img src="/blog/2021/01/04/内存管理（四）/段页式管理方式.png" style="zoom:80%;"><h5 id="分页、分段优缺点分析"><a href="#分页、分段优缺点分析" class="headerlink" title="分页、分段优缺点分析"></a>分页、分段优缺点分析</h5><img src="/blog/2021/01/04/内存管理（四）/分页、分段优缺点分析.png"><h5 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h5><img src="/blog/2021/01/04/内存管理（四）/段页式管理.png"><p>将进程按逻辑模块分段，再将各段分页，再装入大小相同的内存块（页框/页帧/物理块）中。</p><h5 id="段页式管理的逻辑地址结构"><a href="#段页式管理的逻辑地址结构" class="headerlink" title="段页式管理的逻辑地址结构"></a>段页式管理的逻辑地址结构</h5><img src="/blog/2021/01/04/内存管理（四）/段页式管理的逻辑地址结构.png"><ul><li>段号的位数决定每个进程最多可分几个段。</li><li>页号位数决定了每个段最大有多少页。</li><li>页内偏移量决定了页面大小、内存块大小是多少。</li></ul><p><strong>分段</strong>对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将<strong>各段</strong>进行<strong>分页</strong>对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此段页式管理的地址结构是二维的。</p><h5 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h5><img src="/blog/2021/01/04/内存管理（四）/段表、页表.png"><p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，<strong>段号是隐含的</strong>。</p><p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，<strong>页号是隐含的</strong>。</p><img src="/blog/2021/01/04/内存管理（四）/段表、页表寻址.png"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/04/内存管理（四）/段页式管理方式小结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;基本分段存储管理方式&lt;/li&gt;
&lt;li&gt;段页式管理方式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分段存储" scheme="http://www.xingyuzhao.ltd/tags/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode86-分隔链表</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/03/LeetCode86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/03/LeetCode86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</id>
    <published>2021-01-03T10:06:47.000Z</published>
    <updated>2021-01-05T12:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个链表和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有小于 <code>x</code> 的节点都出现在大于或等于 <code>x</code> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><a id="more"></a><img src="/blog/2021/01/03/LeetCode86-分隔链表/86.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将链表一分为二，为小于 <code>x</code> 的部分和大于等于 <code>x</code> 的部分分别建立一个新链表，然后再将小链表的表尾连接至大链表的表头即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *dummyNodeSmall = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *dummyNodeLarge = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *small = dummyNodeSmall;</span><br><span class="line">        ListNode *large = dummyNodeLarge;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = head; iter != <span class="literal">nullptr</span>; iter = iter-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;val &lt; x)&#123;</span><br><span class="line">                small-&gt;next = iter;</span><br><span class="line">                small = small-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                large-&gt;next = iter;</span><br><span class="line">                large = large-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        large-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        small-&gt;next = dummyNodeLarge-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyNodeSmall-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/partition-list/solution/fen-ge-lian-biao-by-leetcode-solution-7ade/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-list/solution/fen-ge-lian-biao-by-leetcode-solution-7ade/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个链表和一个特定值 &lt;code&gt;x&lt;/code&gt; ，请你对链表进行分隔，使得所有小于 &lt;code&gt;x&lt;/code&gt; 的节点都出现在大于或等于 &lt;code&gt;x&lt;/code&gt; 的节点之前。&lt;/p&gt;
&lt;p&gt;你应当保留两个分区中每个节点的初始相对位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode239-滑动窗口的最大值</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/02/LeetCode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/02/LeetCode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2021-01-02T10:06:14.000Z</published>
    <updated>2021-01-05T12:44:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><a id="more"></a><img src="/blog/2021/01/02/LeetCode239-滑动窗口的最大值/239.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先使用优先队列存储 <code>nums</code> 的前 <code>k</code> 个值，队首就是第一个窗口最大的值。</p><p>接着从第 <code>k</code> 个位置开始，将序列入队，每次最大的值都出现在队首。但是<strong>当前的队首不一定是当前窗口中的元素</strong>，此时队列的长度可能大于 <code>k</code>。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = &#123;3,1,1&#125;, k = 2;</span><br><span class="line">1. &#123;3,1&#125; max = 3; // 队列中元素为3,1</span><br><span class="line">2. &#123;1,1&#125; max = 1; // 队列中元素为3,1,1，此时需要将3出队</span><br></pre></td></tr></table></figure><p>如果不是当前窗口中的元素，只有可能是上一个窗口中的最大值，它一定是在当前窗口左端点的左侧，就需要将队首出队，直到队首元素在当前窗口内。</p><p>所以优先队列需要同时存储当前序列的值和坐标。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            q.push(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans&#123;q.top().first&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            q.push(&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="comment">// 队首元素不在当前窗口内</span></span><br><span class="line">            <span class="keyword">while</span>(q.top().second &lt;= i - k)&#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，有一个大小为 &lt;code&gt;k&lt;/code&gt; 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 &lt;code&gt;k&lt;/code&gt; 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="优先队列" scheme="http://www.xingyuzhao.ltd/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode605-种花问题</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/01/LeetCode605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/01/LeetCode605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-01T10:05:37.000Z</published>
    <updated>2021-01-05T12:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组  <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>。</p><a id="more"></a><img src="/blog/2021/01/01/LeetCode605-种花问题/605.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>除了首尾位置，只要当前位置的前一个位置和下一个位置没有种花，那么当前位置就可以种花。</p><p>对于首尾位置，只有其相邻位置没有种花，在它的位置就可以种花。</p><p><strong>当前位置如果没有种花，才需要考虑上述问题</strong>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed.size() == <span class="number">1</span>) <span class="keyword">return</span> flowerbed[<span class="number">0</span>] == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i + <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == flowerbed.size() - <span class="number">1</span> &amp;&amp; flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != flowerbed.size() - <span class="number">1</span> &amp;&amp; flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>] != <span class="number">1</span> &amp;&amp; flowerbed[i + <span class="number">1</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。&lt;/p&gt;
&lt;p&gt;给你一个整数数组  &lt;code&gt;flowerbed&lt;/code&gt; 表示花坛，由若干 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 组成，其中 &lt;code&gt;0&lt;/code&gt; 表示没种植花，&lt;code&gt;1&lt;/code&gt; 表示种植了花。另有一个数 &lt;code&gt;n&lt;/code&gt; ，能否在不打破种植规则的情况下种入 &lt;code&gt;n&lt;/code&gt; 朵花？能则返回 &lt;code&gt;true&lt;/code&gt; ，不能则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode435-无重叠区间</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/31/LeetCode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/31/LeetCode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</id>
    <published>2020-12-31T02:10:32.000Z</published>
    <updated>2021-01-08T01:50:35.445Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意</strong>:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><a id="more"></a><img src="/blog/2020/12/31/LeetCode435-无重叠区间/435.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先对二维数组排序，对其中的每个一维数组，先按照元素的第一个升序排列，如果第一个元素相同，再按照第二个升序排列。</p><p>如此一来，为了使移除的区间数最小，那么就需要<strong>从重叠的区间中选出右端点最小的一个</strong>，那样就可以尽可能留下更多不重叠的空间（所以说只按照第二个元素升序排列也是可以的）。</p><p>排序后，如果前一个数组的第二个元素在第二个数组范围之内，就留下前一个数组，用它把第二个数组覆盖；如果前一个数组第二个元素大于第二个数组的后一个元素，那么留下第二个数组，不用进行覆盖，但是前一个数组是需要移除的。这两种情况下，都需要移除操作。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) -&gt; <span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v1[<span class="number">0</span>] == v2[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> v1[<span class="number">1</span>] &lt; v2[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// sort(intervals.begin(), intervals.end());</span></span><br><span class="line">        <span class="comment">// for(auto &amp;v1 : intervals)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;v2 : v1)</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; v2 &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>] &amp;&amp; intervals[i - <span class="number">1</span>][<span class="number">1</span>] &lt;= intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                intervals[i][<span class="number">0</span>] = intervals[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                intervals[i][<span class="number">1</span>] = intervals[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>] &amp;&amp; intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>C++ STL sort作用于二维vector 效果和应用：</p><p><a href="https://blog.csdn.net/y625658683/article/details/104154089" target="_blank" rel="noopener">https://blog.csdn.net/y625658683/article/details/104154089</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>对于二维数组，<code>sort</code>是把<code>vector&lt;int&gt;</code>作为一个一维数组对象，整体进行比较和排序。</p><p>默认比较两个<code>int</code>向量的规则是：</p><p>从第一个元素开始比，第一个元素小的，整个向量就小，如果第一个元素一样，再比较第二个，第二个元素小的，整个向量小，依此类推。<code>sort</code>默认按从小到大排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;可以认为区间的终点总是大于它的起点。&lt;br&gt;区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1046-最后一块石头的重量</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/30/LeetCode1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/30/LeetCode1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/</id>
    <published>2020-12-30T01:58:07.000Z</published>
    <updated>2020-12-30T02:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><p>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；<br>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p><a id="more"></a><h4 id="思路及代码"><a href="#思路及代码" class="headerlink" title="思路及代码"></a>思路及代码</h4><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p>每次寻找最大的两个石头重量进行碰撞，直到链表为空或只剩下一个元素：</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stones.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> stones.empty() ? <span class="number">0</span> : stones[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">li</span><span class="params">(stones.begin(), stones.end())</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!li.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> it1 = max_element(li.begin(), li.end());</span><br><span class="line">            <span class="keyword">int</span> val1 = *it1;</span><br><span class="line">            li.erase(it1);</span><br><span class="line">            <span class="keyword">auto</span> it2 = max_element(li.begin(), li.end());</span><br><span class="line">            <span class="keyword">int</span> val2 = *it2;</span><br><span class="line">            <span class="keyword">if</span>(val2 != val1)</span><br><span class="line">                *it2 = <span class="built_in">abs</span>(val1 - val2);</span><br><span class="line">            <span class="keyword">else</span> li.erase(it2);</span><br><span class="line">            <span class="keyword">if</span>(li.size() == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> li.empty() ? <span class="number">0</span> : *li.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><h6 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h6><p>大顶堆，每次前两个出队元素就是石头中重量最大的两个。</p><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; p_q(stones.begin(), stones.end());</span><br><span class="line">        <span class="keyword">while</span>(!p_q.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p_q.size() == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> v1 = p_q.top();</span><br><span class="line">            p_q.pop();</span><br><span class="line">            <span class="keyword">int</span> v2 = p_q.top();</span><br><span class="line">            p_q.pop();</span><br><span class="line">            <span class="keyword">int</span> v = <span class="built_in">abs</span>(v1 - v2);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="number">0</span>) p_q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p_q.empty() ? <span class="number">0</span> : p_q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;有一堆石头，每块石头的重量都是正整数。&lt;/p&gt;
&lt;p&gt;每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，且 &lt;code&gt;x &amp;lt;= y&lt;/code&gt;。那么粉碎的可能结果如下：&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;x == y&lt;/code&gt;，那么两块石头都会被完全粉碎；&lt;br&gt;如果 &lt;code&gt;x != y&lt;/code&gt;，那么重量为 &lt;code&gt;x&lt;/code&gt; 的石头将会完全粉碎，而重量为 &lt;code&gt;y&lt;/code&gt; 的石头新重量为 &lt;code&gt;y-x&lt;/code&gt;。&lt;br&gt;最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="优先队列" scheme="http://www.xingyuzhao.ltd/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode330-按要求补齐数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/29/LeetCode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/29/LeetCode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-12-29T02:51:41.000Z</published>
    <updated>2020-12-29T14:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 <code>[1, n]</code> 区间内选取任意个数字补充到 $nums$ 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><a id="more"></a><img src="/blog/2020/12/29/LeetCode330-按要求补齐数组/330.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果区间 $[1,x)$ 的所有数都被覆盖了：</p><ul><li>如果$nums[i]\in[1,x)$，那么区间 $[1+nums[i],x+nums[i])$ 中所有数也会被覆盖。由于 $nums[i]\geq1$ ，则此时 $x\in[1+nums[i],x+nums[i])$，覆盖区间可以更新为 $[1,x+nums[i])$。</li><li>如果 $nums[i]$ 恰好等于 $x$ ，那么覆盖区间变为 $[1,x+nums[i])$。不需要补充 $x$ 。</li><li>否则，补充 $x$ ，则区间 $[1,x]$ 全部覆盖；并且可以得到覆盖区间 $[1+x,x+x)=[x+1,2x)$。两者取交集得到此时覆盖数字区间 $[1,2x)$，此时覆盖的数字最多（如果取小于 $x$ 的数，覆盖区间会变小，这是不希望看到的， $x$ 不能取两次，每个数字只能取一次）。</li><li>当 $x&gt;n$ 时，就可以结束了。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始区间为空，表示已经覆盖</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; nums.size() &amp;&amp; nums[index] &lt; x)&#123;</span><br><span class="line">                x += nums[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; nums.size() &amp;&amp; nums[index] == x)&#123;</span><br><span class="line">                x += nums[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 &lt;code&gt;[1, n]&lt;/code&gt; 区间内选取任意个数字补充到 $nums$ 中，使得 &lt;code&gt;[1, n]&lt;/code&gt; 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode309-最佳买卖股票时机含冷冻期</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</id>
    <published>2020-12-28T13:43:28.000Z</published>
    <updated>2021-01-08T09:50:07.438Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组，其中第 $i$ 个元素代表了第 $i$ 天的股票价格 。</p><ul><li><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p></li><li><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p></li></ul><a id="more"></a><img src="/blog/2020/12/28/LeetCode309-最佳买卖股票时机含冷冻期/309.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题与其他股票问题不同之处在于<strong>卖出之后至少间隔一天才能够买入</strong>，可以多次买入卖出。</p><h5 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h5><p>$dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益。</p><p>$dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。</p><h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul><li><p>如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：<br>$$<br>dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])<br>$$</p></li><li><p>如果当天持有股票，那么前一天可以持有股票或者前两天未持有股票，当天买入（如果前一天持有且卖出股票，当天就不能买入了；前一天如果未持有且没有卖出股票，就与前两天未持有，当天买入等价了）：<br>$$<br>dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i])<br>$$</p></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。假设有第零天，那么收益应也为 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">-1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 用dp_0 = 0代替</span></span><br></pre></td></tr></table></figure><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp_0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], (i - <span class="number">2</span> &lt; <span class="number">0</span> ? dp_0 : dp[i - <span class="number">2</span>][<span class="number">0</span>]) - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h5><p>由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(profit1, profit - prices[i]);</span><br><span class="line">            profit = profit0;</span><br><span class="line">            profit0 = new0;</span><br><span class="line">            profit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">LeetCode121-买卖股票的最佳时机</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/">LeetCode122-买卖股票的最佳时机II</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/">LeetCode122-买卖股票的最佳时机III</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/">LeetCode122-买卖股票的最佳时机IV</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/">LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/">LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个整数数组，其中第 $i$ 个元素代表了第 $i$ 天的股票价格 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;br&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
