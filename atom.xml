<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2020-12-12T14:42:12.000Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存管理（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-12-12T09:46:39.000Z</published>
    <updated>2020-12-12T14:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>内存的基础知识</li><li>内存管理的概念</li><li>覆盖与交换</li></ol><a id="more"></a><h4 id="内存的基本知识"><a href="#内存的基本知识" class="headerlink" title="内存的基本知识"></a>内存的基本知识</h4><h5 id="什么是内存？有何作用？"><a href="#什么是内存？有何作用？" class="headerlink" title="什么是内存？有何作用？"></a>什么是内存？有何作用？</h5><p><strong>内存</strong>是用于存放数据的硬件。程序执行前<strong>需要先放到内存中才能被CPU处理。</strong></p><p>在多道程序环境下，系统中会有多个程序并发执行，会有多个程序的数据需要同时放到内存中。如何区分各个程序的数据在什么地方？——给内存的存储单元编地址。</p><p><strong>内存地址</strong>从0开始，每个地址对应一个存储单元。如果计算机按<strong>字节</strong>编址，则每个存储单元大小为1字节；如果<strong>字长为16位</strong>的计算机按<strong>字</strong>编址，则每个存储单元大小位1个字，也就是16个二进制位。</p><p>常用的几个数量单位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2^10 = 1K</span><br><span class="line">2^20 = 1M</span><br><span class="line">2^30 = 1G</span><br></pre></td></tr></table></figure><h5 id="逻辑地址与物理地址"><a href="#逻辑地址与物理地址" class="headerlink" title="逻辑地址与物理地址"></a>逻辑地址与物理地址</h5><p>编译时产生的指令只关心<strong>相对地址</strong>，实际放入内存中再想办法根据起始位置得到<strong>绝对地址</strong>。</p><p>eg：编译时只需确定变量x的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程<em>起始地址+100</em>即可。</p><p><strong>相对地址</strong>又称<strong>逻辑地址</strong>，<strong>绝对地址</strong>又称<strong>物理地址</strong>。</p><h5 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h5><img src="/blog/2020/12/12/内存管理（一）/程序的执行.png" style="zoom:120%;"><p>编译：由编译程序将用户源代码编译成若干个目标模块（高级语言-&gt;机器语言）。</p><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。</p><p>装入（装载）：由装入程序将装入模块装入内存运行。</p><h5 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h5><img src="/blog/2020/12/12/内存管理（一）/三种装入方式.png" style="zoom:120%;"><h6 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h6><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p>绝对装入<strong>只适用于单道程序环境</strong>。</p><p>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</p><h6 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h6><p>又称<strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址仅从<strong>重定位</strong>，将逻辑地址变换为物理地址（地址变换实在装入时一次完成的）。</p><p>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</p><h6 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h6><p>又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行。</strong>因此装入内存后所有的地址依然是逻辑地址，这种方式需要一个<strong>重定位寄存器支持</strong>。</p><img src="/blog/2020/12/12/内存管理（一）/重定位寄存器.png" style="zoom:120%;"><ul><li>采取动态重定位时<strong>允许程序在内存中发生移动</strong>；</li><li>可将程序分配到<strong>不连续</strong>的存储区中；</li><li>程序运行前只需装入部分代码即可投入运行；</li><li>运行期间根据需要动态申请分配内存。</li></ul><h5 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h5><h6 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h6><p>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</p><img src="/blog/2020/12/12/内存管理（一）/静态链接.png" style="zoom: 80%;"><h6 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h6><p>将各目标模块装入内存时，边装入边链接的链接方式。</p><img src="/blog/2020/12/12/内存管理（一）/装入时动态链接.png" style="zoom:85%;"><h6 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h6><p>在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p><img src="/blog/2020/12/12/内存管理（一）/运行时动态链接.png" style="zoom:90%;"><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/12/内存管理（一）/内存的基本知识小节.png" style="zoom:120%;"><h4 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h4><ol><li><p>操作系统负责<strong>内存空间的分配与回收</strong>。</p></li><li><p>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong>。</p></li><li><p>操作系统需要提供<strong>地址转换</strong>功能，负责程序的<strong>逻辑地址</strong>与<strong>物理地址</strong>的转换。</p></li><li><p>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰。</p></li></ol><p>内存保护的两种方法：</p><ol><li>在CPU中设置一对<strong>上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li><li>采用<strong>重定位寄存器（基址寄存器）</strong>和<strong>界地址寄存器（限长寄存器）</strong>进行越界检查。重定位寄存器存放进程的<strong>起始物理地址</strong>。界地址寄存器存放进程的<strong>最大逻辑地址</strong>。</li></ol><img src="/blog/2020/12/12/内存管理（一）/内存保护方法二.png" style="zoom:80%;"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/12/内存管理（一）/内存管理的概念.png" style="zoom:100%;"><h4 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h4><h5 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h5><p>引入<strong>覆盖技术</strong>，解决<strong>程序大小超过物理内存总和</strong>的问题。</p><p>覆盖技术的思想：将<strong>程序分为多个段（多个模块）</strong>。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为<strong>一个固定区</strong>和<strong>若干个覆盖区</strong>。</p><ul><li>需要常驻内存的段放在<strong>固定区</strong>中，<strong>调入后就不再调出（除非运行结束）</strong>。</li><li>不常用的段放在<strong>覆盖区</strong>，<strong>需要用到时调入内存，用不到时调出内存</strong>。</li></ul><img src="/blog/2020/12/12/内存管理（一）/覆盖技术.png" style="zoom:80%;"><p><em>必须由程序员声明覆盖结构</em>，操作系统完成自动覆盖。</p><p><strong>缺点</strong>：对用户不透明，增加了用户编程负担，已成为历史。</p><h5 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h5><p>交换技术的思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）。进行了中级调度（内存调度）：决定将哪个处于挂起状态的进程重新调入内存。</p><ol><li><p>应该在外存（磁盘）的什么位置保存被换出的进程？</p><p>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用<strong>离散分配</strong>方式；<strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用<strong>连续分配</strong>方式。总之，对换区的<code>I/O</code>速度比文件区的更快。</p></li><li><p>什么时候应该交换？</p><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p></li><li><p>应该换出哪些进程？</p><p>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。</p></li></ol><p><em>PCB会常驻内存</em>，不会被换成外存。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/12/内存管理（一）/覆盖与交换小结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;内存的基础知识&lt;/li&gt;
&lt;li&gt;内存管理的概念&lt;/li&gt;
&lt;li&gt;覆盖与交换&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode376-摆动序列</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/12/LeetCode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/12/LeetCode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</id>
    <published>2020-12-12T03:41:37.000Z</published>
    <updated>2020-12-12T04:06:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><a id="more"></a><img src="/blog/2020/12/12/LeetCode376-摆动序列/376.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以找每次的拐点进行计数，最后再加上首尾两个点即可，比如序列<code>[1,7,4,9,2,5]</code>，有4个拐点，加上首尾一共6个点：</p><img src="/blog/2020/12/12/LeetCode376-摆动序列/1.png" style="zoom:80%;"><p>需要考虑特殊情况：</p><ol><li>连续几个相同的数恰好都是拐点，如<code>[1,12,12,12,1]</code>：</li></ol><img src="/blog/2020/12/12/LeetCode376-摆动序列/2.png" style="zoom:80%;"><ol start="2"><li>输入的序列没有拐点且全部是同一个数，如<code>[1,1,1]</code>：</li></ol><img src="/blog/2020/12/12/LeetCode376-摆动序列/3.png" style="zoom:80%;"><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guaidian = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; nums[i] &amp;&amp; nums[i + <span class="number">1</span>] &gt; nums[i])&#123;</span><br><span class="line">                guaidian++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &lt; nums[i] &amp;&amp; nums[i + <span class="number">1</span>] &lt; nums[i])&#123;</span><br><span class="line">                guaidian++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这一步是为了去除相同的点，如果nums[i]与nums[i + 1]相同，</span></span><br><span class="line">            <span class="comment">// 那么就让nums[i]等于nums[i - 1]，</span></span><br><span class="line">            <span class="comment">// 可以保证nums[i + 1]与改变之后的nums[i]不同。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">1</span> &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">                nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(guaidian == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> f = unique(nums.begin(), nums.end());</span><br><span class="line">            <span class="comment">// 输入的序列全部都是同一个数</span></span><br><span class="line">            <span class="keyword">if</span>(f - <span class="number">1</span> == nums.begin())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> guaidian + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。&lt;/p&gt;
&lt;p&gt;例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。&lt;/p&gt;
&lt;p&gt;给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode649-Dota2参议院</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/11/LeetCode649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/11/LeetCode649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/</id>
    <published>2020-12-11T13:25:10.000Z</published>
    <updated>2020-12-12T14:53:25.845Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p><p>禁止一名参议员的权利：</p><p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p><p>宣布胜利：</p><p>如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</p><a id="more"></a><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。</p><img src="/blog/2020/12/11/LeetCode649-Dota2参议院/649.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>只想到了暴力法解决。首先记录<code>senate</code>中R和D出现次数，再用一个长与<code>senate</code>相同的<code>bool</code>数组来记录当前字母是否被<strong>消灭</strong>了，初始化都为0，代表没有被<strong>消灭</strong>。遍历<code>senate</code>，如果遇到了R，就从R开始找第一个D的位置，直到下一轮循环到它之前的位置；对于D也是一样。这样保证它们能行使自己的权力，除非自己的阵营已经获胜了。</p><p><strong>消灭的策略是：尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴。</strong></p><p>这样做的时间复杂度会很高，用时1452ms。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">predictPartyVictory</span><span class="params">(<span class="built_in">string</span> senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> D_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = senate.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">isUsed</span><span class="params">(senate.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : senate)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'R'</span>) R_cnt++;</span><br><span class="line">            <span class="keyword">else</span> D_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(R_cnt != <span class="number">0</span> &amp;&amp; D_cnt != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; senate.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isUsed[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(senate[i] == <span class="string">'R'</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> m = i + <span class="number">1</span>; m &lt; i + len; ++m)&#123;</span><br><span class="line">                        <span class="keyword">int</span> j = m % len;</span><br><span class="line">                        <span class="keyword">if</span>(senate[j] == <span class="string">'D'</span> &amp;&amp; isUsed[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                            isUsed[j] = <span class="literal">true</span>;</span><br><span class="line">                            D_cnt--;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> m = i + <span class="number">1</span>; m &lt; i + len; ++m)&#123;</span><br><span class="line">                        <span class="keyword">int</span> j = m % len;</span><br><span class="line">                        <span class="keyword">if</span>(senate[j] == <span class="string">'R'</span> &amp;&amp; isUsed[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                            isUsed[j] = <span class="literal">true</span>;</span><br><span class="line">                            R_cnt--;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(R_cnt == <span class="number">0</span> || D_cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R_cnt != <span class="number">0</span> ? <span class="string">"Radiant"</span> : <span class="string">"Dire"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>使用一个变量来记录当前参议员之前有几个对手，从而判断自己是否被消灭了。</p><p>这里使用<code>count&gt;0</code>表示<strong>R在D前面，R可以消灭D</strong>，用<code>count&lt;0</code>表示<strong>D在R前面，D可以消灭R</strong>。</p><p>执行用时：4ms。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">predictPartyVictory</span><span class="params">(<span class="built_in">string</span> senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> R = <span class="literal">true</span>, D = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(R &amp;&amp; D)&#123;</span><br><span class="line">            R = <span class="literal">false</span>;</span><br><span class="line">            D = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; senate.size(); ++i)&#123;</span><br><span class="line">                <span class="comment">// 如果没被完全消灭，本轮循环结束R和D都为true</span></span><br><span class="line">                <span class="keyword">if</span>(senate[i] == <span class="string">'R'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count &lt; <span class="number">0</span>) senate[i] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">else</span> R = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 如果被消灭了计数加一，代表抵挡了一次攻击</span></span><br><span class="line">                    <span class="comment">// 如果没有被消灭，代表有多了一次消灭敌方机会</span></span><br><span class="line">                    <span class="comment">// 无论如何都是需要++的，下面的--同</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(senate[i] == <span class="string">'D'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count &gt; <span class="number">0</span>) senate[i] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">else</span> D = <span class="literal">true</span>;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R != <span class="number">0</span> ? <span class="string">"Radiant"</span> : <span class="string">"Dire"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://leetcode-cn.com/problems/dota2-senate/solution/649-dota2-can-yi-yuan-tan-xin-suan-fa-ji-siha/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dota2-senate/solution/649-dota2-can-yi-yuan-tan-xin-suan-fa-ji-siha/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)&lt;/p&gt;
&lt;p&gt;Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：&lt;/p&gt;
&lt;p&gt;禁止一名参议员的权利：&lt;/p&gt;
&lt;p&gt;参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。&lt;/p&gt;
&lt;p&gt;宣布胜利：&lt;/p&gt;
&lt;p&gt;如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode860-柠檬水找零</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/10/LeetCode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/10/LeetCode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</id>
    <published>2020-12-10T03:09:50.000Z</published>
    <updated>2020-12-10T03:22:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><a id="more"></a><img src="/blog/2020/12/10/LeetCode860-柠檬水找零/860.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>每位顾客付款只有5、10、20美元的选项：</p><ul><li><p>收到5元时记录5元零钱的个数；</p></li><li><p>收到10元时需要找零5元并记录10元的个数；</p></li><li><p>收到20元需要找零15元，但不用记录20元个数，因为不会发生找零20元的情况。</p></li></ul><p><em>收到20元找零时应首先选10元零钱，10元用完后再选5元的。比如找零15元，如果只剩下两张5元，一张10元，先从5元开始无法刚好找零15（5+5+10）。</em></p><p><em>需要找零的总数必须大于等于当前用到的零钱的面值，详见代码。</em></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lemonadeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bills.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="built_in">map</span>[<span class="number">5</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;   </span><br><span class="line">                <span class="keyword">int</span> val = bills[i] - <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">10</span>; j &gt;= <span class="number">5</span>; j /= <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="comment">// 需要找零的总数必须大于等于当前用到的零钱的面值，val &gt;= j</span></span><br><span class="line">                    <span class="keyword">while</span>(<span class="built_in">map</span>[j] != <span class="number">0</span> &amp;&amp; val &gt; <span class="number">0</span> &amp;&amp; val &gt;= j)&#123;</span><br><span class="line">                        val -= j;</span><br><span class="line">                        <span class="built_in">map</span>[j]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(val == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(bills[i] &lt;= <span class="number">10</span>) <span class="built_in">map</span>[bills[i]]++;</span><br><span class="line">                <span class="keyword">if</span>(val != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 5 美元。&lt;/p&gt;
&lt;p&gt;顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。&lt;/p&gt;
&lt;p&gt;每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。&lt;/p&gt;
&lt;p&gt;注意，一开始你手头没有任何零钱。&lt;/p&gt;
&lt;p&gt;如果你能给每位顾客正确找零，返回 true ，否则返回 false 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode62-不同路径</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/09/LeetCode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/09/LeetCode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2020-12-09T01:49:46.000Z</published>
    <updated>2020-12-09T02:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p>与此类似：<a href="http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/">LeetCode-不同路径Ⅱ</a>，<a href="http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more">LeetCode97-交错字符串</a>，<a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">LeetCode174-地下城游戏</a>。</p><a id="more"></a><img src="/blog/2020/12/09/LeetCode62-不同路径/62.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>机器人只能往右或者往下，考虑动态规划（如果四个方向都可以走就不可以用动态规划了，得用DFS或者BFS），对于机器人所在的行和列，都只有一条路径可以到达，初始化为1。而除此之外的位置都是可以由其上边和其左边到达，以此类推得到可以到达最终位置的路径总数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;与此类似：&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/&quot;&gt;LeetCode-不同路径Ⅱ&lt;/a&gt;，&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more&quot;&gt;LeetCode97-交错字符串&lt;/a&gt;，&lt;a href=&quot;https://leetcode-cn.com/problems/dungeon-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode174-地下城游戏&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode842-将数组拆分成斐波那契序列</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/08/LeetCode842-%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/08/LeetCode842-%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/</id>
    <published>2020-12-08T10:10:01.000Z</published>
    <updated>2020-12-08T15:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p><p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p><ul><li>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）</li><li>F.length &gt;= 3；</li><li>对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。</li></ul><p><strong>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</strong></p><p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p><a id="more"></a><img src="/blog/2020/12/08/LeetCode842-将数组拆分成斐波那契序列/842.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>不断地截取字符串，看当前字符串对应的数能不能和之前的两个数构成斐波那契序列，如果可以就继续找下一个，不行的话就进行回退。截取完最后一个字符后，如果截取到的数字的个数大于等于3，则说明此数组可以拆分成斐波那契序列。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">splitIntoFibonacci</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">        backTrack(S, buf, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">string</span> &amp;S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;buf, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf.size() &gt;= <span class="number">3</span> &amp;&amp; index == S.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; S.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 不能以0开头</span></span><br><span class="line">            <span class="keyword">if</span>(S[index] == <span class="string">'0'</span> &amp;&amp; i &gt; index)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 取从index开始到i的字符串并转换为数字</span></span><br><span class="line">            <span class="built_in">string</span> s = S.substr(index, i - index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> num = stol(s, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 如果取出的数大于INT_MAX直接终止</span></span><br><span class="line">            <span class="keyword">if</span>(num &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> len = buf.size();</span><br><span class="line">            <span class="comment">// 如果截取的数字大于前两个数字之后，直接终止，因为后面只会越取越大</span></span><br><span class="line">            <span class="keyword">if</span>(len &gt;= <span class="number">2</span> &amp;&amp; num &gt; (<span class="keyword">long</span>)buf[len - <span class="number">1</span>] + (<span class="keyword">long</span>)buf[len - <span class="number">2</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 刚开始时buf里不到2个数时，将num加入buf中</span></span><br><span class="line">            <span class="comment">// 或者buf已经有2个及以上的数了，如果num等于buf的后两个数之和，加入buf中</span></span><br><span class="line">            <span class="keyword">if</span>(len &lt;= <span class="number">1</span> || num == (<span class="keyword">long</span>)buf[len - <span class="number">1</span>] + (<span class="keyword">long</span>)buf[len - <span class="number">2</span>])&#123;</span><br><span class="line">                buf.push_back(num);</span><br><span class="line">                <span class="keyword">if</span>(backTrack(S, buf, i + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 如果没找到，就将当前的num移除掉</span></span><br><span class="line">                buf.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。&lt;/p&gt;
&lt;p&gt;形式上，斐波那契式序列是一个非负整数列表 F，且满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt;= F[i] &amp;lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）&lt;/li&gt;
&lt;li&gt;F.length &amp;gt;= 3；&lt;/li&gt;
&lt;li&gt;对于所有的0 &amp;lt;= i &amp;lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯算法" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>进程管理（四）-死锁</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/07/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%AD%BB%E9%94%81/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/07/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%AD%BB%E9%94%81/</id>
    <published>2020-12-07T01:32:09.000Z</published>
    <updated>2020-12-08T02:54:12.667Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>死锁的概念</li><li>预防死锁</li><li>避免死锁</li><li>死锁的检测和解除</li></ol><a id="more"></a><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><h5 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h5><p>在并发的环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法推进的现象，就是<strong>死锁</strong>。发生死锁后若无外力干涉，这些进程都将无法向前推进。</p><h5 id="死锁、饥饿、死循环区别"><a href="#死锁、饥饿、死循环区别" class="headerlink" title="死锁、饥饿、死循环区别"></a>死锁、饥饿、死循环区别</h5><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁、饥饿、死循环区别.png" style="zoom:120%;"><h5 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h5><p>产生死锁必须同时满足以下四个条件：</p><ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放。</li><li>请求和保持条件：进程<strong>已经保持了至少一个资源</strong>，但又提出了新的资源要求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</li><li>循环等待条件：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p><em>注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁。</em></p><h5 id="什么时候会发生死锁？"><a href="#什么时候会发生死锁？" class="headerlink" title="什么时候会发生死锁？"></a>什么时候会发生死锁？</h5><ol><li>对系统资源的竞争。</li><li>进程推进顺序非法。</li><li>信号量的使用不当。</li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h5 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h5><ol><li>预防死锁：破坏死锁产生的四个必要条件中的一个。</li><li>避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。</li><li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁的概念.png" style="zoom:120%;"><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><h5 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h5><p>如果把只能互斥使用的资源改造成允许共享使用，则系统不会进入死锁状态。如：<code>SPOOLing</code>技术。</p><p>缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</p><h5 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h5><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。</p><p>缺点：</p><ol><li>实现复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法只适合已保存和恢复状态的资源，如CPU。</li><li>反复的申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，只要暂时得不到某个资源，之前获得的资源都要放弃，以后再重新申请。如果持续发生这种情况，会导致进程饥饿。</li></ol><h5 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h5><p>可以采用<strong>静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行后，资源归其所有，该进程就不会再请求别的资源了。</p><p>缺点：有些资源可能使用很短的时间，如果进程执行期间一直保持所有资源，就会造成严重的资源浪费，资源利用率极低。另外也可能导致某些进程饥饿。</p><h5 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h5><p>可采用<strong>顺序资源分配法</strong>，给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>，同类资源（即编号相同的资源）一次申请完。</p><p>原理：一个进程只有占有小编号的资源时才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p><p>缺点：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号。</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源的浪费。</li><li>必须按规定的次序申请资源，用户编程麻烦。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/预防死锁.png" style="zoom:120%;"><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>不破坏死锁的必要条件，而是在在资源动态分配的过程中，防止系统进入不安全状态。</p><h5 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h5><p>指系统能按某种推进顺序（P1,P2,…,Pn）为每个进程Pi分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称P1,P2,…,Pn为安全序列，若系统无法找到一个安全序列，则称系统处于不安全状态。</p><p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。</p><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>数据结构：</p><ul><li>长度为m的一维数组Avaliable表示还有多少可用资源。</li><li>n*m矩阵Max表示各进程对资源的最大需求数。</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源。</li><li>Max - Alllcation = Need 矩阵表示各进程最多还需要多少资源。</li><li>长度为m的一维数组Request表示进程此次申请的各种资源数。</li></ul><p>银行家算法步骤：</p><ol><li>检查此次申请是否超过了之前声明的最大需求数。</li><li>检查此时系统剩余的可用资源是否还能满足这次请求。</li><li>试探着分配，更改各数据结构。</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态。</li></ol><p>安全性算法步骤：</p><p>检查当前的剩余可用资源能否满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程只有的资源全部回收。</p><p>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><p><em>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。</em></p><p><strong>举例（后面更新）：</strong></p><h4 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h4><p>当可能发生死锁时，系统应当提供两个算法：</p><ol><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li></ol><h5 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h5><p>为了能对系统是否已发生了死锁进行检测，必须：</p><ol><li>用<strong>某种数据结构</strong>来保存资源的请求和分配信息。</li><li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁的检测.png" style="zoom:120%;"><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁的检测1.png" style="zoom:80%;"><p>检测死锁的算法：</p><ol><li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi (即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中己有空闲资源数景。如下图中，R1没有空闲资源，R2有 —个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中P1是满足这一条件的进程结点，于是将P1的所有边消去。</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁的检测2.png" style="zoom:80%;"><p><strong>死锁定理</strong>：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时系统死锁。</p><h5 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h5><p>—旦检测出死锁的发生，就应该立即解除死锁。<br>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程 。<br>解除死锁的主要方法有：</p><ol><li><p>资源剥夺法。挂起（哲时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</p></li><li><p>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能己经运行了很长时间，己经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</p></li><li><p>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程历史信息，设罝还原点。</p></li></ol><p>如何决定”对谁动手“？</p><ol><li>进程优先级：牺牲优先级低的。</li><li>已执行多长时间：牺牲执行时间短的。</li><li>还要多久完成：让快结束的优先获得资源。</li><li>进程已经使用了多少资源：拥有更多资源的先牺牲。</li><li>进程是交互式的还是批处理式的？：先牺牲批处理式的。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/总结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;死锁的概念&lt;/li&gt;
&lt;li&gt;预防死锁&lt;/li&gt;
&lt;li&gt;避免死锁&lt;/li&gt;
&lt;li&gt;死锁的检测和解除&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程管理（三）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/04/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/04/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-12-04T15:26:34.000Z</published>
    <updated>2020-12-06T05:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>进程同步、进程互斥</li><li>进程互斥软件/硬件实现方法</li><li>信号量机制及用其实现进程同步等</li><li>管程</li></ol><a id="more"></a><h4 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h4><h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><p>进程异步性：指各并发执行的进程以各自独立的、不可预知的速度向前推进。</p><p>进程同步：指为完成某种任务而建立的两个或多个进程，这些进程因为需要再某些位置上协调它们的工作次序而产生制约关系。</p><h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><p>临界资源：一个时间段内只允许一个进程使用的资源。如摄像头、打印机等。对临界资源的访问必须<strong>互斥</strong>的进行。</p><p>进程互斥：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。</p><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">entry section; <span class="comment">// 进入区</span></span><br><span class="line">    critical section; <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section; <span class="comment">// 退出区</span></span><br><span class="line">    remainder section;<span class="comment">// 剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ol><li>进入区：检查是否可以进入临界区，若可以进入，则设置正在访问临界资源的标志（上锁），防止其他进程同时进入临界区。</li><li>临界区：访问临界资源的代码。</li><li>退出区：解除正在访问临界资源的标志（解锁）。</li><li>剩余区：做其他处理。</li></ol><p><em>临界区时进程中访问临界资源的代码段。</em></p><p><em>进入区和退出区是负责实现互斥的代码段。</em></p><p>实现对临界资源的互斥访问需要遵循以下四项原则：</p><ol><li>空闲让进。</li><li>忙则等待。</li><li>有限等待，请求访问的进程在有限时间内进入临界区（保证不会饥饿）。</li><li>让权等待，进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><img src="/blog/2020/12/04/进程管理（三）/同步与互斥.png" style="zoom:120%;"><h4 id="进程互斥软件-硬件实现方法"><a href="#进程互斥软件-硬件实现方法" class="headerlink" title="进程互斥软件/硬件实现方法"></a>进程互斥软件/硬件实现方法</h4><h5 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h5><h6 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h6><p>实现思想：两个进程在<strong>访问完临界区后</strong>会把临界区的使用权转交给另一个进程，<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p><p>主要问题：违背<strong>空闲让进</strong>原则。</p><h6 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h6><p>实现思想：<strong>设置</strong>一个布尔型数组<code>flag[]</code>，数组中各个元素用来<strong>标记各进程想要进入临界区的意愿</strong>，比如<code>flag[0]=true</code>表示着0号进程P0想要进入临界区。每个进程在进入临界区之前先看有没有别的进程想要进入临界区，没有就将自身的<code>flag[i]</code>置为<code>true</code>，之后开始访问临界区。</p><p>主要问题：违反<strong>忙则等待</strong>原则。原因在于进入区的检查和上锁不是一气呵成的，在<strong>检查后，上锁前</strong>可能发生进程切换。</p><h6 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h6><p>实现思想：对比双标志先检查法，先进行上锁再进行检查。</p><p>主要问题：虽然解决了<strong>忙则等待</strong>，但是违背了<strong>空闲让进</strong>和<strong>有限等待</strong>原则，会因各进程都长期无法访问临界资源而产生<strong>饥饿</strong>现象。</p><h6 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h6><p>实现思想：对比双标志后检查法，如果双方都争着想进入临界区，可以让进程主动让对方先使用临界区。</p><p>主要问题：违背了<strong>让权等待</strong>原则。</p><img src="/blog/2020/12/04/进程管理（三）/进程互斥的软件实现方法.png" style="zoom:120%;"><h5 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h5><h6 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h6><p>实现思想：利用”开/关中断指令“实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">关中断；// 关中断后不允许当前进程被中断，也必然不会发生进程切换</span><br><span class="line">临界区；</span><br><span class="line">开中断；// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li>优点：简单、高效。</li><li>缺点：不适用于对处理机；只适用于操作系统内核进程，不适用于用户进程。</li></ul><h6 id="TestAndSet-TS指令-TSL指令"><a href="#TestAndSet-TS指令-TSL指令" class="headerlink" title="TestAndSet(TS指令/TSL指令)"></a>TestAndSet(TS指令/TSL指令)</h6><p>简称TS指令，也称TestAndSetLock指令，或TSL指令。</p><p>主要思想：使用硬件实现，将上锁和检查操作变为原子操作，执行过程中不允许被中断。</p><ul><li>优点：实现简单，适用于多处理机环境。</li><li>缺点：不满足<strong>让权等待</strong>原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。</li></ul><h6 id="Swap指令-XCHG指令"><a href="#Swap指令-XCHG指令" class="headerlink" title="Swap指令(XCHG指令)"></a>Swap指令(XCHG指令)</h6><p>也叫Exchange指令，或者XCHG指令。</p><p>逻辑上与TS指令相同。</p><img src="/blog/2020/12/04/进程管理（三）/进程互斥的硬件实现方法.png" style="zoom:120%;"><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量机制时一种功能较强的机制，可以用来解决互斥和同步问题，它只能被两个标准的原语<code>wait(S)</code>和<code>signal(S)</code>访问，简称<strong>P操作</strong>和<strong>V操作</strong>。</p><p>信号量其实就是一个变量，可以是一个整数，也可以是更复杂的记录型变量，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>。</p><h5 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h5><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S = <span class="number">1</span>; <span class="comment">// 表示当前系统中可用的打印机数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123; <span class="comment">// wait原语，相当于进入区</span></span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>); <span class="comment">// 资源不够，等待</span></span><br><span class="line">    S = S - <span class="number">1</span>; <span class="comment">// 资源够，占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123; <span class="comment">// signal原语，相当于退出区 </span></span><br><span class="line">    S = S + <span class="number">1</span>; <span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。</li><li><strong>检查</strong>和<strong>上锁</strong>一气呵成，避免并发、异步导致的问题。</li><li>存在问题：不满足<strong>让权等待</strong>原则，会发生<strong>忙等</strong>。</li></ol><h5 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h5><p>用记录型数据结构表示的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span><span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*某进程需要资源时，通过wait原语申请*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="comment">// 如果剩余资源不够，使用block原语使进程由运行态进入阻塞态</span></span><br><span class="line">    <span class="comment">// 并将其挂到信号量S的等待队列（即阻塞队列）中</span></span><br><span class="line">    <span class="comment">// 遵循了让权等待原则，不会出现忙等</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">block(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*进程使用完资源后，通过signal原语释放*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="comment">// 释放完资源后，若还有别的进程在等待这种资源</span></span><br><span class="line">    <span class="comment">// 则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="用信号量机制实现进程互斥、同步、前驱关系"><a href="#用信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量机制实现进程互斥、同步、前驱关系"></a>用信号量机制实现进程互斥、同步、前驱关系</h5><h6 id="进程互斥-1"><a href="#进程互斥-1" class="headerlink" title="进程互斥"></a>进程互斥</h6><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）。</li><li>设置<strong>互斥信号量</strong>mutex，<strong>初始值为1</strong>。</li><li>在临界区之前执行P(mutex)。</li><li>在临界区之后执行V(mutex)。</li></ol><p><em>注意：对不同的临界资源需要设置不同的互斥信号量，P、V操作必须成对出现</em>。</p><h6 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h6><ol><li>分析什么地方需要实现”同步关系“，即必须保证”一前一后“执行的两个操作（或两句代码）。</li><li>设置<strong>同步信号量</strong>S，<strong>初始值为0</strong>。</li><li>在”前操作”之后执行V(S)。</li><li>在”后操作“之前执行P(S)。</li></ol><h6 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h6><p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后操作）。</p><ol><li>要为每一对前驱关系各设置一个同步变量。</li><li>在”前操作“之后对相应的同步变量执行V操作。</li><li>在”后操作“之前对相应的同步变量执行P操作。</li></ol><img src="/blog/2020/12/04/进程管理（三）/信号量实现同步与互斥.png" style="zoom:120%;"><p>常见的使用场景</p><ul><li>生产者消费者问题</li><li>多生产者—多消费者模型</li><li>吸烟者问题</li><li>读者—写者问题</li><li>哲学家进餐问题</li></ul><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>引入管程的原因：信号量机制编写程序困难，易出错而导致死锁。</p><p>管程是一种特殊的软件模块，由这些部分组成：</p><ol><li>局部于管程的共享数据结构说明。</li><li>对该数据结构进行操作的一组过程（或函数）。</li><li>对局部于管程的共享数据设置的一组过程。</li><li>管程的名称。</li></ol><p>基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问。</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据。</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程，即同一时刻只有一个进程在管程内执行某个函数。</strong></li></ol><img src="/blog/2020/12/04/进程管理（三）/管程.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;进程同步、进程互斥&lt;/li&gt;
&lt;li&gt;进程互斥软件/硬件实现方法&lt;/li&gt;
&lt;li&gt;信号量机制及用其实现进程同步等&lt;/li&gt;
&lt;li&gt;管程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++顺序容器</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/25/C-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/25/C-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2020-11-25T13:17:11.000Z</published>
    <updated>2020-11-28T14:39:06.851Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>顺序容器概述</li><li>容器库概览</li><li>顺序容器操作</li><li><code>vector</code>对象是如何增长的</li><li>额外的<code>string</code>操作</li><li>容器适配器</li></ol><a id="more"></a><h4 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h4><img src="/blog/2020/11/25/C-顺序容器/概述.png" style="zoom:120%;"><p>选择容器的基本原则：</p><ul><li>尽量使用<code>vector</code>。</li><li>要求随机访问元素，使用<code>vector</code>或者<code>deque</code>。</li><li>要求在中间插入或删除元素，使用<code>list</code>或者<code>forward_list</code>。</li><li>要求在首尾插入或删除元素且不会在中间插入或者删除，使用<code>deque</code>。</li><li>如果程序要读取输入，且必须在中间插入，使用<code>list</code>，随后拷贝到<code>vector</code>。</li></ul><h4 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h4><img src="/blog/2020/11/25/C-顺序容器/容器操作.png" style="zoom:120%;"><img src="/blog/2020/11/25/C-顺序容器/容器操作1.png" style="zoom:120%;"><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p><code>forward_list</code>迭代器不支持递减运算符。</p><h6 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h6><p><strong>左闭合区间</strong>：<code>[begin, end)</code>，表示范围自<code>begin</code>开始，于<code>end</code>之前结束。</p><ul><li>如果<code>begin</code>与<code>end</code>相等，则范围为空。</li><li>如果<code>begin</code>与<code>end</code>不等，则范围至少包含一个元素，且<code>begin</code>指向该范围中的第一个元素。</li><li>可以对<code>begin</code>递增若干次，使得<code>begin==end</code>。</li></ul><h5 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::difference_type count</span><br></pre></td></tr></table></figure><h5 id="begin与end成员"><a href="#begin与end成员" class="headerlink" title="begin与end成员"></a>begin与end成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; a = &#123;<span class="string">"abc"</span>, <span class="string">"bcd"</span>, <span class="string">"cde"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.begin(); <span class="comment">// list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.rbegin(); <span class="comment">// list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.cbegin(); <span class="comment">// list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.crbegin(); <span class="comment">// list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure><h5 id="容器定义及初始化"><a href="#容器定义及初始化" class="headerlink" title="容器定义及初始化"></a>容器定义及初始化</h5><img src="/blog/2020/11/25/C-顺序容器/初始化.png" style="zoom:120%;"><p><strong>array的使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia1; <span class="comment">// 10个默认初始化的int</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia3 = &#123;<span class="number">42</span>&#125;; <span class="comment">// ia3[0]为42， 其余为0</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia4 = &#123;&#125;; <span class="comment">// 初始化为0</span></span><br></pre></td></tr></table></figure><h5 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h5><img src="/blog/2020/11/25/C-顺序容器/assign.png" style="zoom:120%;"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assign第一种用法</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle; <span class="comment">// 错误，容器类型不匹配</span></span><br><span class="line"><span class="comment">// 正确，可以将const char*转为string</span></span><br><span class="line">names.assign(oldstyle.cbegin(), oldstyle.cend()); </span><br><span class="line"><span class="comment">// assign的第二种用法</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist1</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 1个元素，为空string</span></span><br><span class="line">slist1.assign(<span class="number">10</span>, <span class="string">"Hiya!"</span>); <span class="comment">// 10个元素，每个都是"Hiya"</span></span><br></pre></td></tr></table></figure><h6 id="使用swap"><a href="#使用swap" class="headerlink" title="使用swap"></a>使用swap</h6><p>swap操作交换两个相同类型容器的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line">swap(svec1, svec2);</span><br><span class="line"><span class="comment">// 元素本身并未交换，swap只是交换了两个容器的内部数据结构</span></span><br></pre></td></tr></table></figure><p><strong>除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间完成</strong>。<strong>对array会真正交换它们的元素</strong>。</p><h5 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h5><p><code>size</code>：返回容器中元素数目。</p><p><code>empty</code>：容器是否为空。</p><p><code>max_size</code>：返回一个大于或等于该类型容器所能容纳的最大元素数的值。</p><p>注：<code>forward_list</code>不支持<code>size</code>。</p><h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">// v1 &lt; v2 true，在v1[2] &lt; v2[2]</span></span><br><span class="line"><span class="comment">// v1 &lt; v3 false，所有元素相等，但是v3元素更少</span></span><br><span class="line"><span class="comment">// v1 == v4 true，元素对应相等且长度相同</span></span><br><span class="line"><span class="comment">// v1 == v2 false，v2元素比v1少</span></span><br></pre></td></tr></table></figure><h4 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h4><img src="/blog/2020/11/25/C-顺序容器/添加元素.png" style="zoom:120%;"><h5 id="使用emplace操作"><a href="#使用emplace操作" class="headerlink" title="使用emplace操作"></a>使用emplace操作</h5><p>当调用一个<code>emplace</code>成员函数时，将参数传递给元素类型的构造函数。<code>emplace</code>成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.emplace_back(<span class="string">"978-0590353403"</span>, <span class="number">24</span>, <span class="number">15.99</span>);</span><br><span class="line">c.push_back(Sales_data(<span class="string">"978-0590353403"</span>, <span class="number">24</span>, <span class="number">15.99</span>));</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">c.push_back(<span class="string">"978-0590353403"</span>, <span class="number">24</span>, <span class="number">15.99</span>);</span><br></pre></td></tr></table></figure><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><img src="/blog/2020/11/25/C-顺序容器/访问元素.png" style="zoom:120%;"><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><img src="/blog/2020/11/25/C-顺序容器/删除元素.png" style="zoom:120%;"><h5 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h5><img src="/blog/2020/11/25/C-顺序容器/改变容器大小.png" style="zoom:120%;"><h5 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h5><p>向容器中添加/删除元素可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。</p><p>在向容器添加元素后：</p><ul><li>容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但插入位置之后的迭代器、指针和引用将会失效。</li><li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，指向存在元素的引用和指针不会失效。</li><li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器、指针和引用仍有效。</li></ul><p>删除元素时，指向被删除元素的迭代器、指针和引用都会失效。</p><ul><li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针都有效。</li><li>对于<code>deque</code>，在首尾之外的任何位置删除元素，指向被删除元素外其他元素的迭代器、指针或引用也会失效。删除尾，尾后迭代器会失效，但其他迭代器、引用和指针不受影响；删除首，也不受影响。</li><li>对于<code>vector</code>和<code>string</code>，指向被删元素之前元素的迭代器、引用和指针仍有效。</li></ul><p><em>注意：当我们删除元素时，尾后迭代器总会失效</em>。</p><h4 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h4><p><code>vector</code>会分配比新的空间需求更大的内存空间，作为备用。</p><h5 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h5><img src="/blog/2020/11/25/C-顺序容器/管理vector.png" style="zoom:120%;"><p><em><code>reserve</code>不改变容器中元素的数量，只影响<code>vector</code>预先分配多大的内存空间。</em></p><h4 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h4><img src="/blog/2020/11/25/C-顺序容器/额外string.png" style="zoom:120%;"><p>这些构造函数接受一个<code>string</code>或一个<code>const char*</code>参数，还接受（可选的）指定拷贝多少个字符的参数。</p><p>从<code>const char*</code>创建<code>string</code>时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。且：</p><ul><li>如果同时传一个计数值，就不必以空字符结尾。</li><li>如果未传递计数值且数组未以空字符结尾，或者计数值大于数组大小，则构造函数未定义。</li></ul><p>从<code>string</code>拷贝时，可选开始位置和计数值。位置大于<code>size</code>，构造函数抛出一个<em>out of range</em>异常。计数值代表从当前位置拷贝这么多个字符，最多拷贝到<code>string</code>结尾。</p><h5 id="sbustr"><a href="#sbustr" class="headerlink" title="sbustr"></a>sbustr</h5><img src="/blog/2020/11/25/C-顺序容器/substr.png" style="zoom:120%;"><h5 id="aapend和replace"><a href="#aapend和replace" class="headerlink" title="aapend和replace"></a>aapend和replace</h5><ol><li><code>append</code>操作是在<code>string</code>末尾进行插入操作的一种简写形式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.append(<span class="string">"123abc"</span>); <span class="comment">// 将"123abc"追加在s之后</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>replace</code>操作是调用<code>erase</code>和<code>insert</code>的一种简写形式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.erase(<span class="number">11</span>, <span class="number">3</span>);</span><br><span class="line">s.insert(<span class="number">11</span>, <span class="string">"5th"</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">s.replace(<span class="number">11</span>, <span class="number">3</span>, <span class="string">"5th"</span>);</span><br></pre></td></tr></table></figure><p>还有<code>assign</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.assign(arg); <span class="comment">// 将s中字符替换未arg，返回指向s的引用</span></span><br></pre></td></tr></table></figure><p><code>assign</code>总是替换<code>string</code>中所有内容。</p><h5 id="string的搜索操作"><a href="#string的搜索操作" class="headerlink" title="string的搜索操作"></a>string的搜索操作</h5><img src="/blog/2020/11/25/C-顺序容器/string_find.png" style="zoom:120%;"><img src="/blog/2020/11/25/C-顺序容器/string_find_form.png" style="zoom:120%;"><p><em><code>string</code>搜索返回<code>string::size_type</code>类型，是无符号的，因此用<code>int</code>表示不是很好的选择。</em></p><h5 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h5><img src="/blog/2020/11/25/C-顺序容器/compare.png" style="zoom:120%;"><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"pi = 3.14"</span>;</span><br><span class="line"><span class="comment">// 转换s中以数字开始的第一个字串，d=3.14</span></span><br><span class="line">d = stod(s.substr(s.find_first_of(<span class="string">"+-.0123456789"</span>)));</span><br></pre></td></tr></table></figure><p><em>如果<code>string</code>不能转换为数值，抛出<code>invalid_argument</code>异常。如果转换的数值无法用任何类型表示，则抛出一个<code>out_of_range</code>异常</em>。</p><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p><strong>适配器</strong>是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。比如：<code>stack</code>、<code>queue</code>、<code>priority_queue</code>。</p><img src="/blog/2020/11/25/C-顺序容器/容器适配器.png" style="zoom:120%;"><p>每个适配器都定义了两个构造函数：</p><ol><li>默认构造函数创建一个空对象，接受一个容器的构造函数拷贝来初始化适配器。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定dep使一个deque&lt;int&gt;</span></span><br><span class="line"><span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stk</span><span class="params">(dep)</span></span>; <span class="comment">// 从deq拷贝元素到stk</span></span><br></pre></td></tr></table></figure><ol start="2"><li>默认情况下，<code>stack</code>和<code>queue</code>基于<code>deque</code>实现，<code>priority_deque</code>基于<code>vector</code>。创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于vector实现空栈</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">// str_stk2在vector上实现，初始化时保存svec的拷贝</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec);</span><br></pre></td></tr></table></figure><h5 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h5><p><code>stack</code>类型定义在<code>stack</code>头文件中。</p><img src="/blog/2020/11/25/C-顺序容器/stack.png" style="zoom:120%;"><h5 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h5><p><code>queue</code>和<code>priority_queue</code>适配器定义在<code>queue</code>头文件中。</p><img src="/blog/2020/11/25/C-顺序容器/queue.png" style="zoom:120%;"><img src="/blog/2020/11/25/C-顺序容器/queue1.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;顺序容器概述&lt;/li&gt;
&lt;li&gt;容器库概览&lt;/li&gt;
&lt;li&gt;顺序容器操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;对象是如何增长的&lt;/li&gt;
&lt;li&gt;额外的&lt;code&gt;string&lt;/code&gt;操作&lt;/li&gt;
&lt;li&gt;容器适配器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode148-排序链表</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-11-22T02:27:25.000Z</published>
    <updated>2020-11-22T03:16:08.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p><strong>进阶</strong>：</p><p>你可以在<code>O(nlogn)</code>时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p>本题可与<a href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more">LeetCode147-对链表进行插入排序</a>，<a href="http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/">LeetCode143-重排链表</a>共同学习。</p><a id="more"></a><img src="/blog/2020/11/22/LeetCode148-排序链表/示例.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目要求用<code>O(nlogn)</code>的时间复杂度来进行排序，所以不能用<a href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more">LeetCode147-对链表进行插入排序</a>的方法来进行解，所以采用归并排序的思想对链表进行排序。</p><p>使用归并排序首先得找到链表的中间节点，找到中间节点，根据中间节点的位置将链表分为两个部分，再进行归并排序。<strong>中间节点在链表前半部分的末尾，将链表拆开后，要让中间节点的下一个指向空</strong>，再分别对两个链表进行归并排序，最后再合并两个排序好的链表，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode* __mergeSort(ListNode *node)&#123;</span><br><span class="line">    <span class="comment">// 如果节点为空或只有一个节点，返回当前节点即可</span></span><br><span class="line">    <span class="keyword">if</span>(!node || !node-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    ListNode *fast = node;</span><br><span class="line">    ListNode *slow = node;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *l2 = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* left = __mergeSort(node);</span><br><span class="line">    ListNode* right = __mergeSort(l2);</span><br><span class="line">    <span class="keyword">return</span> __merge(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并的操作需要创建一个新的链表，新的链表根据两个链表的值建立。如果<code>l1</code>的值小于<code>l2</code>，那么将<code>l1</code>插入新的链表中，同时<code>l1</code>移动到它的下一个节点；否则将<code>l2</code>插入新的链表中，同时<code>l2</code>移动到它的下一个节点。插入操作结束后，再将新链表向后移动一个节点（也就是新插入的节点）。<strong>如果两个链表长度不一样（两个链表长度最多差一个），还要判断插入操作结束后哪个链表不为空，如果不为空，它就是新链表的最后一个节点</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ListNode* __merge(ListNode *l1, ListNode *l2)&#123;</span><br><span class="line">    ListNode *dummyNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode *cur = dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; l2-&gt;val;</span></span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = l1 != <span class="literal">nullptr</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __mergeSort(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其余两个函数</span></span><br><span class="line">ListNode* __mergeSort(ListNode *node);</span><br><span class="line">ListNode* __merge(ListNode *l1, ListNode *l2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;你可以在&lt;code&gt;O(nlogn)&lt;/code&gt;时间复杂度和常数级空间复杂度下，对链表进行排序吗？&lt;/p&gt;
&lt;p&gt;本题可与&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more&quot;&gt;LeetCode147-对链表进行插入排序&lt;/a&gt;，&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/&quot;&gt;LeetCode143-重排链表&lt;/a&gt;共同学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="归并排序" scheme="http://www.xingyuzhao.ltd/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode147-对链表进行插入排序</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2020-11-21T14:42:04.000Z</published>
    <updated>2020-11-22T03:19:14.774Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>插入排序算法：</p><ol><li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li><li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li><li>重复直到所有输入数据插入完为止。</li></ol><p>本题可与<a href="http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/">LeetCode143-重排链表</a>，<a href="http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">LeetCode148-排序链表</a>共同学习。</p><a id="more"></a><img src="/blog/2020/11/21/LeetCode147-对链表进行插入排序/description.png" style="zoom:80%;"><img src="/blog/2020/11/21/LeetCode147-对链表进行插入排序/示例.png" style="zoom:100%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，使用一个指针记录下一个要进行排序的节点；对于当前节点，从头开始寻找插入位置，然后将当前节点插入。</p><p>那么需要保存插入位置的前一个节点和后一个节点，从头开始，如果当前节点的值大于后一个节点，那么同时将两个节点后移，否则直接进行插入即可。</p><p>最后再将当前节点更新为下一个要进行排序的节点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            ListNode *next = node-&gt;next;</span><br><span class="line">            <span class="comment">// 对排好序的链表进行插入</span></span><br><span class="line">            ListNode *pre = dummyNode;</span><br><span class="line">            ListNode *sorted = dummyNode-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(sorted)&#123;</span><br><span class="line">                <span class="comment">// 当前点大于后一个点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;val &gt; sorted-&gt;val)&#123;</span><br><span class="line">                    pre = sorted;</span><br><span class="line">                    sorted = sorted-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时当前点小于等于最后一个点，可以进行插入</span></span><br><span class="line">            <span class="comment">// 此时sorted之前的点都已经排好序了</span></span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            node-&gt;next = sorted;</span><br><span class="line"></span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;插入排序算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。&lt;/li&gt;
&lt;li&gt;每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。&lt;/li&gt;
&lt;li&gt;重复直到所有输入数据插入完为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本题可与&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/&quot;&gt;LeetCode143-重排链表&lt;/a&gt;，&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/&quot;&gt;LeetCode148-排序链表&lt;/a&gt;共同学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="插入排序" scheme="http://www.xingyuzhao.ltd/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库-I/O库</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/21/C-%E6%A0%87%E5%87%86%E5%BA%93-I-O%E5%BA%93/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/21/C-%E6%A0%87%E5%87%86%E5%BA%93-I-O%E5%BA%93/</id>
    <published>2020-11-21T12:35:33.000Z</published>
    <updated>2020-11-21T14:30:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>I/O类</li><li>文件输入输出</li><li>string流</li></ol><a id="more"></a><h4 id="I-O类"><a href="#I-O类" class="headerlink" title="I/O类"></a>I/O类</h4><p><code>iostream</code>定义了用于读写流的基本类型。</p><p><code>fstream</code>定义了用于读写命名文件的类型。</p><p><code>sstream</code>定义了用于读写内存<code>string</code>对象的类型。</p><img src="/blog/2020/11/21/C-标准库-I-O库/io类.png" style="zoom:120%;"><p><code>I/O</code>对象无拷贝或赋值，传递和引用不能是<code>const</code>的。</p><h5 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h5><img src="/blog/2020/11/21/C-标准库-I-O库/条件状态.png" style="zoom:120%;"><p>上表是<code>I/O</code>类所定义的一些函数和标志，可以访问和操作流的<strong>条件状态</strong>。</p><p>由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态最简单的方法是将它当作一个条件使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line"><span class="comment">// ok：读操作成功</span></span><br></pre></td></tr></table></figure><h5 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出hi和换行，然后刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; flush; <span class="comment">// 输出hi后直接刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; ends;  <span class="comment">// 输出hi和一个空字符再刷新缓冲区</span></span><br></pre></td></tr></table></figure><h4 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h4><p>头文件<code>fstream</code>定义了三个类型来支持文件IO：</p><ol><li><strong>ifstream</strong>从一个给定文件读取数据。</li><li><strong>ofstream</strong>向一个给定文件写入数据。</li><li><strong>fstream</strong>可以读写给定文件。</li></ol><img src="/blog/2020/11/21/C-标准库-I-O库/fstream.png" style="zoom:120%;"><h5 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h5><p>创建文件流对象时，可以提供文件名（可选）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">// 构造一个ifstream并打开给定文件</span></span><br><span class="line">ofstream out; <span class="comment">// 输出文件流未关联到任何文件</span></span><br></pre></td></tr></table></figure><h5 id="成员函数open和close"><a href="#成员函数open和close" class="headerlink" title="成员函数open和close"></a>成员函数open和close</h5><p>open用来判断文件是否打开成功，一旦打开成功，它就保持与对应文件的关联，对于一个已经打开的文件流调用open会失败，直到使用close关闭文件，成功关闭后可以打开新的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;</span><br><span class="line">in.close();</span><br><span class="line">in.open(ifile + <span class="string">"2"</span>);</span><br></pre></td></tr></table></figure><p>当一个<code>fstream</code>对象离开其作用域时，与之关联的文件会自动关闭。</p><h5 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h5><img src="/blog/2020/11/21/C-标准库-I-O库/文件模式.png" style="zoom:120%;"><p>指定文件模式有如下限制（部分）：</p><ul><li>只可以对<code>ofstream/fstream</code>对象设定out模式。</li><li>只可以对<code>ifstream/fstream</code>对象设定in模式。</li></ul><p>在未指定文件模式时，与<code>ifstream</code>关联的文件默认以in模式打开；与<code>ofstream</code>关联的文件默认以out模式打开；与<code>fstream</code>关联的文件默认以in和out模式打开。</p><p>默认情况下，<strong>以out模式打开文件会丢去已有数据</strong>。阻止一个<code>ofstream</code>清空给定文件内容的方法是同时指定app模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这几条语句中，file1都被截断</span></span><br><span class="line"><span class="comment">// 隐含以输出模式打开文件并截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file1"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 隐含地截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out1</span><span class="params">(<span class="string">"file1"</span>, ofstream::out)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">"flie2"</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">// 为了保留文本内容，必须显示指定app模式</span></span><br><span class="line"><span class="comment">// 隐含为输出模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file1"</span>, ofstream::app)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">app1</span><span class="params">(<span class="string">"file2"</span>, ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure><p><em>保留被<code>ofstream</code>打开地文件中已有数据地唯一方法是显示指定app或in模式（17.5.3节，676页）</em>。每次调用<code>open</code>时都会确定文件模式。</p><h4 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h4><p><code>istringstream</code>从<code>string</code>中读取数据。</p><p><code>ostringstream</code>向<code>string</code>中写入数据。</p><p><code>stringstream</code>既可从<code>string</code>中读数据也可以向<code>string</code>中写数据。</p><img src="/blog/2020/11/21/C-标准库-I-O库/stringstream.png" style="zoom:120%;"><h5 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h5><p>当我们的工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词，通常可以用<code>istringstream</code>。</p><p>假如一个文件，列出了一些人和他们所拥有的电话号码（一个或多个），输入文件可能如下：</p><img src="/blog/2020/11/21/C-标准库-I-O库/输入文件.png"><p>定义一个类描述输入数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; phones;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用程序读取数据文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line, word; <span class="comment">// 分别保存来自输入的一行和单词</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PersonInfo&gt; people;</span><br><span class="line"><span class="comment">// 逐行从输入读取数据，直到cin遇到文件尾（或其他错误）</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))&#123;</span><br><span class="line">PersonInfo info;</span><br><span class="line">    <span class="comment">// 将记录绑定到刚输入的行</span></span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">    record &gt;&gt; info.name;</span><br><span class="line">    <span class="keyword">while</span>(record &gt;&gt; word)</span><br><span class="line">        info.phones.push_back(word);</span><br><span class="line">    people.push_back(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h5><p>当我们逐步构造输出，最后一起进行打印时，可以使用ostringstream。对上一节的例子，逐个验证电话号码并将其格式化。将有效的号码输出到一个新文件中；对于无效的号码不输出到文件中，并打印一条包含人名和无效号码的错误信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;entry : people)&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> formatted, badNums;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nums : entry.phones)&#123;</span><br><span class="line">        <span class="comment">// 如果号码无效，将数的字符串写入badNums</span></span><br><span class="line">        <span class="keyword">if</span>(!valid(nums))&#123;</span><br><span class="line">            badnums &lt;&lt; <span class="string">" "</span> &lt;&lt; nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 号码有效，将格式化的字符串写入formatted</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            formatted &lt;&lt; <span class="string">" "</span> format(nums);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有错误的数，打印名字和格式化的数</span></span><br><span class="line">    <span class="keyword">if</span>(badNums.str().empty())</span><br><span class="line">        os &lt;&lt; entry.name &lt;&lt; <span class="string">" "</span> &lt;&lt; formatted.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 否则，打印名字和错误的数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"input error:"</span> &lt;&lt; entry.name  </span><br><span class="line">        &lt;&lt; <span class="string">"invalid number(s)"</span> &lt;&lt; badNums.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设两个函数<code>valid</code>和<code>format</code>已知，分别完成电话号码的验证和格式化功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;I/O类&lt;/li&gt;
&lt;li&gt;文件输入输出&lt;/li&gt;
&lt;li&gt;string流&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>进程管理（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/17/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/17/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-11-17T14:24:00.000Z</published>
    <updated>2020-11-21T16:13:45.524Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>处理机调度概念、层次</li><li>进程调度的时机/切换与过程/方式</li><li>调度算法的评价指标</li><li>非交互性调度算法</li><li>交互性调度算法</li></ol><a id="more"></a><h4 id="处理机调度概念、层次"><a href="#处理机调度概念、层次" class="headerlink" title="处理机调度概念、层次"></a>处理机调度概念、层次</h4><p><strong>处理机调度</strong>是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理及分配给它运行，以实现进程并发的执行。</p><p><strong>调度的三个层次</strong></p><ol><li><p>高级调度（作业调度）</p><ul><li>按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使他（们）获得竞争处理机的权利。</li><li><strong>作业调入一次（建立PCB），调出一次（撤销PCB）。</strong></li><li>高级调度主要是指调入的问题，只有调入的时机需要操作系统来确定，调出必然是作业结束时刻。</li><li>执行频率低。</li></ul></li><li><p>中级调度（内存调度）</p><ul><li><p>引入虚拟存储技术后，可将在暂时不能运行的进程调至外存等待，此时状态称为<strong>挂起态。</strong></p></li><li><p>PCB不会调到外存，而是常驻内存，被挂起的进程PCB会被放到挂起队列中。</p></li><li><p>中级调度就是决定将哪个处于挂起态的进程重新调入内存。</p></li><li><p>一个进程可能会被多次调出、调入内存，中级调度频率高于高级调度。</p></li><li><p>进程的挂起态与七状态模型。</p></li></ul><img src="/blog/2020/11/17/进程管理（二）/7states.png"></li><li><p>低级调度（进程调度）</p><ul><li>按照某种方法从就绪队列中选取一个进程，将处理机分配给他。</li><li>是<strong>最基本的一种调度。</strong></li><li>频率很高，一般几十毫秒一次。</li></ul><p><strong>三层调度的联系、对比</strong></p></li></ol><img src="/blog/2020/11/17/进程管理（二）/三层调度的联系及对比.png"><p><em>调度算法要研究的问题</em>：<strong>高级调度、进程调度</strong></p><h4 id="进程调度的时机-切换与过程-方式"><a href="#进程调度的时机-切换与过程-方式" class="headerlink" title="进程调度的时机/切换与过程/方式"></a>进程调度的时机/切换与过程/方式</h4><h5 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h5><img src="/blog/2020/11/17/进程管理（二）/进程调度的时机.png"><p>需要注意：</p><ol><li>进程在<strong>操作系统内核程序临界区</strong>中<em>不能</em>进行调度与切换<ul><li>内核程序临界区时用来访问某种内核数据结构的（如进程的就绪队列，由各就绪进程的PCB组成）。</li><li>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。</li></ul></li><li>进程处于<strong>临界区</strong>时<em>可以</em>进行处理机调度<ul><li>如打印机在打印完成之前，进程一直处于临界区内并将临界资源上锁，但打印机是慢速设备，如果此时不允许进程调度会导致CPU一直空闲。</li><li>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，因此普通临界区可以进行调度和切换。</li></ul></li></ol><h5 id="进程调度的切换与过程"><a href="#进程调度的切换与过程" class="headerlink" title="进程调度的切换与过程"></a>进程调度的切换与过程</h5><p><em>狭义的进程调度</em>指的是从就绪队列中选中一个要运行的进程，可以是刚刚被暂停的进程，也可能是另外一个进程，后者需要进程切换。</p><p><em>广义的进程调度</em>指包含了选择一个进程和进程切换两个步骤。</p><p><em>进程切换</em>是指一个进程让出处理机，由另一个进程占用处理机的过程。进程切换的过程主要完成了：</p><ol><li>对原来运行进程各种数据的保存。</li><li>对新的进程各种数据的恢复。</li></ol><p><strong>注意</strong>：进程切换时由代价的，过于频繁的进行进程调度、切换，会使整个系统的效率降低。</p><h5 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h5><ol><li>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</li><li>剥夺调度方式，又称抢占方式。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合与分时操作系统、实时操作系统。</li></ol><h4 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h4><img src="/blog/2020/11/17/进程管理（二）/调度算法的评价指标.png"><h5 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h5><p>$$<br>利用率=\frac{忙碌的时间}{总时间}<br>$$</p><h5 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h5><p>单位时间内完成作业的数量。<br>$$<br>系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间}、<br>$$</p><h5 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h5><p>从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔，它包括4个部分：</p><ol><li>作业在外存后备队列上等待作业调度（高级调度）的时间。</li><li>进程在就绪队列上等待进程调度（低级调度）的时间。</li><li>进程在CPU上执行的时间。</li><li>进程等待I/O操作完成的时间。</li></ol><p>后三项可能发生多次。<br>$$<br>周转时间=作业完成时间-作业提交时间<br>$$</p><p>$$<br>平均周转时间=\frac{各作业周转时间之和}{作业数}<br>$$</p><p>$$<br>带权周转时间=\frac{作业周转时间}{作业实际运行的时间}=\frac{作业完成时间-作业提交时间}{作业实际运行的时间}<br>$$</p><p>$$<br>平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}<br>$$</p><p>后两个比较重要，带权周转时间和周转时间都是越短越好。</p><h5 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h5><p>进程/作业处于等待处理机状态时间之和。</p><p>对于<strong>进程</strong>来说，等待时间就是指建立进程后等待被服务的时间之和，在等待I/O完成的期间其实进程也是被服务的，不计入等待时间内。</p><p>对于<strong>作业</strong>来说，不仅考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><h5 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h5><p>从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p><h4 id="非交互性调度算法"><a href="#非交互性调度算法" class="headerlink" title="非交互性调度算法"></a>非交互性调度算法</h4><h5 id="先来先服务（FCFS-First-Come-First-Serve）"><a href="#先来先服务（FCFS-First-Come-First-Serve）" class="headerlink" title="先来先服务（FCFS, First Come First Serve）"></a>先来先服务（FCFS, First Come First Serve）</h5><img src="/blog/2020/11/17/进程管理（二）/先来先服务.png"><h5 id="最短作业优先（SJF-Shortest-Job-First）"><a href="#最短作业优先（SJF-Shortest-Job-First）" class="headerlink" title="最短作业优先（SJF, Shortest Job First）"></a>最短作业优先（SJF, Shortest Job First）</h5><p>最短作业/进程优先得到服务；既可用于作业调度，也可用于进程调度，用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”；SJF和SPF是<strong>非抢占式的算法</strong>，也有<strong>抢占式的版本</strong>—<strong>最短剩余时间优先</strong>算法（SRTN, Shortest Remaining Time Next）。</p><p>短作业/进程优先调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>运行时间最短</strong>的作业/进程，对比FCFS，SPF的平均等待/周转/带权周转的时间都要低。</p><p>最短剩余时间优先算法：每当有进程加入，就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。对比非抢占式的算法，其平均等待/周转/带权周转的时间都要低。</p><img src="/blog/2020/11/17/进程管理（二）/SJF.png"><h5 id="最高响应比优先（HRRN-Highest-Response-Ratio-Next）"><a href="#最高响应比优先（HRRN-Highest-Response-Ratio-Next）" class="headerlink" title="最高响应比优先（HRRN, Highest Response Ratio Next）"></a>最高响应比优先（HRRN, Highest Response Ratio Next）</h5><p>非抢占式的调度算法，只有当前运行的进程<strong>主动放弃CPU时</strong>，才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。<br>$$<br>响应比=\frac{等待时间+要求服务时间}{要求服务时间}<br>$$<br><img src="/blog/2020/11/17/进程管理（二）/HRRN.png"></p><h4 id="交互性调度算法"><a href="#交互性调度算法" class="headerlink" title="交互性调度算法"></a>交互性调度算法</h4><h5 id="时间片轮转（RR-Round-Robin）"><a href="#时间片轮转（RR-Round-Robin）" class="headerlink" title="时间片轮转（RR, Round-Robin）"></a>时间片轮转（RR, Round-Robin）</h5><p>轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列头的进程），常用于分时操作系统。</p><p>如果<strong>时间片过大</strong>，使得每个进程可以在一个时间片内完成，则时间片轮转调度算法退化为<strong>先来先服务</strong>算法，且会增加进程响应时间。</p><p>如果<strong>时间片过小</strong>，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比列减少。</p><p>一般来说，设计时间片时要让切换进程的开销占比不超过1%。</p><img src="/blog/2020/11/17/进程管理（二）/RR.png"><h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p><em>非抢占式的优先级调度算法</em>：每次调度时选择当前已到达且优先级最高的进程。当前进程<strong>主动</strong>放弃处理机时发生调度。</p><p><em>抢占式的优先级调度算法</em>：每次调度时选择当前已到达且优先级最高的进程。当前进程<strong>主动</strong>放弃处理机时发生调度。另外，当<strong>就绪队列发生改变时</strong>也需要检查是否会发生抢占。</p><ol><li><em>静态优先级</em>：创建进程时确定，之后一直不变。</li><li><em>动态优先级</em>：创建进程时有一个初始值，之后会根据情况动态的调整优先级。</li></ol><p>如何合理设置优先级，通常情况下：</p><ul><li>系统进程优先级<strong>高于</strong>用户进程</li><li>前台进程优先级<strong>高于</strong>后台进程</li><li>操作系统<strong>更偏好I/O型进程（I/O繁忙型进程）</strong><ul><li>I/O设备和CPU可以并行工作，最好让其尽早投入工作</li></ul></li></ul><p>采取动态优先级，何时调整：</p><ul><li>某进程在就绪队列中等待很长时间，可适当提高其优先级</li><li>某进程占用处理机运行了很长时间，可适当降低其优先级</li><li>某进程频繁进行I/O操作，可适当提升其优先级</li></ul><img src="/blog/2020/11/17/进程管理（二）/优先级调度算法.png"><h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><img src="/blog/2020/11/17/进程管理（二）/多级反馈队列调度算法.png"><p><strong>总结</strong>：</p><img src="/blog/2020/11/17/进程管理（二）/总结.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;处理机调度概念、层次&lt;/li&gt;
&lt;li&gt;进程调度的时机/切换与过程/方式&lt;/li&gt;
&lt;li&gt;调度算法的评价指标&lt;/li&gt;
&lt;li&gt;非交互性调度算法&lt;/li&gt;
&lt;li&gt;交互性调度算法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程管理（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/11/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/11/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-11-11T14:41:11.000Z</published>
    <updated>2020-11-14T15:45:42.079Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>进程的定义、组成、组织方式、特征</li><li>线程</li></ol><a id="more"></a><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><h5 id="一、进程的概念"><a href="#一、进程的概念" class="headerlink" title="一、进程的概念"></a>一、进程的概念</h5><p>多道程序环境下引入<em>进程</em>的概念，为了更好地描述和控制程序的并发执行，实现操作系统的并发行和共享性。</p><ol><li><p>进程控制块(Process Control Block, PCB)：描述进程的基本情况和运行状态，进而控制和管理进程，<strong>PCB是进程存在的唯一标志</strong>。</p></li><li><p><strong>进程映像（进程实体）</strong>由程序段、相关数据段和PCB构成，进程映像是静态的，进程是动态的。</p></li><li><p><strong>进程</strong>是<strong>进程实体</strong>的运行过程，是系统进行资源分配和调度的一个独立单位。</p></li><li><p><strong>进程的典型定义</strong>：</p><ol><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理及上顺序执行时所发生的活动</li><li>进程时具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ol></li></ol><h5 id="二、进程的组成"><a href="#二、进程的组成" class="headerlink" title="二、进程的组成"></a>二、进程的组成</h5><img src="/blog/2020/11/11/进程管理（一）/进程的组成.png"><h5 id="三、进程的特征"><a href="#三、进程的特征" class="headerlink" title="三、进程的特征"></a>三、进程的特征</h5><ol><li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消失的，<strong>最基本特征</strong></li><li>并发性：内存中有多个进程实体，各进程可并发执行</li><li>独立性：进程是能独立运行、独立获得资源、独立接受调度的<strong>基本单位</strong></li><li>异步性：各进程按照独立的、<strong>不可预知</strong>的速度向前推进，操作系统要提供<strong>进程同步机制</strong>来解决异步问题</li><li>结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成</li></ol><h5 id="四、进程的状态与转换"><a href="#四、进程的状态与转换" class="headerlink" title="四、进程的状态与转换"></a>四、进程的状态与转换</h5><img src="/blog/2020/11/11/进程管理（一）/进程的状态.png"><p>创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB</p><p>终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</p><h6 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h6><ol><li>运行态：占有CPU，并在CPU上运行（单核处理器下，每个时刻最多一个进程处于运行态）</li><li>就绪态：已经具备运行条件，但由于没有空闲CPU，暂时不能运行（万事俱备，只欠CPU）</li><li>阻塞态：又称等待态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机），或等待输入/输出完成。即使处理机空闲，该进程也不能运行</li></ol><h6 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h6><img src="/blog/2020/11/11/进程管理（一）/进程的状态转换.png"><p>就绪态-&gt;运行态：进程被调度</p><p>运行态-&gt;就绪态：时间片到，或CPU被其他高优先级的进程抢占</p><p>运行态-&gt;阻塞态：等待系统分配资源，或等到某事件发生（<em>主动行为</em>）</p><p>阻塞态-&gt;就绪态：资源分配到位，等待的事件发生（<em>被动行为</em>）</p><h5 id="五、进程控制"><a href="#五、进程控制" class="headerlink" title="五、进程控制"></a>五、进程控制</h5><p>进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为<strong>原语</strong>，<strong>原语</strong>的特点是在<strong>执行期间不允许中断</strong>，它是一个不可分割的基本单位，<strong>原语采用关中断指令和开中断指令实现</strong>。</p><h6 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h6><img src="/blog/2020/11/11/进程管理（一）/进程的创建.png"><h6 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h6><img src="/blog/2020/11/11/进程管理（一）/进程的终止.png"><h6 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h6><p>进程的阻塞和唤醒要成对出现</p><img src="/blog/2020/11/11/进程管理（一）/进程的阻塞和唤醒.png"><h6 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h6><img src="/blog/2020/11/11/进程管理（一）/进程的切换.png"><h5 id="六、进程通信"><a href="#六、进程通信" class="headerlink" title="六、进程通信"></a>六、进程通信</h5><img src="/blog/2020/11/11/进程管理（一）/进程通信.png"><h6 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h6><p>两个进程对共享空间的访问必须是互斥的，通过操作系统提供的工具实现。操作系统只负责提供共享空间和同步互斥工具（如P、V操作）。</p><p>方法：</p><ol><li><p>基于数据结构的共享，低级通信方式</p></li><li><p>基于存储区的共享，高级通信方式</p></li></ol><h6 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h6><p>进程间数据交换以<strong>格式化的消息</strong>为单位，包括消息头和消息体。进程通过操作系统提供的“发送信息/接受信息”两个原语进行数据交换。</p><p>方法：</p><ol><li>直接通信方式，发送进程将消息直接发送给接收进程，挂在接收进程的消息缓冲队列上</li><li>间接通信方式，消息要先发送到中间实体（信箱）中，也称“信箱通信方式”</li></ol><h6 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h6><ol><li>管道通信采用半双工，若要实现双向同时通信，需要设置两个管道</li><li>各进程要互斥地访问管道</li><li>管道满时，写进程write()系统调用被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程read()被阻塞</li><li>如果<strong>没写满就不允许读</strong>，如果<strong>没读空就不允许写</strong></li><li>数据一旦被读出，就从管道中被抛弃，意味着读进程最多只能有一个</li></ol><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行的执行一系列程序。为此，引入了“线程”来增加并发度，<strong>引入线程后，线程成为了程序执行流的最小单位</strong>。</p><p>引入线程后，进程只作为除CPU之外的系统资源的分配单位，线程则作为处理机的分配单元。</p><img src="/blog/2020/11/11/进程管理（一）/线程.png"><h5 id="一、线程的实现方式"><a href="#一、线程的实现方式" class="headerlink" title="一、线程的实现方式"></a>一、线程的实现方式</h5><ol><li>用户级线程</li></ol><img src="/blog/2020/11/11/进程管理（一）/用户级线程.png" style="zoom:80%;"><ol start="2"><li>内核级线程</li></ol><img src="/blog/2020/11/11/进程管理（一）/内核级线程.png" style="zoom:80%;"><ol start="3"><li>二者组合方式，将n个用户级线程映射到m个内核级线程上（n&gt;=m）</li></ol><img src="/blog/2020/11/11/进程管理（一）/组合线程实现.png" style="zoom:80%;"><p>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p><h5 id="二、多线程模型"><a href="#二、多线程模型" class="headerlink" title="二、多线程模型"></a>二、多线程模型</h5><p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p><ol><li>多对一模型：多个用户级线程映射到一个内核级线程</li></ol><img src="/blog/2020/11/11/进程管理（一）/多线程1.png" style="zoom:80%;"><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p><ol start="2"><li>一对一模型：一个用户级线程映射到一个内核级线程</li></ol><img src="/blog/2020/11/11/进程管理（一）/多线程2.png" style="zoom:80%;"><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行。</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，线程管理成本高，开销大。</p><ol start="3"><li>多对多模型：n个用户级线程映射到m个内核级线程（n&gt;=m）</li></ol><img src="/blog/2020/11/11/进程管理（一）/多线程3.png" style="zoom:80%;"><p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;进程的定义、组成、组织方式、特征&lt;/li&gt;
&lt;li&gt;线程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>图论（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/03/%E5%9B%BE%E8%AE%BA2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/03/%E5%9B%BE%E8%AE%BA2/</id>
    <published>2020-11-03T08:06:02.000Z</published>
    <updated>2020-11-14T15:49:33.294Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>读取一个图</li><li>深度优先搜索DFS</li><li>广度优先搜索BFS</li></ol><a id="more"></a><h4 id="从文件中读取一个图"><a href="#从文件中读取一个图" class="headerlink" title="从文件中读取一个图"></a>从文件中读取一个图</h4><p>如果要从已有的文件中读取并构建一张图，需要使用到C++的IO库，使用头文件<code>fstream</code>和<code>sstream</code>，类型如下:</p><p><strong>fstream:</strong></p><ul><li><code>ifstream, wifstream</code>从文件中读取数据</li><li><code>ofstream, wofstram</code>向文件中写入数据</li><li><code>fstream, wfstream</code>读写文件</li></ul><p><strong>sstream:</strong></p><ul><li><code>istringstream, wistringfstream</code>从<code>string</code>中读取数据</li><li><code>ostringstream, wosringstream</code>向<code>string</code>中写入数据</li><li><code>stringstream, wstringstream</code>读写<code>string</code></li></ul><h5 id="读文件—类的实现"><a href="#读文件—类的实现" class="headerlink" title="读文件—类的实现"></a>读文件—类的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ReadGraph(Graph &amp;graph, <span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)&#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">int</span> V, E;</span><br><span class="line"></span><br><span class="line">        assert(file.is_open());</span><br><span class="line">        assert(getline(file, line));</span><br><span class="line">        <span class="comment">// 首先读入顶点数和边数</span></span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">        ss &gt;&gt; V &gt;&gt; E;</span><br><span class="line">        assert(V == graph.V());</span><br><span class="line">        <span class="comment">// 读入每一条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; ++i)&#123;</span><br><span class="line">            assert(getline(file, line));</span><br><span class="line">            <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            ss &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            assert(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; V);</span><br><span class="line">            assert(b &gt;= <span class="number">0</span> &amp;&amp; b &lt; V);</span><br><span class="line">            graph.addEdge(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="测试主函数"><a href="#测试主函数" class="headerlink" title="测试主函数"></a>测试主函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    <span class="comment">// G2是有6个顶点的无向图</span></span><br><span class="line">    <span class="function">SparseGraph <span class="title">g1</span><span class="params">(<span class="number">6</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g1, filename)</span></span>;</span><br><span class="line">    <span class="comment">// 在两种头文件中新加show函数打印结果</span></span><br><span class="line">    g1.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DenseGraph <span class="title">g2</span><span class="params">(<span class="number">6</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;DenseGraph&gt; <span class="title">readGraph2</span><span class="params">(g2, filename)</span></span>;</span><br><span class="line">    g2.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">vertex <span class="number">0</span>:       <span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line">vertex <span class="number">1</span>:       <span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">vertex <span class="number">2</span>:       <span class="number">0</span> <span class="number">1</span></span><br><span class="line">vertex <span class="number">3</span>:       <span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">vertex <span class="number">4</span>:       <span class="number">1</span> <span class="number">3</span></span><br><span class="line">vertex <span class="number">5</span>:       <span class="number">0</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">vertex <span class="number">0</span>:       <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">vertex <span class="number">1</span>:       <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">vertex <span class="number">2</span>:       <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">vertex <span class="number">3</span>:       <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">vertex <span class="number">4</span>:       <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">vertex <span class="number">5</span>:       <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h4><p>与二叉树的深度优先搜索遍历不同，二叉树总会遇到空，但是图可能成环，或者无向图，所以遍历时应记录每个节点是否被遍历了。</p><h5 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h5><p>无向图Graph的极大连通子图称为G的<strong>连通分量</strong>( Connected Component)。任何<strong>连通图</strong>的连通分量只有一个，即是其自身，<strong>非连通的无向图</strong>有多个连通分量。如图所示，无向图共有4个连通分量：</p><img src="/blog/2020/11/03/图论2/dfs1.png"><p>对于一个非连通的无向图来说，可以用DFS得到Graph共有几个连通分量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Components</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">bool</span> *visited; <span class="comment">// 当前节点是否被遍历过</span></span><br><span class="line">    <span class="keyword">int</span> ccount;<span class="comment">// 记录连通分量总数</span></span><br><span class="line">    <span class="keyword">int</span> *id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 相当于并查集，让同一个联通分量中的节点指向同一个数</span></span><br><span class="line">    id[v] = ccount;</span><br><span class="line">    <span class="comment">// 编译器无法判断是Graph的一个类型还是一个成员变量，需加关键字typename</span></span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = adj.begin(); !adj.end(); i = adj.next())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Components(Graph &amp;graph): G(graph)&#123;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[G.v()];</span><br><span class="line">        ccount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); ++i)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            id[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">                ccount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Components()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ccount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询两个节点是否相连</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; G.V());</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V());</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="测试主函数-1"><a href="#测试主函数-1" class="headerlink" title="测试主函数"></a>测试主函数</h6><p>对于图<code>testG1.txt</code>和<code>testG2.txt</code>，先从文件中读取到稀疏图中，再对此图进行DFS得到连通分量的个数，两个文件内容分别为：</p><ul><li>testG1:</li></ul><img src="/blog/2020/11/03/图论2/testG1.png"><ul><li>testG2:</li></ul><img src="/blog/2020/11/03/图论2/testG2.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename1 = <span class="string">"testG1.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SparseGraph <span class="title">g1</span><span class="params">(<span class="number">13</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g1, filename1)</span></span>;</span><br><span class="line">    <span class="function">Components&lt;SparseGraph&gt; <span class="title">component1</span><span class="params">(g1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"TestG1.txt, Component Count: "</span>&lt;&lt; component1.count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> filename2 = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    <span class="function">SparseGraph <span class="title">g2</span><span class="params">(<span class="number">6</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph2</span><span class="params">(g2, filename2)</span></span>;</span><br><span class="line">    <span class="function">Components&lt;SparseGraph&gt; <span class="title">component2</span><span class="params">(g2)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"TestG2.txt, Component Count: "</span> &lt;&lt; component2.count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">TestG1.txt, Component Count: <span class="number">3</span></span><br><span class="line">TestG2.txt, Component Count: <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="获得两点之间的一条路径"><a href="#获得两点之间的一条路径" class="headerlink" title="获得两点之间的一条路径"></a>获得两点之间的一条路径</h5><p>使用DFS可以找连通图两点之间的一条路径，但不一定是最短路径。对于稀疏图，复杂度为O(V+E)，对于稠密图，复杂度为O(V^2)。对于下图，寻找节点0到节点6的一条路径。</p><img src="/blog/2020/11/03/图论2/dfs2.png"><p>在遍历每个节点时，可以存储当前节点是由哪个节点遍历到的，以此可以反推出原始节点到当前节点的一条路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="comment">// 源节点</span></span><br><span class="line">    <span class="keyword">bool</span> *visited;</span><br><span class="line">    <span class="keyword">int</span> *from; <span class="comment">// 当前节点是由哪个节点遍历到的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = adj.begin(); !adj.end(); i = adj.next())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="comment">// 节点i是由节点v遍历到的</span></span><br><span class="line">                from[i] = v;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Path(Graph &amp;graph, <span class="keyword">int</span> s): G(graph)&#123;</span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        assert(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V());</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); ++i)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="comment">// 寻路</span></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Path()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] visited;</span><br><span class="line">        <span class="keyword">delete</span> [] from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="comment">// 找到从源节点到目标节点所经过的每一个节点入栈</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span>)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            <span class="comment">// 将p更新为可以到达p的一个节点</span></span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="comment">// 出栈是正向路径</span></span><br><span class="line">            vec.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        path(w, vec);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vec[i];</span><br><span class="line">            <span class="keyword">if</span> (i == vec.size() - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="测试主函数-2"><a href="#测试主函数-2" class="headerlink" title="测试主函数"></a>测试主函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph</span><span class="params">(g, filename)</span></span>;</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Path&lt;SparseGraph&gt; <span class="title">dfs</span><span class="params">(g, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS : "</span>;</span><br><span class="line">    dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">vertex <span class="number">0</span>:       <span class="number">1</span>       <span class="number">2</span>       <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">vertex <span class="number">1</span>:       <span class="number">0</span></span><br><span class="line">vertex <span class="number">2</span>:       <span class="number">0</span></span><br><span class="line">vertex <span class="number">3</span>:       <span class="number">4</span>       <span class="number">5</span></span><br><span class="line">vertex <span class="number">4</span>:       <span class="number">3</span>       <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">vertex <span class="number">5</span>:       <span class="number">0</span>       <span class="number">3</span>       <span class="number">4</span></span><br><span class="line">vertex <span class="number">6</span>:       <span class="number">0</span>       <span class="number">4</span></span><br><span class="line"></span><br><span class="line">DFS : <span class="number">0</span> -&gt; <span class="number">5</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h4><p>使用深度优先搜索可以找到无权图两个节点之间的最短路径，复杂度与DFS相同。</p><h5 id="最短路径—类的实现"><a href="#最短路径—类的实现" class="headerlink" title="最短路径—类的实现"></a>最短路径—类的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">bool</span> *visited;</span><br><span class="line">    <span class="keyword">int</span> *from;</span><br><span class="line">    <span class="keyword">int</span> *ord; <span class="comment">// 当前点到源节点的最短距离</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ShortestPath(Graph &amp;graph, <span class="keyword">int</span> s): G(graph)&#123;</span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        assert(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V());</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[graph.V()];</span><br><span class="line">        ord = <span class="keyword">new</span> <span class="keyword">int</span>[graph.V()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; graph.V() ; i ++ )&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">            ord[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 无向图最短路径算法</span></span><br><span class="line">        q.push(s);</span><br><span class="line">        visited[s] = <span class="literal">true</span>;</span><br><span class="line">        ord[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = adj.begin(); !adj.end(); i = adj.next())&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                    q.push(i);</span><br><span class="line">                    visited[i] = <span class="literal">true</span>;</span><br><span class="line">                    from[i] = v;</span><br><span class="line">                    ord[i] = ord[v] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ShortestPath()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] visited;</span><br><span class="line">        <span class="keyword">delete</span> [] from;</span><br><span class="line">        <span class="keyword">delete</span> [] ord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>( p != <span class="number">-1</span> )&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span>( !s.empty() )&#123;</span><br><span class="line">            vec.push_back( s.top() );</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        path(w, vec);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vec.size() ; i ++ )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;vec[i];</span><br><span class="line">            <span class="keyword">if</span>( i == vec.size()<span class="number">-1</span> )</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">" -&gt; "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> ord[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="测试主函数-3"><a href="#测试主函数-3" class="headerlink" title="测试主函数"></a>测试主函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph</span><span class="params">(g, filename)</span></span>;</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Path&lt;SparseGraph&gt; <span class="title">dfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"DFS : "</span>;</span><br><span class="line">    dfs.showPath(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">ShortestPath&lt;SparseGraph&gt; <span class="title">bfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BFS : "</span>;</span><br><span class="line">    bfs.showPath(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"Shortest length : "</span> &lt;&lt; bfs.length(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">vertex <span class="number">0</span>:       <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">vertex <span class="number">1</span>:       <span class="number">0</span></span><br><span class="line">vertex <span class="number">2</span>:       <span class="number">0</span></span><br><span class="line">vertex <span class="number">3</span>:       <span class="number">4</span> <span class="number">5</span></span><br><span class="line">vertex <span class="number">4</span>:       <span class="number">3</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">vertex <span class="number">5</span>:       <span class="number">0</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">vertex <span class="number">6</span>:       <span class="number">0</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">DFS : <span class="number">0</span> -&gt; <span class="number">5</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span></span><br><span class="line">BFS : <span class="number">0</span> -&gt; <span class="number">5</span> -&gt; <span class="number">4</span></span><br><span class="line">Shortest Length : <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="完整工程："><a href="#完整工程：" class="headerlink" title="完整工程："></a>完整工程：</h4><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;读取一个图&lt;/li&gt;
&lt;li&gt;深度优先搜索DFS&lt;/li&gt;
&lt;li&gt;广度优先搜索BFS&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>图论（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/27/%E5%9B%BE%E8%AE%BA1/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/27/%E5%9B%BE%E8%AE%BA1/</id>
    <published>2020-10-27T14:40:55.000Z</published>
    <updated>2020-10-28T15:02:53.557Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>图的基本概念</li><li>图的两种表示方法及实现</li><li>对图进行遍历</li></ol><a id="more"></a><h4 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><h5 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h5><ul><li>节点（Vertex）</li><li>边（Edge）</li></ul><p>使用场景：交通运输，社交网络，互联网，工作安排，脑区活动，程序状态执行（自动机）等。</p><h5 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h5><ul><li>无向图（Undirected Graph）</li><li>有向图（Directed Graph）</li></ul><p>无向图是一种特殊的有向图，比如A指向B，同时B指向A</p><ul><li>无权图（Unweighted Graph）</li><li>有权图（Weighted Graph）</li></ul><p>其他概念：图的连通性，简单图（无自环边与平行边）</p><img src="/blog/2020/10/27/图论1/7-1-1.png" style="zoom:80%;"><h4 id="图的两种表示方法及实现（邻接矩阵与邻接表）"><a href="#图的两种表示方法及实现（邻接矩阵与邻接表）" class="headerlink" title="图的两种表示方法及实现（邻接矩阵与邻接表）"></a>图的两种表示方法及实现（邻接矩阵与邻接表）</h4><h5 id="邻接矩阵（适合表示稠密图Dense-Graph）"><a href="#邻接矩阵（适合表示稠密图Dense-Graph）" class="headerlink" title="邻接矩阵（适合表示稠密图Dense Graph）"></a>邻接矩阵（适合表示稠密图Dense Graph）</h5><img src="/blog/2020/10/27/图论1/7-2-1.png" style="zoom:80%;"><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenseGraph</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;      <span class="comment">// 节点数和边数</span></span><br><span class="line">    <span class="keyword">bool</span> directed; <span class="comment">// 是否是有向图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; g;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DenseGraph(<span class="keyword">int</span> n, <span class="keyword">bool</span> directed)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            g.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DenseGraph()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> n;&#125; <span class="comment">// 图的节点总数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m;&#125; <span class="comment">// 图的边总数</span></span><br><span class="line">    <span class="comment">// 增加节点v与节点w之间的一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">        <span class="keyword">if</span>(hasEdge(v, w)) <span class="keyword">return</span>; <span class="comment">// 处理了平行边，并且防止边数m多加一次</span></span><br><span class="line">        g[v][w] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!directed) <span class="comment">// 如果是无向图</span></span><br><span class="line">            g[w][v] = <span class="literal">true</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">        <span class="keyword">return</span> g[v][w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="邻接表（适合表示稀疏图Sparse-Graph）"><a href="#邻接表（适合表示稀疏图Sparse-Graph）" class="headerlink" title="邻接表（适合表示稀疏图Sparse Graph）"></a>邻接表（适合表示稀疏图Sparse Graph）</h5><img src="/blog/2020/10/27/图论1/7-2-2.png" style="zoom:80%;"><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseGraph</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">bool</span> directed;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SparseGraph(<span class="keyword">int</span> n, <span class="keyword">bool</span> directed)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            g.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~SparseGraph()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> n;&#125; <span class="comment">// 图的节点总数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m;&#125; <span class="comment">// 图的边总数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line"></span><br><span class="line">        g[v].push_back(w);</span><br><span class="line">        <span class="keyword">if</span>(v != w &amp;&amp; !directed) <span class="comment">// 处理了自环边，并且防止边数m多加一次</span></span><br><span class="line">            g[w].push_back(v);</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[v][i] == w) <span class="comment">// 节点v与w相连</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="对图进行遍历——迭代器的实现"><a href="#对图进行遍历——迭代器的实现" class="headerlink" title="对图进行遍历——迭代器的实现"></a>对图进行遍历——迭代器的实现</h4><pre class="mermaid">graph LR    0-->3;    0-->5;    0-->8;</pre><p>在邻接矩阵中如下：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p>在邻接表中如下：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>3</td><td>5</td><td>8</td></tr></tbody></table><p>如果要遍历某个节点的所有邻边，可以借鉴迭代器的思想。</p><h5 id="稠密图（邻接矩阵中）"><a href="#稠密图（邻接矩阵中）" class="headerlink" title="稠密图（邻接矩阵中）"></a>稠密图（邻接矩阵中）</h5><p>在<code>DenseGraph</code>类中实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器实现</span></span><br><span class="line"><span class="comment">// 顶点的邻边按顺序输出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">adjIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DenseGraph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// 遍历到的节点坐标</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    adjIterator(DenseGraph &amp;graph, <span class="keyword">int</span> v) : G(graph) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (index; index &lt; G.V(); index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G.g[v][index]) <span class="comment">// 如果v与index相连</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有邻边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= G.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="稀疏图（邻接表中）"><a href="#稀疏图（邻接表中）" class="headerlink" title="稀疏图（邻接表中）"></a>稀疏图（邻接表中）</h5><p>在<code>SparseGraph</code>类中实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">adjIterator</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SparseGraph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    adjIterator(SparseGraph &amp;graph, <span class="keyword">int</span> v):G(graph)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="comment">// 与稠密图不同的是，这里的index表示遍历到v的第index个节点，不表示节点index</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;index = index; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(G.g[v].size())</span><br><span class="line">            <span class="keyword">return</span> G.g[v].size();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; G.g[v].size())</span><br><span class="line">            <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 返回-1说明已经遍历结束，此时index = G.g[v].size()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= G.g[v].size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>测试用主函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sparse Graph</span></span><br><span class="line">    <span class="comment">// 存在平行边</span></span><br><span class="line">    <span class="function">SparseGraph <span class="title">g1</span><span class="params">(N, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = rand() % N;</span><br><span class="line">        <span class="keyword">int</span> b = rand() % N;</span><br><span class="line">        g1.addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(E)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; N; ++v)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" : "</span>;</span><br><span class="line">        <span class="function">SparseGraph::adjIterator <span class="title">adj</span><span class="params">(g1, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = adj.begin(); !adj.end(); w = adj.next())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Dense Graph</span></span><br><span class="line">    <span class="comment">// 存在自环边</span></span><br><span class="line">    <span class="function">DenseGraph <span class="title">g2</span><span class="params">(N, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = rand() % N;</span><br><span class="line">        <span class="keyword">int</span> b = rand() % N;</span><br><span class="line">        g2.addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(V^2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; N; ++v)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" : "</span>;</span><br><span class="line">        <span class="function">DenseGraph::adjIterator <span class="title">adj</span><span class="params">(g2, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = adj.begin(); !adj.end(); w = adj.next())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Sparse Graph</span><br><span class="line">// 可以看出存在平行边</span><br><span class="line">0 : 3 6 6 7 6</span><br><span class="line">1 : 9 2</span><br><span class="line">2 : 7 9 5 1 9</span><br><span class="line">3 : 5 0 5 6 4 9 5</span><br><span class="line">4 : 6 3 8 6 8</span><br><span class="line">5 : 9 7 3 2 3 3 9</span><br><span class="line">6 : 9 4 0 3 9 0 4 0</span><br><span class="line">7 : 5 2 8 9 0</span><br><span class="line">8 : 7 8 9 4 4</span><br><span class="line">9 : 5 2 6 1 7 3 6 8 5 2</span><br><span class="line"></span><br><span class="line">// Sparse Graph</span><br><span class="line">// 可以看出存在自环边</span><br><span class="line">0 : 0 2 4</span><br><span class="line">1 : 4 5 7 9</span><br><span class="line">2 : 0 4 8</span><br><span class="line">3 : 3 4 5 6</span><br><span class="line">4 : 0 1 2 3 6 7 9</span><br><span class="line">5 : 1 3 6</span><br><span class="line">6 : 3 4 5 7 8 9</span><br><span class="line">7 : 1 4 6 7</span><br><span class="line">8 : 2 6 8</span><br><span class="line">9 : 1 4 6</span><br></pre></td></tr></table></figure><h4 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h4><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;图的基本概念&lt;/li&gt;
&lt;li&gt;图的两种表示方法及实现&lt;/li&gt;
&lt;li&gt;对图进行遍历&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode143-重排链表</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</id>
    <published>2020-10-27T01:50:20.000Z</published>
    <updated>2020-11-22T03:19:32.108Z</updated>
    
    <content type="html"><![CDATA[<p>本题同时解决<strong>LeetCode206-反转链表</strong>和<strong>LeetCode876-链表的中间结点</strong></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>本题可与<a href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more">LeetCode147-对链表进行插入排序</a>，<a href="http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">LeetCode148-排序链表</a>共同学习。</p><a id="more"></a><img src="/blog/2020/10/27/LeetCode143-重排链表/示例.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>观察链表，对于长度为偶数的链表，如示例1，可以将2之后的子链表进行反转得到<code>4-&gt;3</code>，然后再与剩下的链表<code>1-&gt;2</code>交叉合并，得到<code>1-&gt;4-&gt;2-&gt;3</code>；</p><p>长度为奇数的链表同理，找到中间结点3，将3之后的子链表反转得到<code>5-&gt;4</code>，再与剩下的链表<code>1-&gt;2-&gt;3</code>进行合并，得到<code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>。</p><h4 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于偶数长度链表，找到的是中间靠后的一个</span></span><br><span class="line"><span class="function">ListNode* <span class="title">midNode</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || !root-&gt;next) </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    ListNode *fast = root;</span><br><span class="line">    ListNode *slow = root;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于偶数长度链表，找到的是中间靠前的一个</span></span><br><span class="line"><span class="function">ListNode* <span class="title">midNode</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || !root-&gt;next) </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    ListNode *fast = root;</span><br><span class="line">    ListNode *slow = root;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span>;</span><br><span class="line">        ListNode *mid = midNode(head);</span><br><span class="line">        ListNode *l2 = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>; </span><br><span class="line">        l2 = reverseList(l2);</span><br><span class="line">        mergeList(head, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">midNode</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">        ListNode *fast = root;</span><br><span class="line">        ListNode *slow = root;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode *l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode *tmp1;</span><br><span class="line">        ListNode *tmp2;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            tmp1 = l1-&gt;next;</span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            tmp2 = l2-&gt;next;</span><br><span class="line">            l2-&gt;next = tmp1;</span><br><span class="line">            l1 = tmp1;</span><br><span class="line">            l2 = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题同时解决&lt;strong&gt;LeetCode206-反转链表&lt;/strong&gt;和&lt;strong&gt;LeetCode876-链表的中间结点&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个单链表 L：L0→L1→…→Ln-1→Ln ，&lt;br&gt;将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;
&lt;p&gt;本题可与&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more&quot;&gt;LeetCode147-对链表进行插入排序&lt;/a&gt;，&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/&quot;&gt;LeetCode148-排序链表&lt;/a&gt;共同学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的三种遍历方法（迭代）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89/</id>
    <published>2020-10-19T03:01:41.000Z</published>
    <updated>2020-10-19T03:38:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概要</strong></p><ol><li>二叉树的前序遍历</li><li>二叉树的中序遍历</li><li>二叉树的后序遍历</li></ol><a id="more"></a><p>递归进行二叉树的遍历比较简单，学习使用迭代法进行二叉树的遍历，主要是使用栈这种数据结构。</p><h4 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h4><p>前序遍历的顺序为：中—左—右</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preOrder;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        TreeNode *node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            preOrder.push_back(node-&gt;val);</span><br><span class="line">            <span class="comment">// 这里需要注意，前序遍历第二次遍历的是左节点</span></span><br><span class="line">            <span class="comment">// 所以先将右节点入栈，再将左节点入栈，保证左节点先出栈</span></span><br><span class="line">            st.push(node-&gt;right);</span><br><span class="line">            st.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h4><p>中序遍历的顺序为：左—中—右</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode *node = root;</span><br><span class="line">    <span class="comment">// 先判断根节点不为空，进入迭代，后面再根据栈是否为空进行迭代</span></span><br><span class="line">    <span class="keyword">while</span>(!st.empty() || node)&#123;</span><br><span class="line">        <span class="comment">// 当前节点存在，查看其左节点情况，如果其左节点不存在，那就弹出当前节点</span></span><br><span class="line">        <span class="comment">// 再查看其右节点情况，如果右节点也不存在，就弹出当前栈顶（也就是上一个左节点）</span></span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            st.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h4><p>后序遍历的顺序为：左—右—中</p><h5 id="根据二叉树结构遍历"><a href="#根据二叉树结构遍历" class="headerlink" title="根据二叉树结构遍历"></a>根据二叉树结构遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    TreeNode *pre;</span><br><span class="line">    <span class="keyword">while</span>(cur || !st.empty())&#123;</span><br><span class="line">        <span class="comment">// 首先当前节点的左子树入栈</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出最后一个左节点</span></span><br><span class="line">        cur = st.top();</span><br><span class="line">        <span class="comment">// 如果当前节点的右节点为空或者已经遍历过了，那么就记录当前节点</span></span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;right || cur-&gt;right == pre)&#123;</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">// 如果记录了当前节点，那么当前节点必须置为空，否则会陷入第一个while中死循环</span></span><br><span class="line">            cur = <span class="literal">nullptr</span>;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则查看当前节点的右节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画演示：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/di-gui-die-dai-qu-qiao-san-chong-fang-fa-quan-jie-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/di-gui-die-dai-qu-qiao-san-chong-fang-fa-quan-jie-/</a></p><h5 id="破坏结构遍历"><a href="#破坏结构遍历" class="headerlink" title="破坏结构遍历"></a>破坏结构遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        TreeNode *node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            st.push(node-&gt;left);</span><br><span class="line">            st.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到的结果是中—右—左，需要反转一下得到左—右—中</span></span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概要&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二叉树的前序遍历&lt;/li&gt;
&lt;li&gt;二叉树的中序遍历&lt;/li&gt;
&lt;li&gt;二叉树的后序遍历&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://www.xingyuzhao.ltd/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++类的一些知识点</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/18/C-%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/18/C-%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-10-18T14:31:26.000Z</published>
    <updated>2020-10-18T14:39:36.414Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》第七章内容——类</p><p><strong>部分总结</strong></p><a id="more"></a><h4 id="第七章：类"><a href="#第七章：类" class="headerlink" title="第七章：类"></a>第七章：类</h4><ol><li><h5 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h5></li></ol><ul><li><p>类可以允许其他类或者函数访问它的非共有成员，方法是令其他类或者函数（可以是成员函数也可以是非成员函数）成为它的友元。一般来说，在类的开始或者结束前位置集中声明友元。如果希望类的用户能够调用某个友元函数，那么就需要在类中友元声明之外再进行一次声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sale_data&amp;, <span class="keyword">const</span> Sale_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    /.../</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    /.../</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 非成员函数声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sale_data&amp;, <span class="keyword">const</span> Sale_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元的关系不具有传递性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">// Window_mgr的成员可以访问Screen类的私有部分</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">    /.../</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以只为某个成员函数提供访问权限</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">// Window_mgr::clear必须再Screen类之前声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    /.../</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>构造函数</strong></li></ol><ul><li><p>使用构造函数初始值列表来初始化成员。</p></li><li><p>如果成员是引用或者const时，必须通过函数初始值列标将其初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstRef</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ConstRef(<span class="keyword">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line"><span class="keyword">int</span> &amp;ri;</span><br><span class="line">&#125;</span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii): i(ii), ci(ii), ri(ii);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>类的静态成员</strong></li></ol><ul><li><p>适用于类的成员直接与类相关，而不是与类的各个对象关联，比如说：银行的利率</p></li><li><p>静态成员可以是public或者private，使用关键字static，成员函数不用通过作用域运算符就能直接使用静态成员。静态成员不是由类的构造函数初始化的，一般在类的外部定义和初始化每个静态成员，只能定义一次：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> owner;</span><br><span class="line">    <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Account::rate</span><span class="params">(<span class="keyword">double</span> newRate)</span></span>&#123;</span><br><span class="line">    interestRate = newRate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义并初始化一个静态成员</span></span><br><span class="line"><span class="keyword">double</span> Account::interestRate = initRate();</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account c1;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    r = c1.rate();</span><br><span class="line">    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    </span><br><span class="line">    Account::rate(<span class="number">0.8</span>);</span><br><span class="line">    r = c1.rate();</span><br><span class="line">    <span class="comment">// 输出0.8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》第七章内容——类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分总结&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="类(class)" scheme="http://www.xingyuzhao.ltd/tags/%E7%B1%BB-class/"/>
    
  </entry>
  
  <entry>
    <title>LCP19-秋叶收藏集</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/11/LCP19-%E7%A7%8B%E5%8F%B6%E6%94%B6%E8%97%8F%E9%9B%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/11/LCP19-%E7%A7%8B%E5%8F%B6%E6%94%B6%E8%97%8F%E9%9B%86/</id>
    <published>2020-10-11T03:25:10.000Z</published>
    <updated>2020-10-12T09:27:57.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。<br>出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p><a id="more"></a><img src="/blog/2020/10/11/LCP19-秋叶收藏集/image-20201011112801516.png" style="zoom:80%;"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用三个状态来标记其中的每一个部分，0和2表示前面和后面的红色，1表示中间的黄色，于是三部分结构为「0、1、2」。</p><p>定义<code>dp[i][j]</code>表示：对**[0..i]<strong>片叶子进行调整，并且第</strong>i<strong>片叶子处于</strong>j**状态的最小操作数，所以有下面三种情况：</p><ol><li>当<strong>j = 0</strong>时，第<strong>i</strong>片叶子应为红色，并且第<strong>i - 1</strong>片叶子也应该处于<strong>j = 0</strong>的状态：</li></ol><p>$$<br>dp[i][0] = dp[i-1][0] + isYellow(i)<br>$$</p><p>$$<br>isYellow(i)=<br>\begin{cases}<br>1&amp; \text{leaves[i] = ‘y’}\\<br>0&amp; \text{leaves[i] = ‘r’}<br>\end{cases}<br>$$</p><p>如果是黄色，那么需要进行一次操作修改颜色：</p><ol start="2"><li>当<strong>j = 1</strong>时，第<strong>i</strong>片叶子应为黄色，第<strong>i - 1</strong>片叶子可以处于<strong>j = 0</strong>或<strong>j = 1</strong>的状态，所以取其中的较小值：</li></ol><p>$$<br>dp[i][1] = min(dp[i-1][1], dp[i-1][0]) + isRed(i)<br>$$</p><p>$$<br>isRed(i)=<br>\begin{cases}<br>1&amp; \text{leaves[i] = ‘r’}\\<br>0&amp; \text{leaves[i] = ‘y’}<br>\end{cases}<br>$$</p><p>​        如果是红色，那么需要进行一次操作修改颜色：</p><ol start="3"><li>当<strong>j = 2</strong>时，第<strong>i</strong>片叶子应为红色，第<strong>i - 1</strong>片叶子可以处于<strong>j = 2</strong>或<strong>j = 1</strong>的状态（不能取<strong>j = 0</strong>的状态，因为每种状态至少含有一片叶子，中间必须存在有黄色叶子），再取其中的较小值：</li></ol><p>$$<br>dp[i][2] = min(dp[i-1][2], dp[i-1][1]) + isYellow(i)<br>$$</p><p>如果是黄色，那么需要进行一次操作修改颜色，公式同1</p><p>最终答案为<code>dp[n-1][2]</code>。</p><p><strong><em>初始化条件：</em></strong></p><ol><li>要保证每种状态都有叶子，则叶子数量应大于等于状态数量，对于<code>dp[i][j]</code>，有<strong>i &gt;= j</strong>；如果<strong>i &lt; j</strong>，那么可以令<code>dp[i][j] = INT_MAX</code>；</li><li>对于<strong>i = 0</strong>，<strong>j</strong>也必须为0，于是有<code>dp[0][0] = isYellow(0)</code>。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">string</span> leaves)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(leaves.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = leaves[<span class="number">0</span>] == <span class="string">'y'</span>;</span><br><span class="line">        <span class="comment">// 不合要求的,实际上也不会遇到dp[0][2]这种情况</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">1</span>][<span class="number">2</span>] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; leaves.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> isYellow = leaves[i] == <span class="string">'y'</span>;</span><br><span class="line">            <span class="keyword">int</span> isRed = leaves[i] == <span class="string">'r'</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + isYellow;</span><br><span class="line">            dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]) + isRed;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>) dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + isYellow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[leaves.size() - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以优化空间，使用3个变量来代替状态转移数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">string</span> leaves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = leaves.size();</span><br><span class="line">        <span class="comment">// dp[0][0]</span></span><br><span class="line">        <span class="keyword">int</span> start = leaves[<span class="number">0</span>] == <span class="string">'y'</span>;</span><br><span class="line">        <span class="comment">// dp[0][1]</span></span><br><span class="line">        <span class="keyword">int</span> mid = INT_MAX;</span><br><span class="line">        <span class="comment">// dp[1][2]</span></span><br><span class="line">        <span class="keyword">int</span> last = INT_MAX;</span><br><span class="line">        <span class="comment">// 初始化转移变量</span></span><br><span class="line">        <span class="keyword">int</span> start2, mid2, last2 = INT_MAX, red = <span class="number">0</span>, yellow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            red = leaves[i] == <span class="string">'r'</span>;</span><br><span class="line">            yellow = leaves[i] == <span class="string">'y'</span>;</span><br><span class="line">            start2 = start + yellow;</span><br><span class="line">            mid2 = min(start, mid) + red;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>) last2 = min(mid, last) + yellow;</span><br><span class="line"></span><br><span class="line">            start = start2;</span><br><span class="line">            mid = mid2;</span><br><span class="line">            last = last2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://leetcode-cn.com/problems/UlBDOe/solution/qiu-xie-shou-cang-ji-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/UlBDOe/solution/qiu-xie-shou-cang-ji-by-leetcode-solution/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。&lt;br&gt;出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
