<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2021-01-08T01:50:35.445Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode435-无重叠区间</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/31/LeetCode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/31/LeetCode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</id>
    <published>2020-12-31T02:10:32.000Z</published>
    <updated>2021-01-08T01:50:35.445Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意</strong>:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><a id="more"></a><img src="/blog/2020/12/31/LeetCode435-无重叠区间/435.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先对二维数组排序，对其中的每个一维数组，先按照元素的第一个升序排列，如果第一个元素相同，再按照第二个升序排列。</p><p>如此一来，为了使移除的区间数最小，那么就需要<strong>从重叠的区间中选出右端点最小的一个</strong>，那样就可以尽可能留下更多不重叠的空间（所以说只按照第二个元素升序排列也是可以的）。</p><p>排序后，如果前一个数组的第二个元素在第二个数组范围之内，就留下前一个数组，用它把第二个数组覆盖；如果前一个数组第二个元素大于第二个数组的后一个元素，那么留下第二个数组，不用进行覆盖，但是前一个数组是需要移除的。这两种情况下，都需要移除操作。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) -&gt; <span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v1[<span class="number">0</span>] == v2[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> v1[<span class="number">1</span>] &lt; v2[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// sort(intervals.begin(), intervals.end());</span></span><br><span class="line">        <span class="comment">// for(auto &amp;v1 : intervals)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;v2 : v1)</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; v2 &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>] &amp;&amp; intervals[i - <span class="number">1</span>][<span class="number">1</span>] &lt;= intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                intervals[i][<span class="number">0</span>] = intervals[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                intervals[i][<span class="number">1</span>] = intervals[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>] &amp;&amp; intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>C++ STL sort作用于二维vector 效果和应用：</p><p><a href="https://blog.csdn.net/y625658683/article/details/104154089" target="_blank" rel="noopener">https://blog.csdn.net/y625658683/article/details/104154089</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>对于二维数组，<code>sort</code>是把<code>vector&lt;int&gt;</code>作为一个一维数组对象，整体进行比较和排序。</p><p>默认比较两个<code>int</code>向量的规则是：</p><p>从第一个元素开始比，第一个元素小的，整个向量就小，如果第一个元素一样，再比较第二个，第二个元素小的，整个向量小，依此类推。<code>sort</code>默认按从小到大排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;可以认为区间的终点总是大于它的起点。&lt;br&gt;区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1046-最后一块石头的重量</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/30/LeetCode1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/30/LeetCode1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/</id>
    <published>2020-12-30T01:58:07.000Z</published>
    <updated>2020-12-30T02:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><p>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；<br>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p><a id="more"></a><h4 id="思路及代码"><a href="#思路及代码" class="headerlink" title="思路及代码"></a>思路及代码</h4><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p>每次寻找最大的两个石头重量进行碰撞，直到链表为空或只剩下一个元素：</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stones.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> stones.empty() ? <span class="number">0</span> : stones[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">li</span><span class="params">(stones.begin(), stones.end())</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!li.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> it1 = max_element(li.begin(), li.end());</span><br><span class="line">            <span class="keyword">int</span> val1 = *it1;</span><br><span class="line">            li.erase(it1);</span><br><span class="line">            <span class="keyword">auto</span> it2 = max_element(li.begin(), li.end());</span><br><span class="line">            <span class="keyword">int</span> val2 = *it2;</span><br><span class="line">            <span class="keyword">if</span>(val2 != val1)</span><br><span class="line">                *it2 = <span class="built_in">abs</span>(val1 - val2);</span><br><span class="line">            <span class="keyword">else</span> li.erase(it2);</span><br><span class="line">            <span class="keyword">if</span>(li.size() == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> li.empty() ? <span class="number">0</span> : *li.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><h6 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h6><p>大顶堆，每次前两个出队元素就是石头中重量最大的两个。</p><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; p_q(stones.begin(), stones.end());</span><br><span class="line">        <span class="keyword">while</span>(!p_q.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p_q.size() == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> v1 = p_q.top();</span><br><span class="line">            p_q.pop();</span><br><span class="line">            <span class="keyword">int</span> v2 = p_q.top();</span><br><span class="line">            p_q.pop();</span><br><span class="line">            <span class="keyword">int</span> v = <span class="built_in">abs</span>(v1 - v2);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="number">0</span>) p_q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p_q.empty() ? <span class="number">0</span> : p_q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;有一堆石头，每块石头的重量都是正整数。&lt;/p&gt;
&lt;p&gt;每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，且 &lt;code&gt;x &amp;lt;= y&lt;/code&gt;。那么粉碎的可能结果如下：&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;x == y&lt;/code&gt;，那么两块石头都会被完全粉碎；&lt;br&gt;如果 &lt;code&gt;x != y&lt;/code&gt;，那么重量为 &lt;code&gt;x&lt;/code&gt; 的石头将会完全粉碎，而重量为 &lt;code&gt;y&lt;/code&gt; 的石头新重量为 &lt;code&gt;y-x&lt;/code&gt;。&lt;br&gt;最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="优先队列" scheme="http://www.xingyuzhao.ltd/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode330-按要求补齐数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/29/LeetCode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/29/LeetCode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-12-29T02:51:41.000Z</published>
    <updated>2020-12-29T14:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 <code>[1, n]</code> 区间内选取任意个数字补充到 $nums$ 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><a id="more"></a><img src="/blog/2020/12/29/LeetCode330-按要求补齐数组/330.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果区间 $[1,x)$ 的所有数都被覆盖了：</p><ul><li>如果$nums[i]\in[1,x)$，那么区间 $[1+nums[i],x+nums[i])$ 中所有数也会被覆盖。由于 $nums[i]\geq1$ ，则此时 $x\in[1+nums[i],x+nums[i])$，覆盖区间可以更新为 $[1,x+nums[i])$。</li><li>如果 $nums[i]$ 恰好等于 $x$ ，那么覆盖区间变为 $[1,x+nums[i])$。不需要补充 $x$ 。</li><li>否则，补充 $x$ ，则区间 $[1,x]$ 全部覆盖；并且可以得到覆盖区间 $[1+x,x+x)=[x+1,2x)$。两者取交集得到此时覆盖数字区间 $[1,2x)$，此时覆盖的数字最多（如果取小于 $x$ 的数，覆盖区间会变小，这是不希望看到的， $x$ 不能取两次，每个数字只能取一次）。</li><li>当 $x&gt;n$ 时，就可以结束了。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始区间为空，表示已经覆盖</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; nums.size() &amp;&amp; nums[index] &lt; x)&#123;</span><br><span class="line">                x += nums[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; nums.size() &amp;&amp; nums[index] == x)&#123;</span><br><span class="line">                x += nums[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 &lt;code&gt;[1, n]&lt;/code&gt; 区间内选取任意个数字补充到 $nums$ 中，使得 &lt;code&gt;[1, n]&lt;/code&gt; 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode309-最佳买卖股票时机含冷冻期</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</id>
    <published>2020-12-28T13:43:28.000Z</published>
    <updated>2020-12-28T14:39:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组，其中第 $i$ 个元素代表了第 $i$ 天的股票价格 。</p><ul><li><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p></li><li><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p></li></ul><a id="more"></a><img src="/blog/2020/12/28/LeetCode309-最佳买卖股票时机含冷冻期/309.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题与其他股票问题不同之处在于<strong>卖出之后至少间隔一天才能够买入</strong>，可以多次买入卖出。</p><h5 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h5><p>$dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益。</p><p>$dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。</p><h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul><li><p>如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：<br>$$<br>dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])<br>$$</p></li><li><p>如果当天持有股票，那么前一天可以持有股票或者前两天未持有股票，当天买入（如果前一天持有且卖出股票，当天就不能买入了；前一天如果未持有且没有卖出股票，就与前两天未持有，当天买入等价了）：<br>$$<br>dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i])<br>$$</p></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。假设有第零天，那么收益应也为 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">-1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 用dp_0 = 0代替</span></span><br></pre></td></tr></table></figure><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp_0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], (i - <span class="number">2</span> &lt; <span class="number">0</span> ? dp_0 : dp[i - <span class="number">2</span>][<span class="number">0</span>]) - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h5><p>由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(profit1, profit - prices[i]);</span><br><span class="line">            profit = profit0;</span><br><span class="line">            profit0 = new0;</span><br><span class="line">            profit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href>LeetCode121-买卖股票的最佳时机</a></p><p><a href>LeetCode122-买卖股票的最佳时机II</a></p><p><a href>LeetCode122-买卖股票的最佳时机III</a></p><p><a href>LeetCode122-买卖股票的最佳时机 IV</a></p><p><a href>LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href>LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个整数数组，其中第 $i$ 个元素代表了第 $i$ 天的股票价格 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;br&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode121-买卖股票的最佳时机</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2020-12-28T12:55:32.000Z</published>
    <updated>2020-12-28T14:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p><strong>注意</strong>：你不能在买入股票前卖出股票。</p><a id="more"></a><img src="/blog/2020/12/28/LeetCode121-买卖股票的最佳时机/121.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h5><h6 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h6><p>从前往后遍历找到最小的价格买入，再往后找到最大的价格卖出即可。</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        st.push(prices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt;= st.top())</span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> m = prices[i] - st.top();</span><br><span class="line">                res = res &gt; m ? res : m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>本题是<a href>LeetCode122-买卖股票的最佳时机II</a>的简化版，这道题与其最大的区别在于限制交易次数为 <strong>一次</strong>，找到最小的起点之后，再去找最大的终点即可。</p><h6 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h6><p>$dp[i][0]$ 表示第 $i$ 天不持有股票可获得的最大收益。</p><p>$dp[i][1]$ 表示第 $i$ 天持有股票可获得的最大收益。</p><h6 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h6><ul><li><p>如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：<br>$$<br>dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])<br>$$</p></li><li><p>如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入（只能持有一次，所以第一次持有时的利润为$-prices[i]$）：<br>$$<br>dp[i][1]=max(dp[i-1][1],-prices[i])<br>$$</p></li></ul><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h6><p>由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(profit1, -prices[i]);</span><br><span class="line">            profit0 = new0;</span><br><span class="line">            profit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href>LeetCode121-买卖股票的最佳时机</a></p><p><a href>LeetCode122-买卖股票的最佳时机II</a></p><p><a href>LeetCode122-买卖股票的最佳时机III</a></p><p><a href>LeetCode122-买卖股票的最佳时机 IV</a></p><p><a href>LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href>LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你不能在买入股票前卖出股票。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
      <category term="栈" scheme="http://www.xingyuzhao.ltd/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode123-买卖股票的最佳时机III</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/</id>
    <published>2020-12-28T12:37:14.000Z</published>
    <updated>2020-12-28T14:48:14.080Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意</strong>: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><a id="more"></a><img src="/blog/2020/12/28/LeetCode123-买卖股票的最佳时机III/123.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题是<a href>LeetCode122-买卖股票的最佳时机II</a>的升级版，这道题与其最大的区别在于限制交易次数为 <strong>两次</strong>，所以选择哪两次交易至关重要。</p><h5 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h5><p>需要记录当前还剩下多少次交易次数，还有当天是否持有股票（ $k=0,1,2$ ）。</p><p>$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。</p><p>$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。</p><h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul><li><p>第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：<br>$$<br>dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);<br>$$</p></li><li><p>第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：<br>$$<br>dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);<br>$$</p></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剩余交易i次，获得收益初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">2</span> + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span> + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = max(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = max(dp[j][<span class="number">1</span>], dp[j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href>LeetCode121-买卖股票的最佳时机</a></p><p><a href>LeetCode122-买卖股票的最佳时机II</a></p><p><a href>LeetCode122-买卖股票的最佳时机III</a></p><p><a href>LeetCode122-买卖股票的最佳时机 IV</a></p><p><a href>LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href>LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 &lt;strong&gt;两笔&lt;/strong&gt; 交易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode122-买卖股票的最佳时机II</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</id>
    <published>2020-12-28T08:20:58.000Z</published>
    <updated>2020-12-28T14:47:49.366Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><a id="more"></a><img src="/blog/2020/12/28/LeetCode122-买卖股票的最佳时机II/122.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h5><h6 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h6><p>本题要求尽可能地完成更多地交易，所以可以使用贪心策略，在局部价格最低时买入，在局部价格最高时卖出，重复此操作直到最后一天，最后一天不持有股票时收益最大。</p><ul><li>局部最低：如果后一天价格低于前一天价格，更新局部最低，否则已经是局部最低</li><li>局部最高：在持有股票后，当前价格的下一天价格降低，说明已经达到局部最高</li></ul><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt;= val) &#123;</span><br><span class="line">                val = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; prices.size() &amp;&amp; prices[i + <span class="number">1</span>] &lt; prices[i])&#123;</span><br><span class="line">                    res += prices[i] - val;</span><br><span class="line">                    val = prices[i + <span class="number">1</span>];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 最后一天如果还持有股票应该卖出</span></span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> == prices.size())&#123;</span><br><span class="line">                    res += prices[i] - val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="另一种策略"><a href="#另一种策略" class="headerlink" title="另一种策略"></a>另一种策略</h6><p>把股票的交易价格看成曲线图，找出图中上升的部分，即为交易获利。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size()<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; prices[i + <span class="number">1</span>])</span><br><span class="line">            sum += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><h6 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h6><p>每天的状态可以为持有股票或不持有股票，所以使用 $dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益； $dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。本题交易次数 <strong>+∞</strong> 。</p><h6 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h6><ul><li><p>如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：<br>$$<br>dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])<br>$$</p></li><li><p>如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入：<br>$$<br>dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])<br>$$</p></li></ul><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h6><p>由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(profit1, profit0 - prices[i]);</span><br><span class="line">            profit0 = new0;</span><br><span class="line">            profit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href>LeetCode121-买卖股票的最佳时机</a></p><p><a href>LeetCode122-买卖股票的最佳时机II</a></p><p><a href>LeetCode122-买卖股票的最佳时机III</a></p><p><a href>LeetCode122-买卖股票的最佳时机 IV</a></p><p><a href>LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href>LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode188-买卖股票的最佳时机IV</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/</id>
    <published>2020-12-28T08:19:36.000Z</published>
    <updated>2020-12-28T14:40:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><a id="more"></a><img src="/blog/2020/12/28/LeetCode188-买卖股票的最佳时机IV/188.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题是<a href>LeetCode122-买卖股票的最佳时机II</a>的升级版，这道题与其最大的区别在于限制交易次数为 <strong>k</strong> 次，所以选择在何时交易至关重要。</p><p>因为买入卖出至少得两天，所以最大的交易次数不会超过 $prices.size()/2$ 。如果 $k\geq{prices.size()/2}$ ，那么本题就退化为122题。</p><h5 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h5><p>需要记录当前还剩下多少次交易次数，还有当天是否持有股票。</p><p>$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。</p><p>$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。</p><h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul><li><p>第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：<br>$$<br>dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);<br>$$</p></li><li><p>第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：<br>$$<br>dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);<br>$$</p></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剩余交易i次，获得收益初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在没有进行股票交易时不允许持有股票</span></span><br><span class="line"><span class="comment">// 这个系列中没有用到，记录学习一下</span></span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = -INF;</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -INF;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.size() / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxprofit(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)))</span></span>;</span><br><span class="line">        <span class="comment">// 最多交易i次，获得的收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="comment">// 第i天不持有，前一天不持有或前一天持有今天卖出</span></span><br><span class="line">                dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">// 第i天持有，前一天持有或前一天不持有今天买入</span></span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxprofit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(profit1, profit0 - prices[i]);</span><br><span class="line">            profit0 = new0;</span><br><span class="line">            profit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.size() / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxprofit(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 最多交易i次，获得的收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="comment">// 第i天不持有，前一天不持有或前一天持有今天卖出</span></span><br><span class="line">                dp[j][<span class="number">0</span>] = max(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">// 第i天持有，前一天持有或前一天不持有今天买入</span></span><br><span class="line">                dp[j][<span class="number">1</span>] = max(dp[j][<span class="number">1</span>], dp[j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxprofit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(fit0, fit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(fit1, fit0 - prices[i]);</span><br><span class="line">            fit0 = new0;</span><br><span class="line">            fit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href>LeetCode121-买卖股票的最佳时机</a></p><p><a href>LeetCode122-买卖股票的最佳时机II</a></p><p><a href>LeetCode122-买卖股票的最佳时机III</a></p><p><a href>LeetCode122-买卖股票的最佳时机 IV</a></p><p><a href>LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href>LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;prices&lt;/code&gt; ，它的第 &lt;code&gt;i&lt;/code&gt; 个元素 &lt;code&gt;prices[i]&lt;/code&gt; 是一支给定的股票在第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 &lt;strong&gt;k&lt;/strong&gt; 笔交易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode205-同构字符串</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/27/LeetCode205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/27/LeetCode205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-12-27T02:29:59.000Z</published>
    <updated>2020-12-27T02:36:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，判断它们是否是同构的。</p><p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong><em>t</em></strong> ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p>本题是<a href="http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more">LeetCode290-单词规律</a>的简化版。</p><a id="more"></a><img src="/blog/2020/12/27/LeetCode205-同构字符串/205.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>与<a href="http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more">LeetCode290-单词规律</a>基本一致。</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>此题字母大小写均可，数组初始化时为0，每对字符都应唯一映射为同一个数。如果两个数不同，返回<code>false</code>，否则返回<code>true</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; map1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; map2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            map1[s[i]].insert(t[i]);</span><br><span class="line">            map2[t[i]].insert(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(map1[s[i]].size() &gt; <span class="number">1</span> || map2[t[i]].size() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> map1[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> map2[<span class="number">256</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1[s[i]] != map2[t[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            map1[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            map2[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解评论区：</p><p><a href="https://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt;，判断它们是否是同构的。&lt;/p&gt;
&lt;p&gt;如果 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 中的字符可以被替换得到 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt; ，那么这两个字符串是同构的。&lt;/p&gt;
&lt;p&gt;所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。&lt;/p&gt;
&lt;p&gt;本题是&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more&quot;&gt;LeetCode290-单词规律&lt;/a&gt;的简化版。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.xingyuzhao.ltd/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode85-最大矩形</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/26/LeetCode85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/26/LeetCode85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</id>
    <published>2020-12-26T10:46:28.000Z</published>
    <updated>2020-12-26T12:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p>本题与<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LeetCode84-柱状图中最大的矩形</a>基本一致。</p> <a id="more"></a><img src="/blog/2020/12/26/LeetCode85-最大矩形/85.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如图，使坐标值竖向移动，求出每个坐标轴下的矩形最大面积，再从中取最大值就是最大的矩形：</p><img src="/blog/2020/12/26/LeetCode85-最大矩形/坐标轴.png" style="zoom:80%;"><p>很明显在图三中得到最大矩形，面积为6。求当前坐标轴下的最大矩形面积与<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/c-dan-diao-zhan-si-lu-qing-xi-you-tu-you-ip3c/" target="_blank" rel="noopener">LeetCode84-柱状图中最大的矩形</a>方法一致。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preHeights;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heights;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    heights.push_back(matrix[i][j] - <span class="string">'0'</span>);    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>) </span><br><span class="line">                        heights.push_back(preHeights[j] + matrix[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        heights.push_back(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            preHeights = heights;</span><br><span class="line">            res = max(res, maxArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;heights)</span></span>&#123;</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> mArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()])&#123;</span><br><span class="line">                <span class="keyword">int</span> v = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> right = i;</span><br><span class="line">                <span class="keyword">int</span> left = st.empty() ? <span class="number">0</span> : st.top() + <span class="number">1</span>;</span><br><span class="line">                area = heights[v] * (right - left);</span><br><span class="line">                mArea = max(mArea, area);</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>评论区：<a href="https://leetcode-cn.com/problems/maximal-rectangle/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-rectangle/comments/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个仅包含 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 、大小为 &lt;code&gt;rows x cols&lt;/code&gt; 的二维二进制矩阵，找出只包含 &lt;code&gt;1&lt;/code&gt; 的最大矩形，并返回其面积。&lt;/p&gt;
&lt;p&gt;本题与&lt;a href=&quot;https://leetcode-cn.com/problems/largest-rectangle-in-histogram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode84-柱状图中最大的矩形&lt;/a&gt;基本一致。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="单调栈" scheme="http://www.xingyuzhao.ltd/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode84-柱状图中最大的矩形</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/26/LeetCode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/26/LeetCode84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</id>
    <published>2020-12-26T08:09:01.000Z</published>
    <updated>2020-12-27T12:22:05.018Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><a id="more"></a><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/84.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>找到当前高度下的最大矩形面积，然后从所有得到的面积中挑出最大的那一个就是能够勾勒出来矩形的最大面积，如下：</p><ol><li>第1个高度，当前面积为2。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-1.png"><ol start="2"><li>第2个高度，当前面积为6。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-2.png"><ol start="3"><li>第3个高度，当前面积为10。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-3.png"><ol start="4"><li>第4个高度，当前面积为6。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-4.png"><ol start="5"><li>第5个高度，当前面积为8。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-5.png"><ol start="6"><li>第6个高度，当前面积为3。</li></ol><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-6.png"><p>综上，面积最大出现在第三个高度，此时面积为5。</p><p>我们需要找到当前高度下可以构成矩形的左边界和右边界，再去计算矩形的面积，使用单调栈来实现：</p><ul><li><p>计算高度：如果当前高度小于栈顶元素，此时的栈顶就是上一次高度的最大值（准确一点，是上一次高度最大值的坐标），将其记录并出栈，这时候就可以计算上一个高度面积的最大值了，直到遇到栈顶元素小于等于当前元素或者栈为空，在此之前会一直计算高度</p></li><li><p>寻找边界：当前遍历到的坐标 $i$ 就是右边界，左边界就是 $st.top()+1$（对于示例，当遍历到第二个2时，坐标为4，作为<strong>右边界</strong>；经过一系列的出栈操作，栈中<strong>最后剩下</strong>的元素坐标为1，而<strong>左边界</strong>就应该是<strong>1+1​</strong>而不是1），<strong>如果栈为空，那么左边界就是0</strong>。如下图：</p></li></ul><img src="/blog/2020/12/26/LeetCode84-柱状图中最大的矩形/示例-边界.png"><p>所以为了提供坐标6，还需要给高度矩阵后面续上一个0。</p><p>由于找到了下一个小于栈顶高度的值时才会计算面积，所以对于示例，最后得到的结果及顺序如下：</p><table><thead><tr><th align="center">坐标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th></tr></thead><tbody><tr><td align="center">高度</td><td align="center">2</td><td align="center">1</td><td align="center">5</td><td align="center">6</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">当前坐标最大面积</td><td align="center">2</td><td align="center">6</td><td align="center">10</td><td align="center">6</td><td align="center">8</td><td align="center">3</td></tr><tr><td align="center">面积出现的顺序</td><td align="center">1</td><td align="center">6</td><td align="center">3</td><td align="center">2</td><td align="center">5</td><td align="center">4</td></tr></tbody></table><p>即，真正得到的面积结果为<code>2, 6, 10, 3, 8, 6</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> mArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()])&#123;</span><br><span class="line">                <span class="keyword">int</span> v = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> right = i;</span><br><span class="line">                <span class="keyword">int</span> left = st.empty() ? <span class="number">0</span> : st.top() + <span class="number">1</span>;</span><br><span class="line">                area = heights[v] * (right - left);</span><br><span class="line">                mArea = max(mArea, area);</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>CSDN：<a href="https://blog.csdn.net/Zolewit/article/details/88863970" target="_blank" rel="noopener">https://blog.csdn.net/Zolewit/article/details/88863970</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;/p&gt;
&lt;p&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="单调栈" scheme="http://www.xingyuzhao.ltd/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode365-水壶问题</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-25T14:44:59.000Z</published>
    <updated>2020-12-27T12:23:01.343Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有两个容量分别为 <code>x</code> 升和 <code>y</code> 升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <code>z</code> 升的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <code>z</code> 升水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul><a id="more"></a><img src="/blog/2020/12/25/LeetCode365-水壶问题/365.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题实际上是一个数学问题，需要有先验知识——<a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&fromid=5185441" target="_blank" rel="noopener">贝祖定理</a>：若 $a, b$ 是整数，且$gcd(a,b)=d$，那么对于任意的整数 $x$$，y$，$ax+by$ 都一定是 $d$ 的倍数，特别地，一定存在整数 $x$,  $y$，使 $ax+by=d$ 成立。$gcd(a,b)$ 用来求 $a, b$ 的最大公约数，称为辗转相除法。</p><p>实际上，每次操作只会让桶里的水增加<code>x</code>或增加<code>y</code>，减少<code>x</code>或减少<code>y</code>，两个桶不可能同时有水且不满，观察所有的操作都至少有一个桶是空的或满的。如果往一个不满的桶里加水或将其倒空是没有意义的，这是因为：</p><ul><li>向有水且不满的桶加水是没有意义的：<ul><li>另一个桶满，加水等价于从初始状态给两个桶加满水</li><li>另一个桶空，加水等价于将不满的桶加满</li></ul></li><li>将有水且不满的桶倒掉是没有意义的：<ul><li>另一个桶满，倒水等价于从初始状态给另一个桶加满水</li><li>另一个桶空，倒水等价于两个桶都没水，回到初始状态</li></ul></li></ul><p>所以每次操作只会给水的总量带来<code>x</code>或<code>y</code>的变化量，所以目标为找到一组 $a, b$ ，满足：<br>$$<br>ax+by=z<br>$$<br>根据贝祖定理，当且仅当<code>z</code>是  $a, b$ 最大公约数倍数时，有解。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b) swap(a, b);</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x + y &lt; z) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> z == <span class="number">0</span> || x + y == z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(z % gcd(x, y) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：</p><p><a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/</a></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>要满足$z\le{x+y}$，且这样的 $a, b$ 存在，目标就可以达成，是因为：</p><ul><li><p>若 $a\ge0, b\ge0$时，可以达成</p></li><li><p>若 $a&lt;0$ ，那么执行以下操作：</p><ul><li>将<code>y</code>壶倒满</li><li>将<code>y</code>壶中水倒入<code>x</code>壶</li><li>如果<code>y</code>不为空，那么<code>x</code>肯定是满的，把<code>x</code><strong>倒空</strong>，再把<code>y</code>剩下的倒入<code>x</code>壶</li></ul><p>重复以上操作直到某一步<code>x</code>壶进行了 $a$ 次倒空，<code>y</code>壶进行了 $b$ 次倒水操作。</p></li><li><p>若 $b&lt;0$，方法同上，<code>x</code>与<code>y</code>互换。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;有两个容量分别为 &lt;code&gt;x&lt;/code&gt; 升和 &lt;code&gt;y&lt;/code&gt; 升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 &lt;code&gt;z&lt;/code&gt; 升的水？&lt;/p&gt;
&lt;p&gt;如果可以，最后请用以上水壶中的一或两个来盛放取得的 &lt;code&gt;z&lt;/code&gt; 升水。&lt;/p&gt;
&lt;p&gt;你允许：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装满任意一个水壶&lt;/li&gt;
&lt;li&gt;清空任意一个水壶&lt;/li&gt;
&lt;li&gt;从一个水壶向另外一个水壶倒水，直到装满或者倒空&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数学" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode12-整数转罗马数字</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2020-12-25T13:20:32.000Z</published>
    <updated>2020-12-27T12:24:34.507Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><img src="/blog/2020/12/25/LeetCode12-整数转罗马数字/12.png"><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>主要是处理那些特殊的样例，结合代码，对于示例中的1994，去掉1000后还剩下994，这个900的表示是特殊的，所以如果当前 $num$ 范围是900-999，就需要加上”CM”；$num$ 还剩下94，这个90也是特殊的，所以如果当前 $num$ 范围是90-99，就需要加上”XC”；最后剩下4，所以加上”IV”，得到结果”MCMXCIV”。</p><p><strong>需要注意<code>if</code>语句的顺序不能改变，就像状态机一样，执行完一个状态后才能执行下一个状态</strong>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前面几行针对特定案例，注释了也不影响</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">4</span>) <span class="keyword">return</span> <span class="string">"IV"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">9</span>) <span class="keyword">return</span> <span class="string">"IX"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">40</span>) <span class="keyword">return</span> <span class="string">"XL"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">90</span>) <span class="keyword">return</span> <span class="string">"XC"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">400</span>) <span class="keyword">return</span> <span class="string">"CD"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">900</span>) <span class="keyword">return</span> <span class="string">"CM"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num / <span class="number">1000</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">1000</span>, <span class="string">'M'</span>);</span><br><span class="line">                num -= num / <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">900</span> &amp;&amp; num &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">                res += <span class="string">"CM"</span>;</span><br><span class="line">                num -= <span class="number">900</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">500</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">500</span>, <span class="string">'D'</span>);</span><br><span class="line">                num -= num / <span class="number">500</span> * <span class="number">500</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">400</span> &amp;&amp; num &lt; <span class="number">500</span>)&#123;</span><br><span class="line">                res += <span class="string">"CD"</span>;</span><br><span class="line">                num -= <span class="number">400</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">100</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">100</span>, <span class="string">'C'</span>);</span><br><span class="line">                num -= num / <span class="number">100</span> * <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">90</span> &amp;&amp; num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                res += <span class="string">"XC"</span>;</span><br><span class="line">                num -= <span class="number">90</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">50</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">50</span>, <span class="string">'L'</span>);</span><br><span class="line">                num -= num / <span class="number">50</span> * <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt;= <span class="number">40</span> &amp;&amp; num &lt; <span class="number">50</span>)&#123;</span><br><span class="line">                res += <span class="string">"XL"</span>;</span><br><span class="line">                num -= <span class="number">40</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">10</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">10</span>, <span class="string">'X'</span>);</span><br><span class="line">                num -= num / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">9</span>)&#123;</span><br><span class="line">                res += <span class="string">"IX"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">5</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">5</span>, <span class="string">'V'</span>);</span><br><span class="line">                num -= num / <span class="number">5</span> * <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">4</span>)&#123;</span><br><span class="line">                res += <span class="string">"IV"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num / <span class="number">1</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">string</span>(num / <span class="number">1</span>, <span class="string">'I'</span>);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;罗马数字包含以下七种字符： &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;/blog/2020/12/25/LeetCode12-整数转罗马数字/12.png&quot;&gt;

&lt;p&gt;例如， 罗马数字 2 写做 &lt;code&gt;II&lt;/code&gt; ，即为两个并列的 1。12 写做 &lt;code&gt;XII&lt;/code&gt; ，即为 &lt;code&gt;X&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。 27 写做  &lt;code&gt;XXVII&lt;/code&gt;, 即为 &lt;code&gt;XX&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 &lt;code&gt;IIII&lt;/code&gt;，而是 &lt;code&gt;IV&lt;/code&gt;。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 &lt;code&gt;IX&lt;/code&gt;。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; 可以放在 &lt;code&gt;V&lt;/code&gt; (5) 和 &lt;code&gt;X&lt;/code&gt; (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; 可以放在 &lt;code&gt;L&lt;/code&gt; (50) 和 &lt;code&gt;C&lt;/code&gt; (100) 的左边，来表示 40 和 90。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt; 可以放在 &lt;code&gt;D&lt;/code&gt; (500) 和 &lt;code&gt;M&lt;/code&gt; (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="状态机" scheme="http://www.xingyuzhao.ltd/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>内存管理（三）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/25/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/25/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-12-25T08:17:08.000Z</published>
    <updated>2021-01-07T16:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>基本分页存储管理的基本概念</li><li>基本地址变换机构</li><li>具有快表的地址变换机构</li><li>基本分段存储管理方式</li><li>段页式管理方式</li></ol><a id="more"></a><h4 id="基本分页存储管理的基本概念"><a href="#基本分页存储管理的基本概念" class="headerlink" title="基本分页存储管理的基本概念"></a>基本分页存储管理的基本概念</h4><h5 id="连续分配方式的缺点"><a href="#连续分配方式的缺点" class="headerlink" title="连续分配方式的缺点"></a>连续分配方式的缺点</h5><ol><li>固定分区分配：内存利用率低，会产生大量的内部碎片。</li><li>动态分区分配：会产生很多外部碎片，可以通过“紧凑”处理，但代价很高。</li></ol><p>如果允许将一个程序分散的装入到许多不相邻的分区中，便可充分利用内存——非连续分配方式（离散分配方式）。</p><h5 id="基本分页存储管理思想"><a href="#基本分页存储管理思想" class="headerlink" title="基本分页存储管理思想"></a>基本分页存储管理思想</h5><p>把内存分为一个个相等的小分区，再按照分区大小把进程拆分为一个个小部分。</p><p><em>如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高</em>。</p><h5 id="分页存储的基本概念"><a href="#分页存储的基本概念" class="headerlink" title="分页存储的基本概念"></a>分页存储的基本概念</h5><p><strong>页框</strong>：将内存空间分为一个个<strong>大小相等的分区</strong>，每个分区就是一个页框，也称为”页帧“、”内存块“、”物理块“。</p><p><strong>页框号</strong>：每个页框的编号，其他名称同上。从0开始。</p><p><strong>页</strong>：将用户进程的地址空间分为<strong>与页框大小相等</strong>的一个个区域，称为”页“或者”页面“。</p><p><strong>页号</strong>：每个页面的编号，也是从0开始。</p><p>操作系统<strong>以页框为单位为各个进程分配</strong>内存空间。进程的<strong>页面</strong>与内存的<strong>页框</strong>有<strong>一一对应</strong>的关系。</p><h5 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h5><h6 id="进程在内存中连续存放"><a href="#进程在内存中连续存放" class="headerlink" title="进程在内存中连续存放"></a>进程在内存中连续存放</h6><p>重定位寄存器：存放装入模块的起始位置。</p><p>思想：模块在内存中的“起始地址” + 目标内存单元相对于起始位置的“偏移量”。</p><h6 id="进程在内存中非连续存放"><a href="#进程在内存中非连续存放" class="headerlink" title="进程在内存中非连续存放"></a>进程在内存中非连续存放</h6><img src="/blog/2020/12/25/内存管理（三）/进程在内存中非连续存放.png" style="zoom:80%;"><p>如何计算进程在内存中的存放位置？</p><ol><li><p>计算出逻辑地址对应的页号：<br>$$<br>页号=逻辑地址/页面长度（取整）<br>$$</p></li><li><p>该页号对应页面在内存中的起始位置： 操作系统的某种数据结构记录</p></li><li><p>逻辑地址在页面内的偏移量：<br>$$<br>页内偏移量=逻辑地址%页面长度<br>$$</p></li><li><p>物理地址 = 页面地址+ 页内偏移量</p></li></ol><p>对于逻辑地址为80的内存单元：</p><ol><li>在1号页 : $80 / 50 = 1$</li><li>该页在内存中的起始地址为450</li><li>内存单元相对于该页起始地址偏移量为 $80%50=30$</li><li>实际物理地址为 $450+30=480$</li></ol><p>为了方便计算页号、页内偏移量，<strong>页面大小</strong>一般取<strong>2的整数幂</strong>。</p><p>假设用32个二进制位表示逻辑地址，页面大小为 $2^{12}B=4096B=4KB$。</p><ul><li><p>0号页逻辑地址空间为0~4095，用二进制表示为：</p><p><code>0000_0000_0000_0000_0000_0000_0000_0000~0000_0000_0000_0000_0000_1111_1111_1111</code></p></li><li><p>1号页逻辑地址空间为4096~8191，用二进制表示为：</p><p><code>0000_0000_0000_0000_0001_0000_0000_0000~0000_0000_0000_0000_0001_1111_1111_1111</code></p></li><li><p>2号页逻辑地址空间为4096~8191，用二进制表示为：</p><p><code>0000_0000_0000_0000_0010_0000_0000_0000~0000_0000_0000_0000_0010_1111_1111_1111</code></p></li></ul><p>eg：逻辑地址4097，用二进制表示为：<code>0000_0000_0000_0000_0001_0000_0000_0001</code>。</p><p>若1号页在内存中的起始地址为X，则逻辑地址4097对应的物理地址为：<code>X+0000_0000_0001</code>。</p><p>结论：</p><p>如果每个页面大小为 $2^KB$，用二进制数表示逻辑地址，则末尾的 $K$ 位为<strong>页内偏移量</strong>，其余部分就是<strong>页号</strong>。所以让<strong>每个页面的大小为2的整数幂</strong>。</p><h6 id="分页存储管理的逻辑地址结构"><a href="#分页存储管理的逻辑地址结构" class="headerlink" title="分页存储管理的逻辑地址结构"></a>分页存储管理的逻辑地址结构</h6><img src="/blog/2020/12/25/内存管理（三）/分页存储管理的逻辑地址结构.png"><p><strong>如果有 $K$ 位表示“页内偏移量”，则说明系统中一个页面的大小是 $2^K$ 个内存单元</strong>。</p><p><strong>如果有 $M$ 位表示“页号”，则说明在该系统中，一个进程最多允许有 $2^M$ 个页面</strong>。</p><h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为<strong>每个进程建立一张页表</strong>。</p><img src="/blog/2020/12/25/内存管理（三）/页表.png"><p>上述的第五条，是因为：</p><p>假设内存大小位4GB，页面大小位4KB，则每个页表项至少为多少个字节？</p><p>$4GB=2^{32}B$</p><p>$4KB=2^{12}B$</p><p> $4GB$ 内存会被划分为 $2^{32}/2^{12}=2^{20}$ 个内存块，所以内存块号的范围是 $0\sim2^{20}-1$ ，所以至少需要20个二进制位才能表示内存块号，即至少需要3个字节。</p><p>各页表项会<strong>按顺序且连续的</strong>存在在内存中，如果该页表在内存中存放的起始位置为X，则M号页对应的页表项一定是存放在内存地址为 $X+3*M$ 处。</p><p>因此，只需要知道<strong>页表存放的起始位置</strong>和<strong>页表项长度</strong>。即可找到各个页号对应的页表项存放的位置。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/25/内存管理（三）/分页存储管理小结.png"><h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h4><p>用于实现逻辑地址到物理地址转换的一组硬件机构。</p><p>在<strong>系统中</strong>设置一个<strong>页表寄存器（PTR）</strong>，存放：</p><ul><li>页表在内存中的起始地址F</li><li>页表长度M</li></ul><p>进程还未执行时，上述两个参数存放在<strong>进程控制块（PCB）</strong>中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。<strong>页面大小是2的整数幂</strong>。</p><h5 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h5><p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><img src="/blog/2020/12/25/内存管理（三）/逻辑地址2物理地址.png"><ol><li>计算页号P和页内偏移量W</li><li>比较页号P和页表长度M，若 $P\geq{M}$ ，则产生越界</li><li>页表中页号P对应的 $页表项地址=页表起始地址F+页号P\times页表项长度M$ ，取出该页表项内容b即为内存块号</li><li>计算 $E=b\times L+W$，用得到的物理地址E去访问内存</li></ol><p><strong>注意</strong>：</p><ul><li>页表长度：当前页表中总共有几个页表项，即总共有几个页（用户进程）</li><li>页表项长度：每个页表项占多大的存储空间</li><li>页面大小：一个页面占多大的存储空间（与页框大小一致，用户进程）</li></ul><h5 id="一个例题"><a href="#一个例题" class="headerlink" title="一个例题"></a>一个例题</h5><p>若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</p><p>等价描述：某系统<strong>按字节寻址</strong>，逻辑地址结构中，<strong>页内偏移量占10位</strong>（说明一个页面的大小位2^10B=1KB），页号2对应的内存块号b=8，将逻辑地址A=2500转换位物理地址E。</p><ol><li>计算页号P、页内偏移量W</li></ol><p>$$<br>P=A/L=2500/1024=2\\<br>W=A%L=2500%1024=452<br>$$</p><ol start="2"><li>页号2没有越界，存放内存块号为b=8</li><li>计算物理地址E</li></ol><p>$$<br>E=b\times L+W=8\times 1024+425=8644<br>$$</p><p>分页式存储管理系统中，只要确定每个页面的大小，逻辑地址结构就确定了。因此，<strong>页式管理中地址是一维的</strong>。即，只要给出逻辑地址，系统会自动算出页号、页内偏移量，<strong>不需要</strong>显示的告诉系统页内偏移量占多少位。</p><h5 id="对页表项大小的进一步探讨"><a href="#对页表项大小的进一步探讨" class="headerlink" title="对页表项大小的进一步探讨"></a>对页表项大小的进一步探讨</h5><p>之前说过一个页表项占据3B的内存，如果一个页面为4KB，则每个页框可以存放4096/3=1365个页表项，则会剩下4096%3=1B的页内碎片，如果<strong>每个页表项占4个字节</strong>，则每个页框刚好可存放1024个页表项。</p><p>除此之外，如果<strong>每个页表项占据3个字节</strong>，则1365号页表项地址为 $X+3\times1365+1$。如果<strong>每个页表项占4个字节</strong>，则1024号页表项地址为 $X+4\times1024$，更方便计算。</p><p>理论上，页表项长度为3B即可表示内存块号的范围，但是<strong>为了方便页表查询，常常会让一个页表项占据更多的字节，使得每个页面恰好可以装得下整数个页表项</strong>。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/25/内存管理（三）/基本地址变换机构.png"><h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h4><p>基本地址变换机构的改进版本。</p><h5 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h5><ul><li>时间局部性：如果程序执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很有可能再次被访问（程序中一般存在大量循环）。</li><li>空间局部性：如果程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（数据在内存中连续存放）。</li></ul><p>之前提到的<strong>基本地址变换机构</strong>中，每访问一个逻辑地址，都<strong>需要查询内存中的页表</strong>。由于局部性原理，可能<strong>连续很多次查到的都是同一个页表项</strong>。可以利用这个特性减少访问页表的次数。</p><h5 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h5><p>也称联想寄存器（TLB），是一种<strong>访问速度比内存快很多</strong>的<strong>高速缓冲存储器</strong>，存储当前访问的若页表项，加速地址变换过程。相对应的<strong>内存</strong>中的页表称为<strong>慢表</strong>。</p><h5 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h5><img src="/blog/2020/12/25/内存管理（三）/引入快表后的地址变换过程.png"><ol><li>CPU给出逻辑地址，由<strong>硬件</strong>得到页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>找到匹配的页号，直接从<strong>快表</strong>中取出该页对应的内存块号，将内存块号和页内偏移量拼接成物理地址，再访问该物理地址对应的内存单元。因此<strong>快表命中</strong>，访问某个逻辑地址仅需<strong>一次访存</strong>。</li><li>未找到匹配的页号，访问<strong>内存中的页表</strong>，找到对应页表项，根据页表项得到页面存放的内存块号，再将内存块号和页内偏移量拼接得到物理地址，再根据物理地址访问对应的内存单元。因此<strong>快表未命中</strong>，访问某个逻辑地址需要<strong>两次访存</strong>（找到页表项后，同时将其<strong>存入快表</strong>，若快表已满，则按照一定算法对旧的页表进行替换）。</li></ol><p>由于局部性原理，快表命中率可达**90%**以上。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/25/内存管理（三）/快表小结.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;基本分页存储管理的基本概念&lt;/li&gt;
&lt;li&gt;基本地址变换机构&lt;/li&gt;
&lt;li&gt;具有快表的地址变换机构&lt;/li&gt;
&lt;li&gt;基本分段存储管理方式&lt;/li&gt;
&lt;li&gt;段页式管理方式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分页存储" scheme="http://www.xingyuzhao.ltd/tags/%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode455-分发饼干</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/25/LeetCode455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</id>
    <published>2020-12-25T01:23:17.000Z</published>
    <updated>2020-12-25T01:45:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j]</code> &gt;= <code>g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><a id="more"></a><img src="/blog/2020/12/25/LeetCode455-分发饼干/455.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先将两个数组分别排序，使用两个指针分别指向两个数组的首元素，当饼干值满足胃口值时，两个指针后移；否则只需要将饼干数组的指针进行后移，直到满足胃口值或到达数组末尾。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; g.size() &amp;&amp; j &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] &gt;= g[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。&lt;/p&gt;
&lt;p&gt;对每个孩子 &lt;code&gt;i&lt;/code&gt;，都有一个胃口值 &lt;code&gt;g[i]&lt;/code&gt;，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 &lt;code&gt;j&lt;/code&gt;，都有一个尺寸 &lt;code&gt;s[j]&lt;/code&gt; 。如果 &lt;code&gt;s[j]&lt;/code&gt; &amp;gt;= &lt;code&gt;g[i]&lt;/code&gt;，我们可以将这个饼干 &lt;code&gt;j&lt;/code&gt; 分配给孩子 &lt;code&gt;i&lt;/code&gt; ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode135-分发糖果</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/24/LeetCode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/24/LeetCode135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</id>
    <published>2020-12-24T07:43:02.000Z</published>
    <updated>2020-12-24T10:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><a id="more"></a><img src="/blog/2020/12/24/LeetCode135-分发糖果/135.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用数组 $store$ 记录每个孩子得到的糖果数，$store[i]$ 表示第 $i$ 个孩子获得的糖果数。</p><p>首先找到最低的评分，这个位置记为 $pos$，最低分孩子的糖果数必为1，所以可以得到 $store[pos]=1$ ，以 $pos$为界，将评分数组分为两个部分分别操作，两个部分是<strong>互不影响</strong>的。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/评分数组.png" style="zoom:80%;"><ol><li><p>对于 $pos$ 之前（包括 $pos$），往回遍历评分数组，在不越界的条件下可以得到：</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从后往前1.png" style="zoom:80%;"><ol><li><p>如果前一个评分小于当前评分：</p><ol><li><p>当前糖果数不为1，那么前一个孩子获得的糖果置为1，结束；</p></li><li><p>当前糖果数为1，那么前一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于前一个孩子获得的糖果数（前一个评分小于当前评分）。所以需要从前一个位置开始往后遍历：</p><ol><li><p>如果遇到<strong>后一个评分大于当前评分，并且后一个的糖果等于当前糖果数（上图红线）</strong>，需要给后一个糖果数加1，保证后一个的糖果大于当前糖果数。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从后往前2.png" style="zoom:80%;"></li><li><p>如果后一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从后往前3.png" style="zoom:80%;"></li></ol></li></ol></li><li><p>如果前一个评分等于当前评分，前一个糖果数为1</p></li><li><p>如果前一个评分大于当前评分，前一个糖果数为当前糖果数加1</p></li></ol></li><li><p>对于 $pos$ 之后（包括 $pos$），往后遍历评分数组，在不越界的条件下：</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从前往后1.png" style="zoom:80%;"><ol><li><p>如果后一个评分小于当前评分：</p><ol><li><p>当前糖果数不为1，那么后一个孩子获得的糖果置为1，结束；</p></li><li><p>当前糖果数为1，那么后一个孩子获得的糖果置为1，但是当前孩子的糖果数必须要大于后一个孩子获得的糖果数（后一个评分小于当前评分）。所以需要从后一个位置开始往前遍历：</p><ol><li><p>如果遇到<strong>前一个评分大于当前评分，并且前一个的糖果等于当前糖果数（上图红线）</strong>，需要给前一个糖果数加1，保证前一个的糖果大于当前糖果数。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从前往后2.png" style="zoom: 80%;"></li><li><p>如果前一个评分等于当前评分，直接退出即可。因为如果相等的评分相邻，没有糖果数的大小关系约束。</p><img src="/blog/2020/12/24/LeetCode135-分发糖果/从前往后3.png" style="zoom:80%;"></li></ol></li></ol></li><li><p>如果后一个评分等于当前评分，后一个糖果数为1</p></li><li><p>如果后一个评分大于当前评分，后一个糖果数为当前糖果数加1</p></li></ol></li></ol><p>最终结果：</p><table><thead><tr><th>ratings</th><th>2</th><th>3</th><th>3</th><th>1</th><th>3</th><th>2</th><th>2</th><th>1</th></tr></thead><tbody><tr><td>store</td><td>1</td><td>2</td><td>2</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td></tr></tbody></table><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = min_element(ratings.begin(), ratings.end());</span><br><span class="line">        <span class="keyword">int</span> val = *iter;</span><br><span class="line">        <span class="keyword">int</span> pos = iter - ratings.begin();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">store</span><span class="params">(ratings.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        store[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从pos往前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ratings[i - <span class="number">1</span>] &lt; ratings[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(store[i] != <span class="number">1</span>) store[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    store[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &lt; pos; ++j)&#123;</span><br><span class="line">                        <span class="comment">// 往后走</span></span><br><span class="line">                        <span class="comment">// 下一个评分比当前评分高，并且下一个的糖果又没当前糖果多</span></span><br><span class="line">                        <span class="keyword">if</span>(ratings[j + <span class="number">1</span>] &gt; ratings[j] &amp;&amp; store[j + <span class="number">1</span>] &lt;= store[j])&#123;</span><br><span class="line">                            store[j + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(ratings[j + <span class="number">1</span>] == ratings[j]) <span class="keyword">break</span>;                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ratings[i - <span class="number">1</span>] == ratings[i])&#123;</span><br><span class="line">                store[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ratings[i - <span class="number">1</span>] &gt; ratings[i])&#123;</span><br><span class="line">                store[i - <span class="number">1</span>] = store[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从pos往后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; ratings.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.size() &amp;&amp; ratings[i + <span class="number">1</span>] &lt; ratings[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(store[i] != <span class="number">1</span>) store[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    store[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; pos; --j)&#123;</span><br><span class="line">                        <span class="comment">// 往前走</span></span><br><span class="line">                        <span class="comment">// 上一个评分比当前评分高，并且上一个的糖果又没当前糖果多</span></span><br><span class="line">                        <span class="keyword">if</span>(ratings[j - <span class="number">1</span>] &gt; ratings[j] &amp;&amp; store[j - <span class="number">1</span>] &lt;= store[j])&#123;</span><br><span class="line">                            store[j - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(ratings[j - <span class="number">1</span>] == ratings[j]) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.size() &amp;&amp; ratings[i + <span class="number">1</span>] == ratings[i])&#123;</span><br><span class="line">                store[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.size() &amp;&amp; ratings[i + <span class="number">1</span>] &gt; ratings[i])&#123;</span><br><span class="line">                store[i + <span class="number">1</span>] = store[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto &amp;v : store) cout &lt;&lt; v &lt;&lt; " ";</span></span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(store.begin(), store.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p><strong>相邻的孩子中，评分高的孩子必须获得更多的糖果</strong>。这句话可以拆为两个规则分别处理：</p><ul><li>左规则：当 $ratings[i-1]&lt;ratings[i]$ 时，$i$ 获得的糖果要多于 $i-1$ 。</li><li>右规则：当 $ratings[i]&gt;ratings[i+1]$ 时，$i$ 获得的糖果要多于 $i+1$ 。</li></ul><p>遍历数组两次，分别得到每一个孩子满足左规则和右规则的糖果数，取两者之间的最大值就是这个孩子最少分配的糖果数。</p><p>在实际代码中，我们先计算出左规则 $left$ 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(ratings.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ratings.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ratings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.size() &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>])&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += max(left[i], right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;老师想给孩子们分发糖果，有 &lt;em&gt;N&lt;/em&gt; 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。&lt;/p&gt;
&lt;p&gt;你需要按照以下要求，帮助老师给这些孩子分发糖果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个孩子至少分配到 1 个糖果。&lt;/li&gt;
&lt;li&gt;相邻的孩子中，评分高的孩子必须获得更多的糖果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么这样下来，老师至少需要准备多少颗糖果呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode387-字符串中的第一个唯一字符</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/23/LeetCode387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/23/LeetCode387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</id>
    <published>2020-12-23T01:11:04.000Z</published>
    <updated>2020-12-23T01:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><a id="more"></a><img src="/blog/2020/12/23/LeetCode387-字符串中的第一个唯一字符/387.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用一个哈希表记录一下每个字母出现的次数，返回第一个出现次数为1的字母位置即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)</span><br><span class="line">            cnt[ch - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[s[i] - <span class="string">'a'</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.xingyuzhao.ltd/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode103-二叉树的锯齿形层序遍历</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/22/LeetCode103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/22/LeetCode103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2020-12-22T03:16:27.000Z</published>
    <updated>2020-12-22T03:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><a id="more"></a><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><img src="/blog/2020/12/22/LeetCode103-二叉树的锯齿形层序遍历/103.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题和二叉树的层序遍历很相似，无非就是遍历完每一层需要改变一次方向，使用一个标志位标记从前往后或者从后往前遍历。可以使用双端队列，根据标志位决定从队列的那一头开始遍历。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; deq;</span><br><span class="line">        deq.push_back(root);</span><br><span class="line">        <span class="keyword">int</span> dir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deq.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">            <span class="comment">// 前往后</span></span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">0</span>)&#123;</span><br><span class="line">                dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> n = deq.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                    TreeNode* tmp = deq.front();</span><br><span class="line">                    buf.push_back(tmp-&gt;val);</span><br><span class="line">                    <span class="comment">// 前向时需要先将左边的点入队，保证下次遍历的顺序正确</span></span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;left) deq.push_back(tmp-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;right) deq.push_back(tmp-&gt;right);</span><br><span class="line">                    deq.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后往前</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dir = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> n = deq.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                    TreeNode* tmp = deq.back();</span><br><span class="line">                    buf.push_back(tmp-&gt;val);</span><br><span class="line">                    <span class="comment">// 后向时需要先将右边的点入队，保证下次遍历的顺序正确</span></span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;right) deq.push_front(tmp-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;left) deq.push_front(tmp-&gt;left);</span><br><span class="line">                    deq.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(buf);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                TreeNode *node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                buf.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="二叉树" scheme="http://www.xingyuzhao.ltd/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++关联容器</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/21/C-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/21/C-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2020-12-21T11:50:14.000Z</published>
    <updated>2020-12-24T14:50:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>使用关联容器</li><li>关联容器概述</li><li>关联容器操作</li><li>无序容器</li></ol><a id="more"></a><p>关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是<strong>map</strong>和<strong>set</strong>。</p><ul><li><code>map</code>中元素是一些关键字-值（key-value）对，关键字起到索引的作用，值则表示于索引相关联的数据。</li><li><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作-检查一个给定的关键字是否在set中。</li></ul><img src="/blog/2020/12/21/C-关联容器/关联容器类型.png"><p>类型<code>map</code>和<code>multimap</code>定义在头文件<code>map</code>中；<code>set</code>和<code>multiset</code>定义在头文件<code>set</code>中；无序容器定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中。</p><h4 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h4><h5 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h5><p>单词计数程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> count;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">++word_count[word];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; w.second</span><br><span class="line">    &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">" times"</span> : <span class="string">" time"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>此程序读取输入，报告每个单词出现多少次。<code>map</code>保存的每个元素中，关键字是<code>string</code>，值是<code>size_t</code>类型。如果<code>word</code>还未在<code>map</code>中。下标运算符会创建一个新元素。从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象，<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p><h5 id="使用set"><a href="#使用set" class="headerlink" title="使用set"></a>使用set</h5><p>对上一个程序扩展，忽略常见单词，如“the”、“and”、“or”等。可以用<code>set</code>保存想忽略的单词，只对不在集合中的单词统计出现次数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>, <span class="string">"But"</span>, <span class="string">"And"</span>, <span class="string">"Or"</span>, <span class="string">"An"</span>, <span class="string">"A"</span>,</span><br><span class="line">                       <span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>, <span class="string">"or"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> count;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    <span class="keyword">if</span>(exclude.find(word) == exclude.end())</span><br><span class="line">++word_count[word];</span><br></pre></td></tr></table></figure><p>在<code>if</code>中，<code>find</code>返回一个迭代器。如果给定关键字在<code>set</code>中，迭代器指向该关键字。否则，<code>find</code>返回尾后迭代器。</p><h4 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h4><h5 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h5><p>当定义一个<code>map</code>时，必须指明<strong>关键字类型</strong>和<strong>值类型</strong>；而定义一个<code>set</code>时，只需要指明<strong>关键字类型</strong>。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count; <span class="comment">// 空容器</span></span><br><span class="line"><span class="comment">// 列表初始化</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>, <span class="string">"But"</span>, <span class="string">"And"</span>, <span class="string">"Or"</span>, <span class="string">"An"</span>, <span class="string">"A"</span>,</span><br><span class="line">                       <span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>, <span class="string">"or"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>&#125;;</span><br><span class="line"><span class="comment">// 三个元素；authors将姓映射为名</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; authors = &#123; &#123;<span class="string">"zhao"</span>, <span class="string">"xingyu"</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">"zhou"</span>, <span class="string">"yanxuan"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>初始化<code>map</code>时，每对映射用花括号包含：{<em>key</em>, <em>value</em>}。</p><h5 id="初始化multimap或multiset"><a href="#初始化multimap或multiset" class="headerlink" title="初始化multimap或multiset"></a>初始化multimap或multiset</h5><p><code>map</code>和<code>set</code>的关键字都是唯一的。容器<code>multiset</code>和<code>multimap</code>没有此限制，它们都允许多个元素具有相同的关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个有20哥元素的vector，保存0到9每个整数的两个拷贝</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iset包含来自ivec的不重复的元素；miset包含所有20个元素</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(ivec.begin(), ivec.end())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">miset</span><span class="params">(ivec.begin(), ivec.end())</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; miset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h5><h6 id="有序容器的关键字类型"><a href="#有序容器的关键字类型" class="headerlink" title="有序容器的关键字类型"></a>有序容器的关键字类型</h6><p>所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>。可以将严格弱序看作“小于”（<strong>书上是”小于等于”，网上查到为小于</strong>），它必须具备以下性质：</p><ul><li>两个关键字不能同时“小于”对方</li><li>如果k1”小于”k2，k2“小于”k3，那么k1必须”小于“k3</li><li>如果存在两个关键字，任何一个都不”小于“另一个，那么我们称这两个关键字是”等价“的。并且等价具有传递性。</li></ul><p>如果两个关键字等价，那么容器将它们视作相等来处理。</p><h6 id="使用关键字类型的比较函数"><a href="#使用关键字类型的比较函数" class="headerlink" title="使用关键字类型的比较函数"></a>使用关键字类型的比较函数</h6><p>在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数的形式提供真正的比较操作（其类型必须与尖括号中指定的类型相吻合）。</p><p>例如：我们不能直接定义一个<code>Sales_data</code>的<code>multiset</code>，因为<code>Sales_data</code>没有<code>&lt;</code>运算符。以下函数在<code>ISBN</code>成员上定义一个严格弱序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要使用自己定义的操作</strong>，在定义<code>multiset</code>时必须提供两个类型：<strong>关键字类型</strong>Sales_data以及<strong>比较操作类型</strong>——应该是一种函数指针类型，可以指向<code>compareIsbn</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bookstore中多条记录可以有相同的ISBN</span></span><br><span class="line"><span class="comment">// bookstore中的元素以ISBN的顺序进行排列</span></span><br><span class="line">multiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn);</span><br></pre></td></tr></table></figure><p>*<em>当用decltype来获得一个函数指针类型时，必须加上一个</em>来指出我们要使用一个给定函数的指针**。<code>bookstore</code>中的元素将按它们的<code>ISBN</code>成员的值升序排列。</p><h5 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h5><p><code>pair</code>标注库类型定义在头文件<code>utility</code>中。<code>pair</code>保存两个数据成员，它是一个用来生成特定类型的模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span> &gt; anon;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; line;</span><br></pre></td></tr></table></figure><p><code>pair</code>的默认构造函数对数据成员进行值初始化。以下三种初始化都是可以的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; q&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">pair&lt;int, int&gt; m(1,1);</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/21/C-关联容器/pair上的操作.png"><h6 id="创建pair对象的函数"><a href="#创建pair对象的函数" class="headerlink" title="创建pair对象的函数"></a>创建pair对象的函数</h6><p>新标准下，可以对返回值进行列表初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, int&gt; process(vector&lt;string&gt; &amp;v)&#123;</span><br><span class="line"><span class="comment">// 处理v</span></span><br><span class="line">    <span class="keyword">if</span>(!v.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;v.back(), v.back().size()&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(); <span class="comment">// 隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>早期版本必须显式的构造返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!v.empty())</span><br><span class="line">    <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(v.back(), v.back().size());</span><br></pre></td></tr></table></figure><p>还可以使用<code>make_pair</code>来生成<code>pair</code>对象，<code>pair</code>的两个类型来自于<code>make_pair</code>的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!v.empty())</span><br><span class="line"><span class="keyword">return</span> make_pair(v.back(), v.back().size());</span><br></pre></td></tr></table></figure><h4 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h4><img src="/blog/2020/12/21/C-关联容器/关联容器额外的类型别名.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::value_type v1; <span class="comment">// v1是一个string</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::key_value v2; <span class="comment">// v2是一个string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type v3; <span class="comment">// v3是一个pair&lt;const string, int&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::key_type v4; <span class="comment">// v4是一个string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::mapped_type v5; <span class="comment">// v5是一个int</span></span><br></pre></td></tr></table></figure><p>只有<code>map</code>类型（<code>unordered_map、unordered_multimap、multimap、map</code>）才定义了<code>mapped_type</code>;</p><h5 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h5><p>解引用一个关联容器的迭代器时，得到一个类型为容器的<code>value_type</code>的值的<strong>引用</strong>。对<code>map</code>而言，<code>value_type</code>是一个<code>pair</code>类型，其<code>first</code>成员保存<code>cosnt</code>的关键字，<code>second</code>成员保存值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得指向word_count中一个元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.begin();</span><br><span class="line"><span class="comment">// *map_it是指向一个pair&lt;const string, size_t&gt;对象的引用</span></span><br><span class="line"><span class="comment">// 或者使用(*map_it).first，(*map_it).second</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first; <span class="comment">// 打印此元素的关键字</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; map_it-&gt;second; <span class="comment">// 打印此元素的值</span></span><br><span class="line">map_it-&gt;first = <span class="string">"new key"</span>; <span class="comment">// 错误：关键字是const的</span></span><br><span class="line">++map_it-&gt;second; <span class="comment">// 正确：可以通过迭代器改变元素</span></span><br></pre></td></tr></table></figure><h6 id="set的迭代器是const的"><a href="#set的迭代器是const的" class="headerlink" title="set的迭代器是const的"></a>set的迭代器是const的</h6><p>虽然<code>set</code>类型同时定义了<code>iterator</code>和<code>const_iterator</code>类型， 但两种类型都只允许读<code>set</code>中的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator set_it = iset.begin();</span><br><span class="line"><span class="keyword">if</span>(set_it != iset.end())&#123;</span><br><span class="line">    *set_it = <span class="number">42</span>; <span class="comment">// 错误：set中的关键字是只读的</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *set_it &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正确：可以读关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="遍历关联容器"><a href="#遍历关联容器" class="headerlink" title="遍历关联容器"></a>遍历关联容器</h6><p><code>map</code>和<code>set</code>都支持之前所说的<code>begin</code>和<code>end</code>操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.cbegin();</span><br><span class="line"><span class="keyword">while</span>(map_it != word_count.cbegin())&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; map_it-&gt;first &lt;&lt; <span class="string">" occurs"</span></span><br><span class="line">         &lt;&lt; map_it-&gt;second &lt;&lt; <span class="string">" times"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++map_it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="关联容器和算法"><a href="#关联容器和算法" class="headerlink" title="关联容器和算法"></a>关联容器和算法</h6><p>通常不对关联容器使用泛型算法，有其专用算法。如果真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的位置。</p><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>使用关联容器的<code>insert</code>成员向容器中添加一个元素或一个元素范围：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;; <span class="comment">// ivec有8个元素</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set2;</span><br><span class="line">set2.insert(ivec.cbegin(), ivec.cend()); <span class="comment">// set2有4个元素</span></span><br><span class="line">set2.insert(&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;); <span class="comment">// set2现在有8个元素</span></span><br></pre></td></tr></table></figure><h6 id="向map添加元素"><a href="#向map添加元素" class="headerlink" title="向map添加元素"></a>向map添加元素</h6><p>对一个<code>map</code>进行<code>insert</code>操作时，必须记住元素类型是<code>pair</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向word_count插入word的4种方法</span></span><br><span class="line">word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.insert(make_pair(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;::value_type(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/21/C-关联容器/关联容器insert操作.png"><h6 id="检测insert返回值"><a href="#检测insert返回值" class="headerlink" title="检测insert返回值"></a>检测insert返回值</h6><p><code>insert</code>(或<code>emplace</code>)返回的值依赖于容器类型和参数。对于<strong>不包含重复关键字</strong>的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，告诉我们插入操作是否成功。<code>pair</code>的<code>first</code>成员是一个<strong>迭代器</strong>，指向<strong>具有给定关键字的元素</strong>；<code>second</code>成员是一个<code>bool</code>值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则<code>insert</code>什么事情也不做，且返回值中的<code>bool</code>部分为<code>false</code>。如果关键字不存在，元素被插入容器中，且<code>bool</code>值为<code>true</code>。</p><p>例子，重写单词计数程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>(!ret.second)</span><br><span class="line">        ++ret.first-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="展开递增语句"><a href="#展开递增语句" class="headerlink" title="展开递增语句"></a>展开递增语句</h6><ul><li><strong>ret</strong>：保存<code>insert</code>返回的值，是一个<strong>pair</strong></li><li><strong>ret.first</strong>：是一个<code>map</code>迭代器，指向具有给定关键字的元素</li><li>**ret.first-&gt;**：解引用此迭代器，提取<code>map</code>种元素，元素也是一个<code>pair</code></li><li><strong>ret.first-&gt;second</strong>：<code>map</code>中元素的值部分</li><li><strong>++ret.first-&gt;second</strong>：递增此值</li></ul><h6 id="向multiset或multimap添加元素"><a href="#向multiset或multimap添加元素" class="headerlink" title="向multiset或multimap添加元素"></a>向multiset或multimap添加元素</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; authors;</span><br><span class="line"><span class="comment">// 插入第一个元素，关键字为zxy</span></span><br><span class="line">authors.insert(&#123;<span class="string">"zxy"</span>, <span class="string">"c++泛型算法"</span>&#125;);</span><br><span class="line"><span class="comment">// 正确：添加第二个元素，关键字也是zxy"</span></span><br><span class="line">authors.insert(&#123;<span class="string">"zxy"</span>, <span class="string">"c++关联容器"</span>&#125;);</span><br></pre></td></tr></table></figure><p>这里<code>insert</code>操作返回一个指向新元素的迭代器。无需返回一个<code>bool</code>值，因为<code>insert</code>总是向这类容器中加入一个新元素。</p><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>关联容器定义了三个版本的<code>erase</code>，如下：</p><img src="/blog/2020/12/21/C-关联容器/关联容器erase操作.png"><p>后两个与顺序容器一样，第一个是关联容器额外提供的，它接受一个<code>key_type</code>类型。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除元素的数量。</p><ul><li>对于保存不重复关键字的容器，<code>erase</code>的返回值总是0或1。0表示要删除的元素不在容器中</li><li>对于允许重复关键字的容器，删除元素的数量可能大于1</li></ul><h5 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h5><p><code>map</code>和<code>unordered_map</code>容器提供了下标运算符和一个对应的<code>at</code>函数：</p><img src="/blog/2020/12/21/C-关联容器/map和unordered_map的下标操作.png"><p><strong><code>set</code>类型不支持下标，因为<code>set</code>中元素本身就是关键字，同时也不能对<code>multimap</code>或者<code>unordered_multimap</code>进行下标操作，因为这些容器中可能有多个值与一个关键字相关联</strong>。</p><img src="/blog/2020/12/21/C-关联容器/map_note.png"><h6 id="使用下标操作的返回值"><a href="#使用下标操作的返回值" class="headerlink" title="使用下标操作的返回值"></a>使用下标操作的返回值</h6><p>当对一个<code>map</code>进行下标操作时，会获得一个<code>mapped_type</code>对象；但当解引用一个<code>map</code>迭代器时，会得到一个<code>value_type</code>对象。与其他下标运算符相同的是，<code>map</code>的下标运算符返回一个左值，所以既可以读也可以写元素。</p><img src="/blog/2020/12/21/C-关联容器/map下标_note.png"><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><p>关联容器提供多种查找一个指定元素的方法，应该使用哪个取决我们要解决什么问题。</p><img src="/blog/2020/12/21/C-关联容器/在一个关联容器种查找元素的操作.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">iset.find(<span class="number">1</span>); <span class="comment">// 返回一个迭代器，指向key = 1的元素</span></span><br><span class="line">iset.find(<span class="number">11</span>); <span class="comment">// 返回一个迭代器，其值等于iset.end()</span></span><br><span class="line">iset.count(<span class="number">1</span>); <span class="comment">// 返回1</span></span><br><span class="line">iset.count(<span class="number">11</span>); <span class="comment">// 返回0</span></span><br></pre></td></tr></table></figure><h6 id="对map和find代替下标操作"><a href="#对map和find代替下标操作" class="headerlink" title="对map和find代替下标操作"></a>对map和find代替下标操作</h6><p>如果我们只是想知道一个给定的关键字是否在<code>map</code>中，而不想改变<code>map</code>（下标操作会插入一个未在<code>map</code>的元素）。这种情况下应该使用<code>find</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(word_count.find(<span class="string">"foobar"</span>) == word_count.end())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"foobar is not in the map"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h6 id="在multimap或multiset中查找元素"><a href="#在multimap或multiset中查找元素" class="headerlink" title="在multimap或multiset中查找元素"></a>在multimap或multiset中查找元素</h6><p>如果一个<code>multimap</code>或<code>multiset</code>中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。</p><p>例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。可以用三种不同方法来解决这个问题。最直观的方法是使用<code>find</code>和<code>count</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">search_item</span><span class="params">(<span class="string">"zxy"</span>)</span></span>; <span class="comment">// 作者</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors.count(search_item); <span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.find(search_item); <span class="comment">// 作者的第一本书</span></span><br><span class="line"><span class="comment">// 查找此作者所有著作</span></span><br><span class="line"><span class="keyword">while</span>(entries)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印书名</span></span><br><span class="line">    ++iter; <span class="comment">// 下一本</span></span><br><span class="line">    --entries; <span class="comment">// 打印一次，计数减一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/21/C-关联容器/multimap或multiset中查找元素_note.png"><h6 id="一种不同的，面向迭代器的解决办法"><a href="#一种不同的，面向迭代器的解决办法" class="headerlink" title="一种不同的，面向迭代器的解决办法"></a>一种不同的，面向迭代器的解决办法</h6><p>可以使用<code>lower_bound</code>和<code>upper_bound</code>来解决。</p><ul><li>关键字在容器中，<code>lower_bound</code>返回迭代器将指向第一个具有给定关键字的元素，<code>upper_bound</code>返回迭代器指向最后一个匹配关键字元素之后的位置</li><li>关键字不在容器中，两者返回一个不影响排序的关键字插入位置</li></ul><p>因此，使用相同关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到关键字元素的范围。我们可以重写程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> beg = authors.lower_bound(search_item),</span><br><span class="line">    end = authors.upper_bound(search_item);</span><br><span class="line">    beg != end; ++ beg)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/21/C-关联容器/lower_bound和upper_bound_note.png"><h6 id="equal-range函数"><a href="#equal-range函数" class="headerlink" title="equal_range函数"></a>equal_range函数</h6><p>此函数接受一个关键字，返回一个**迭代器<code>pair</code>**（不是<code>pair</code>对象）。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。再次修改程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = authors.equal_range(search_item);</span><br><span class="line">pos.first != pos.second; ++pos.first)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pos.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="一个单词转换的map"><a href="#一个单词转换的map" class="headerlink" title="一个单词转换的map"></a>一个单词转换的map</h5><p>程序功能：给定一个<code>string</code>，将它转换为另一个<code>string</code>。我们需要根据单词转换文件将待转换的文本转换为我们想要的样子：</p><p>单词转换文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k okay?</span><br><span class="line">y why</span><br><span class="line">r are</span><br><span class="line">u you</span><br><span class="line">pic picture</span><br><span class="line">thk thank!</span><br><span class="line">l8r later</span><br></pre></td></tr></table></figure><p>待转换文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where r u</span><br><span class="line">y dont u send me a pic</span><br><span class="line">k thk l8r</span><br></pre></td></tr></table></figure><p>转换结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">where are you</span><br><span class="line">why dont you send me a picture</span><br><span class="line">okay? thanks! later</span><br></pre></td></tr></table></figure><h6 id="单词转换程序"><a href="#单词转换程序" class="headerlink" title="单词转换程序"></a>单词转换程序</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map_file 转换规则</span></span><br><span class="line"><span class="comment">// input 待转换文本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">word_transform</span><span class="params">(ifstream &amp;map_file, ifstream &amp;input, ofstream &amp;output)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> trans_map = buildMap(map_file);</span><br><span class="line">    <span class="built_in">string</span> text; <span class="comment">// 保存输入中的每一行</span></span><br><span class="line">    <span class="keyword">while</span>(getline(input, text))&#123; <span class="comment">// 读取每一行输入</span></span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">stream</span><span class="params">(text)</span></span>; <span class="comment">// 读取每个单词</span></span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">bool</span> firstword = <span class="literal">true</span>; <span class="comment">// 控制是否打印空格</span></span><br><span class="line">        <span class="keyword">while</span>(stream &gt;&gt; word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(firstword)</span><br><span class="line">                firstword = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                output &lt;&lt; <span class="string">" "</span>; <span class="comment">// 单词间打印一个空格</span></span><br><span class="line">            output &lt;&lt; transform(word, trans_map); <span class="comment">// 打印输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        output &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 完成一行的转换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="建立转换映射"><a href="#建立转换映射" class="headerlink" title="建立转换映射"></a>建立转换映射</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; buildMap(ifstream &amp; map_file)&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; trans_map; <span class="comment">// 保存转换规则</span></span><br><span class="line">    <span class="built_in">string</span> key; <span class="comment">// 要转换的单词</span></span><br><span class="line">    <span class="built_in">string</span> value; <span class="comment">// 替换后的内容</span></span><br><span class="line">    <span class="comment">// 读取第一个单词存入key，剩余存入value（包括标点）</span></span><br><span class="line">    <span class="comment">// map_file&gt;&gt;key流只读取第一个空格前string，剩下的流由getline读取到value中</span></span><br><span class="line">    <span class="keyword">while</span>(map_file &gt;&gt; key &amp;&amp; getline(map_file, value))</span><br><span class="line">        <span class="keyword">if</span>(value.size() &gt; <span class="number">1</span>) <span class="comment">// 检查是否有转换规则</span></span><br><span class="line">            trans_map[key] = value.substr(<span class="number">1</span>); <span class="comment">// 跳过前导空格，getline不会跳过前导空格</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"no rule for "</span> + key);</span><br><span class="line">    <span class="keyword">return</span> trans_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="生成转换文本"><a href="#生成转换文本" class="headerlink" title="生成转换文本"></a>生成转换文本</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">transform</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; &amp;m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> map_it = m.find(s);</span><br><span class="line">    <span class="keyword">if</span>(map_it != m.cend())</span><br><span class="line">        <span class="keyword">return</span> map_it-&gt;second; <span class="comment">// 使用替换短语</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s; <span class="comment">// 否则返回原string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h4><p>新标准定义了<strong>4</strong>个<strong>无序关联容器</strong>，这些容器使用一个哈希函数和关键字类型的<code>==</code>运算符。</p><h6 id="使用无序容器"><a href="#使用无序容器" class="headerlink" title="使用无序容器"></a>使用无序容器</h6><p>用于<code>map</code>和<code>set</code>的操作也能用于<code>unordered_map</code>和<code>unordered_set</code>，如<code>find、insert</code>等。无序容器也有允许重复关键字的版本。</p><h6 id="管理桶"><a href="#管理桶" class="headerlink" title="管理桶"></a>管理桶</h6><p>无序容器在存储上组织为<strong>一组桶</strong>，每个桶保存零个或多个元素。<strong>无序容器使用一个哈希函数将元素映射到桶</strong>。</p><ul><li><p>为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。</p></li><li><p>容器将具有一个特定哈希值的所有元素都保存在相同的桶中。</p></li><li><p>如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。</p></li></ul><p>因此，无序容器的性能依赖于<strong>哈希函数的质量</strong>和<strong>桶的数量和大小</strong>。</p><p>对于相同的参数，哈希函数必须总是产生相同的结果。<strong>理想情况下，哈希函数将每个特定的值映射到唯一的桶</strong>。但是，<strong>将不同关键字的元素映射到相同的桶也是允许的</strong>。</p><ul><li>当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。</li><li>计算一个元素的哈希值和在桶中搜索通常都是很快的操作。</li><li>如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。</li></ul><p>以下这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。</p><img src="/blog/2020/12/21/C-关联容器/无序容器管理操作.png"><h6 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h6><p>默认情况下，无序容器使用关键字类型<code>==</code>运算符来比较元素，它们还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来<strong>生成每个元素的哈希值</strong>。</p><ul><li>无序容器支持关键字是<strong>内置类型(包括指针类型)**、</strong><code>string</code><strong>或者</strong>智能指针**类型的无序容器。</li><li>无序容器<strong>不能</strong>直接定义<strong>关键字类型为自定义类类型的无序容器</strong>。与容器不同，不能直接使用哈希模板，而必须提供我们自己的<code>hash</code>模板版本。</li><li>不使用默认的<code>hash</code>，而是使用一种类似于<strong>为有序容器重载关键字类型</strong>的默认比较操作。</li></ul><p>为了能将<code>Sale_data</code>用作关键字，我们需要提供函数来替代<code>==</code>运算符和哈希值计算函数。我们从定义这些重载函数开始：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;sd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hasher</code>函数使用标准库<code>hash</code>类型对象计算<code>ISBN</code>成员的哈希值，该哈希值建立在<code>string</code>之上。</p><p><code>eqOp</code>函数通过比较<code>ISBN</code>号来比较两个<code>Salas_data</code>。</p><p>使用以上函数来定义一个<code>unordered_multiset</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SD_multiset = <span class="built_in">unordered_multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(hasher)*, <span class="keyword">decltype</span>(eqOp)*&gt;;</span><br><span class="line"><span class="comment">// 参数是桶大小、哈希函数指针和相等性判断运算符指针</span></span><br><span class="line"><span class="function">SD_miltiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqOp)</span></span>;</span><br></pre></td></tr></table></figure><p>此集合的哈希和相等性判断操作与<code>hasher</code>和<code>eqOp</code>函数有着相同的类型。在定义<code>bookstore</code>时可以将我们希望它使用的函数的指针传递给它。</p><p>如果类定义了<code>==</code>运算符，则可以只重载哈希函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用FooHash生成哈希值；Foo必须有==运算符</span></span><br><span class="line">unordered_set&lt;Foo, decltype(FooHash)*&gt; fooSet(10, FoolHash);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用关联容器&lt;/li&gt;
&lt;li&gt;关联容器概述&lt;/li&gt;
&lt;li&gt;关联容器操作&lt;/li&gt;
&lt;li&gt;无序容器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode746-使用最小花费爬楼梯</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/21/LeetCode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/21/LeetCode746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2020-12-21T06:57:07.000Z</published>
    <updated>2020-12-21T07:16:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组的每个索引作为一个阶梯，第<code>i</code>个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><a id="more"></a><img src="/blog/2020/12/21/LeetCode746-使用最小花费爬楼梯/746.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>像这种爬楼梯问题考虑动态规划，当前状态花费 $dp[i]$ 可以由上一次 $dp[i-1]$ 或者上上次 $dp[i-2]$ 中的最小花费得到（对应爬一层台阶和爬两层台阶），其次当前状态还有体力消耗 $cost[i]$，所以可以定义状态转移方程：<br>$$<br>dp[i]=min(dp[i-1],dp[i-2])+cost[i]<br>$$<br>当楼梯只有两阶时，假定有第三阶，那么到达第三阶的花费就为0，初始化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">cost.push_back(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        cost.push_back(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.size(); ++i)&#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;数组的每个索引作为一个阶梯，第&lt;code&gt;i&lt;/code&gt;个阶梯对应着一个非负数的体力花费值 &lt;code&gt;cost[i]&lt;/code&gt;(索引从0开始)。&lt;/p&gt;
&lt;p&gt;每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。&lt;/p&gt;
&lt;p&gt;您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
