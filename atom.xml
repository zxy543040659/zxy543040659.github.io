<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2020-11-28T14:39:06.851Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++顺序容器</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/25/C-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/25/C-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2020-11-25T13:17:11.000Z</published>
    <updated>2020-11-28T14:39:06.851Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>顺序容器概述</li><li>容器库概览</li><li>顺序容器操作</li><li><code>vector</code>对象是如何增长的</li><li>额外的<code>string</code>操作</li><li>容器适配器</li></ol><a id="more"></a><h4 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h4><img src="/blog/2020/11/25/C-顺序容器/概述.png" style="zoom:120%;"><p>选择容器的基本原则：</p><ul><li>尽量使用<code>vector</code>。</li><li>要求随机访问元素，使用<code>vector</code>或者<code>deque</code>。</li><li>要求在中间插入或删除元素，使用<code>list</code>或者<code>forward_list</code>。</li><li>要求在首尾插入或删除元素且不会在中间插入或者删除，使用<code>deque</code>。</li><li>如果程序要读取输入，且必须在中间插入，使用<code>list</code>，随后拷贝到<code>vector</code>。</li></ul><h4 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h4><img src="/blog/2020/11/25/C-顺序容器/容器操作.png" style="zoom:120%;"><img src="/blog/2020/11/25/C-顺序容器/容器操作1.png" style="zoom:120%;"><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p><code>forward_list</code>迭代器不支持递减运算符。</p><h6 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h6><p><strong>左闭合区间</strong>：<code>[begin, end)</code>，表示范围自<code>begin</code>开始，于<code>end</code>之前结束。</p><ul><li>如果<code>begin</code>与<code>end</code>相等，则范围为空。</li><li>如果<code>begin</code>与<code>end</code>不等，则范围至少包含一个元素，且<code>begin</code>指向该范围中的第一个元素。</li><li>可以对<code>begin</code>递增若干次，使得<code>begin==end</code>。</li></ul><h5 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::difference_type count</span><br></pre></td></tr></table></figure><h5 id="begin与end成员"><a href="#begin与end成员" class="headerlink" title="begin与end成员"></a>begin与end成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; a = &#123;<span class="string">"abc"</span>, <span class="string">"bcd"</span>, <span class="string">"cde"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.begin(); <span class="comment">// list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.rbegin(); <span class="comment">// list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.cbegin(); <span class="comment">// list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.crbegin(); <span class="comment">// list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure><h5 id="容器定义及初始化"><a href="#容器定义及初始化" class="headerlink" title="容器定义及初始化"></a>容器定义及初始化</h5><img src="/blog/2020/11/25/C-顺序容器/初始化.png" style="zoom:120%;"><p><strong>array的使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia1; <span class="comment">// 10个默认初始化的int</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia3 = &#123;<span class="number">42</span>&#125;; <span class="comment">// ia3[0]为42， 其余为0</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia4 = &#123;&#125;; <span class="comment">// 初始化为0</span></span><br></pre></td></tr></table></figure><h5 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h5><img src="/blog/2020/11/25/C-顺序容器/assign.png" style="zoom:120%;"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assign第一种用法</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle; <span class="comment">// 错误，容器类型不匹配</span></span><br><span class="line"><span class="comment">// 正确，可以将const char*转为string</span></span><br><span class="line">names.assign(oldstyle.cbegin(), oldstyle.cend()); </span><br><span class="line"><span class="comment">// assign的第二种用法</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist1</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 1个元素，为空string</span></span><br><span class="line">slist1.assign(<span class="number">10</span>, <span class="string">"Hiya!"</span>); <span class="comment">// 10个元素，每个都是"Hiya"</span></span><br></pre></td></tr></table></figure><h6 id="使用swap"><a href="#使用swap" class="headerlink" title="使用swap"></a>使用swap</h6><p>swap操作交换两个相同类型容器的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line">swap(svec1, svec2);</span><br><span class="line"><span class="comment">// 元素本身并未交换，swap只是交换了两个容器的内部数据结构</span></span><br></pre></td></tr></table></figure><p><strong>除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间完成</strong>。<strong>对array会真正交换它们的元素</strong>。</p><h5 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h5><p><code>size</code>：返回容器中元素数目。</p><p><code>empty</code>：容器是否为空。</p><p><code>max_size</code>：返回一个大于或等于该类型容器所能容纳的最大元素数的值。</p><p>注：<code>forward_list</code>不支持<code>size</code>。</p><h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">// v1 &lt; v2 true，在v1[2] &lt; v2[2]</span></span><br><span class="line"><span class="comment">// v1 &lt; v3 false，所有元素相等，但是v3元素更少</span></span><br><span class="line"><span class="comment">// v1 == v4 true，元素对应相等且长度相同</span></span><br><span class="line"><span class="comment">// v1 == v2 false，v2元素比v1少</span></span><br></pre></td></tr></table></figure><h4 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h4><img src="/blog/2020/11/25/C-顺序容器/添加元素.png" style="zoom:120%;"><h5 id="使用emplace操作"><a href="#使用emplace操作" class="headerlink" title="使用emplace操作"></a>使用emplace操作</h5><p>当调用一个<code>emplace</code>成员函数时，将参数传递给元素类型的构造函数。<code>emplace</code>成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.emplace_back(<span class="string">"978-0590353403"</span>, <span class="number">24</span>, <span class="number">15.99</span>);</span><br><span class="line">c.push_back(Sales_data(<span class="string">"978-0590353403"</span>, <span class="number">24</span>, <span class="number">15.99</span>));</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">c.push_back(<span class="string">"978-0590353403"</span>, <span class="number">24</span>, <span class="number">15.99</span>);</span><br></pre></td></tr></table></figure><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><img src="/blog/2020/11/25/C-顺序容器/访问元素.png" style="zoom:120%;"><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><img src="/blog/2020/11/25/C-顺序容器/删除元素.png" style="zoom:120%;"><h5 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h5><img src="/blog/2020/11/25/C-顺序容器/改变容器大小.png" style="zoom:120%;"><h5 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h5><p>向容器中添加/删除元素可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。</p><p>在向容器添加元素后：</p><ul><li>容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但插入位置之后的迭代器、指针和引用将会失效。</li><li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，指向存在元素的引用和指针不会失效。</li><li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器、指针和引用仍有效。</li></ul><p>删除元素时，指向被删除元素的迭代器、指针和引用都会失效。</p><ul><li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针都有效。</li><li>对于<code>deque</code>，在首尾之外的任何位置删除元素，指向被删除元素外其他元素的迭代器、指针或引用也会失效。删除尾，尾后迭代器会失效，但其他迭代器、引用和指针不受影响；删除首，也不受影响。</li><li>对于<code>vector</code>和<code>string</code>，指向被删元素之前元素的迭代器、引用和指针仍有效。</li></ul><p><em>注意：当我们删除元素时，尾后迭代器总会失效</em>。</p><h4 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h4><p><code>vector</code>会分配比新的空间需求更大的内存空间，作为备用。</p><h5 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h5><img src="/blog/2020/11/25/C-顺序容器/管理vector.png" style="zoom:120%;"><p><em><code>reserve</code>不改变容器中元素的数量，只影响<code>vector</code>预先分配多大的内存空间。</em></p><h4 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h4><img src="/blog/2020/11/25/C-顺序容器/额外string.png" style="zoom:120%;"><p>这些构造函数接受一个<code>string</code>或一个<code>const char*</code>参数，还接受（可选的）指定拷贝多少个字符的参数。</p><p>从<code>const char*</code>创建<code>string</code>时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。且：</p><ul><li>如果同时传一个计数值，就不必以空字符结尾。</li><li>如果未传递计数值且数组未以空字符结尾，或者计数值大于数组大小，则构造函数未定义。</li></ul><p>从<code>string</code>拷贝时，可选开始位置和计数值。位置大于<code>size</code>，构造函数抛出一个<em>out of range</em>异常。计数值代表从当前位置拷贝这么多个字符，最多拷贝到<code>string</code>结尾。</p><h5 id="sbustr"><a href="#sbustr" class="headerlink" title="sbustr"></a>sbustr</h5><img src="/blog/2020/11/25/C-顺序容器/substr.png" style="zoom:120%;"><h5 id="aapend和replace"><a href="#aapend和replace" class="headerlink" title="aapend和replace"></a>aapend和replace</h5><ol><li><code>append</code>操作是在<code>string</code>末尾进行插入操作的一种简写形式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.append(<span class="string">"123abc"</span>); <span class="comment">// 将"123abc"追加在s之后</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>replace</code>操作是调用<code>erase</code>和<code>insert</code>的一种简写形式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.erase(<span class="number">11</span>, <span class="number">3</span>);</span><br><span class="line">s.insert(<span class="number">11</span>, <span class="string">"5th"</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">s.replace(<span class="number">11</span>, <span class="number">3</span>, <span class="string">"5th"</span>);</span><br></pre></td></tr></table></figure><p>还有<code>assign</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.assign(arg); <span class="comment">// 将s中字符替换未arg，返回指向s的引用</span></span><br></pre></td></tr></table></figure><p><code>assign</code>总是替换<code>string</code>中所有内容。</p><h5 id="string的搜索操作"><a href="#string的搜索操作" class="headerlink" title="string的搜索操作"></a>string的搜索操作</h5><img src="/blog/2020/11/25/C-顺序容器/string_find.png" style="zoom:120%;"><img src="/blog/2020/11/25/C-顺序容器/string_find_form.png" style="zoom:120%;"><p><em><code>string</code>搜索返回<code>string::size_type</code>类型，是无符号的，因此用<code>int</code>表示不是很好的选择。</em></p><h5 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h5><img src="/blog/2020/11/25/C-顺序容器/compare.png" style="zoom:120%;"><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"pi = 3.14"</span>;</span><br><span class="line"><span class="comment">// 转换s中以数字开始的第一个字串，d=3.14</span></span><br><span class="line">d = stod(s.substr(s.find_first_of(<span class="string">"+-.0123456789"</span>)));</span><br></pre></td></tr></table></figure><p><em>如果<code>string</code>不能转换为数值，抛出<code>invalid_argument</code>异常。如果转换的数值无法用任何类型表示，则抛出一个<code>out_of_range</code>异常</em>。</p><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p><strong>适配器</strong>是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。比如：<code>stack</code>、<code>queue</code>、<code>priority_queue</code>。</p><img src="/blog/2020/11/25/C-顺序容器/容器适配器.png" style="zoom:120%;"><p>每个适配器都定义了两个构造函数：</p><ol><li>默认构造函数创建一个空对象，接受一个容器的构造函数拷贝来初始化适配器。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定dep使一个deque&lt;int&gt;</span></span><br><span class="line"><span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stk</span><span class="params">(dep)</span></span>; <span class="comment">// 从deq拷贝元素到stk</span></span><br></pre></td></tr></table></figure><ol start="2"><li>默认情况下，<code>stack</code>和<code>queue</code>基于<code>deque</code>实现，<code>priority_deque</code>基于<code>vector</code>。创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于vector实现空栈</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">// str_stk2在vector上实现，初始化时保存svec的拷贝</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec);</span><br></pre></td></tr></table></figure><h5 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h5><p><code>stack</code>类型定义在<code>stack</code>头文件中。</p><img src="/blog/2020/11/25/C-顺序容器/stack.png" style="zoom:120%;"><h5 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h5><p><code>queue</code>和<code>priority_queue</code>适配器定义在<code>queue</code>头文件中。</p><img src="/blog/2020/11/25/C-顺序容器/queue.png" style="zoom:120%;"><img src="/blog/2020/11/25/C-顺序容器/queue1.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;顺序容器概述&lt;/li&gt;
&lt;li&gt;容器库概览&lt;/li&gt;
&lt;li&gt;顺序容器操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;对象是如何增长的&lt;/li&gt;
&lt;li&gt;额外的&lt;code&gt;string&lt;/code&gt;操作&lt;/li&gt;
&lt;li&gt;容器适配器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode148-排序链表</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-11-22T02:27:25.000Z</published>
    <updated>2020-11-22T03:16:08.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p><strong>进阶</strong>：</p><p>你可以在<code>O(nlogn)</code>时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p>本题可与<a href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more">LeetCode147-对链表进行插入排序</a>，<a href="http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/">LeetCode143-重排链表</a>共同学习。</p><a id="more"></a><img src="/blog/2020/11/22/LeetCode148-排序链表/示例.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目要求用<code>O(nlogn)</code>的时间复杂度来进行排序，所以不能用<a href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more">LeetCode147-对链表进行插入排序</a>的方法来进行解，所以采用归并排序的思想对链表进行排序。</p><p>使用归并排序首先得找到链表的中间节点，找到中间节点，根据中间节点的位置将链表分为两个部分，再进行归并排序。<strong>中间节点在链表前半部分的末尾，将链表拆开后，要让中间节点的下一个指向空</strong>，再分别对两个链表进行归并排序，最后再合并两个排序好的链表，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode* __mergeSort(ListNode *node)&#123;</span><br><span class="line">    <span class="comment">// 如果节点为空或只有一个节点，返回当前节点即可</span></span><br><span class="line">    <span class="keyword">if</span>(!node || !node-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    ListNode *fast = node;</span><br><span class="line">    ListNode *slow = node;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *l2 = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* left = __mergeSort(node);</span><br><span class="line">    ListNode* right = __mergeSort(l2);</span><br><span class="line">    <span class="keyword">return</span> __merge(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并的操作需要创建一个新的链表，新的链表根据两个链表的值建立。如果<code>l1</code>的值小于<code>l2</code>，那么将<code>l1</code>插入新的链表中，同时<code>l1</code>移动到它的下一个节点；否则将<code>l2</code>插入新的链表中，同时<code>l2</code>移动到它的下一个节点。插入操作结束后，再将新链表向后移动一个节点（也就是新插入的节点）。<strong>如果两个链表长度不一样（两个链表长度最多差一个），还要判断插入操作结束后哪个链表不为空，如果不为空，它就是新链表的最后一个节点</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ListNode* __merge(ListNode *l1, ListNode *l2)&#123;</span><br><span class="line">    ListNode *dummyNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode *cur = dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; l2-&gt;val;</span></span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = l1 != <span class="literal">nullptr</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __mergeSort(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其余两个函数</span></span><br><span class="line">ListNode* __mergeSort(ListNode *node);</span><br><span class="line">ListNode* __merge(ListNode *l1, ListNode *l2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;你可以在&lt;code&gt;O(nlogn)&lt;/code&gt;时间复杂度和常数级空间复杂度下，对链表进行排序吗？&lt;/p&gt;
&lt;p&gt;本题可与&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more&quot;&gt;LeetCode147-对链表进行插入排序&lt;/a&gt;，&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/&quot;&gt;LeetCode143-重排链表&lt;/a&gt;共同学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="归并排序" scheme="http://www.xingyuzhao.ltd/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode147-对链表进行插入排序</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2020-11-21T14:42:04.000Z</published>
    <updated>2020-11-22T03:19:14.774Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>插入排序算法：</p><ol><li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li><li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li><li>重复直到所有输入数据插入完为止。</li></ol><p>本题可与<a href="http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/">LeetCode143-重排链表</a>，<a href="http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">LeetCode148-排序链表</a>共同学习。</p><a id="more"></a><img src="/blog/2020/11/21/LeetCode147-对链表进行插入排序/description.png" style="zoom:80%;"><img src="/blog/2020/11/21/LeetCode147-对链表进行插入排序/示例.png" style="zoom:100%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，使用一个指针记录下一个要进行排序的节点；对于当前节点，从头开始寻找插入位置，然后将当前节点插入。</p><p>那么需要保存插入位置的前一个节点和后一个节点，从头开始，如果当前节点的值大于后一个节点，那么同时将两个节点后移，否则直接进行插入即可。</p><p>最后再将当前节点更新为下一个要进行排序的节点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            ListNode *next = node-&gt;next;</span><br><span class="line">            <span class="comment">// 对排好序的链表进行插入</span></span><br><span class="line">            ListNode *pre = dummyNode;</span><br><span class="line">            ListNode *sorted = dummyNode-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(sorted)&#123;</span><br><span class="line">                <span class="comment">// 当前点大于后一个点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;val &gt; sorted-&gt;val)&#123;</span><br><span class="line">                    pre = sorted;</span><br><span class="line">                    sorted = sorted-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时当前点小于等于最后一个点，可以进行插入</span></span><br><span class="line">            <span class="comment">// 此时sorted之前的点都已经排好序了</span></span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            node-&gt;next = sorted;</span><br><span class="line"></span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;插入排序算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。&lt;/li&gt;
&lt;li&gt;每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。&lt;/li&gt;
&lt;li&gt;重复直到所有输入数据插入完为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本题可与&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/&quot;&gt;LeetCode143-重排链表&lt;/a&gt;，&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/&quot;&gt;LeetCode148-排序链表&lt;/a&gt;共同学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="插入排序" scheme="http://www.xingyuzhao.ltd/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库-I/O库</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/21/C-%E6%A0%87%E5%87%86%E5%BA%93-I-O%E5%BA%93/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/21/C-%E6%A0%87%E5%87%86%E5%BA%93-I-O%E5%BA%93/</id>
    <published>2020-11-21T12:35:33.000Z</published>
    <updated>2020-11-21T14:30:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>I/O类</li><li>文件输入输出</li><li>string流</li></ol><a id="more"></a><h4 id="I-O类"><a href="#I-O类" class="headerlink" title="I/O类"></a>I/O类</h4><p><code>iostream</code>定义了用于读写流的基本类型。</p><p><code>fstream</code>定义了用于读写命名文件的类型。</p><p><code>sstream</code>定义了用于读写内存<code>string</code>对象的类型。</p><img src="/blog/2020/11/21/C-标准库-I-O库/io类.png" style="zoom:120%;"><p><code>I/O</code>对象无拷贝或赋值，传递和引用不能是<code>const</code>的。</p><h5 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h5><img src="/blog/2020/11/21/C-标准库-I-O库/条件状态.png" style="zoom:120%;"><p>上表是<code>I/O</code>类所定义的一些函数和标志，可以访问和操作流的<strong>条件状态</strong>。</p><p>由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态最简单的方法是将它当作一个条件使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line"><span class="comment">// ok：读操作成功</span></span><br></pre></td></tr></table></figure><h5 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出hi和换行，然后刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; flush; <span class="comment">// 输出hi后直接刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; ends;  <span class="comment">// 输出hi和一个空字符再刷新缓冲区</span></span><br></pre></td></tr></table></figure><h4 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h4><p>头文件<code>fstream</code>定义了三个类型来支持文件IO：</p><ol><li><strong>ifstream</strong>从一个给定文件读取数据。</li><li><strong>ofstream</strong>向一个给定文件写入数据。</li><li><strong>fstream</strong>可以读写给定文件。</li></ol><img src="/blog/2020/11/21/C-标准库-I-O库/fstream.png" style="zoom:120%;"><h5 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h5><p>创建文件流对象时，可以提供文件名（可选）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">// 构造一个ifstream并打开给定文件</span></span><br><span class="line">ofstream out; <span class="comment">// 输出文件流未关联到任何文件</span></span><br></pre></td></tr></table></figure><h5 id="成员函数open和close"><a href="#成员函数open和close" class="headerlink" title="成员函数open和close"></a>成员函数open和close</h5><p>open用来判断文件是否打开成功，一旦打开成功，它就保持与对应文件的关联，对于一个已经打开的文件流调用open会失败，直到使用close关闭文件，成功关闭后可以打开新的文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;</span><br><span class="line">in.close();</span><br><span class="line">in.open(ifile + <span class="string">"2"</span>);</span><br></pre></td></tr></table></figure><p>当一个<code>fstream</code>对象离开其作用域时，与之关联的文件会自动关闭。</p><h5 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h5><img src="/blog/2020/11/21/C-标准库-I-O库/文件模式.png" style="zoom:120%;"><p>指定文件模式有如下限制（部分）：</p><ul><li>只可以对<code>ofstream/fstream</code>对象设定out模式。</li><li>只可以对<code>ifstream/fstream</code>对象设定in模式。</li></ul><p>在未指定文件模式时，与<code>ifstream</code>关联的文件默认以in模式打开；与<code>ofstream</code>关联的文件默认以out模式打开；与<code>fstream</code>关联的文件默认以in和out模式打开。</p><p>默认情况下，<strong>以out模式打开文件会丢去已有数据</strong>。阻止一个<code>ofstream</code>清空给定文件内容的方法是同时指定app模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这几条语句中，file1都被截断</span></span><br><span class="line"><span class="comment">// 隐含以输出模式打开文件并截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file1"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 隐含地截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out1</span><span class="params">(<span class="string">"file1"</span>, ofstream::out)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">"flie2"</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">// 为了保留文本内容，必须显示指定app模式</span></span><br><span class="line"><span class="comment">// 隐含为输出模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file1"</span>, ofstream::app)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">app1</span><span class="params">(<span class="string">"file2"</span>, ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure><p><em>保留被<code>ofstream</code>打开地文件中已有数据地唯一方法是显示指定app或in模式（17.5.3节，676页）</em>。每次调用<code>open</code>时都会确定文件模式。</p><h4 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h4><p><code>istringstream</code>从<code>string</code>中读取数据。</p><p><code>ostringstream</code>向<code>string</code>中写入数据。</p><p><code>stringstream</code>既可从<code>string</code>中读数据也可以向<code>string</code>中写数据。</p><img src="/blog/2020/11/21/C-标准库-I-O库/stringstream.png" style="zoom:120%;"><h5 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h5><p>当我们的工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词，通常可以用<code>istringstream</code>。</p><p>假如一个文件，列出了一些人和他们所拥有的电话号码（一个或多个），输入文件可能如下：</p><img src="/blog/2020/11/21/C-标准库-I-O库/输入文件.png"><p>定义一个类描述输入数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; phones;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用程序读取数据文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line, word; <span class="comment">// 分别保存来自输入的一行和单词</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PersonInfo&gt; people;</span><br><span class="line"><span class="comment">// 逐行从输入读取数据，直到cin遇到文件尾（或其他错误）</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))&#123;</span><br><span class="line">PersonInfo info;</span><br><span class="line">    <span class="comment">// 将记录绑定到刚输入的行</span></span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">    record &gt;&gt; info.name;</span><br><span class="line">    <span class="keyword">while</span>(record &gt;&gt; word)</span><br><span class="line">        info.phones.push_back(word);</span><br><span class="line">    people.push_back(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h5><p>当我们逐步构造输出，最后一起进行打印时，可以使用ostringstream。对上一节的例子，逐个验证电话号码并将其格式化。将有效的号码输出到一个新文件中；对于无效的号码不输出到文件中，并打印一条包含人名和无效号码的错误信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;entry : people)&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> formatted, badNums;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nums : entry.phones)&#123;</span><br><span class="line">        <span class="comment">// 如果号码无效，将数的字符串写入badNums</span></span><br><span class="line">        <span class="keyword">if</span>(!valid(nums))&#123;</span><br><span class="line">            badnums &lt;&lt; <span class="string">" "</span> &lt;&lt; nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 号码有效，将格式化的字符串写入formatted</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            formatted &lt;&lt; <span class="string">" "</span> format(nums);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有错误的数，打印名字和格式化的数</span></span><br><span class="line">    <span class="keyword">if</span>(badNums.str().empty())</span><br><span class="line">        os &lt;&lt; entry.name &lt;&lt; <span class="string">" "</span> &lt;&lt; formatted.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 否则，打印名字和错误的数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"input error:"</span> &lt;&lt; entry.name  </span><br><span class="line">        &lt;&lt; <span class="string">"invalid number(s)"</span> &lt;&lt; badNums.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设两个函数<code>valid</code>和<code>format</code>已知，分别完成电话号码的验证和格式化功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;I/O类&lt;/li&gt;
&lt;li&gt;文件输入输出&lt;/li&gt;
&lt;li&gt;string流&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>进程管理（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/17/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/17/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-11-17T14:24:00.000Z</published>
    <updated>2020-11-21T16:13:45.524Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>处理机调度概念、层次</li><li>进程调度的时机/切换与过程/方式</li><li>调度算法的评价指标</li><li>非交互性调度算法</li><li>交互性调度算法</li></ol><a id="more"></a><h4 id="处理机调度概念、层次"><a href="#处理机调度概念、层次" class="headerlink" title="处理机调度概念、层次"></a>处理机调度概念、层次</h4><p><strong>处理机调度</strong>是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理及分配给它运行，以实现进程并发的执行。</p><p><strong>调度的三个层次</strong></p><ol><li><p>高级调度（作业调度）</p><ul><li>按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使他（们）获得竞争处理机的权利。</li><li><strong>作业调入一次（建立PCB），调出一次（撤销PCB）。</strong></li><li>高级调度主要是指调入的问题，只有调入的时机需要操作系统来确定，调出必然是作业结束时刻。</li><li>执行频率低。</li></ul></li><li><p>中级调度（内存调度）</p><ul><li><p>引入虚拟存储技术后，可将在暂时不能运行的进程调至外存等待，此时状态称为<strong>挂起态。</strong></p></li><li><p>PCB不会调到外存，而是常驻内存，被挂起的进程PCB会被放到挂起队列中。</p></li><li><p>中级调度就是决定将哪个处于挂起态的进程重新调入内存。</p></li><li><p>一个进程可能会被多次调出、调入内存，中级调度频率高于高级调度。</p></li><li><p>进程的挂起态与七状态模型。</p></li></ul><img src="/blog/2020/11/17/进程管理（二）/7states.png"></li><li><p>低级调度（进程调度）</p><ul><li>按照某种方法从就绪队列中选取一个进程，将处理机分配给他。</li><li>是<strong>最基本的一种调度。</strong></li><li>频率很高，一般几十毫秒一次。</li></ul><p><strong>三层调度的联系、对比</strong></p></li></ol><img src="/blog/2020/11/17/进程管理（二）/三层调度的联系及对比.png"><p><em>调度算法要研究的问题</em>：<strong>高级调度、进程调度</strong></p><h4 id="进程调度的时机-切换与过程-方式"><a href="#进程调度的时机-切换与过程-方式" class="headerlink" title="进程调度的时机/切换与过程/方式"></a>进程调度的时机/切换与过程/方式</h4><h5 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h5><img src="/blog/2020/11/17/进程管理（二）/进程调度的时机.png"><p>需要注意：</p><ol><li>进程在<strong>操作系统内核程序临界区</strong>中<em>不能</em>进行调度与切换<ul><li>内核程序临界区时用来访问某种内核数据结构的（如进程的就绪队列，由各就绪进程的PCB组成）。</li><li>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。</li></ul></li><li>进程处于<strong>临界区</strong>时<em>可以</em>进行处理机调度<ul><li>如打印机在打印完成之前，进程一直处于临界区内并将临界资源上锁，但打印机是慢速设备，如果此时不允许进程调度会导致CPU一直空闲。</li><li>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，因此普通临界区可以进行调度和切换。</li></ul></li></ol><h5 id="进程调度的切换与过程"><a href="#进程调度的切换与过程" class="headerlink" title="进程调度的切换与过程"></a>进程调度的切换与过程</h5><p><em>狭义的进程调度</em>指的是从就绪队列中选中一个要运行的进程，可以是刚刚被暂停的进程，也可能是另外一个进程，后者需要进程切换。</p><p><em>广义的进程调度</em>指包含了选择一个进程和进程切换两个步骤。</p><p><em>进程切换</em>是指一个进程让出处理机，由另一个进程占用处理机的过程。进程切换的过程主要完成了：</p><ol><li>对原来运行进程各种数据的保存。</li><li>对新的进程各种数据的恢复。</li></ol><p><strong>注意</strong>：进程切换时由代价的，过于频繁的进行进程调度、切换，会使整个系统的效率降低。</p><h5 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h5><ol><li>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</li><li>剥夺调度方式，又称抢占方式。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合与分时操作系统、实时操作系统。</li></ol><h4 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h4><img src="/blog/2020/11/17/进程管理（二）/调度算法的评价指标.png"><h5 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h5><p>$$<br>利用率=\frac{忙碌的时间}{总时间}<br>$$</p><h5 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h5><p>单位时间内完成作业的数量。<br>$$<br>系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间}、<br>$$</p><h5 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h5><p>从<strong>作业被提交给系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔，它包括4个部分：</p><ol><li>作业在外存后备队列上等待作业调度（高级调度）的时间。</li><li>进程在就绪队列上等待进程调度（低级调度）的时间。</li><li>进程在CPU上执行的时间。</li><li>进程等待I/O操作完成的时间。</li></ol><p>后三项可能发生多次。<br>$$<br>周转时间=作业完成时间-作业提交时间<br>$$</p><p>$$<br>平均周转时间=\frac{各作业周转时间之和}{作业数}<br>$$</p><p>$$<br>带权周转时间=\frac{作业周转时间}{作业实际运行的时间}=\frac{作业完成时间-作业提交时间}{作业实际运行的时间}<br>$$</p><p>$$<br>平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}<br>$$</p><p>后两个比较重要，带权周转时间和周转时间都是越短越好。</p><h5 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h5><p>进程/作业处于等待处理机状态时间之和。</p><p>对于<strong>进程</strong>来说，等待时间就是指建立进程后等待被服务的时间之和，在等待I/O完成的期间其实进程也是被服务的，不计入等待时间内。</p><p>对于<strong>作业</strong>来说，不仅考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><h5 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h5><p>从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p><h4 id="非交互性调度算法"><a href="#非交互性调度算法" class="headerlink" title="非交互性调度算法"></a>非交互性调度算法</h4><h5 id="先来先服务（FCFS-First-Come-First-Serve）"><a href="#先来先服务（FCFS-First-Come-First-Serve）" class="headerlink" title="先来先服务（FCFS, First Come First Serve）"></a>先来先服务（FCFS, First Come First Serve）</h5><img src="/blog/2020/11/17/进程管理（二）/先来先服务.png"><h5 id="最短作业优先（SJF-Shortest-Job-First）"><a href="#最短作业优先（SJF-Shortest-Job-First）" class="headerlink" title="最短作业优先（SJF, Shortest Job First）"></a>最短作业优先（SJF, Shortest Job First）</h5><p>最短作业/进程优先得到服务；既可用于作业调度，也可用于进程调度，用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”；SJF和SPF是<strong>非抢占式的算法</strong>，也有<strong>抢占式的版本</strong>—<strong>最短剩余时间优先</strong>算法（SRTN, Shortest Remaining Time Next）。</p><p>短作业/进程优先调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>运行时间最短</strong>的作业/进程，对比FCFS，SPF的平均等待/周转/带权周转的时间都要低。</p><p>最短剩余时间优先算法：每当有进程加入，就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占</strong>处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。对比非抢占式的算法，其平均等待/周转/带权周转的时间都要低。</p><img src="/blog/2020/11/17/进程管理（二）/SJF.png"><h5 id="最高响应比优先（HRRN-Highest-Response-Ratio-Next）"><a href="#最高响应比优先（HRRN-Highest-Response-Ratio-Next）" class="headerlink" title="最高响应比优先（HRRN, Highest Response Ratio Next）"></a>最高响应比优先（HRRN, Highest Response Ratio Next）</h5><p>非抢占式的调度算法，只有当前运行的进程<strong>主动放弃CPU时</strong>，才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。<br>$$<br>响应比=\frac{等待时间+要求服务时间}{要求服务时间}<br>$$<br><img src="/blog/2020/11/17/进程管理（二）/HRRN.png"></p><h4 id="交互性调度算法"><a href="#交互性调度算法" class="headerlink" title="交互性调度算法"></a>交互性调度算法</h4><h5 id="时间片轮转（RR-Round-Robin）"><a href="#时间片轮转（RR-Round-Robin）" class="headerlink" title="时间片轮转（RR, Round-Robin）"></a>时间片轮转（RR, Round-Robin）</h5><p>轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列头的进程），常用于分时操作系统。</p><p>如果<strong>时间片过大</strong>，使得每个进程可以在一个时间片内完成，则时间片轮转调度算法退化为<strong>先来先服务</strong>算法，且会增加进程响应时间。</p><p>如果<strong>时间片过小</strong>，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比列减少。</p><p>一般来说，设计时间片时要让切换进程的开销占比不超过1%。</p><img src="/blog/2020/11/17/进程管理（二）/RR.png"><h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p><em>非抢占式的优先级调度算法</em>：每次调度时选择当前已到达且优先级最高的进程。当前进程<strong>主动</strong>放弃处理机时发生调度。</p><p><em>抢占式的优先级调度算法</em>：每次调度时选择当前已到达且优先级最高的进程。当前进程<strong>主动</strong>放弃处理机时发生调度。另外，当<strong>就绪队列发生改变时</strong>也需要检查是否会发生抢占。</p><ol><li><em>静态优先级</em>：创建进程时确定，之后一直不变。</li><li><em>动态优先级</em>：创建进程时有一个初始值，之后会根据情况动态的调整优先级。</li></ol><p>如何合理设置优先级，通常情况下：</p><ul><li>系统进程优先级<strong>高于</strong>用户进程</li><li>前台进程优先级<strong>高于</strong>后台进程</li><li>操作系统<strong>更偏好I/O型进程（I/O繁忙型进程）</strong><ul><li>I/O设备和CPU可以并行工作，最好让其尽早投入工作</li></ul></li></ul><p>采取动态优先级，何时调整：</p><ul><li>某进程在就绪队列中等待很长时间，可适当提高其优先级</li><li>某进程占用处理机运行了很长时间，可适当降低其优先级</li><li>某进程频繁进行I/O操作，可适当提升其优先级</li></ul><img src="/blog/2020/11/17/进程管理（二）/优先级调度算法.png"><h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><img src="/blog/2020/11/17/进程管理（二）/多级反馈队列调度算法.png"><p><strong>总结</strong>：</p><img src="/blog/2020/11/17/进程管理（二）/总结.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;处理机调度概念、层次&lt;/li&gt;
&lt;li&gt;进程调度的时机/切换与过程/方式&lt;/li&gt;
&lt;li&gt;调度算法的评价指标&lt;/li&gt;
&lt;li&gt;非交互性调度算法&lt;/li&gt;
&lt;li&gt;交互性调度算法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>进程管理（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/11/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/11/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-11-11T14:41:11.000Z</published>
    <updated>2020-11-14T15:45:42.079Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>进程的定义、组成、组织方式、特征</li><li>线程</li></ol><a id="more"></a><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><h5 id="一、进程的概念"><a href="#一、进程的概念" class="headerlink" title="一、进程的概念"></a>一、进程的概念</h5><p>多道程序环境下引入<em>进程</em>的概念，为了更好地描述和控制程序的并发执行，实现操作系统的并发行和共享性。</p><ol><li><p>进程控制块(Process Control Block, PCB)：描述进程的基本情况和运行状态，进而控制和管理进程，<strong>PCB是进程存在的唯一标志</strong>。</p></li><li><p><strong>进程映像（进程实体）</strong>由程序段、相关数据段和PCB构成，进程映像是静态的，进程是动态的。</p></li><li><p><strong>进程</strong>是<strong>进程实体</strong>的运行过程，是系统进行资源分配和调度的一个独立单位。</p></li><li><p><strong>进程的典型定义</strong>：</p><ol><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理及上顺序执行时所发生的活动</li><li>进程时具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ol></li></ol><h5 id="二、进程的组成"><a href="#二、进程的组成" class="headerlink" title="二、进程的组成"></a>二、进程的组成</h5><img src="/blog/2020/11/11/进程管理（一）/进程的组成.png"><h5 id="三、进程的特征"><a href="#三、进程的特征" class="headerlink" title="三、进程的特征"></a>三、进程的特征</h5><ol><li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消失的，<strong>最基本特征</strong></li><li>并发性：内存中有多个进程实体，各进程可并发执行</li><li>独立性：进程是能独立运行、独立获得资源、独立接受调度的<strong>基本单位</strong></li><li>异步性：各进程按照独立的、<strong>不可预知</strong>的速度向前推进，操作系统要提供<strong>进程同步机制</strong>来解决异步问题</li><li>结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成</li></ol><h5 id="四、进程的状态与转换"><a href="#四、进程的状态与转换" class="headerlink" title="四、进程的状态与转换"></a>四、进程的状态与转换</h5><img src="/blog/2020/11/11/进程管理（一）/进程的状态.png"><p>创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB</p><p>终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</p><h6 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h6><ol><li>运行态：占有CPU，并在CPU上运行（单核处理器下，每个时刻最多一个进程处于运行态）</li><li>就绪态：已经具备运行条件，但由于没有空闲CPU，暂时不能运行（万事俱备，只欠CPU）</li><li>阻塞态：又称等待态，进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机），或等待输入/输出完成。即使处理机空闲，该进程也不能运行</li></ol><h6 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h6><img src="/blog/2020/11/11/进程管理（一）/进程的状态转换.png"><p>就绪态-&gt;运行态：进程被调度</p><p>运行态-&gt;就绪态：时间片到，或CPU被其他高优先级的进程抢占</p><p>运行态-&gt;阻塞态：等待系统分配资源，或等到某事件发生（<em>主动行为</em>）</p><p>阻塞态-&gt;就绪态：资源分配到位，等待的事件发生（<em>被动行为</em>）</p><h5 id="五、进程控制"><a href="#五、进程控制" class="headerlink" title="五、进程控制"></a>五、进程控制</h5><p>进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为<strong>原语</strong>，<strong>原语</strong>的特点是在<strong>执行期间不允许中断</strong>，它是一个不可分割的基本单位，<strong>原语采用关中断指令和开中断指令实现</strong>。</p><h6 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h6><img src="/blog/2020/11/11/进程管理（一）/进程的创建.png"><h6 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h6><img src="/blog/2020/11/11/进程管理（一）/进程的终止.png"><h6 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h6><p>进程的阻塞和唤醒要成对出现</p><img src="/blog/2020/11/11/进程管理（一）/进程的阻塞和唤醒.png"><h6 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h6><img src="/blog/2020/11/11/进程管理（一）/进程的切换.png"><h5 id="六、进程通信"><a href="#六、进程通信" class="headerlink" title="六、进程通信"></a>六、进程通信</h5><img src="/blog/2020/11/11/进程管理（一）/进程通信.png"><h6 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h6><p>两个进程对共享空间的访问必须是互斥的，通过操作系统提供的工具实现。操作系统只负责提供共享空间和同步互斥工具（如P、V操作）。</p><p>方法：</p><ol><li><p>基于数据结构的共享，低级通信方式</p></li><li><p>基于存储区的共享，高级通信方式</p></li></ol><h6 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h6><p>进程间数据交换以<strong>格式化的消息</strong>为单位，包括消息头和消息体。进程通过操作系统提供的“发送信息/接受信息”两个原语进行数据交换。</p><p>方法：</p><ol><li>直接通信方式，发送进程将消息直接发送给接收进程，挂在接收进程的消息缓冲队列上</li><li>间接通信方式，消息要先发送到中间实体（信箱）中，也称“信箱通信方式”</li></ol><h6 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h6><ol><li>管道通信采用半双工，若要实现双向同时通信，需要设置两个管道</li><li>各进程要互斥地访问管道</li><li>管道满时，写进程write()系统调用被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程read()被阻塞</li><li>如果<strong>没写满就不允许读</strong>，如果<strong>没读空就不允许写</strong></li><li>数据一旦被读出，就从管道中被抛弃，意味着读进程最多只能有一个</li></ol><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行的执行一系列程序。为此，引入了“线程”来增加并发度，<strong>引入线程后，线程成为了程序执行流的最小单位</strong>。</p><p>引入线程后，进程只作为除CPU之外的系统资源的分配单位，线程则作为处理机的分配单元。</p><img src="/blog/2020/11/11/进程管理（一）/线程.png"><h5 id="一、线程的实现方式"><a href="#一、线程的实现方式" class="headerlink" title="一、线程的实现方式"></a>一、线程的实现方式</h5><ol><li>用户级线程</li></ol><img src="/blog/2020/11/11/进程管理（一）/用户级线程.png" style="zoom:80%;"><ol start="2"><li>内核级线程</li></ol><img src="/blog/2020/11/11/进程管理（一）/内核级线程.png" style="zoom:80%;"><ol start="3"><li>二者组合方式，将n个用户级线程映射到m个内核级线程上（n&gt;=m）</li></ol><img src="/blog/2020/11/11/进程管理（一）/组合线程实现.png" style="zoom:80%;"><p>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p><h5 id="二、多线程模型"><a href="#二、多线程模型" class="headerlink" title="二、多线程模型"></a>二、多线程模型</h5><p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p><ol><li>多对一模型：多个用户级线程映射到一个内核级线程</li></ol><img src="/blog/2020/11/11/进程管理（一）/多线程1.png" style="zoom:80%;"><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p><ol start="2"><li>一对一模型：一个用户级线程映射到一个内核级线程</li></ol><img src="/blog/2020/11/11/进程管理（一）/多线程2.png" style="zoom:80%;"><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行。</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，线程管理成本高，开销大。</p><ol start="3"><li>多对多模型：n个用户级线程映射到m个内核级线程（n&gt;=m）</li></ol><img src="/blog/2020/11/11/进程管理（一）/多线程3.png" style="zoom:80%;"><p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;进程的定义、组成、组织方式、特征&lt;/li&gt;
&lt;li&gt;线程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>图论（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/03/%E5%9B%BE%E8%AE%BA2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/03/%E5%9B%BE%E8%AE%BA2/</id>
    <published>2020-11-03T08:06:02.000Z</published>
    <updated>2020-11-14T15:49:33.294Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>读取一个图</li><li>深度优先搜索DFS</li><li>广度优先搜索BFS</li></ol><a id="more"></a><h4 id="从文件中读取一个图"><a href="#从文件中读取一个图" class="headerlink" title="从文件中读取一个图"></a>从文件中读取一个图</h4><p>如果要从已有的文件中读取并构建一张图，需要使用到C++的IO库，使用头文件<code>fstream</code>和<code>sstream</code>，类型如下:</p><p><strong>fstream:</strong></p><ul><li><code>ifstream, wifstream</code>从文件中读取数据</li><li><code>ofstream, wofstram</code>向文件中写入数据</li><li><code>fstream, wfstream</code>读写文件</li></ul><p><strong>sstream:</strong></p><ul><li><code>istringstream, wistringfstream</code>从<code>string</code>中读取数据</li><li><code>ostringstream, wosringstream</code>向<code>string</code>中写入数据</li><li><code>stringstream, wstringstream</code>读写<code>string</code></li></ul><h5 id="读文件—类的实现"><a href="#读文件—类的实现" class="headerlink" title="读文件—类的实现"></a>读文件—类的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ReadGraph(Graph &amp;graph, <span class="keyword">const</span> <span class="built_in">string</span> &amp;filename)&#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">int</span> V, E;</span><br><span class="line"></span><br><span class="line">        assert(file.is_open());</span><br><span class="line">        assert(getline(file, line));</span><br><span class="line">        <span class="comment">// 首先读入顶点数和边数</span></span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">        ss &gt;&gt; V &gt;&gt; E;</span><br><span class="line">        assert(V == graph.V());</span><br><span class="line">        <span class="comment">// 读入每一条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; ++i)&#123;</span><br><span class="line">            assert(getline(file, line));</span><br><span class="line">            <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            ss &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            assert(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; V);</span><br><span class="line">            assert(b &gt;= <span class="number">0</span> &amp;&amp; b &lt; V);</span><br><span class="line">            graph.addEdge(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="测试主函数"><a href="#测试主函数" class="headerlink" title="测试主函数"></a>测试主函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    <span class="comment">// G2是有6个顶点的无向图</span></span><br><span class="line">    <span class="function">SparseGraph <span class="title">g1</span><span class="params">(<span class="number">6</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g1, filename)</span></span>;</span><br><span class="line">    <span class="comment">// 在两种头文件中新加show函数打印结果</span></span><br><span class="line">    g1.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DenseGraph <span class="title">g2</span><span class="params">(<span class="number">6</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;DenseGraph&gt; <span class="title">readGraph2</span><span class="params">(g2, filename)</span></span>;</span><br><span class="line">    g2.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">vertex <span class="number">0</span>:       <span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line">vertex <span class="number">1</span>:       <span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">vertex <span class="number">2</span>:       <span class="number">0</span> <span class="number">1</span></span><br><span class="line">vertex <span class="number">3</span>:       <span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">vertex <span class="number">4</span>:       <span class="number">1</span> <span class="number">3</span></span><br><span class="line">vertex <span class="number">5</span>:       <span class="number">0</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">vertex <span class="number">0</span>:       <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">vertex <span class="number">1</span>:       <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">vertex <span class="number">2</span>:       <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">vertex <span class="number">3</span>:       <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">vertex <span class="number">4</span>:       <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">vertex <span class="number">5</span>:       <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h4><p>与二叉树的深度优先搜索遍历不同，二叉树总会遇到空，但是图可能成环，或者无向图，所以遍历时应记录每个节点是否被遍历了。</p><h5 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h5><p>无向图Graph的极大连通子图称为G的<strong>连通分量</strong>( Connected Component)。任何<strong>连通图</strong>的连通分量只有一个，即是其自身，<strong>非连通的无向图</strong>有多个连通分量。如图所示，无向图共有4个连通分量：</p><img src="/blog/2020/11/03/图论2/dfs1.png"><p>对于一个非连通的无向图来说，可以用DFS得到Graph共有几个连通分量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Components</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">bool</span> *visited; <span class="comment">// 当前节点是否被遍历过</span></span><br><span class="line">    <span class="keyword">int</span> ccount;<span class="comment">// 记录连通分量总数</span></span><br><span class="line">    <span class="keyword">int</span> *id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 相当于并查集，让同一个联通分量中的节点指向同一个数</span></span><br><span class="line">    id[v] = ccount;</span><br><span class="line">    <span class="comment">// 编译器无法判断是Graph的一个类型还是一个成员变量，需加关键字typename</span></span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = adj.begin(); !adj.end(); i = adj.next())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Components(Graph &amp;graph): G(graph)&#123;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[G.v()];</span><br><span class="line">        ccount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); ++i)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            id[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">                ccount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Components()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">delete</span>[] id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ccount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询两个节点是否相连</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; G.V());</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V());</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="测试主函数-1"><a href="#测试主函数-1" class="headerlink" title="测试主函数"></a>测试主函数</h6><p>对于图<code>testG1.txt</code>和<code>testG2.txt</code>，先从文件中读取到稀疏图中，再对此图进行DFS得到连通分量的个数，两个文件内容分别为：</p><ul><li>testG1:</li></ul><img src="/blog/2020/11/03/图论2/testG1.png"><ul><li>testG2:</li></ul><img src="/blog/2020/11/03/图论2/testG2.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename1 = <span class="string">"testG1.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SparseGraph <span class="title">g1</span><span class="params">(<span class="number">13</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph1</span><span class="params">(g1, filename1)</span></span>;</span><br><span class="line">    <span class="function">Components&lt;SparseGraph&gt; <span class="title">component1</span><span class="params">(g1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"TestG1.txt, Component Count: "</span>&lt;&lt; component1.count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> filename2 = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    <span class="function">SparseGraph <span class="title">g2</span><span class="params">(<span class="number">6</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph2</span><span class="params">(g2, filename2)</span></span>;</span><br><span class="line">    <span class="function">Components&lt;SparseGraph&gt; <span class="title">component2</span><span class="params">(g2)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"TestG2.txt, Component Count: "</span> &lt;&lt; component2.count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">TestG1.txt, Component Count: <span class="number">3</span></span><br><span class="line">TestG2.txt, Component Count: <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="获得两点之间的一条路径"><a href="#获得两点之间的一条路径" class="headerlink" title="获得两点之间的一条路径"></a>获得两点之间的一条路径</h5><p>使用DFS可以找连通图两点之间的一条路径，但不一定是最短路径。对于稀疏图，复杂度为O(V+E)，对于稠密图，复杂度为O(V^2)。对于下图，寻找节点0到节点6的一条路径。</p><img src="/blog/2020/11/03/图论2/dfs2.png"><p>在遍历每个节点时，可以存储当前节点是由哪个节点遍历到的，以此可以反推出原始节点到当前节点的一条路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="comment">// 源节点</span></span><br><span class="line">    <span class="keyword">bool</span> *visited;</span><br><span class="line">    <span class="keyword">int</span> *from; <span class="comment">// 当前节点是由哪个节点遍历到的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = adj.begin(); !adj.end(); i = adj.next())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="comment">// 节点i是由节点v遍历到的</span></span><br><span class="line">                from[i] = v;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Path(Graph &amp;graph, <span class="keyword">int</span> s): G(graph)&#123;</span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        assert(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V());</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); ++i)&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="comment">// 寻路</span></span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Path()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] visited;</span><br><span class="line">        <span class="keyword">delete</span> [] from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="comment">// 找到从源节点到目标节点所经过的每一个节点入栈</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span>)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            <span class="comment">// 将p更新为可以到达p的一个节点</span></span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="comment">// 出栈是正向路径</span></span><br><span class="line">            vec.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        path(w, vec);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vec[i];</span><br><span class="line">            <span class="keyword">if</span> (i == vec.size() - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="测试主函数-2"><a href="#测试主函数-2" class="headerlink" title="测试主函数"></a>测试主函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph</span><span class="params">(g, filename)</span></span>;</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Path&lt;SparseGraph&gt; <span class="title">dfs</span><span class="params">(g, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"DFS : "</span>;</span><br><span class="line">    dfs.showPath(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">vertex <span class="number">0</span>:       <span class="number">1</span>       <span class="number">2</span>       <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">vertex <span class="number">1</span>:       <span class="number">0</span></span><br><span class="line">vertex <span class="number">2</span>:       <span class="number">0</span></span><br><span class="line">vertex <span class="number">3</span>:       <span class="number">4</span>       <span class="number">5</span></span><br><span class="line">vertex <span class="number">4</span>:       <span class="number">3</span>       <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">vertex <span class="number">5</span>:       <span class="number">0</span>       <span class="number">3</span>       <span class="number">4</span></span><br><span class="line">vertex <span class="number">6</span>:       <span class="number">0</span>       <span class="number">4</span></span><br><span class="line"></span><br><span class="line">DFS : <span class="number">0</span> -&gt; <span class="number">5</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h4><p>使用深度优先搜索可以找到无权图两个节点之间的最短路径，复杂度与DFS相同。</p><h5 id="最短路径—类的实现"><a href="#最短路径—类的实现" class="headerlink" title="最短路径—类的实现"></a>最短路径—类的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Graph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">bool</span> *visited;</span><br><span class="line">    <span class="keyword">int</span> *from;</span><br><span class="line">    <span class="keyword">int</span> *ord; <span class="comment">// 当前点到源节点的最短距离</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ShortestPath(Graph &amp;graph, <span class="keyword">int</span> s): G(graph)&#123;</span><br><span class="line">        <span class="comment">// 算法初始化</span></span><br><span class="line">        assert(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.V());</span><br><span class="line"></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">bool</span>[graph.V()];</span><br><span class="line">        from = <span class="keyword">new</span> <span class="keyword">int</span>[graph.V()];</span><br><span class="line">        ord = <span class="keyword">new</span> <span class="keyword">int</span>[graph.V()];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; graph.V() ; i ++ )&#123;</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            from[i] = <span class="number">-1</span>;</span><br><span class="line">            ord[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 无向图最短路径算法</span></span><br><span class="line">        q.push(s);</span><br><span class="line">        visited[s] = <span class="literal">true</span>;</span><br><span class="line">        ord[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = adj.begin(); !adj.end(); i = adj.next())&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                    q.push(i);</span><br><span class="line">                    visited[i] = <span class="literal">true</span>;</span><br><span class="line">                    from[i] = v;</span><br><span class="line">                    ord[i] = ord[v] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ShortestPath()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] visited;</span><br><span class="line">        <span class="keyword">delete</span> [] from;</span><br><span class="line">        <span class="keyword">delete</span> [] ord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> p = w;</span><br><span class="line">        <span class="keyword">while</span>( p != <span class="number">-1</span> )&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = from[p];</span><br><span class="line">        &#125;</span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">while</span>( !s.empty() )&#123;</span><br><span class="line">            vec.push_back( s.top() );</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        path(w, vec);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vec.size() ; i ++ )&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;vec[i];</span><br><span class="line">            <span class="keyword">if</span>( i == vec.size()<span class="number">-1</span> )</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">" -&gt; "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert( w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.V() );</span><br><span class="line">        <span class="keyword">return</span> ord[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="测试主函数-3"><a href="#测试主函数-3" class="headerlink" title="测试主函数"></a>测试主函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> filename = <span class="string">"testG2.txt"</span>;</span><br><span class="line">    SparseGraph g = SparseGraph(<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="function">ReadGraph&lt;SparseGraph&gt; <span class="title">readGraph</span><span class="params">(g, filename)</span></span>;</span><br><span class="line">    g.show();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Path&lt;SparseGraph&gt; <span class="title">dfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"DFS : "</span>;</span><br><span class="line">    dfs.showPath(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">ShortestPath&lt;SparseGraph&gt; <span class="title">bfs</span><span class="params">(g,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BFS : "</span>;</span><br><span class="line">    bfs.showPath(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"Shortest length : "</span> &lt;&lt; bfs.length(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">vertex <span class="number">0</span>:       <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">vertex <span class="number">1</span>:       <span class="number">0</span></span><br><span class="line">vertex <span class="number">2</span>:       <span class="number">0</span></span><br><span class="line">vertex <span class="number">3</span>:       <span class="number">4</span> <span class="number">5</span></span><br><span class="line">vertex <span class="number">4</span>:       <span class="number">3</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">vertex <span class="number">5</span>:       <span class="number">0</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">vertex <span class="number">6</span>:       <span class="number">0</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">DFS : <span class="number">0</span> -&gt; <span class="number">5</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span></span><br><span class="line">BFS : <span class="number">0</span> -&gt; <span class="number">5</span> -&gt; <span class="number">4</span></span><br><span class="line">Shortest Length : <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="完整工程："><a href="#完整工程：" class="headerlink" title="完整工程："></a>完整工程：</h4><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;读取一个图&lt;/li&gt;
&lt;li&gt;深度优先搜索DFS&lt;/li&gt;
&lt;li&gt;广度优先搜索BFS&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>图论（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/27/%E5%9B%BE%E8%AE%BA1/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/27/%E5%9B%BE%E8%AE%BA1/</id>
    <published>2020-10-27T14:40:55.000Z</published>
    <updated>2020-10-28T15:02:53.557Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>图的基本概念</li><li>图的两种表示方法及实现</li><li>对图进行遍历</li></ol><a id="more"></a><h4 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><h5 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h5><ul><li>节点（Vertex）</li><li>边（Edge）</li></ul><p>使用场景：交通运输，社交网络，互联网，工作安排，脑区活动，程序状态执行（自动机）等。</p><h5 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h5><ul><li>无向图（Undirected Graph）</li><li>有向图（Directed Graph）</li></ul><p>无向图是一种特殊的有向图，比如A指向B，同时B指向A</p><ul><li>无权图（Unweighted Graph）</li><li>有权图（Weighted Graph）</li></ul><p>其他概念：图的连通性，简单图（无自环边与平行边）</p><img src="/blog/2020/10/27/图论1/7-1-1.png" style="zoom:80%;"><h4 id="图的两种表示方法及实现（邻接矩阵与邻接表）"><a href="#图的两种表示方法及实现（邻接矩阵与邻接表）" class="headerlink" title="图的两种表示方法及实现（邻接矩阵与邻接表）"></a>图的两种表示方法及实现（邻接矩阵与邻接表）</h4><h5 id="邻接矩阵（适合表示稠密图Dense-Graph）"><a href="#邻接矩阵（适合表示稠密图Dense-Graph）" class="headerlink" title="邻接矩阵（适合表示稠密图Dense Graph）"></a>邻接矩阵（适合表示稠密图Dense Graph）</h5><img src="/blog/2020/10/27/图论1/7-2-1.png" style="zoom:80%;"><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenseGraph</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;      <span class="comment">// 节点数和边数</span></span><br><span class="line">    <span class="keyword">bool</span> directed; <span class="comment">// 是否是有向图</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; g;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DenseGraph(<span class="keyword">int</span> n, <span class="keyword">bool</span> directed)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            g.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DenseGraph()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> n;&#125; <span class="comment">// 图的节点总数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m;&#125; <span class="comment">// 图的边总数</span></span><br><span class="line">    <span class="comment">// 增加节点v与节点w之间的一条边</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">        <span class="keyword">if</span>(hasEdge(v, w)) <span class="keyword">return</span>; <span class="comment">// 处理了平行边，并且防止边数m多加一次</span></span><br><span class="line">        g[v][w] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!directed) <span class="comment">// 如果是无向图</span></span><br><span class="line">            g[w][v] = <span class="literal">true</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line">        <span class="keyword">return</span> g[v][w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="邻接表（适合表示稀疏图Sparse-Graph）"><a href="#邻接表（适合表示稀疏图Sparse-Graph）" class="headerlink" title="邻接表（适合表示稀疏图Sparse Graph）"></a>邻接表（适合表示稀疏图Sparse Graph）</h5><img src="/blog/2020/10/27/图论1/7-2-2.png" style="zoom:80%;"><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseGraph</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">bool</span> directed;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SparseGraph(<span class="keyword">int</span> n, <span class="keyword">bool</span> directed)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            g.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~SparseGraph()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> n;&#125; <span class="comment">// 图的节点总数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m;&#125; <span class="comment">// 图的边总数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line"></span><br><span class="line">        g[v].push_back(w);</span><br><span class="line">        <span class="keyword">if</span>(v != w &amp;&amp; !directed) <span class="comment">// 处理了自环边，并且防止边数m多加一次</span></span><br><span class="line">            g[w].push_back(v);</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n);</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[v][i] == w) <span class="comment">// 节点v与w相连</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="对图进行遍历——迭代器的实现"><a href="#对图进行遍历——迭代器的实现" class="headerlink" title="对图进行遍历——迭代器的实现"></a>对图进行遍历——迭代器的实现</h4><pre class="mermaid">graph LR    0-->3;    0-->5;    0-->8;</pre><p>在邻接矩阵中如下：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p>在邻接表中如下：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>3</td><td>5</td><td>8</td></tr></tbody></table><p>如果要遍历某个节点的所有邻边，可以借鉴迭代器的思想。</p><h5 id="稠密图（邻接矩阵中）"><a href="#稠密图（邻接矩阵中）" class="headerlink" title="稠密图（邻接矩阵中）"></a>稠密图（邻接矩阵中）</h5><p>在<code>DenseGraph</code>类中实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器实现</span></span><br><span class="line"><span class="comment">// 顶点的邻边按顺序输出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">adjIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DenseGraph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// 遍历到的节点坐标</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    adjIterator(DenseGraph &amp;graph, <span class="keyword">int</span> v) : G(graph) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (index; index &lt; G.V(); index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G.g[v][index]) <span class="comment">// 如果v与index相连</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有邻边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= G.V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="稀疏图（邻接表中）"><a href="#稀疏图（邻接表中）" class="headerlink" title="稀疏图（邻接表中）"></a>稀疏图（邻接表中）</h5><p>在<code>SparseGraph</code>类中实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">adjIterator</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SparseGraph &amp;G;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    adjIterator(SparseGraph &amp;graph, <span class="keyword">int</span> v):G(graph)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="comment">// 与稠密图不同的是，这里的index表示遍历到v的第index个节点，不表示节点index</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;index = index; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(G.g[v].size())</span><br><span class="line">            <span class="keyword">return</span> G.g[v].size();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; G.g[v].size())</span><br><span class="line">            <span class="keyword">return</span> G.g[v][index];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 返回-1说明已经遍历结束，此时index = G.g[v].size()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= G.g[v].size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>测试用主函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sparse Graph</span></span><br><span class="line">    <span class="comment">// 存在平行边</span></span><br><span class="line">    <span class="function">SparseGraph <span class="title">g1</span><span class="params">(N, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = rand() % N;</span><br><span class="line">        <span class="keyword">int</span> b = rand() % N;</span><br><span class="line">        g1.addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(E)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; N; ++v)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" : "</span>;</span><br><span class="line">        <span class="function">SparseGraph::adjIterator <span class="title">adj</span><span class="params">(g1, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = adj.begin(); !adj.end(); w = adj.next())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Dense Graph</span></span><br><span class="line">    <span class="comment">// 存在自环边</span></span><br><span class="line">    <span class="function">DenseGraph <span class="title">g2</span><span class="params">(N, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = rand() % N;</span><br><span class="line">        <span class="keyword">int</span> b = rand() % N;</span><br><span class="line">        g2.addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(V^2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; N; ++v)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" : "</span>;</span><br><span class="line">        <span class="function">DenseGraph::adjIterator <span class="title">adj</span><span class="params">(g2, v)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = adj.begin(); !adj.end(); w = adj.next())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Sparse Graph</span><br><span class="line">// 可以看出存在平行边</span><br><span class="line">0 : 3 6 6 7 6</span><br><span class="line">1 : 9 2</span><br><span class="line">2 : 7 9 5 1 9</span><br><span class="line">3 : 5 0 5 6 4 9 5</span><br><span class="line">4 : 6 3 8 6 8</span><br><span class="line">5 : 9 7 3 2 3 3 9</span><br><span class="line">6 : 9 4 0 3 9 0 4 0</span><br><span class="line">7 : 5 2 8 9 0</span><br><span class="line">8 : 7 8 9 4 4</span><br><span class="line">9 : 5 2 6 1 7 3 6 8 5 2</span><br><span class="line"></span><br><span class="line">// Sparse Graph</span><br><span class="line">// 可以看出存在自环边</span><br><span class="line">0 : 0 2 4</span><br><span class="line">1 : 4 5 7 9</span><br><span class="line">2 : 0 4 8</span><br><span class="line">3 : 3 4 5 6</span><br><span class="line">4 : 0 1 2 3 6 7 9</span><br><span class="line">5 : 1 3 6</span><br><span class="line">6 : 3 4 5 7 8 9</span><br><span class="line">7 : 1 4 6 7</span><br><span class="line">8 : 2 6 8</span><br><span class="line">9 : 1 4 6</span><br></pre></td></tr></table></figure><h4 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h4><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;图的基本概念&lt;/li&gt;
&lt;li&gt;图的两种表示方法及实现&lt;/li&gt;
&lt;li&gt;对图进行遍历&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode143-重排链表</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</id>
    <published>2020-10-27T01:50:20.000Z</published>
    <updated>2020-11-22T03:19:32.108Z</updated>
    
    <content type="html"><![CDATA[<p>本题同时解决<strong>LeetCode206-反转链表</strong>和<strong>LeetCode876-链表的中间结点</strong></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>本题可与<a href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more">LeetCode147-对链表进行插入排序</a>，<a href="http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/">LeetCode148-排序链表</a>共同学习。</p><a id="more"></a><img src="/blog/2020/10/27/LeetCode143-重排链表/示例.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>观察链表，对于长度为偶数的链表，如示例1，可以将2之后的子链表进行反转得到<code>4-&gt;3</code>，然后再与剩下的链表<code>1-&gt;2</code>交叉合并，得到<code>1-&gt;4-&gt;2-&gt;3</code>；</p><p>长度为奇数的链表同理，找到中间结点3，将3之后的子链表反转得到<code>5-&gt;4</code>，再与剩下的链表<code>1-&gt;2-&gt;3</code>进行合并，得到<code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>。</p><h4 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于偶数长度链表，找到的是中间靠后的一个</span></span><br><span class="line"><span class="function">ListNode* <span class="title">midNode</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || !root-&gt;next) </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    ListNode *fast = root;</span><br><span class="line">    ListNode *slow = root;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于偶数长度链表，找到的是中间靠前的一个</span></span><br><span class="line"><span class="function">ListNode* <span class="title">midNode</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || !root-&gt;next) </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    ListNode *fast = root;</span><br><span class="line">    ListNode *slow = root;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span>;</span><br><span class="line">        ListNode *mid = midNode(head);</span><br><span class="line">        ListNode *l2 = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>; </span><br><span class="line">        l2 = reverseList(l2);</span><br><span class="line">        mergeList(head, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">midNode</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">        ListNode *fast = root;</span><br><span class="line">        ListNode *slow = root;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *root)</span></span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode *l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode *tmp1;</span><br><span class="line">        ListNode *tmp2;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            tmp1 = l1-&gt;next;</span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            tmp2 = l2-&gt;next;</span><br><span class="line">            l2-&gt;next = tmp1;</span><br><span class="line">            l1 = tmp1;</span><br><span class="line">            l2 = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题同时解决&lt;strong&gt;LeetCode206-反转链表&lt;/strong&gt;和&lt;strong&gt;LeetCode876-链表的中间结点&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个单链表 L：L0→L1→…→Ln-1→Ln ，&lt;br&gt;将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;
&lt;p&gt;本题可与&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more&quot;&gt;LeetCode147-对链表进行插入排序&lt;/a&gt;，&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/&quot;&gt;LeetCode148-排序链表&lt;/a&gt;共同学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的三种遍历方法（迭代）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89/</id>
    <published>2020-10-19T03:01:41.000Z</published>
    <updated>2020-10-19T03:38:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概要</strong></p><ol><li>二叉树的前序遍历</li><li>二叉树的中序遍历</li><li>二叉树的后序遍历</li></ol><a id="more"></a><p>递归进行二叉树的遍历比较简单，学习使用迭代法进行二叉树的遍历，主要是使用栈这种数据结构。</p><h4 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h4><p>前序遍历的顺序为：中—左—右</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preOrder;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        TreeNode *node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            preOrder.push_back(node-&gt;val);</span><br><span class="line">            <span class="comment">// 这里需要注意，前序遍历第二次遍历的是左节点</span></span><br><span class="line">            <span class="comment">// 所以先将右节点入栈，再将左节点入栈，保证左节点先出栈</span></span><br><span class="line">            st.push(node-&gt;right);</span><br><span class="line">            st.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h4><p>中序遍历的顺序为：左—中—右</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode *node = root;</span><br><span class="line">    <span class="comment">// 先判断根节点不为空，进入迭代，后面再根据栈是否为空进行迭代</span></span><br><span class="line">    <span class="keyword">while</span>(!st.empty() || node)&#123;</span><br><span class="line">        <span class="comment">// 当前节点存在，查看其左节点情况，如果其左节点不存在，那就弹出当前节点</span></span><br><span class="line">        <span class="comment">// 再查看其右节点情况，如果右节点也不存在，就弹出当前栈顶（也就是上一个左节点）</span></span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            st.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h4><p>后序遍历的顺序为：左—右—中</p><h5 id="根据二叉树结构遍历"><a href="#根据二叉树结构遍历" class="headerlink" title="根据二叉树结构遍历"></a>根据二叉树结构遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    TreeNode *pre;</span><br><span class="line">    <span class="keyword">while</span>(cur || !st.empty())&#123;</span><br><span class="line">        <span class="comment">// 首先当前节点的左子树入栈</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出最后一个左节点</span></span><br><span class="line">        cur = st.top();</span><br><span class="line">        <span class="comment">// 如果当前节点的右节点为空或者已经遍历过了，那么就记录当前节点</span></span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;right || cur-&gt;right == pre)&#123;</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">// 如果记录了当前节点，那么当前节点必须置为空，否则会陷入第一个while中死循环</span></span><br><span class="line">            cur = <span class="literal">nullptr</span>;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则查看当前节点的右节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画演示：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/di-gui-die-dai-qu-qiao-san-chong-fang-fa-quan-jie-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/di-gui-die-dai-qu-qiao-san-chong-fang-fa-quan-jie-/</a></p><h5 id="破坏结构遍历"><a href="#破坏结构遍历" class="headerlink" title="破坏结构遍历"></a>破坏结构遍历</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    st.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">        TreeNode *node = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            st.push(node-&gt;left);</span><br><span class="line">            st.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到的结果是中—右—左，需要反转一下得到左—右—中</span></span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概要&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二叉树的前序遍历&lt;/li&gt;
&lt;li&gt;二叉树的中序遍历&lt;/li&gt;
&lt;li&gt;二叉树的后序遍历&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://www.xingyuzhao.ltd/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++类的一些知识点</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/18/C-%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/18/C-%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-10-18T14:31:26.000Z</published>
    <updated>2020-10-18T14:39:36.414Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》第七章内容——类</p><p><strong>部分总结</strong></p><a id="more"></a><h4 id="第七章：类"><a href="#第七章：类" class="headerlink" title="第七章：类"></a>第七章：类</h4><ol><li><h5 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h5></li></ol><ul><li><p>类可以允许其他类或者函数访问它的非共有成员，方法是令其他类或者函数（可以是成员函数也可以是非成员函数）成为它的友元。一般来说，在类的开始或者结束前位置集中声明友元。如果希望类的用户能够调用某个友元函数，那么就需要在类中友元声明之外再进行一次声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sale_data&amp;, <span class="keyword">const</span> Sale_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    /.../</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    /.../</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 非成员函数声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sale_data&amp;, <span class="keyword">const</span> Sale_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元的关系不具有传递性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">// Window_mgr的成员可以访问Screen类的私有部分</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">    /.../</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以只为某个成员函数提供访问权限</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="comment">// Window_mgr::clear必须再Screen类之前声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    /.../</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>构造函数</strong></li></ol><ul><li><p>使用构造函数初始值列表来初始化成员。</p></li><li><p>如果成员是引用或者const时，必须通过函数初始值列标将其初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstRef</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ConstRef(<span class="keyword">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line"><span class="keyword">int</span> &amp;ri;</span><br><span class="line">&#125;</span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii): i(ii), ci(ii), ri(ii);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>类的静态成员</strong></li></ol><ul><li><p>适用于类的成员直接与类相关，而不是与类的各个对象关联，比如说：银行的利率</p></li><li><p>静态成员可以是public或者private，使用关键字static，成员函数不用通过作用域运算符就能直接使用静态成员。静态成员不是由类的构造函数初始化的，一般在类的外部定义和初始化每个静态成员，只能定义一次：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> owner;</span><br><span class="line">    <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Account::rate</span><span class="params">(<span class="keyword">double</span> newRate)</span></span>&#123;</span><br><span class="line">    interestRate = newRate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义并初始化一个静态成员</span></span><br><span class="line"><span class="keyword">double</span> Account::interestRate = initRate();</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account c1;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    r = c1.rate();</span><br><span class="line">    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    </span><br><span class="line">    Account::rate(<span class="number">0.8</span>);</span><br><span class="line">    r = c1.rate();</span><br><span class="line">    <span class="comment">// 输出0.8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》第七章内容——类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分总结&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="类(class)" scheme="http://www.xingyuzhao.ltd/tags/%E7%B1%BB-class/"/>
    
  </entry>
  
  <entry>
    <title>LCP19-秋叶收藏集</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/11/LCP19-%E7%A7%8B%E5%8F%B6%E6%94%B6%E8%97%8F%E9%9B%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/11/LCP19-%E7%A7%8B%E5%8F%B6%E6%94%B6%E8%97%8F%E9%9B%86/</id>
    <published>2020-10-11T03:25:10.000Z</published>
    <updated>2020-10-12T09:27:57.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。<br>出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p><a id="more"></a><img src="/blog/2020/10/11/LCP19-秋叶收藏集/image-20201011112801516.png" style="zoom:80%;"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用三个状态来标记其中的每一个部分，0和2表示前面和后面的红色，1表示中间的黄色，于是三部分结构为「0、1、2」。</p><p>定义<code>dp[i][j]</code>表示：对**[0..i]<strong>片叶子进行调整，并且第</strong>i<strong>片叶子处于</strong>j**状态的最小操作数，所以有下面三种情况：</p><ol><li>当<strong>j = 0</strong>时，第<strong>i</strong>片叶子应为红色，并且第<strong>i - 1</strong>片叶子也应该处于<strong>j = 0</strong>的状态：</li></ol><p>$$<br>dp[i][0] = dp[i-1][0] + isYellow(i)<br>$$</p><p>$$<br>isYellow(i)=<br>\begin{cases}<br>1&amp; \text{leaves[i] = ‘y’}\\<br>0&amp; \text{leaves[i] = ‘r’}<br>\end{cases}<br>$$</p><p>如果是黄色，那么需要进行一次操作修改颜色：</p><ol start="2"><li>当<strong>j = 1</strong>时，第<strong>i</strong>片叶子应为黄色，第<strong>i - 1</strong>片叶子可以处于<strong>j = 0</strong>或<strong>j = 1</strong>的状态，所以取其中的较小值：</li></ol><p>$$<br>dp[i][1] = min(dp[i-1][1], dp[i-1][0]) + isRed(i)<br>$$</p><p>$$<br>isRed(i)=<br>\begin{cases}<br>1&amp; \text{leaves[i] = ‘r’}\\<br>0&amp; \text{leaves[i] = ‘y’}<br>\end{cases}<br>$$</p><p>​        如果是红色，那么需要进行一次操作修改颜色：</p><ol start="3"><li>当<strong>j = 2</strong>时，第<strong>i</strong>片叶子应为红色，第<strong>i - 1</strong>片叶子可以处于<strong>j = 2</strong>或<strong>j = 1</strong>的状态（不能取<strong>j = 0</strong>的状态，因为每种状态至少含有一片叶子，中间必须存在有黄色叶子），再取其中的较小值：</li></ol><p>$$<br>dp[i][2] = min(dp[i-1][2], dp[i-1][1]) + isYellow(i)<br>$$</p><p>如果是黄色，那么需要进行一次操作修改颜色，公式同1</p><p>最终答案为<code>dp[n-1][2]</code>。</p><p><strong><em>初始化条件：</em></strong></p><ol><li>要保证每种状态都有叶子，则叶子数量应大于等于状态数量，对于<code>dp[i][j]</code>，有<strong>i &gt;= j</strong>；如果<strong>i &lt; j</strong>，那么可以令<code>dp[i][j] = INT_MAX</code>；</li><li>对于<strong>i = 0</strong>，<strong>j</strong>也必须为0，于是有<code>dp[0][0] = isYellow(0)</code>。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">string</span> leaves)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(leaves.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = leaves[<span class="number">0</span>] == <span class="string">'y'</span>;</span><br><span class="line">        <span class="comment">// 不合要求的,实际上也不会遇到dp[0][2]这种情况</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">1</span>][<span class="number">2</span>] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; leaves.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> isYellow = leaves[i] == <span class="string">'y'</span>;</span><br><span class="line">            <span class="keyword">int</span> isRed = leaves[i] == <span class="string">'r'</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + isYellow;</span><br><span class="line">            dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]) + isRed;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>) dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + isYellow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[leaves.size() - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以优化空间，使用3个变量来代替状态转移数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">string</span> leaves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = leaves.size();</span><br><span class="line">        <span class="comment">// dp[0][0]</span></span><br><span class="line">        <span class="keyword">int</span> start = leaves[<span class="number">0</span>] == <span class="string">'y'</span>;</span><br><span class="line">        <span class="comment">// dp[0][1]</span></span><br><span class="line">        <span class="keyword">int</span> mid = INT_MAX;</span><br><span class="line">        <span class="comment">// dp[1][2]</span></span><br><span class="line">        <span class="keyword">int</span> last = INT_MAX;</span><br><span class="line">        <span class="comment">// 初始化转移变量</span></span><br><span class="line">        <span class="keyword">int</span> start2, mid2, last2 = INT_MAX, red = <span class="number">0</span>, yellow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            red = leaves[i] == <span class="string">'r'</span>;</span><br><span class="line">            yellow = leaves[i] == <span class="string">'y'</span>;</span><br><span class="line">            start2 = start + yellow;</span><br><span class="line">            mid2 = min(start, mid) + red;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>) last2 = min(mid, last) + yellow;</span><br><span class="line"></span><br><span class="line">            start = start2;</span><br><span class="line">            mid = mid2;</span><br><span class="line">            last = last2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://leetcode-cn.com/problems/UlBDOe/solution/qiu-xie-shou-cang-ji-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/UlBDOe/solution/qiu-xie-shou-cang-ji-by-leetcode-solution/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。&lt;br&gt;出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode701-二叉搜索树中的插入操作</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/10/09/LeetCode701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/10/09/LeetCode701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</id>
    <published>2020-10-09T14:12:04.000Z</published>
    <updated>2020-10-09T14:20:28.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><a id="more"></a><img src="/blog/2020/10/09/LeetCode701-二叉搜索树中的插入操作/示例.png" style="zoom:80%;"><ul><li>给定的树上的节点数介于 0 和 10^4 之间</li><li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li><li>-10^8 &lt;= val &lt;= 10^8</li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉搜索树满足父节点值大于其左孩子的值小于其右孩子的值，即当前节点大于以它为根节点的左子树的所有值，并且小于其右子树的所有值。根据这个性质，只需要判断<code>val</code>与当前节点的值的大小关系来寻找插入位置。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。&lt;/p&gt;
&lt;p&gt;注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="二叉搜索树" scheme="http://www.xingyuzhao.ltd/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode106-从中序与后序遍历序列构造二叉树</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/09/27/LeetCode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/09/27/LeetCode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-09-27T14:24:39.000Z</published>
    <updated>2020-10-12T09:15:13.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><a id="more"></a><img src="/blog/2020/09/27/LeetCode106-从中序与后序遍历序列构造二叉树/示例.png"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于二叉树的题，大部分都是通过递归来解决的，此题也不例外，需要注意的是，要充分利用二叉树中序遍历和后序遍历的性质。</p><ul><li>中序遍历二叉树(左子树—根节点—右子树)，根节点的左边是左子树，右边是右子树；</li><li>后序遍历二叉树(左子树—右子树—根节点)，根节点是最后输出的。</li></ul><p>在后序遍历数组中找到根节点之后，再从中序遍历数组中搜索根节点的左边，由此坐标将数组分开，分别就是当前根节点下的左子树和右子树：</p><img src="/blog/2020/09/27/LeetCode106-从中序与后序遍历序列构造二叉树/pic1.png"><p>上图中<code>inorder</code>数组中，3是在<code>postorder</code>找到的根节点，由此节点分开，<code>inorder</code>数组中绿色部分是左子树，黄色部分是右子树，在<code>posorder</code>数组中也是一样的。</p><ul><li>定义<code>inorder</code>数组中3的位置为<strong>rootIn</strong>，数组起始位置为<strong>iStart</strong>，结束位置为<strong>iEnd</strong>；</li><li>定义<code>postorder</code>数组数组起始位置为<strong>pStart</strong>，结束位置为<strong>pEnd</strong>；</li></ul><p>根据以上定义，<code>inorder</code>数组中左子树起止位置为<code>iStart-&gt;rootIn-1</code>，右子树起止位置为<code>rootIn+1-&gt;iEnd</code>；<code>postorder</code>数组中左子树起止位置为<code>pStart-&gt;pStart+rootIn-iStart-1</code>，右子树起止位置为<code>pStart+rootIn-iStart-&gt;pEnd-1</code>，图来自leetcode题解(<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/)%EF%BC%9A" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/)：</a></p><img src="/blog/2020/09/27/LeetCode106-从中序与后序遍历序列构造二叉树/pic2.png"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用一个map记录中序遍历数值的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : inorder)&#123;</span><br><span class="line">            <span class="built_in">map</span>[num] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        post = postorder;</span><br><span class="line">        TreeNode *node = dfs(<span class="number">0</span>, inorder.size() - <span class="number">1</span>, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> iStart, <span class="keyword">int</span> iEnd, <span class="keyword">int</span> pStart, <span class="keyword">int</span> pEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(iStart &gt; iEnd || pStart &gt; pEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> root = post[pEnd];</span><br><span class="line">        <span class="keyword">int</span> rootIn = <span class="built_in">map</span>[root];</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        node-&gt;left = dfs(iStart, rootIn - <span class="number">1</span>, pStart, pStart + rootIn - iStart - <span class="number">1</span>);</span><br><span class="line">        node-&gt;right = dfs(rootIn + <span class="number">1</span>, iEnd, pStart + rootIn - iStart, pEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/tu-jie-gou-zao-er-cha-shu-wei-wan-dai-xu-by-user72/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;根据一棵树的中序遍历与后序遍历构造二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;你可以假设树中没有重复的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="二叉树" scheme="http://www.xingyuzhao.ltd/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="http://www.xingyuzhao.ltd/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode200-岛屿数量</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/09/20/LeetCode200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/09/20/LeetCode200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2020-09-20T14:11:50.000Z</published>
    <updated>2020-09-20T15:08:03.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>使用并查集解决此问题</strong></p><a id="more"></a><img src="/blog/2020/09/20/LeetCode200-岛屿数量/示例.png" style="zoom:80%;"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在<code>grid</code>中遇到<code>&#39;1&#39;</code>时，搜索其四周（上下左右），如果发现值也为<code>&#39;1&#39;</code>，那么将他们合并，同时将当前位置值置为<code>&#39;0&#39;</code>，直到遍历到最后一个元素。</p><p>并查集进行初始化时，遇到<code>&#39;1&#39;</code>则增加计数值<code>count</code>，在后续的合并操作中，如果两者根节点不同，要进行合并时，计数值<code>count</code>要减1，说明两个节点进行了连接。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid)&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    parent.push_back(n * i + j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> parent.push_back(<span class="number">-1</span>);</span><br><span class="line">                rank.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 对于根不同的情况，将其相连，计数减1</span></span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 随便指一个</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(grid)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">'1'</span>) uf.unionElem(n * i + j, n * (i - <span class="number">1</span>) + j);</span><br><span class="line">                    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">'1'</span>) uf.unionElem(n * i + j, n * (i + <span class="number">1</span>) + j);</span><br><span class="line">                    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">'1'</span>) uf.unionElem(n * i + j, n * i + j - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">'1'</span>) uf.unionElem(n * i + j, n * i + j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用并查集解决此问题&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>并查集(Union Find)</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/09/06/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/09/06/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find/</id>
    <published>2020-09-06T02:47:39.000Z</published>
    <updated>2020-09-06T05:34:44.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h3><ol><li>并查集的基本概念及实现(Quick_Find/Quick_Union)</li><li>基于size优化与基于rank优化</li><li>路径压缩</li></ol><a id="more"></a><h3 id="并查集的基本概念及实现"><a href="#并查集的基本概念及实现" class="headerlink" title="并查集的基本概念及实现"></a>并查集的基本概念及实现</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>并查集是一种特殊的图，较图论而言要简单一些。对于图论来说，主要解决的问题是<strong>连接问题和路径问题</strong>，而并查集只是回答前者——连接问题。比如网络节点间的连接状态，数学中集合类的实现等。</p><p>并查集支持两个动作（合并两个节点，查询某个节点）：</p><ul><li>union(p, q)</li><li>find(p)</li></ul><p>用来回答一个问题（两个节点是否相连接）：</p><ul><li>isConnected(p, q)</li></ul><p>并查集可以用数组来表示，基本数据表示如下（0<del>4，5</del>9互相连接）：</p><table><thead><tr><th align="center"></th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><h4 id="基本实现-Quick-Find"><a href="#基本实现-Quick-Find" class="headerlink" title="基本实现(Quick_Find)"></a>基本实现(Quick_Find)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *id;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind1(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UnionFind1()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uoionElement</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pID = find(p);</span><br><span class="line">        <span class="keyword">int</span> qID = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pID == qID) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 让p指向q，复杂度O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(id[i] == pID)</span><br><span class="line">                id[i] = qID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="基本实现-Quick-Union"><a href="#基本实现-Quick-Union" class="headerlink" title="基本实现(Quick_Union)"></a>基本实现(Quick_Union)</h4><p>将每一个元素，看作是一个节点：</p><img src="/blog/2020/09/06/并查集-Union-Find/quickUnion.png" style="zoom:67%;"><p>对于上图，将7和3连接，只需要把7的根节点指向3的根节点（反过来也行）。</p><table><thead><tr><th align="center">i</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">parent</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td></tr></tbody></table><p><code>parent[i]</code>表示<code>i</code>指向的父亲元素是谁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind2</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *parent;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind2(<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UnionFind2()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">        <span class="comment">// 寻找根节点，复杂度O(n)</span></span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uoionElement</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 让p指向q，复杂度O(1)</span></span><br><span class="line">        parent[pRoot] = qRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h3><h4 id="基于size的优化"><a href="#基于size的优化" class="headerlink" title="基于size的优化"></a>基于size的优化</h4><p>之前实现的并查集中<code>Union(p, q)</code>操作都是让p的根节点指向q，如下图：</p><img src="/blog/2020/09/06/并查集-Union-Find/size1.png" style="zoom: 80%;"><p>如果实现<code>union(9, 4)</code>，那么9的根节点9将指向4的根节点8；相应的如果实现<code>union(4, 9)</code>则会出现将4的根节点8指向了9，如此一来，查找4的根节点需要的时间就更多了，我们完全可以在<code>union</code>操作之前进行判断，将元素少的集合的根节点指向元素多的集合的根节点，用一个数组<code>sz[i]</code>来表示以i为根集合中元素的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind3</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *parent;</span><br><span class="line">    <span class="keyword">int</span> *sz;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind3(<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UnionFind3()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] parent;</span><br><span class="line">        <span class="keyword">delete</span> [] sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">        <span class="comment">// 寻找根节点，复杂度O(n)</span></span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uoionElement</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 基于size优化</span></span><br><span class="line">        <span class="keyword">if</span>(sz[pRoot] &lt; sz[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            sz[qRoot] += sz[pRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            sz[pRoot] += sz[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="基于rank的优化"><a href="#基于rank的优化" class="headerlink" title="基于rank的优化"></a>基于rank的优化</h4><p>基于size的优化会出现下面一个问题：</p><img src="/blog/2020/09/06/并查集-Union-Find/rank1" style="zoom:80%;"><p>根节点为7的size是大于根节点为8的size的，所以基于size的优化会使8指向7，如下图：</p><img src="/blog/2020/09/06/并查集-Union-Find/rank2" style="zoom:80%;"><p>这样一来，这棵树的层数变成了4，一种更合理的方式是根据当前根节点的树的高度来进行优化，如下图，这样树的层数为3：</p><img src="/blog/2020/09/06/并查集-Union-Find/rank3" style="zoom:80%;"><p>我们可以用一个数组<code>rang[i]</code>表示根节点为i的树的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind4</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *parent;</span><br><span class="line">    <span class="keyword">int</span> *rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind4(<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UnionFind4()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] parent;</span><br><span class="line">        <span class="keyword">delete</span> [] rank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">        <span class="comment">// 寻找根节点，复杂度O(n)</span></span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uoionElement</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 基于size优化</span></span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            <span class="comment">// 不用维护层数</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            <span class="comment">// 不用维护层数</span></span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">            <span class="comment">// 层数加1</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径压缩-Path-Compression"><a href="#路径压缩-Path-Compression" class="headerlink" title="路径压缩(Path Compression)"></a>路径压缩(Path Compression)</h3><p>之前我们的<code>find(p)</code>操作中，递归查找的复杂度为<code>O(1)</code>，如下图，要查找4的根节点需要4次递归：</p><img src="/blog/2020/09/06/并查集-Union-Find/pathcompression1" style="zoom:80%;"><table><thead><tr><th align="center"></th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">parent</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr></tbody></table><p>如果将4指向3的父节点2（指向其父节点的父节点），会得到下图：</p><img src="/blog/2020/09/06/并查集-Union-Find/pathcompression2"><p>由于根节点指向自己，所以不会出现无效的情况，继续将p更新为<code>parent[p]</code>，得到下图：</p><img src="/blog/2020/09/06/并查集-Union-Find/pathcompression3"><p>这样一来，所有节点的路径都进行了压缩，查找的时间复杂度近乎是<code>O(1)</code>的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">    <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="keyword">while</span>(p != parent[p])&#123;</span><br><span class="line">        parent[p] = parent[parent[p]];</span><br><span class="line">        p = parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">    <span class="keyword">if</span>(p != parent[p])</span><br><span class="line">        parent[p] = find(parent[p]);</span><br><span class="line">    <span class="keyword">return</span> parent[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>对每种并查集的工程执行100w次<code>union</code>操作和100w次<code>find</code>操作：</p><img src="/blog/2020/09/06/并查集-Union-Find/test" style="zoom:80%;"><p>区别还是很明显的。</p><h3 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h3><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;并查集的基本概念及实现(Quick_Find/Quick_Union)&lt;/li&gt;
&lt;li&gt;基于size优化与基于rank优化&lt;/li&gt;
&lt;li&gt;路径压缩&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序(Quick sort)</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/08/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/08/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort/</id>
    <published>2020-08-15T15:20:58.000Z</published>
    <updated>2020-09-06T02:49:22.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h3><ol><li>快速排序基本实现及优化</li><li>双路快速排序</li><li>三路快速排序</li></ol><a id="more"></a><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>快速排序的基本思想很简单，对于<code>l</code>处的数<code>val</code>，与<code>j</code>处的数进行交换，使得坐标小于<code>j</code>的所有数都小于<code>val</code>，而位于<code>j</code>之后的数都应该大于<code>val</code>，如下图所示：</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-1" style="zoom:80%;"><p>而实现这一操作的过程称为<code>partition</code>，具体过程如下：</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-2"><ol><li>对于上图，<code>arr[l+1...j] &lt; v</code>，<code>arr[j+1...i-1] &gt; v</code>，当前位置<code>i</code>的值为<code>e</code>；</li></ol><ul><li><p>如果<code>e &gt; v</code>，将<code>e</code>放在<code>&gt; v</code>后面，同时<code>i++</code>；</p></li><li><p>如果<code>e &lt; v</code>，将<code>i</code>处的值<code>e</code>与<code>j</code>下一个位置的值进行交换，然后<code>j++,i++</code>；</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-3"><img src="/blog/2020/08/15/快速排序-quick-sort/1-4"></li></ul><ol start="2"><li>继续步骤1，会得到以下结果：</li></ol><img src="/blog/2020/08/15/快速排序-quick-sort/1-5"><ol start="3"><li>此时满足<code>arr[l+1...j] &lt; v</code>，<code>arr[j+1...i-1] &gt; v</code>，再将<code>l</code>和<code>j</code>位置进行交换：</li></ol><img src="/blog/2020/08/15/快速排序-quick-sort/1-6"><ol start="4"><li>重复步骤1-3，直到递归结束。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zxy on 2020/8/16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sortHelper.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p，使arr[l...p-1] &lt; arr[p]; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="comment">// arr[l+1...j] &lt; v; arr[j+1...i) &gt; v</span></span><br><span class="line">    <span class="comment">// 初始状态时两个区间都为空</span></span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i)&#123;</span><br><span class="line">        <span class="comment">// 实际上当前值大于等于v时，将e都直接放在&lt;v后面</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; v)&#123;</span><br><span class="line">            swap(arr[j + <span class="number">1</span>], arr[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[l], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line">    __quickSort(arr, l, p - <span class="number">1</span>);</span><br><span class="line">    __quickSort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    __quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(<span class="number">10</span>, <span class="number">1</span>, <span class="number">50</span>); <span class="comment">// 产生10个1到50间的随机数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printArray(arr, <span class="number">10</span>); <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    quickSort(arr, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printArray(arr, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-7"><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>对于上述的快速排序算法有一个很大的缺点，如果数组近乎有序，复杂度可能退化至O(n^2)，大于<code>v</code>或者小于<code>v</code>的部分分配不均匀。比如对于数组<code>[3,1,1,2,2,2]</code>，经过第一次<code>partition</code>时，3放在了数组的末尾，左边5个数全部小于3，而右边没有大于3的数。</p><p>对于这种情况，我们可以不取数组<code>l</code>处的值作为<code>v</code>，而是在数组中随机取一个值作为分界点<code>v</code>，然后再进行<code>partition</code>操作，此时快速排序复杂度的数学期望为O(nlogn)，具体的推导百度一下。修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">    swap(arr[rand() % (r - l + <span class="number">1</span>) + l], arr[l]);</span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="comment">// arr[l+1...j] &lt; v; arr[j+1...i) &gt; v</span></span><br><span class="line">    <span class="comment">// 初始状态时两个区间都为空</span></span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; v)&#123;</span><br><span class="line">            swap(arr[j + <span class="number">1</span>], arr[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[l], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直观的对比一下两种思路对完全随机数组和近乎有序数组的排序速度（其中<code>swap time</code>表示对于产生一个有序数组，随机取两个数进行交换，一共交换的次数）：</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-8"><h3 id="双路快速排序"><a href="#双路快速排序" class="headerlink" title="双路快速排序"></a>双路快速排序</h3><p>虽然解决了近乎有序数组的排序问题，但是对于数组中存在大量重复键值时，复杂度也可能退化为O(n^2)，如下图所示：</p><img src="/blog/2020/08/15/快速排序-quick-sort/2-1"><p>我们之前的<code>partition</code>操作中，当前值大于等于v时，将e都直接放在小于v最后一个的后面，所以可能出现上述情况。现在我们对于等于v时两边都可以进行收缩，使得<code>partition</code>操作更加均匀：</p><img src="/blog/2020/08/15/快速排序-quick-sort/2-2"><p>话不多说，看代码更容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    swap(arr[rand() % (r - l + <span class="number">1</span>) + l], arr[l]);</span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="comment">// arr[l+1...i) &lt;= v; arr(j...r] =&gt; v</span></span><br><span class="line">    <span class="comment">// 初始状态时两个区间都为空</span></span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r &amp;&amp; arr[i] &lt; v) i++;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= l + <span class="number">1</span> &amp;&amp; arr[j] &gt; v) j--;</span><br><span class="line">        <span class="comment">// 此时i指向第一个大于等于v的位置，j指向最后一个小于等于v的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr[i], arr[j]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[l], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition2(arr, l, r);</span><br><span class="line">    __quickSort2(arr, l, p - <span class="number">1</span>);</span><br><span class="line">    __quickSort2(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    __quickSort2(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2020/08/15/快速排序-quick-sort/2-3"><h3 id="三路快速排序"><a href="#三路快速排序" class="headerlink" title="三路快速排序"></a>三路快速排序</h3><p>要给含有大量重复键值的数组排序同时避免对等于v的值进行交换，还可以进行三路的快速排序：</p><img src="/blog/2020/08/15/快速排序-quick-sort/3-1"><p>现在根据v将数组分为三个部分，分别是：<code>arr[l+1...lt] &lt; v</code>，<code>arr[lt+1...i-1] == v</code>，<code>arr[gt...r] &gt; v</code>。</p><ul><li>如果<code>e == v</code>，<code>i++</code>；</li><li>如果<code>e &lt; v</code>，将e和<code>lt+1</code>位置交换，同时<code>lt++，i++</code>；</li><li>如果<code>e &gt; v</code>，将e和<code>gt-1</code>位置交换，成为大于v的第一个位置，<code>gt--</code>；</li><li>最后将<code>l</code>和<code>lt</code>位置交换，再对小于v部分和大于v部分继续排序。</li></ul><img src="/blog/2020/08/15/快速排序-quick-sort/3-2"><img src="/blog/2020/08/15/快速排序-quick-sort/3-3"><p>数组中<code>arr[l...lt-1] &lt; v</code>，<code>arr[lt...gt-1] == v</code>，<code>arr[gt...r] &gt; v</code>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort3(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    swap(arr[l], arr[rand() % (r - l +<span class="number">1</span> ) + l]);</span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="keyword">int</span> lt = l;     <span class="comment">// arr[l+1...lt] &lt; v</span></span><br><span class="line">    <span class="keyword">int</span> gt = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; v</span></span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>;    <span class="comment">// arr[lt+1...i) == v</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; gt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; v)&#123;</span><br><span class="line">            swap(arr[i], arr[lt+<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">            lt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; v)&#123;</span><br><span class="line">            swap(arr[i], arr[gt<span class="number">-1</span>]);</span><br><span class="line">            gt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> i++; <span class="comment">// arr[i] == v</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap( arr[l] , arr[lt] );</span><br><span class="line">    __quickSort3(arr, l, lt<span class="number">-1</span>);</span><br><span class="line">    __quickSort3(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort3( arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2020/08/15/快速排序-quick-sort/3-4"><p>双路快速排序和三路快速排序都是在对近乎有序数组优化的基础上，对数组存在大量重复键值时进行优化，所以时间复杂度都是O(nlogn)。</p><h3 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h3><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;快速排序基本实现及优化&lt;/li&gt;
&lt;li&gt;双路快速排序&lt;/li&gt;
&lt;li&gt;三路快速排序&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++11之lambda表达式</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/08/02/C-11%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/08/02/C-11%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-08-02T02:34:49.000Z</published>
    <updated>2020-08-02T15:19:15.095Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++11标准中的新特性——lambda表达式</p><a id="more"></a><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><hr><p>如果需要sort按照自己定义的方式进行排序，需要使用其第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个<strong>谓词</strong>。</p><hr><h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><ol><li>定义：谓词是一个<strong>可以调用的表达式</strong>，返回的结果可以被调用</li><li>分类：一元谓词和二元谓词<ol><li>一元谓词：只接受单一的参数</li><li>二元谓词：接受两个参数</li></ol></li><li>接受谓词的算法对输入序列中的<strong>元素</strong>调用谓词，因此<strong>元素</strong>必须能转换为谓词的参数类型</li></ol><p><code>sort</code>函数接受一个<strong>二元谓词</strong>，假如我们要按字符串的长度升序排序，可以定义一个比较函数<code>isShorter</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数，用来按长度排序单词</span></span><br><span class="line"><span class="comment">// 必须是引用类型！！！</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按长度由短至长排序words</span></span><br><span class="line">sort(words.begin(), words.end(), isShorter);</span><br><span class="line"></span><br><span class="line"><span class="meta"># words = &#123;<span class="meta-string">"foxs"</span>, <span class="meta-string">"jumps"</span>, <span class="meta-string">"end"</span>, <span class="meta-string">"kid"</span>&#125;</span></span><br><span class="line"># 输出结果为end kid foxs jumps</span><br></pre></td></tr></table></figure><p><strong><em>注：针对同一长度的单词，<code>sort</code>是不稳定的，如果要保持对应的字典序，可以调用<code>stable_sort</code></em></strong></p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>对于一个对象或者表达式，如果对其可以使用调用运算符<code>()</code>，则称它为可调用的，可以将其传入算法。一个<code>lambda</code>表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。</p><hr><p><strong>与任何函数相似，一个<code>lambda</code>具有一个返回类型，一个参数列表和一个函数体</strong></p><p><strong>不同的是，<code>lambda</code>可以定义在函数内部</strong></p><hr><p>一个<code>lambda</code>表达式具有如下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (parameter <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><ul><li><code>[capture list]</code>（捕获列表）是一个<code>lambda</code><strong>所在函数中</strong>定义的局部变量的列表（通常为空）</li><li><code>return type</code>、<code>parameter list</code>和<code>function body</code>与普通函数一样，分别为返回类型，参数列表和函数体，但是<code>lambda</code>必须使用尾置返回</li></ul><p>我们可以忽略参数列表和返回类型，但必须永远包括捕获列表和函数体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们定义了一个可调用对象f，它不接受参数，返回42</span></span><br><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure><p><code>lambda</code>的调用方式与普通函数相同，使用调用运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出42</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>在此例中，当调用<code>f</code>时，参数列表为空并且忽略了返回类型，<code>lambda</code>根据函数体代码确定返回类型，如果函数体只有一个<code>return</code>语句，则返回类型从返回表达式的类型推断而来，否则返回<code>void</code>。</p><p><strong><em>注：如果函数体中包含任何单一<code>return</code>语句之外的内容，且未指定返回类型，返回<code>void</code></em></strong></p><h4 id="向lambda传递参数"><a href="#向lambda传递参数" class="headerlink" title="向lambda传递参数"></a>向lambda传递参数</h4><p>与一个普通函数调用类似，调用一个<code>lambda</code>给定实参被用来初始化<code>lambda</code>形参，类型需要匹配。但是<code>lambda</code>不能有默认参数（比如：<code>int fun(int a = 1, int b = 1) { return a + b; }</code>）。因此，一个<code>lambda</code>调用的实参数目永远和形参数目相等，一旦形参初始化完毕，就可以执行函数体了。</p><p>我们可以写出来一个与<code>isShorter</code>功能完全一样的<code>lambda</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span><br><span class="line">&#123; <span class="keyword">return</span> s1.size() &lt; s2.size(); &#125;</span><br></pre></td></tr></table></figure><p>空捕获列表表示不使用函数中的局部变量，如下所示，之前的<code>sort</code>函数可以改写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(words.begin(), words.end(), </span><br><span class="line">[] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span><br><span class="line">&#123; <span class="keyword">return</span> s1.size() &lt; s2.size(); &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h4><p>假如我们现在要找到<code>words</code>中第一个长度大于<code>sz</code>的单词的位置，可以编写一个可以传递给<code>find_if</code>的可调用表达式。一个<code>lambda</code>表达式<strong>只能使用明确指明的变量</strong>，在下面的例子中，<code>lambda</code>会捕获<code>sz</code>，，并只有单一的<code>string</code>参数（因为<code>find_if</code>只支持一元谓词），其函数体会将<code>string</code>的大小与捕获的<code>sz</code>进行比较：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sz] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;;</span><br></pre></td></tr></table></figure><h5 id="调用find-if函数"><a href="#调用find-if函数" class="headerlink" title="调用find_if函数"></a>调用<code>find_if</code>函数</h5><p>使用此<code>lambda</code>，查到第一个长度大于等于给定<code>sz</code>元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">     [sz] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">     &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;);</span><br><span class="line"><span class="comment">// 输出满足size &gt;= sz第一个元素的值和位置</span></span><br><span class="line"><span class="comment">// 如果没有找到，返回words.end()的一个拷贝</span></span><br><span class="line"><span class="comment">// 取sz = 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"value:"</span> &lt;&lt; *wc &lt;&lt; <span class="string">"position:"</span> &lt;&lt; wc - words.begin();</span><br><span class="line"><span class="meta"># value:foxs    position:2</span></span><br></pre></td></tr></table></figure><h5 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a><code>for_each</code>算法</h5><p>打印出长度大于等于<code>sz</code>的所有单词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.end(), [] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line"><span class="meta"># foxs jumps</span></span><br></pre></td></tr></table></figure><h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>我们可以认为，当向一个函数传递一个<code>lambda</code>时，同时定义了一个新类型和该类型的对象，传递的参数就是此编译器生成的<strong>类的类型</strong>的<strong>未命名对象</strong>。</p><p><strong>默认情况下，由<code>lambda</code>生成的类，数据成员包含捕获列表中的变量，在<code>lambda</code>对象创建时被初始化。</strong></p><h4 id="值捕获（后面更改不会影响值）"><a href="#值捕获（后面更改不会影响值）" class="headerlink" title="值捕获（后面更改不会影响值）"></a>值捕获（后面更改不会影响值）</h4><p>与参数传递不同之处在于，被捕获的变量的值在<code>lambda</code>创建时拷贝，而不是调用时拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>; <span class="comment">// 局部变量</span></span><br><span class="line"><span class="keyword">auto</span> f = [v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = f();</span><br><span class="line"><span class="meta"># j为42；f保存我们创建它时的拷贝，因此修改v1不会影响lambda内对应的值</span></span><br></pre></td></tr></table></figure><h4 id="引用捕获（后面更改会影响变量值）"><a href="#引用捕获（后面更改会影响变量值）" class="headerlink" title="引用捕获（后面更改会影响变量值）"></a>引用捕获（后面更改会影响变量值）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v2 = <span class="number">42</span>; <span class="comment">// 局部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;v2] &#123; <span class="keyword">return</span> v2; &#125;;</span><br><span class="line">v2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> jj = f2();</span><br><span class="line"><span class="meta"># jj为0；f2保存v1的引用</span></span><br><span class="line"># 需要注意的是必须确保被引用的对象在lambda执行的时候是存在的</span><br><span class="line"># 如果可能的话，避免捕获指针或引用（C++ Primer <span class="number">351</span>页）</span><br></pre></td></tr></table></figure><h4 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h4><p>我们可以让编译器根据<code>lambda</code>函数体中的代码来推断我们要使用哪些变量，在捕获列表中写一个<code>&amp;</code>表示捕获引用，<code>=</code>表示采用值捕获方式，我们可以重写<code>find_if</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sz为隐式值捕获</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">     [=] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">     &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure><p>如果想对一部分变量使用值捕获，一部分使用引用捕获，可以混合使用隐式捕获和显示捕获：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;os = <span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">' '</span>;</span><br><span class="line"><span class="comment">// os隐式引用捕获，c显示值捕获</span></span><br><span class="line">for_each(wc, words.end(), [&amp;, c] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; os &lt;&lt; s &lt;&lt; c;&#125;);</span><br><span class="line"><span class="comment">// os显示引用捕获，c隐式值捕获</span></span><br><span class="line">for_each(wc, words.end(), [=, &amp;os] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; os &lt;&lt; s &lt;&lt; c;&#125;);</span><br></pre></td></tr></table></figure><ol><li><strong>当我们使用混合捕获时，捕获列表第一个变量必须是一个&amp;或者=，定义了默认捕获方式为引用或值。</strong></li><li><strong>混合捕获时，显示捕获的变量必须使用与隐式捕获不同的方式，即：显示引用捕获，隐式值捕获或者显示值捕获，隐式引用捕获。</strong></li></ol><h4 id="指定lambda返回类型"><a href="#指定lambda返回类型" class="headerlink" title="指定lambda返回类型"></a>指定lambda返回类型</h4><p>标准库函数<code>transform</code>：接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中的每个元素调用可调用对象，并将结果写到目的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取绝对值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vv1&#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-20</span>, <span class="number">7</span>&#125;;</span><br><span class="line">transform(vv1.begin(), vv1.end(), vv1.begin(),</span><br><span class="line">          [] (<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i; &#125;);</span><br><span class="line"># <span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">20</span>,<span class="number">7</span></span><br></pre></td></tr></table></figure><p>如果写成以下形式就会产生编译错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(vv1.begin(), vv1.end(), vv1.begin(),</span><br><span class="line">          [] (<span class="keyword">int</span> i) &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure><p>这是因为函数体中不止一个<code>return</code>语句，<code>lambda</code>无法判断返回类型。如果我们需要为其定义返回类型，必须用尾置的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(vv1.begin(), vv1.end(), vv1.begin(),</span><br><span class="line">          [] (<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><hr><p>对于只在一两个地方使用的函数，使用<code>lambda</code>是很方便的，多次使用或者函数体比较长的话定义一个函数来实现更好。但是对于捕获局部变量的<code>lambda</code>表达式来说，用函数代替就不太容易了。</p><hr><p>在之前的<code>find_if</code>函数中，我们可以容易写出来一个相同功能的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="built_in">string</span>::size_type sz)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.size() &gt;= sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>find_if</code>函数只支持一元谓词，直接使用肯定是不可以的。</p><h4 id="标准库bind函数"><a href="#标准库bind函数" class="headerlink" title="标准库bind函数"></a>标准库bind函数</h4><p>使用<code>bind</code>函数可以解决上述问题，此函数定义在头文件<code>functional</code>中，可以将<code>bind</code>函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。</p><p>调用形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list)</span><br></pre></td></tr></table></figure><ul><li><code>newCallable</code>本身是一个可调用对象</li><li><code>arg_list</code>是一个逗号分隔的参数列表，对应给定<code>callable</code>的参数</li></ul><p>当我们调用<code>newCallable</code>时，<code>newCallable</code>会调用<code>callable</code>，并传递给它<code>arg_list</code>中的参数。</p><p><code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，其中<code>n</code>是一个整数，称为<strong>占位符</strong>，表示占据了传递给<code>newCallable</code>参数的位置。</p><h5 id="绑定check-size的sz参数"><a href="#绑定check-size的sz参数" class="headerlink" title="绑定check_size的sz参数"></a>绑定<code>check_size</code>的<code>sz</code>参数</h5><p>一个简单的例子，使用<code>bind</code>生成一个调用<code>check_size</code>的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check4是一个可调用对象，接受一个string类型的参数</span></span><br><span class="line"><span class="comment">// 使用此string和值4调用check_size</span></span><br><span class="line"><span class="comment">// 注意要使用using std::placeholder::_1或using namespace std::placeholders</span></span><br><span class="line"><span class="keyword">auto</span> check4 = bind(check_size, _1, <span class="number">4</span>);</span><br><span class="line"># 此bind调用只有一个占位符，表示check4只接受单一参数</span><br><span class="line"># 占位符在arg_list的第一个位置，表示check4的此参数对应check_size的第一个参数，是<span class="keyword">const</span> <span class="built_in">string</span>&amp;</span><br><span class="line"># 因此调用check4必须传递给它一个<span class="built_in">string</span>类型的参数，check4将其传给check_size</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">bool</span> b1 = check4(s);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"># <span class="number">1</span></span><br></pre></td></tr></table></figure><p>此时我们可以改写<code>find_if</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wcc = find_if(words.begin(), words.end(),</span><br><span class="line">     bind(check_size, _1, sz));</span><br><span class="line">for_each(wcc, words.end(), [] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line"><span class="meta"># foxs jumps</span></span><br><span class="line"><span class="comment">// 对比之前的find_if</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">     [sz] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">     &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>《C++ Primer》370-383</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习C++11标准中的新特性——lambda表达式&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="lambda" scheme="http://www.xingyuzhao.ltd/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode63-不同路径Ⅱ</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/</id>
    <published>2020-07-26T02:09:11.000Z</published>
    <updated>2020-09-20T14:55:31.263Z</updated>
    
    <content type="html"><![CDATA[<p>本题与<a href="http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more"><strong>97交错字符串</strong></a>，<a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener"><strong>174-地下城游戏</strong></a>分析与解法相似</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><a id="more"></a><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/question" style="zoom:80%;"><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/question1" style="zoom:;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于输入为二维数组的题目中出现了只能向下或者向右移动的字眼，一般来说考虑动态规划。这道题的不同之处是设置了障碍物，如果遇到了1则表示<strong>不可达</strong>，假如<code>m = 2, n = 2</code>，并且无障碍物，我们可以得到下图：</p><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/solution1" style="zoom:80%;"><p>那么对于<code>(0,1)</code>和<code>(1,0)</code>位置，都只有一条通路可达：</p><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/solution2" style="zoom:80%;"><p>最后对于末尾处<code>(1,1)</code>，它的上边和左边可以到达，所以到达它的路径为<code>1 + 1 = 2</code>条：</p><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/solution3" style="zoom:80%;"><p>通过观察我们发现，在不遮挡的情况下，可以到达当前位置的路径数就是当前位置的上边和左边路径数的总和。</p><p>对于存在障碍物的情况，我们直接令到达它的路径数为0，这样也就满足的题目的要求。</p><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p>根据上述分析，<code>dp[i][j]</code>表示有多少条路径可以到达<code>(i,j)</code>，如果网格中此处值为1，也就是有障碍的情况下，<code>dp[i][j] = 0</code>。表示无法到达，路径数为0。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在<strong>交错字符串</strong>中使用的是从前往后遍历的思想，这里换一种思路，从后往前进行遍历。对于最后一个位置<code>dp[m-1][n-1]</code>，如果第<code>m - 1</code>行或者<code>n - 1</code>列其他位置可以到达最后位置，则为1，否则为0，只要在网格中往回走遇到了1，在那之后<code>dp</code>数组的值都为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[m][n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后一行到end初始化为1</span></span><br><span class="line"><span class="comment">// 注意有有一个为1，后面都被阻挡</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[m - <span class="number">1</span>][j] == <span class="number">0</span>; --j)&#123;</span><br><span class="line">dp[m - <span class="number">1</span>][j] = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后一列到end初始化为1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][n - <span class="number">1</span>] == <span class="number">0</span>; --i)&#123;</span><br><span class="line">dp[i][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">    dp[i][j] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size();</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 从后往前必须long long</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一行到end初始化为1</span></span><br><span class="line">        <span class="comment">// 注意有有一个为1，后面都被阻挡</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[m - <span class="number">1</span>][j] == <span class="number">0</span>; --j)&#123;</span><br><span class="line">                dp[m - <span class="number">1</span>][j] = <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一列到end初始化为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][n - <span class="number">1</span>] == <span class="number">0</span>; --i)&#123;</span><br><span class="line">                dp[i][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/jian-dan-dpbi-xu-miao-dong-by-sweetiee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii/solution/jian-dan-dpbi-xu-miao-dong-by-sweetiee/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题与&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more&quot;&gt;&lt;strong&gt;97交错字符串&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;https://leetcode-cn.com/problems/dungeon-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;174-地下城游戏&lt;/strong&gt;&lt;/a&gt;分析与解法相似&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode97-交错字符串</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-07-18T15:47:04.000Z</published>
    <updated>2020-07-19T10:20:07.368Z</updated>
    
    <content type="html"><![CDATA[<p>在看了题解之后才慢慢意识到，这道题和<a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener"><strong>63-不同路径Ⅱ</strong></a>，<a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener"><strong>174-地下城游戏</strong></a>是非常相似的，题目虽然具有一定难度，但都是有迹可循。它们都可以抽象为在二维数组中，从起始到末尾找路径的问题。上面两个问题还未更新，跳转位置是题目链接。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定三个字符串 <em>s1</em>, <em>s2</em>, <em>s3</em>, 验证 <em>s3</em> 是否是由 <em>s1</em> 和 <em>s2</em> 交错组成的。</p><a id="more"></a><img src="/blog/2020/07/18/LeetCode97-交错字符串/question1"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>交错的意思是：如果第一次取了<code>s1</code>，那么第二次必须取<code>s2</code>，反之亦然。取多少和哪一个先取都是不一定的，只是要求交错即可。</p><p>对于<code>s1 = &quot;bacc&quot;, s2 = &quot;aabcce&quot;, s3 = &quot;abaacbccec&quot;</code>，这个示例是可以匹配的，按照<strong>可以匹配</strong>的过程分析如下：</p><ol><li>首先只能取<code>s2</code>中的<code>a</code>，再继续往下取<code>a</code>时，与<code>s3</code>已经无法匹配了；</li><li><strong>再取<code>s1</code>中的<code>b</code>或者<code>ba</code>都是可以的</strong>，这里取<code>b</code></li><li>再取<code>s2</code>中的<code>a</code>，此时匹配到<code>aba</code></li><li>再取<code>s1</code>中的<code>ac</code>，此时匹配到<code>abaac</code></li><li>再取<code>s2</code>中的<code>bcce</code>，此时匹配到<code>abaacbbe</code></li><li>再取<code>s1</code>中的<code>c</code>，此时完全匹配</li></ol><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p><code>dp[i][j]</code>表示<code>s1</code>的前<code>i</code>个字符和<code>s2</code>的前<code>j</code>个字符是否匹配，我们可以将刚才的分析表示为下图：</p><img src="/blog/2020/07/18/LeetCode97-交错字符串/question1_dp" style="zoom:80%;"><p>上图是不是很像一个路径问题，而且只能向右或者向下移动，进一步说明是用动态规划来解决，如果还可以往上或者左，那就不能用动态规划来做了，得考虑<code>dfs</code>之类的算法。</p><p>分析中的第二步，也就是图中<code>true</code>的其他可能。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 都为空时匹配</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">// 对于第一行和第一列，当前值若无法匹配，则当前值和之后的都无法匹配</span></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>) dp[<span class="number">0</span>][j] = s2[<span class="number">0</span>,j) == s3[<span class="number">0</span>,j)</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][<span class="number">0</span>] = s2[<span class="number">0</span>,i) == s3[<span class="number">0</span>,i)</span><br></pre></td></tr></table></figure><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])</span><br><span class="line">|| (dp[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.size(), n = s2.size();</span><br><span class="line">        <span class="keyword">if</span>(m + n != s3.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// bool dp[m + 1][n + 1] = &#123;false&#125;;</span></span><br><span class="line">        <span class="keyword">bool</span> **dp = <span class="keyword">new</span> <span class="keyword">bool</span>*[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; (s2.substr(<span class="number">0</span>, j) == s3.substr(<span class="number">0</span>, j)); ++j) </span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; (s1.substr(<span class="number">0</span>, i) == s3.substr(<span class="number">0</span>, i)); ++i) </span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])) ||</span><br><span class="line">                            (dp[i][j - <span class="number">1</span>] &amp;&amp; (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看了题解之后才慢慢意识到，这道题和&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;63-不同路径Ⅱ&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;https://leetcode-cn.com/problems/dungeon-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;174-地下城游戏&lt;/strong&gt;&lt;/a&gt;是非常相似的，题目虽然具有一定难度，但都是有迹可循。它们都可以抽象为在二维数组中，从起始到末尾找路径的问题。上面两个问题还未更新，跳转位置是题目链接。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定三个字符串 &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt;, &lt;em&gt;s3&lt;/em&gt;, 验证 &lt;em&gt;s3&lt;/em&gt; 是否是由 &lt;em&gt;s1&lt;/em&gt; 和 &lt;em&gt;s2&lt;/em&gt; 交错组成的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
