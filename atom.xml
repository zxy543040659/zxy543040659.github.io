<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>工欲善其事，必先利其器</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2021-04-01T15:29:46.000Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Zxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>条款38：通过复合塑模出has-a或“根据某物实现出”</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/04/01/%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/04/01/%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D/</id>
    <published>2021-04-01T14:53:27.000Z</published>
    <updated>2021-04-01T15:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>复合的意义和 public 继承完全不同。</li><li>在应用域，复合意味 has-a（有一个）。在实现域，复合意味 is-implemented-in-terms-of（根据某物实现出）。</li></ul><a id="more"></a><h4 id="复合指某种类型中含其他类型的对象"><a href="#复合指某种类型中含其他类型的对象" class="headerlink" title="复合指某种类型中含其他类型的对象"></a>复合指某种类型中含其他类型的对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">Address address; </span><br><span class="line">PhoneNumber voiceNumber;</span><br><span class="line">PhoneNumber faxNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 对象由 string，Address，PhoneNumber，PhoneNumber 构成。</p><h4 id="has-a-or-is-implemented-in-terms-of"><a href="#has-a-or-is-implemented-in-terms-of" class="headerlink" title="has-a or is-implemented-in-terms-of"></a>has-a or is-implemented-in-terms-of</h4><h5 id="应用域与实现域"><a href="#应用域与实现域" class="headerlink" title="应用域与实现域"></a>应用域与实现域</h5><p>应用域：程序中的对象相当于你所塑造的世界中的某些事物，例如人、汽车等。</p><p>实现域：另外一些对象是实现细节上的人工制品，例如：缓冲区、互斥器、查找树等。</p><p>在应用域中的对象间，复合表现为 has-a 的关系；当它发生于实现域则表现 is-implemented-in-terms-of 的关系。</p><h4 id="区分-is-a-和-is-implemented-in-terms-of"><a href="#区分-is-a-和-is-implemented-in-terms-of" class="headerlink" title="区分 is-a 和 is-implemented-in-terms-of"></a>区分 is-a 和 is-implemented-in-terms-of</h4><p><strong>实现Set</strong>，基于标准库 list <strong>template</strong>。</p><h5 id="Set-template-继承-std-list"><a href="#Set-template-继承-std-list" class="headerlink" title="Set template 继承 std::list"></a>Set template 继承 std::list</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is-a</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 将list应用与set错误用法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span>:</span>:<span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>如果 Set 是一种 list，那么对 list 为真的每件事对 Set 也为真，但是 list 可以包含重复元素而 Set 不行。</p><h5 id="Set-对象根据-list-对象实现出来"><a href="#Set-对象根据-list-对象实现出来" class="headerlink" title="Set 对象根据 list 对象实现出来"></a>Set 对象根据 list 对象实现出来</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Set</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">member</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Set&lt;T&gt;::member(<span class="keyword">const</span> T&amp; item) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::find(rep.begin(), rep.end(), item) != rep.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!member(item)) rep.push_back(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::remove(<span class="keyword">const</span> T&amp; item)&#123;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::iterator it = </span><br><span class="line">        <span class="built_in">std</span>::find(rep.begin(), rep.end(), item);</span><br><span class="line">    <span class="keyword">if</span>(it != rep.end()) rep.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> Set&lt;T&gt;::size() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rep.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Set 与 list 的关系为：<strong>根据某物实现出（is-implemented-in-terms-of）</strong>而不是<strong>是一种（is-a）</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;复合的意义和 public 继承完全不同。&lt;/li&gt;
&lt;li&gt;在应用域，复合意味 has-a（有一个）。在实现域，复合意味 is-implemented-in-terms-of（根据某物实现出）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="has-a" scheme="http://www.xingyuzhao.ltd/tags/has-a/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode132-分割回文串Ⅱ</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/08/LeetCode132-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%E2%85%A1/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/08/LeetCode132-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%E2%85%A1/</id>
    <published>2021-03-08T07:57:54.000Z</published>
    <updated>2021-03-08T12:54:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 <strong>最少分割次数</strong> 。</p><a id="more"></a><img src="/blog/2021/03/08/LeetCode132-分割回文串Ⅱ/132.png"><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>与<a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a>类似，但是不能使用暴力回溯，会超时。</p><p>使用两次动态规划来解决：</p><ol><li>得到回文串的二维 <code>dp</code> 数组，<code>dp[i][j]</code> 表示 <code>s[i:j]</code> 是否构成回文子串；</li><li>设置新的一维数组 <code>f</code>，<code>f[i]</code> 表示以 <code>i</code> 结尾的字符串最少需要几次分割。</li></ol><p><strong>具体算法如下</strong>：</p><p>我们定义 f[i] 为以下标为 i 的字符作为结尾的最小分割次数，那么最终答案为 f[n - 1]。</p><p>不失一般性的考虑第 j 字符的分割方案：</p><ol><li>从起点字符到第 j 个字符能形成回文串，那么最小分割次数为 0。此时有 f[j] = 0；</li><li>从起点字符到第 j 个字符不能形成回文串：<ol><li>该字符独立消耗一次分割次数。此时有 f[j] = f[j - 1] + 1；</li><li>该字符不独立消耗一次分割次数，而是与前面的某个位置 i 形成回文串，[i, j] 作为整体消耗一次分割次数。此时有 f[j] = f[i - 1] + 1；</li></ol></li></ol><p>在 2.2 中满足回文要求的位置 i 可能有很多，我们在所有方案中取一个 min 即可。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        isPalindrome(s, n, dp);</span><br><span class="line">        <span class="comment">// f[i]表示以i结尾的字符串最少需要几次分割</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化，仅一个字符时不需要分割</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="comment">// 如果从起始位置到j可构成回文串，那么仍不需要分割</span></span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                f[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，以j结尾的字符串可选则分割一次或不分割</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 分割一次</span></span><br><span class="line">                f[j] = f[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 从之前某个字符开始时是回文子串</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                        <span class="comment">// 以i开始到j的字符串是回文串</span></span><br><span class="line">                        <span class="comment">// 由i-1处的分割次数加1得到，持续更新最小值</span></span><br><span class="line">                        f[j] = min(f[j], f[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j]) dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>作者：AC_OIer<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/xiang-jie-liang-bian-dong-tai-gui-hua-ji-s5xr/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/xiang-jie-liang-bian-dong-tai-gui-hua-ji-s5xr/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，请你将 &lt;code&gt;s&lt;/code&gt; 分割成一些子串，使每个子串都是回文。&lt;/p&gt;
&lt;p&gt;返回符合要求的 &lt;strong&gt;最少分割次数&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://www.xingyuzhao.ltd/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>回文子串/子序列相关问题</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/07/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/07/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-07T09:02:58.000Z</published>
    <updated>2021-03-08T07:57:04.219Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h4><ol><li><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></li><li><a href="https://leetcode-cn.com/problems/shortest-palindrome/" target="_blank" rel="noopener">214. 最短回文串</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></li></ol><a id="more"></a><h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h4><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><img src="/blog/2021/03/07/回文相关问题/647.png" style="zoom:80%;"><h5 id="解决方案一：动态规划"><a href="#解决方案一：动态规划" class="headerlink" title="解决方案一：动态规划"></a>解决方案一：动态规划</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]表示s[i:j]是否是回文子串</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 三种情况</span></span><br><span class="line">        <span class="comment">// 1.自身</span></span><br><span class="line">        <span class="comment">// 2.如果长度为2，判断两个是否相同</span></span><br><span class="line">        <span class="comment">// 3.长度大于2，在两个字符相同的条件下，判断dp[i+1][j-1]也是就是左右各缩小一位的字串是否是回文</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i == <span class="number">1</span> &amp;&amp; s[j] == s[i])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i &gt; <span class="number">1</span> &amp;&amp; s[j] == s[i] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解决方案二：中心扩展法"><a href="#解决方案二：中心扩展法" class="headerlink" title="解决方案二：中心扩展法"></a>解决方案二：中心扩展法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 回文长度为奇数</span></span><br><span class="line">            <span class="keyword">int</span> count1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="comment">// 回文长度为偶数</span></span><br><span class="line">            <span class="keyword">int</span> count2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            ans += count1 + count2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中心扩展求当前字符起始的最长回文子串</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解决方案三：Manacher算法"><a href="#解决方案三：Manacher算法" class="headerlink" title="解决方案三：Manacher算法"></a>解决方案三：Manacher算法</h5><p>后续补充</p><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><img src="/blog/2021/03/07/回文相关问题/5.png"><h5 id="解决方案一：动态规划-1"><a href="#解决方案一：动态规划-1" class="headerlink" title="解决方案一：动态规划"></a>解决方案一：动态规划</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 以列填充dp数组，因为dp[i][j]由dp[i + 1][j - 1]转移而来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j]) dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时s[i]=s[j]，剩下的字符串长度为0或者1时，都是回文字符串</span></span><br><span class="line">                    <span class="comment">// 即(j - 1) - (i + 1)  + 1 &lt; 2 =&gt; j - i &lt; 3</span></span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                        begin = i;</span><br><span class="line">                        maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种动态规划的写法，跟<strong>回文子串</strong>类似，能稍微快些：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]表示s[i:j]是否是回文子串</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 三种情况</span></span><br><span class="line">        <span class="comment">// 1.自身</span></span><br><span class="line">        <span class="comment">// 2.如果长度为2，判断两个是否相同</span></span><br><span class="line">        <span class="comment">// 3.长度大于2，在两个字符相同的条件下，判断dp[i+1][j-1]也是就是左右各缩小一位的字串是否是回文</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i == <span class="number">1</span> &amp;&amp; s[j] == s[i])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i &gt; <span class="number">1</span> &amp;&amp; s[j] == s[i] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解决方案二：中心扩展法-1"><a href="#解决方案二：中心扩展法-1" class="headerlink" title="解决方案二：中心扩展法"></a>解决方案二：中心扩展法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 回文串为奇数</span></span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="comment">// 回文串为偶数</span></span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> curLen = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(curLen &gt; maxLen)&#123;</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">                <span class="comment">// 自己画图模拟一下</span></span><br><span class="line">                begin = i - (maxLen - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正回文串长度需要减去两边</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最短回文串"><a href="#最短回文串" class="headerlink" title="最短回文串"></a>最短回文串</h4><p>给定一个字符串 <strong><em>s</em></strong>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><img src="/blog/2021/03/07/回文相关问题/214.png"><p>本题其实是找包括  <code>s</code> 起始位置的最长回文子串，但是只有在 $O(n)$ 的复杂度情况下才能过，所以不能用 $O(n^2)$ 的动态规划或者中心扩展法，只能用Manacher算法和KMP匹配算法。</p><h5 id="解决方案：Manacher算法"><a href="#解决方案：Manacher算法" class="headerlink" title="解决方案：Manacher算法"></a>解决方案：Manacher算法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = longestPalindrome(s);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pos;</span><br><span class="line">        <span class="built_in">string</span> helper = s.substr(pos, s.size() - pos);</span><br><span class="line">        reverse(helper.begin(), helper.end());</span><br><span class="line">        s = helper + s;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> buf;</span><br><span class="line">        buf = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">int</span> mirror;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_pos;</span><br><span class="line">        <span class="keyword">int</span> l, r;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">            buf += ch;</span><br><span class="line">            buf += <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = buf.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i != n; ++i)&#123;</span><br><span class="line">            mirror = <span class="number">2</span> * center - i;</span><br><span class="line">            p[i] = min(p[mirror], max_right - i);</span><br><span class="line">            l = i - p[i] - <span class="number">1</span>;</span><br><span class="line">            r = i + p[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(buf[l] == buf[r])&#123;</span><br><span class="line">                    --l;</span><br><span class="line">                    ++r;</span><br><span class="line">                    ++p[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i - p[i] &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                max_pos = i + p[i];</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span>(i + p[i] &gt;= max_right)&#123;</span><br><span class="line">                max_right = i + p[i];</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; p[i] &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_pos / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p><img src="/blog/2021/03/07/回文相关问题/516.png"><h5 id="解决方案：动态规划"><a href="#解决方案：动态规划" class="headerlink" title="解决方案：动态规划"></a>解决方案：动态规划</h5><img src="/blog/2021/03/07/回文相关问题/516-helper.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// dp[i][j]表示从i到j的最长回文子序列</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从右下角进行左斜上遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">// 如果相等，缩小区间的最长回文子序列长度加上两个边界</span></span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 否则，缩小左区间或缩小右区间的最长回文子序列长度中的较大值得到</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目列表&quot;&gt;&lt;a href=&quot;#题目列表&quot; class=&quot;headerlink&quot; title=&quot;题目列表&quot;&gt;&lt;/a&gt;题目列表&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindromic-substrings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;647. 回文子串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;5. 最长回文子串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shortest-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;214. 最短回文串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;516. 最长回文子序列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://www.xingyuzhao.ltd/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="中心扩展法" scheme="http://www.xingyuzhao.ltd/tags/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/"/>
    
      <category term="Manacher算法" scheme="http://www.xingyuzhao.ltd/tags/Manacher%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>条款25：考虑写出一个不抛异常的swap函数</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/05/%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/05/%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-05T07:25:38.000Z</published>
    <updated>2021-03-05T09:08:47.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>缺省情况下 <code>swap</code> 动作由标准库提供的 <code>swap</code> 算法实现，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line"><span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要 T 支持拷贝运算（拷贝构造函数和拷贝赋值运算符）就可使用，但是经历了三次复制，对于某些类型而言，这样的复制操作并无必要，那么应该如何做？</p><a id="more"></a><h4 id="pimpl-pointer-to-implement"><a href="#pimpl-pointer-to-implement" class="headerlink" title="pimpl(pointer to implement)"></a>pimpl(pointer to implement)</h4><p>这种类型主要就是<strong>以指针指向一个对象，内含真正数据</strong>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span> <span class="comment">// 这个class使用pimpl手法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">privete:</span><br><span class="line">    WidgetImpl *pImpl; <span class="comment">// 所指对象内含Widget数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="为类特化std-swap"><a href="#为类特化std-swap" class="headerlink" title="为类特化std::swap"></a>为类特化std::swap</h5><p>我们希望告诉 <code>std::swap</code>：当 <code>Widget</code>被置换时真正该做的是置换其内部的 <code>pImpl</code> 指针。一个实现的思路是将 <code>std::swap</code> 针对 <code>Widget</code> 特例化，同时为了能够访问 <code>Widget</code> 的 <code>private</code>，令 <code>Widget</code> 声明一个 <code>swap</code> 的 <code>public</code> 成员函数做真正的置换操作，再将 <code>std::swap</code> 特例化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp;other)</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">swap(pImpl, other.pImpl);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123; <span class="comment">// 一般不能被改变std中任何东西，但是可以进行特例化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">void</span> swap&lt;Widget&gt;(Widget &amp;a, Widget &amp;b)&#123;</span><br><span class="line">a.swap(b); <span class="comment">// 调用Widget的成员函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="假设两个类都是类模板"><a href="#假设两个类都是类模板" class="headerlink" title="假设两个类都是类模板"></a>假设两个类都是类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure><p>此时再去特化 <code>std::swap</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt; &amp;a, Widget&lt;T&gt; &amp;b)&#123;</span><br><span class="line">a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上做法是<strong>错误的</strong>，因为我们企图<strong>偏特化</strong>一个函数模板，这是不允许的，<strong>因为有函数重载的概念，C++ 根据参数的类型来判断重载哪一个函数，如果还进行偏特化，这就与重载相冲突</strong>。但是我们可以对一个函数模板进行重载，同时需要注意不能在 std 中重载，因为 C++ 标准禁止添加新的 <code>template</code> 到 std 中（包括 <code>class</code> 或 <code>function</code> 等任何其他东西）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff&#123;</span><br><span class="line">... <span class="comment">// 模板化的WidgetImpl等</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 同前，含swap成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt; &amp;a, Widget&lt;T&gt; &amp;b)</span></span>&#123; <span class="comment">// 非成员函数且不属于std</span></span><br><span class="line">a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果准备置换两个对象，C++ 名称查找法则会找到 <code>WidgetStuff</code> 内的 <code>Widget</code> 的专属版本。</p><p>上述方法对<strong>类</strong>和<strong>类模板</strong>都适用，但是为了让你的<strong>类专属版</strong>的 <code>swap</code> 在更多的语境下调用，你需要同时在该 <code>class</code> 所在命名空间内写一个非成员函数版本和一个 <code>std::swap</code> 特化版本。</p><h5 id="更多语境下使用类专属的swap"><a href="#更多语境下使用类专属的swap" class="headerlink" title="更多语境下使用类专属的swap"></a>更多语境下使用类专属的swap</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T &amp;obj1, T &amp;obj2)</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 令std::swap在此函数内可用</span></span><br><span class="line">...</span><br><span class="line">swap(obj1, obj2); <span class="comment">// 为T型对象调用最佳的swap版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，C++ 的名称查找法则确保将找到 global 作用域及 T 所在命名空间内的任何 T 专属的 <code>swap</code>，具体顺序如下：</p><ol><li>编译器使用<strong>实参取决之查找规则</strong>找出 <code>WidgetStuff</code> 内的 <code>swap</code>，如果没有，转下；</li><li>使用 <code>std</code> 中对于 T 的特例化  <code>swap</code>，如果没有，转下；</li><li>使用 <code>std</code> 中一般化的 <code>template</code> 版本。</li></ol><p><strong>不能使用</strong> <code>std::swap(obj1, obj2)</code>，这会使**编译器只认 <code>std</code> 内的 <code>swap</code>**。</p><h5 id="成员版swap绝不可抛出异常"><a href="#成员版swap绝不可抛出异常" class="headerlink" title="成员版swap绝不可抛出异常"></a>成员版swap绝不可抛出异常</h5><p>当写下一个自定版本的 <code>swap</code>，往往提供的不只是高效率的置换对象值的办法，而且不抛出异常。因为高效率的 <code>swap</code> 几乎总是基于对内置类型的操作，而内置类型上的操作绝不会抛出异常。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ol><li>如果 <code>swap</code> 的缺省版本对类或者类模板提供可接受的效率，那么不需要额外做任何事。</li><li>如果效率不足，意味着你的类或者模板使用了 pimpl 手法，试着做以下事情：<ol><li>提供一个成员函数 <code>swap</code>，让它高效置换你的类型的两个对象值且不抛出异常；</li><li>在你的类或模板所在的命名空间提供一个非成员函数调用上述成员函数 <code>swap</code>；</li><li>如果你正在编写一个类而<strong>非</strong>类模板，特化 <code>std::swap</code>，并令其调用成员函数 <code>swap</code>，并且调用前使用 <code>using</code> 声明式。</li></ol></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>当 <code>std::swap</code> 对你的类型效率不高时，提供一个 <code>swap</code> 成员函数，并确定这个函数不抛出异常。</li><li>如果你提供一个成员函数 <code>swap</code>，也应提供一个非成员函数调用前者，对于类，也要特化 <code>std::swap</code>。</li><li>调用 <code>swap</code> 时应针对 <code>std::swap</code> 使用 <code>using </code> 声明式，然后调用 <code>swap</code> 并且不带任何<strong>命名空间资格修饰</strong>。</li><li>为“用户定义类型”进行 std <strong>template</strong> 全特化是好的，但不要尝试在 std 内加入对 std 而言全新的东西。</li></ol><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《Effective C++》条款 25：考虑写出一个不抛异常的 swap 函数</p><p><a href="https://blog.csdn.net/qq_35976351/article/details/82822285" target="_blank" rel="noopener">https://blog.csdn.net/qq_35976351/article/details/82822285</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;缺省情况下 &lt;code&gt;swap&lt;/code&gt; 动作由标准库提供的 &lt;code&gt;swap&lt;/code&gt; 算法实现，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T &amp;amp;a, T &amp;amp;b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		a = b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		b = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;只要 T 支持拷贝运算（拷贝构造函数和拷贝赋值运算符）就可使用，但是经历了三次复制，对于某些类型而言，这样的复制操作并无必要，那么应该如何做？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="swap" scheme="http://www.xingyuzhao.ltd/tags/swap/"/>
    
  </entry>
  
  <entry>
    <title>一些小tips</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/03/%E4%B8%80%E4%BA%9B%E5%B0%8Ftips/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/03/%E4%B8%80%E4%BA%9B%E5%B0%8Ftips/</id>
    <published>2021-03-03T07:06:14.000Z</published>
    <updated>2021-04-03T02:50:57.666Z</updated>
    
    <content type="html"><![CDATA[<p>有关做题时的一些小知识点，持续记录。</p><a id="more"></a><h5 id="位运算-i-amp-i-1"><a href="#位运算-i-amp-i-1" class="headerlink" title="位运算 $i&amp;(i-1)$"></a>位运算 $i&amp;(i-1)$</h5><p>作用：将 $i$ 的二进制表示中的最低位的 1 改为 0。</p><p>使用场景：计算二进制数中 1 的个数。</p><p>例题：<a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></p><h5 id="lowbit-x"><a href="#lowbit-x" class="headerlink" title="$lowbit(x)$"></a>$lowbit(x)$</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：$x$ 的二进制表示中最低位的 1 所对应的值。</p><p>例如，6 的二进制为 110，则 $lowbit(6)$ 为 $110&amp;010=010$，即 2。</p><p>使用场景：树状数组。</p><p>例题：<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></p><h5 id="位掩码"><a href="#位掩码" class="headerlink" title="位掩码"></a>位掩码</h5><h6 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h6><p>对于一个长度位 $n$ 的数组求其所有的子集，则一共有 $2^n$ 种可能，也就是 $1&lt;&lt;n$。使用一个长度为 $n$ 的二进制数表示数组中每一个数<strong>是否出现</strong>，出现为 1，否则为 0。</p><p>例如：数组 [1,2] 对应长度为 2 的二进制数，一共有四种可能：</p><ol><li>00 表示两个都不取，为 []；</li><li>01 表示只取第一个，为 [1]；</li><li>10 表示只取第二个，为 [2]；</li><li>11 表示全部都取，为 [1,2]。</li></ol><p>以上，就得到的数组的所有子集。</p><p>例题：<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></p><h6 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h6><p>详见：<a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/" target="_blank" rel="noopener">1178. 猜字谜</a></p><h5 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h5><p>作用：求取公因数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) swap(a, b);</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">365. 水壶问题</a></p><h5 id="快速幂运算"><a href="#快速幂运算" class="headerlink" title="快速幂运算"></a>快速幂运算</h5><p>作用：求 $x^n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line"><span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">ret *= x;</span><br><span class="line">x *= x;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? ret : <span class="number">1</span> / ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有关做题时的一些小知识点，持续记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="位运算" scheme="http://www.xingyuzhao.ltd/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="数学" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>条款03：尽可能使用const</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/01/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/01/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/</id>
    <published>2021-03-01T11:34:15.000Z</published>
    <updated>2021-04-01T15:31:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>const</code> 可以在  <code>class</code> 外部修饰 <code>global</code> 或 <code>namespace</code> 作用域中的常量，或修饰文件、函数、或<strong>区域作用块中被声明为 <code>static</code> 的对象</strong>；也可以修饰 <code>class</code> 内部的静态或非静态成员变量。对于指针，可以指出指针自身、指针所指物，或两者都（或都不）是 <code>const</code>。</p><a id="more"></a><h4 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = s; <span class="comment">// non_const pointer, non_const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = s; <span class="comment">// non_const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = s; <span class="comment">// const pointer, non_const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = s; <span class="comment">// const_pointer, const_data</span></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>const</code> 出现在 * 左侧，表示被指物为常量；如果出现在 * 右侧，表示指针自身为常量</strong>。</p></li><li><p>如果被指物为常量，则 <code>const char*</code> 或 <code>char const*</code> 都一样。</p></li></ul><h4 id="迭代器与const"><a href="#迭代器与const" class="headerlink" title="迭代器与const"></a>迭代器与const</h4><p>迭代器类似于 <code>T*</code> 指针：</p><ul><li>迭代器为 <code>const</code>：<code>T* const</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin(); <span class="comment">// T* const</span></span><br><span class="line">*iter = <span class="number">10</span>; <span class="comment">// 正确，所指变量可变</span></span><br><span class="line">iter++; <span class="comment">// 错误，迭代器不可变</span></span><br></pre></td></tr></table></figure><ul><li>迭代器所指对象为 <code>const</code>：<code>const T*</code> ，且需要使用 <code>const_iterator</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="comment">// auto cIter = vec.cbegin();</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.begin(); <span class="comment">// T* const</span></span><br><span class="line">*cIter = <span class="number">10</span>; <span class="comment">// 错误，所指变量为常量</span></span><br><span class="line">cIter++; <span class="comment">// 正确，迭代器可变</span></span><br></pre></td></tr></table></figure><h4 id="令函数返回一个常量值防止误操作而造成的意外"><a href="#令函数返回一个常量值防止误操作而造成的意外" class="headerlink" title="令函数返回一个常量值防止误操作而造成的意外"></a>令函数返回一个常量值防止误操作而造成的意外</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs);</span><br><span class="line"><span class="comment">/***************************/</span></span><br><span class="line">Rational a, b, c;</span><br><span class="line">(a * b) = c; <span class="comment">// 错误，防止无意义的赋值</span></span><br></pre></td></tr></table></figure><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p><code>const</code> 用于成员函数，表示该成员函数可作用于 <code>const</code> 对象，其理由有二：</p><ol><li>使 <code>class</code> 接口容易理解，告诉哪个函数可以改变对象内容哪个不行；</li><li>使操作 <code>const</code> 对象成为可能。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TextBlock(<span class="built_in">string</span> &amp;s): text(s) &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)&#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/***************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function">TextBlock <span class="title">tb</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>]; <span class="comment">// OK，读一个non_const TextBlock</span></span><br><span class="line">    tb[<span class="number">0</span>] = <span class="string">'x'</span>; <span class="comment">// OK，写一个non_const TextBlock</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>]; <span class="comment">// OK，读一个const TextBlock</span></span><br><span class="line">    ctb[<span class="number">0</span>] = <span class="string">'x'</span>; <span class="comment">// Error，写一个const TextBlock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bitwise-constness"><a href="#bitwise-constness" class="headerlink" title="bitwise constness"></a>bitwise constness</h5><p>成员函数不能更改对象的任何成员变量（除了 <code>static</code>），编译器只需找到成员的赋值动作即可。</p><p>然而一个更改了”指针所指物“的成员函数虽然不能算是 <code>const</code>，但如果只有指针（而非其所指物）属于对象，那么称此函数为 <code>bitwise constness</code> 不会引发编译器异议。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CTextBlock(<span class="keyword">char</span> *s): pText(s) &#123;&#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span>&#123; <span class="comment">// bitwise const声明，但不恰当</span></span><br><span class="line">        <span class="keyword">return</span> pText[position];<span class="comment">// 并不更改pText，所以是bitwise const</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/***************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(s)</span></span>; <span class="comment">// 声明一个常量对象</span></span><br><span class="line">    <span class="keyword">char</span> *pc = &amp;cctb[<span class="number">0</span>]; <span class="comment">// 调用const operatorp[]取得一个指针，指向cctb数据</span></span><br><span class="line">    *pc = <span class="string">'J'</span>; <span class="comment">// cctb现在有了"Jello"的内容，这样是不允许的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="logical-constness"><a href="#logical-constness" class="headerlink" title="logical constness"></a>logical constness</h5><p>一个 <code>const</code> 成员函数可以修改它所处理的对象内的某些 <code>bits</code>，但只有在<strong>客户端侦测不出的情况下</strong>才得如此。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">size_t</span> textLength; <span class="comment">// 最近一次计算的文本区块长度</span></span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid; <span class="comment">// 目前的长度是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">        <span class="comment">// 错误！在const成员函数内不能赋值</span></span><br><span class="line">        textLength = <span class="built_in">strlen</span>(pText);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>logical constness</code>，编译器不允许这种做法，此时需要使用一个与 <code>const</code> 相关的摆动场：**<code>mutable</code>（可变的）**。<code>mutable</code> 释放掉 <code>non_static</code> 成员变量的 <code>bitwise constness</code> 约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="comment">// 这些成员变量可能总是会被更改，即使在const函数内</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> textLength; </span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">        <span class="comment">// 赋值正确</span></span><br><span class="line">        textLength = <span class="built_in">strlen</span>(pText);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h4><p>如果 <code>const</code> 和 <code>non_const</code> 成员函数有着等价的实现时，令 <code>non-const</code> 版本调用 <code>const</code> 版本可避免代码重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zxy on 2021/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TextBlock(<span class="built_in">string</span> &amp;s): text(s) &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)&#123;</span><br><span class="line">        <span class="comment">// 第一次为*this添加const，第二次从const operator[]的返回值移除const。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function">TextBlock <span class="title">tb</span><span class="params">(s)</span></span>;</span><br><span class="line">    tb[<span class="number">0</span>] = <span class="string">'H'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>]; <span class="comment">// 正确，对象为变量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">1</span>];</span><br><span class="line">    ctb[<span class="number">1</span>] = <span class="string">'E'</span>; <span class="comment">// 错误，对象为常量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>将某些东西声明为 <code>const</code> 可帮助编译器侦测出错误用法；</li><li>编译器强制实施 <code>bitwise constness</code>，但编程时应注重<strong>概念上的常量性</strong>；</li><li>如果 <code>const</code> 和 <code>non_const</code> 成员函数有着等价的实现时，令 <code>non-const</code> 版本调用 <code>const</code> 版本可避免代码重复。</li></ul><p>除此之外：</p><ul><li><code>const</code> 对象只能调用 <code>const</code> 成员函数；</li><li>非 <code>const</code> 对象既可以调用 <code>const</code> 成员函数，又可以调用非 <code>const</code> 成员函数。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《Effective C++》条款 03：尽可能使用 const</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 可以在  &lt;code&gt;class&lt;/code&gt; 外部修饰 &lt;code&gt;global&lt;/code&gt; 或 &lt;code&gt;namespace&lt;/code&gt; 作用域中的常量，或修饰文件、函数、或&lt;strong&gt;区域作用块中被声明为 &lt;code&gt;static&lt;/code&gt; 的对象&lt;/strong&gt;；也可以修饰 &lt;code&gt;class&lt;/code&gt; 内部的静态或非静态成员变量。对于指针，可以指出指针自身、指针所指物，或两者都（或都不）是 &lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="const" scheme="http://www.xingyuzhao.ltd/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1178-猜字谜</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/26/LeetCode1178-%E7%8C%9C%E5%AD%97%E8%B0%9C/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/26/LeetCode1178-%E7%8C%9C%E5%AD%97%E8%B0%9C/</id>
    <published>2021-02-26T08:38:08.000Z</published>
    <updated>2021-02-26T09:21:51.577Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p><ul><li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li><li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。</li></ul><p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p><a id="more"></a><img src="/blog/2021/02/26/LeetCode1178-猜字谜/1178.png"><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>从题目我们可以得到两个信息（省略了在 <code>i</code> 处）：</p><ul><li><code>puzzle</code> 的第一个字母在 <code>word</code> 中；</li><li><code>puzzle</code> 中包括 <code>word</code> 中的任一字母。</li></ul><p>如果对于每个 <code>puzzle</code> 都去遍历每个 <code>word</code>，那么复杂度会很高，因为每个 <code>word</code> 都含有多个字母。<strong>除此之外，<code>puzzle</code> 的长度都为 7</strong>。</p><h6 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h6><p>如果我们用一个<strong>26位</strong>长的二进制数来表示对应字母是否存在（存在为 1，否则为 0），再用<strong>哈希表</strong>存储每种二进制数出现的次数，可以大大降低查询 <code>words</code> 的时间复杂度，这种方法称为<strong>状态压缩</strong>（换句话说，去重后的 <code>word</code> 如果具有相同特征，将对应相同的二进制数）。</p><h6 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h6><ol><li>统计 <code>words</code> 对应二进制数的出现次数（每个二进制数中 1 的个数必须小于等于 7，否则 <code>puzzle</code> 不可能将 <code>word</code> 完全覆盖）；</li><li>由于 <code>puzzle</code> 的长度为 7，且第一个字母必须出现在 <code>word</code> 中，所以只需要计算 $2^6$ 种二进制组合，再将 <code>puzzle[0]</code> 对应二进制数的位置为 1。如果哈希表中存在此二进制数，说明此二进制数是 <code>puzzle</code> 谜底。</li></ol><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据word建立哈希表，映射26个字母</span></span><br><span class="line">        <span class="comment">// 统计每种状态压缩的出现次数</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : words)&#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计二进制位中1的出现次数</span></span><br><span class="line">            <span class="keyword">if</span>(__builtin_popcount(mask) &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">                <span class="built_in">map</span>[mask]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// puzzle的第一个字母在word中</span></span><br><span class="line">        <span class="comment">// puzzle中包括word中的任一字母</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;puzzle : puzzles)&#123;</span><br><span class="line">            <span class="comment">// 一共有2^6种可能</span></span><br><span class="line">            <span class="comment">// puzzle的第一个字母对应的位必为1</span></span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> choose = <span class="number">0</span>; choose &lt; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>); ++choose)&#123;</span><br><span class="line">                <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// puzzle的每个字母</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">                    <span class="comment">// 每个位代表一个字母是否存在</span></span><br><span class="line">                    <span class="comment">// choose代表二进制的一种组合，使用与操作找到此种组合下存在的每一位</span></span><br><span class="line">                    <span class="keyword">if</span>(choose &amp; (<span class="number">1</span> &lt;&lt; i))&#123;</span><br><span class="line">                        mask |= (<span class="number">1</span> &lt;&lt; (puzzle[i + <span class="number">1</span>] - <span class="string">'a'</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// puzzle的第一个字母必须存在于word中</span></span><br><span class="line">                    mask |= (<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>] - <span class="string">'a'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.count(mask))&#123;</span><br><span class="line">                    total += <span class="built_in">map</span>[mask];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/cai-zi-mi-by-leetcode-solution-345u/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/cai-zi-mi-by-leetcode-solution-345u/</a></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><code>__builtin_popcount(var)</code>：统计二进制数中 1 的个数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。&lt;/p&gt;
&lt;p&gt;字谜的迷面 &lt;code&gt;puzzle&lt;/code&gt; 按字符串形式给出，如果一个单词 &lt;code&gt;word&lt;/code&gt; 符合下面两个条件，那么它就可以算作谜底：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单词 &lt;code&gt;word&lt;/code&gt; 中包含谜面 &lt;code&gt;puzzle&lt;/code&gt; 的第一个字母。&lt;/li&gt;
&lt;li&gt;单词 &lt;code&gt;word&lt;/code&gt; 中的每一个字母都可以在谜面 &lt;code&gt;puzzle&lt;/code&gt; 中找到。&lt;br&gt;例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回一个答案数组 &lt;code&gt;answer&lt;/code&gt;，数组中的每个元素 &lt;code&gt;answer[i]&lt;/code&gt; 是在给出的单词列表 &lt;code&gt;words&lt;/code&gt; 中可以作为字谜迷面 &lt;code&gt;puzzles[i]&lt;/code&gt; 所对应的谜底的单词数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="位运算" scheme="http://www.xingyuzhao.ltd/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="状态压缩" scheme="http://www.xingyuzhao.ltd/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++模板与泛型编程（三）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/24/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/24/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-02-24T04:11:34.000Z</published>
    <updated>2021-03-09T16:04:46.906Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>重载与模板</li><li>可变参数模板</li><li>模板特例化</li></ol><a id="more"></a><h4 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h4><h5 id="编写重载模板"><a href="#编写重载模板" class="headerlink" title="编写重载模板"></a>编写重载模板</h5><p>在调试中可能用到的一组函数，每个函数都返回一个给定对象的 <code>string</code> 表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line"><span class="built_in">ostringstream</span> ret;</span><br><span class="line">ret &lt;&lt; t;</span><br><span class="line"><span class="keyword">return</span> ret.str(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个打印指针的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line"><span class="built_in">ostringstream</span> ret;</span><br><span class="line">ret &lt;&lt; <span class="string">"pointer: "</span> &lt;&lt; p; <span class="comment">// 打印指针本身的值</span></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">ret &lt;&lt; <span class="string">" "</span> &lt;&lt; debug_rep(*p); <span class="comment">// 打印p指向的值</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret &lt;&lt; <span class="string">" null pointer"</span>; <span class="comment">// 或指出p为空</span></span><br><span class="line"><span class="keyword">return</span> ret.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此函数不能打印字符指针</strong>。</p><ol><li>只能匹配第一个版本：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hi"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>两个版本都可匹配，而第二个精确匹配，选择第二个：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(&amp;s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="多个可行模板"><a href="#多个可行模板" class="headerlink" title="多个可行模板"></a>多个可行模板</h5><p>当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。</p><h5 id="非模板和模板重载"><a href="#非模板和模板重载" class="headerlink" title="非模板和模板重载"></a>非模板和模板重载</h5><p>对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</p><h5 id="重载模板与类型转换"><a href="#重载模板与类型转换" class="headerlink" title="重载模板与类型转换"></a>重载模板与类型转换</h5><p>C 风格字符串指针和字符串常量，考虑调用 <code>cout &lt;&lt; debug_rep(&quot;hi world!&quot;) &lt;&lt; endl</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debug_rep(<span class="keyword">const</span> T&amp;); <span class="comment">// T被绑定到char[10]</span></span><br><span class="line">debug_rep(T*); <span class="comment">// T被绑定到const char</span></span><br><span class="line">debug_rep(<span class="keyword">const</span> <span class="built_in">string</span>&amp;); <span class="comment">// 要求从const char*到string的类型转换</span></span><br></pre></td></tr></table></figure><h5 id="缺少声明可能导致程序行为异常"><a href="#缺少声明可能导致程序行为异常" class="headerlink" title="缺少声明可能导致程序行为异常"></a>缺少声明可能导致程序行为异常</h5><p>在定义任何函数之前，<strong>需要声明所有重载的函数版本</strong>，否则编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</p><h4 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h4><p>可变参数模板：接受<strong>可变数目</strong>参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>。</p><p>参数包有两种：</p><ol><li>模板参数包，表示零个或多个模板参数；</li><li>函数参数包，表示零个或多个函数参数。</li></ol><p>在一个模板参数列表中，<code>class...</code> 或 <code>typename...</code> 指出接下来的参数表示零个或多个类型的列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure><p>编译器从函数的实参推断模板参数类型，对于可变参数模板，编译器同时推断包中参数的数目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; <span class="built_in">string</span> s = <span class="string">"how now brown cow"</span>;</span><br><span class="line"><span class="comment">// void foo(const int&amp;, const string&amp;, const int&amp;, const double&amp;);</span></span><br><span class="line">foo(i, s, <span class="number">42</span>, d); <span class="comment">// 包中有三个参数</span></span><br><span class="line"><span class="comment">// void foo(const string&amp;, const int&amp;, const int&amp;, const char[3]&amp;);</span></span><br><span class="line">foo(s, <span class="number">42</span>, <span class="string">"hi"</span>); <span class="comment">// 包中有两个参数</span></span><br><span class="line"><span class="comment">// void foo(const double&amp;, const string&amp;);</span></span><br><span class="line">foo(d, s); <span class="comment">// 包中有一个参数</span></span><br><span class="line"><span class="comment">// void foo(const char[3]&amp;);</span></span><br><span class="line">foo(<span class="string">"hi"</span>); <span class="comment">// 空包</span></span><br></pre></td></tr></table></figure><p><strong>sizeof…运算符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 类型参数的数目</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h5><p>可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">// 此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> os &lt;&lt; t; <span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">os &lt;&lt; t &lt;&lt; <span class="string">", "</span>; <span class="comment">// 打印第一个实参</span></span><br><span class="line"><span class="keyword">return</span> print(os, rest...); <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个版本的 <code>print</code> 负责终止递归并打印最后一个实参，第二个版本的 <code>print</code> 是可变参数版本，它打印绑定到 <code>t</code> 的实参，并调用自身来打印函数参数包中的剩余值。</p><p>对于 <code>print(cout, i, s, 42)</code>，递归会执行如下：</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/调用.png"><p>对于最后一个调用，两个函数提供同样好的匹配。但是<strong>非可变参数模板</strong>比<strong>可变参数模板</strong>更特例化，因此编译器选择非可变参数模板。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/调用warning.png"><h5 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h5><p>扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号 <code>...</code> 来触发扩展操作。（**此处不是很理解，包扩展不就是可变参数模板吗?**）</p><h6 id="理解包扩展"><a href="#理解包扩展" class="headerlink" title="理解包扩展"></a>理解包扩展</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在print调用中对每个实参调用debug_req</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line"><span class="comment">// print(os, debug_req(a1), debug_req(a2), ..., debug_req(an))</span></span><br><span class="line">print(os, debug_req(rest)...); <span class="comment">// print(os, debug_req(rest...))错误，此调用无匹配函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/24/C-模板与泛型编程（三）/包扩展.png"><h5 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h5><p>新标准下，我们可以组合使用可变参数模板与 <code>forward</code> 机制来编写函数，实现将其实参不变的传递给其他函数。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/建议_转发和可变参数模板.png"><h4 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h4><h5 id="定义函数模板特例化"><a href="#定义函数模板特例化" class="headerlink" title="定义函数模板特例化"></a>定义函数模板特例化</h5><p>定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。先前声明版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempalte &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span></span><br></pre></td></tr></table></figure><p>特例化版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// &lt;&gt;表示我们正在实例化一个模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数重载与模板实例化"><a href="#函数重载与模板实例化" class="headerlink" title="函数重载与模板实例化"></a>函数重载与模板实例化</h5><p><strong>一个特例化版本的本质上是一个实例，而非函数名的一个重载版本</strong>。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/函数重载与模板实例化.png"><img src="/blog/2021/02/24/C-模板与泛型编程（三）/普通作用域规则应用于特例化.png"><h5 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h5><p>P626.</p><h5 id="类模板部分特例化"><a href="#类模板部分特例化" class="headerlink" title="类模板部分特例化"></a>类模板部分特例化</h5><p>与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。</p><p>一个类模板的部分特例化（partial specialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/类模板部分特例化.png"><p>标准库 <code>remove_reference</code> 模板是通过一系列的特例化版本来完成其功能的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 最原始、最通用版本</span><br><span class="line">template &lt;class T&gt; struct remove_reference&#123;</span><br><span class="line">typedef T type;</span><br><span class="line">&#125;;</span><br><span class="line">// 部分特例化版本， 将用于左值引用和右值引用</span><br><span class="line">template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt;&#123;</span><br><span class="line">typedef T type;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt;&#123;</span><br><span class="line">typedef T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// decltype(42)为int，使用原始模板</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;</span><br><span class="line"><span class="comment">// decltype(i)为int&amp;，使用特例化版本一</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(i)&gt;::type b;</span><br><span class="line"><span class="comment">// decltype(std::move(i))为int&amp;&amp;，使用特例化版本二</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="built_in">std</span>::move(i))&gt;::type c;</span><br></pre></td></tr></table></figure><p>以上三个变量都是 <code>int</code> 类型。</p><h5 id="特例化成员而不是类"><a href="#特例化成员而不是类" class="headerlink" title="特例化成员而不是类"></a>特例化成员而不是类</h5><p>我们可以只特例化成员函数而不是特例化整个模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">Foo(<span class="keyword">const</span> T &amp;t = T()): mem(t)&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span>&#123; <span class="comment">/* ... */</span>&#125;</span><br><span class="line">T mem;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// 特例化</span></span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()&#123;</span><br><span class="line"><span class="comment">// 进行应用于int的特例化处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 <code>Foo&lt;int&gt;</code> 类的一个成员，其他成员由 <code>Foo</code> 模板提供：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs; <span class="comment">// Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.Bar(); <span class="comment">// Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi; <span class="comment">// Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.Bar(); <span class="comment">// 使用我们特例化版本的Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;重载与模板&lt;/li&gt;
&lt;li&gt;可变参数模板&lt;/li&gt;
&lt;li&gt;模板特例化&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++模板与泛型编程（二）——模板实参推断</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/23/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/23/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-23T15:34:45.000Z</published>
    <updated>2021-02-24T09:18:43.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>类型转换与模板类型参数</li><li>函数模板显式实参</li><li>尾置返回类型与类型转换</li><li>函数指针和实参推断</li><li>模板实参推断和引用</li><li>理解 <code>std::move</code></li><li>转发</li></ol><a id="more"></a><p>从函数实参来确定模板实参的过程称为<strong>模板实参推断</strong>。</p><h4 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h4><p>编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。顶层 <code>const</code>无论在形参还是实参中都会被忽略。</p><ul><li><code>const</code> 转换：可以将一个非 <code>const</code> 对象的引用（或指针）传递给一个 <code>const</code> 的引用（或指针）形参。</li><li>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li></ul><img src="/blog/2021/02/23/C-模板与泛型编程（二）/实参传递给模板类型的函数形参note.png"><h5 id="使用相同模板参数类型的函数形参"><a href="#使用相同模板参数类型的函数形参" class="headerlink" title="使用相同模板参数类型的函数形参"></a>使用相同模板参数类型的函数形参</h5><p>一个模板类型参数可以作为多个函数形参的类型，但是传递给形参的实参类型必须相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>); <span class="comment">// 错误，不能实例化compare(long, int)，类型不匹配</span></span><br></pre></td></tr></table></figure><p>如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span><span class="params">(<span class="keyword">const</span> A&amp; v1, <span class="keyword">const</span> B&amp; v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="正常类型转换应用于普通函数实参"><a href="#正常类型转换应用于普通函数实参" class="headerlink" title="正常类型转换应用于普通函数实参"></a>正常类型转换应用于普通函数实参</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>os</code> 类型固定，因此调用 <code>print</code> 时，传递给它的实参会正常进行类型转换。</p><img src="/blog/2021/02/23/C-模板与泛型编程（二）/正常类型转换应用于普通函数实参.png"><h4 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h4><h5 id="指定显式模板实参"><a href="#指定显式模板实参" class="headerlink" title="指定显式模板实参"></a>指定显式模板实参</h5><p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure><p>每次调用前，调用者必须为 <code>T1</code> 提供一个<strong>显式模板实参</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng); <span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure><p><strong>显式模板实参按照由左至右的顺序与对应的模板参数匹配</strong>。</p><h5 id="正常类型转换应用于显式指定的实参"><a href="#正常类型转换应用于显式指定的实参" class="headerlink" title="正常类型转换应用于显式指定的实参"></a>正常类型转换应用于显式指定的实参</h5><p>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>); <span class="comment">// 错误：模板类型不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">// 正确：实例化compare(long, long)，接受两个const long&amp;;</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">// 正确：实例化compare(int, int)，lng被转换为int;</span></span><br></pre></td></tr></table></figure><h4 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回类型允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg) // 迭代器解引用返回元素引用</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> *beg; <span class="comment">// 返回序列中的一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进行类型转换的标准库模板类"><a href="#进行类型转换的标准库模板类" class="headerlink" title="进行类型转换的标准库模板类"></a>进行类型转换的标准库模板类</h5><p>如果希望编写一个类似 <code>fcn</code> 的函数，但返回一个元素的值而非引用。可以使用标准库的<strong>类型转换</strong>模板，定义在头文件 <code>type_traits</code> 中。模板如下表：</p><img src="/blog/2021/02/23/C-模板与泛型编程（二）/标准类型转换模板.png"><p>上述模板中每个都拥有一个名为 <code>type</code> 的 <code>public</code> 成员，表示一个类型。</p><ul><li>如果不可能（不必要）转换模板参数，则 <code>type</code> 成员就是模板参数本身。</li></ul><p>组合使用 <code>remove_reference</code> ，尾置返回类型及 <code>decltype</code>，我们可以在函数中返回元素值的拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用typename表示type是一个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;typnemae It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)::type</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h4><p>当我们使用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure><p>如果不能从函数指针类型确定函数模板，则产生错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func的重载版本，每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line">func(compare); <span class="comment">// 错误，使用compare的哪个实例？</span></span><br></pre></td></tr></table></figure><p>可以使用显式模板实参来消除 <code>func</code> 调用的歧义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;); <span class="comment">// 传递compare(const int&amp;, const int&amp;)</span></span><br></pre></td></tr></table></figure><h4 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h4><h5 id="从左值引用函数参数推断类型"><a href="#从左值引用函数参数推断类型" class="headerlink" title="从左值引用函数参数推断类型"></a>从左值引用函数参数推断类型</h5><p>当一个函数参数是模板类型参数的一个普通(左值)引用时（即，形如T&amp;）。绑定规则告诉我们：</p><ul><li>只能传递给它一个左值（如，一个变量或一个返回引用类型的表达式）。</li></ul><p>实参可以是 <code>const</code> 类型，也可以不是。如果实参是 <code>const</code> 的，则 <code>T</code> 将被推断为 <code>const</code> 类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>; <span class="comment">// 实参必须是一个左值</span></span><br><span class="line">f1(i); <span class="comment">// i是一个int，模板参数类型T是int</span></span><br><span class="line">f1(ci); <span class="comment">// ci是一个const int，模板参数T是const int</span></span><br><span class="line">f1(<span class="number">5</span>); <span class="comment">// 错误：5是右值</span></span><br></pre></td></tr></table></figure><p>如果一个函数参数的类型是 <code>const T&amp;</code>，正常的绑定规则告诉我们：</p><ul><li>可以传递给它任何类型的实参一个对象（ <code>const</code> 或非 <code>const</code> ）、一个临时对象或是一个字面常量值。</li></ul><p>当函数参数本身是 <code>const</code> 时，其已经是<strong>函数参数类型</strong>的一部分，因此，<strong>它不会也是模板参数类型的一部分</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">// f2中的参数是const &amp;，实参中的const是无关的</span></span><br><span class="line"><span class="comment">// 在每个调用中，f2的函数实参都被推断为const int&amp;</span></span><br><span class="line">f2(i); <span class="comment">// i是一个int，模板参数类型T是int</span></span><br><span class="line">f2(ci); <span class="comment">// ci是一个const int，但模板参数T是int</span></span><br><span class="line">f2(<span class="number">5</span>); <span class="comment">// 一个const &amp;参数可以绑定到一个右值，T是int</span></span><br></pre></td></tr></table></figure><h5 id="从右值引用函数参数推断类型"><a href="#从右值引用函数参数推断类型" class="headerlink" title="从右值引用函数参数推断类型"></a>从右值引用函数参数推断类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>); <span class="comment">// 实参是一个int类型的右值，模板参数T是int</span></span><br></pre></td></tr></table></figure><h5 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h5><ul><li>X&amp; &amp;、X&amp; &amp;&amp; 和 X&amp;&amp; &amp; 都折叠成类型 X&amp;</li><li>类型 X&amp;&amp; &amp;&amp; 折叠成 X&amp;&amp;</li></ul><img src="/blog/2021/02/23/C-模板与泛型编程（二）/引用折叠.png"><p>这两个规则导致了两个重要结果：</p><ol><li>函数参数指向模板类型参数的右值引用，则它可以被绑定到一个左值；</li><li>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个普通左值引用参数。</li></ol><img src="/blog/2021/02/23/C-模板与泛型编程（二）/右值引用参数.png" style="zoom:80%;"><h5 id="编写接受右值引用参数的函数模板"><a href="#编写接受右值引用参数的函数模板" class="headerlink" title="编写接受右值引用参数的函数模板"></a>编写接受右值引用参数的函数模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>; <span class="comment">// 绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// 左值和const右值</span></span><br></pre></td></tr></table></figure><h4 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h4><h5 id="std-move是如何定义的"><a href="#std-move是如何定义的" class="headerlink" title="std::move是如何定义的"></a>std::move是如何定义的</h5><p>标准库定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引用折叠，我们既可以传递给 <code>move</code> 一个左值，也可以传递给它一个右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("hi!"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"bye!"</span>)); <span class="comment">// 正确，从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1); <span class="comment">// 正确，但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure><h5 id="std-move是如何工作的"><a href="#std-move是如何工作的" class="headerlink" title="std::move是如何工作的"></a>std::move是如何工作的</h5><p>在 <code>std::move(string(&quot;bye!&quot;))</code> 中：</p><ul><li>推断出的 <code>T</code> 的类型为 <code>string</code>。</li><li>因此，<code>remove reference</code> 用 <code>string</code> 进行实例化。</li><li><code>remove_reference&lt;string&gt; </code>的 <code>type</code> 成员是 <code>string</code>。</li><li><code>move</code> 的返回类型是 <code>string&amp;&amp;</code>。</li><li><code>move</code> 的函数参数 <code>t</code> 的类型为 <code>string&amp;&amp;</code>。</li></ul><p>这个调用实例化 <code>move&lt;string&gt;</code>，即函数：<code>string&amp;&amp; move(string &amp;&amp;t)</code>。无需类型转换。</p><p>第二个赋值，传递给 <code>move</code> 的实参是一个左值：</p><ul><li>推断出的 <code>T</code> 的类型为 <code>string&amp;</code>（ <code>string</code> 的引用，而非普通 <code>string</code>)。</li><li>因此，<code>remove_reference</code> 用 <code>string&amp;</code> 进行实例化。</li><li><code>remove_reference&lt;string&amp;&gt;</code> 的 <code>type</code> 成员是 <code>string</code>。</li><li><code>move</code>的返回类型仍是 <code>string&amp;</code>。</li><li><code>move</code> 的函数参数 <code>t</code> 实例化为 <code>string&amp; &amp;&amp;</code>，会折叠为 <code>string&amp;</code>。</li></ul><p>这个调用实例化 <code>move&lt;string&amp;&gt;</code>，即函数：<code>string&amp;&amp; move(string &amp;t)</code>。</p><p><strong>将一个右值引用绑定到一个左值</strong>。这个实例的函数体返回 <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>，在此情况下，<code>cast</code> 将 <code>t</code> 的类型 <code>string&amp;</code> 转换为 <code>string&amp;&amp;</code>。</p><h5 id="从一个左值static-cast到一个右值引用时允许的"><a href="#从一个左值static-cast到一个右值引用时允许的" class="headerlink" title="从一个左值static_cast到一个右值引用时允许的"></a>从一个左值static_cast到一个右值引用时允许的</h5><p> 可以用 <code>static_cast</code> 显式的将一个左值转换为一个右值引用。</p><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span>&#123;</span><br><span class="line">f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">" "</span> &lt;&lt; ++v2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>f</code> 改变了绑定到 <code>v2</code> 的实参的值，但是通过 <code>flip1</code> 调用 <code>f</code>，<code>f</code> 所作的改变就不会影响实参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">42</span>, i); <span class="comment">// f改变了实参i</span></span><br><span class="line">flip1(f, j, <span class="number">42</span>); <span class="comment">// 通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure><h5 id="定义能保持类型信息的函数参数"><a href="#定义能保持类型信息的函数参数" class="headerlink" title="定义能保持类型信息的函数参数"></a>定义能保持类型信息的函数参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/23/C-模板与泛型编程（二）/转发.png"><p>当 <code>flip2</code> 调用 <code>f</code> 时，<code>f</code> 中的引用参数 <code>v2</code> 被绑定到 <code>t1</code>，也就是绑定到 <code>j</code>，当 <code>f</code> 递增 <code>v2</code> 时，它同时改变了 <code>j</code> 的值。</p><p>上述 <code>flip2</code> 不能用于接受右值引用参数的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 <code>flip2</code> 调用 <code>g</code>，则参数 <code>t2</code> 将被传递给 <code>g</code> 的右值引用参数。即使我们传递一个右值给 <code>flip2</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flip2(g, i, <span class="number">42</span>); <span class="comment">// 函数参数为左值表达式，不能从一个左值实例化int&amp;&amp;</span></span><br></pre></td></tr></table></figure><h5 id="在调用中使用std-forward保持类型信息"><a href="#在调用中使用std-forward保持类型信息" class="headerlink" title="在调用中使用std::forward保持类型信息"></a>在调用中使用std::forward保持类型信息</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在头文件utility中，forward必须通过显式模板来调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; intermediary(Type &amp;&amp;arg)&#123;</span><br><span class="line">finalFcn(<span class="built_in">std</span>::forward&lt;Type&gt;(arg));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/23/C-模板与泛型编程（二）/forward.png"><p>重写翻转函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用 <code>flip(g, i, 42)</code>，<code>i</code> 将以 <code>int&amp;</code> 类型传递给 <code>g</code>，<code>42</code> 将以 <code>int&amp;&amp;</code> 类型传递给 <code>g</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;类型转换与模板类型参数&lt;/li&gt;
&lt;li&gt;函数模板显式实参&lt;/li&gt;
&lt;li&gt;尾置返回类型与类型转换&lt;/li&gt;
&lt;li&gt;函数指针和实参推断&lt;/li&gt;
&lt;li&gt;模板实参推断和引用&lt;/li&gt;
&lt;li&gt;理解 &lt;code&gt;std::move&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转发&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="泛型" scheme="http://www.xingyuzhao.ltd/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1052-爱生气的书店老板</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/23/LeetCode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/23/LeetCode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</id>
    <published>2021-02-23T07:12:44.000Z</published>
    <updated>2021-02-25T14:24:24.640Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><a id="more"></a><img src="/blog/2021/02/23/LeetCode1052-爱生气的书店老板/1052.png"><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>先求得原始条件下可获得的满意数量之和 <code>sum</code>；</li><li>维护一个长度为 <code>X</code> 的窗口，从 <code>customers</code> 起始位置开始滑动。先得到当前窗口原始条件下的满意总和，使用 <code>sum</code> 减去此和，再加上当前窗口顾客全部满意数的和；</li><li>更新最大满意数量 <code>ans = max(ans, sum)</code>。</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum_copy = sum;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = left + X;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; customers.size() + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> subSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grumpy[j] == <span class="number">0</span>)</span><br><span class="line">                    subSum += customers[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; subSum &lt;&lt; " ";</span></span><br><span class="line">            sum -= subSum;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">            sum += accumulate(customers.begin() + left, customers.begin() + right, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">            ans = max(sum, ans);</span><br><span class="line">            sum = sum_copy;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度很高，为 $O((2X)^n)$。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>在求得原始条件下可获得的满意数量之和 <code>sum</code>，同时将不生气时顾客的满意值置为 0 后，此时题目转换为：在修改后的 <code>customers</code> 数组中，长度为 <code>X</code> 的子数组的最大的和为多少？找的这个最大值再加上 <code>sum</code> 即可。时间复杂度为 $O(n)$。</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(X == customers.size()) <span class="keyword">return</span> accumulate(customers.begin(), customers.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += customers[i];</span><br><span class="line">                customers[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> subSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; ++i)</span><br><span class="line">            subSum += customers[i];</span><br><span class="line">        <span class="keyword">int</span> maxVal = subSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = X; i &lt; customers.size(); ++i)&#123;</span><br><span class="line">            subSum -= customers[i - X];</span><br><span class="line">            subSum += customers[i];</span><br><span class="line">            maxVal = max(maxVal, subSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum + maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>评论区：<a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/grumpy-bookstore-owner/comments/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;今天，书店老板有一家店打算试营业 &lt;code&gt;customers.length&lt;/code&gt; 分钟。每分钟都有一些顾客（&lt;code&gt;customers[i]&lt;/code&gt;）会进入书店，所有这些顾客都会在那一分钟结束后离开。&lt;/p&gt;
&lt;p&gt;在某些时候，书店老板会生气。 如果书店老板在第 &lt;code&gt;i&lt;/code&gt; 分钟生气，那么 &lt;code&gt;grumpy[i] = 1&lt;/code&gt;，否则 &lt;code&gt;grumpy[i] = 0&lt;/code&gt;。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。&lt;/p&gt;
&lt;p&gt;书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 &lt;code&gt;X&lt;/code&gt; 分钟不生气，但却只能使用一次。&lt;/p&gt;
&lt;p&gt;请你返回这一天营业下来，最多有多少客户能够感到满意的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://www.xingyuzhao.ltd/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>C++模板与泛型编程（一）——定义模板</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/22/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/22/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-22T09:01:08.000Z</published>
    <updated>2021-02-24T04:10:38.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>函数模板</li><li>类模板</li><li>模板参数</li><li>成员模板</li><li>控制实例化</li><li>效率与灵活性</li></ol><a id="more"></a><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模板定义中，模板参数列表不能为空。</p><h5 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h5><p>编译器用推断处的模板参数来进行<strong>实例化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化出int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// T为int</span></span><br></pre></td></tr></table></figure><h5 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h5><p>类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</p><p>类型参数前必须使用关键字 <code>class</code> 或 <code>typename</code>，两个关键字含义相同，可以互相使用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, class U&gt; calc(const T&amp;, const U&amp;);</span><br></pre></td></tr></table></figure><h5 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h5><p>一个非类型参数表示一个值而非一个类型。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用此函数 <code>compare(&quot;hi&quot;, &quot;mom&quot;)</code> 时，编译器使用字面常量的大小来代替 N 和 M，从而实例化模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[<span class="number">3</span>], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure><p><strong>非类型模板参数的模板实参必须是常量表达式</strong>。</p><h5 id="inline和constexpr的函数模板"><a href="#inline和constexpr的函数模板" class="headerlink" title="inline和constexpr的函数模板"></a>inline和constexpr的函数模板</h5><p>注意位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h5><p>模板的头文件通常既包括声明也包括定义。</p><ul><li>函数模板和类模板成员函数的定义通常放在头文件中。</li></ul><img src="/blog/2021/02/22/C-模板与泛型编程（一）/模板和头文件.png"><h5 id="大多数编译错误在实例化期间报告"><a href="#大多数编译错误在实例化期间报告" class="headerlink" title="大多数编译错误在实例化期间报告"></a>大多数编译错误在实例化期间报告</h5><img src="/blog/2021/02/22/C-模板与泛型编程（一）/调用者责任.png"><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><h5 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Blob之前只针对string</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h5><p>当使用一个类模板时，必须提供额外信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia; <span class="comment">// 空Blob&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>对我们指定的每一种元素类型，编译器都生成一个不同的类。</p><img src="/blog/2021/02/22/C-模板与泛型编程（一）/类模板的实例.png"><h5 id="在模板作用域中引用模板类型"><a href="#在模板作用域中引用模板类型" class="headerlink" title="在模板作用域中引用模板类型"></a>在模板作用域中引用模板类型</h5><p>通常将模板自己的参数当作被使用模板的参数。</p><h5 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h5><p>定义在类模板之外的成员函数必须以关键字 <code>template</code> 开始，后接类模板参数列表。</p><h5 id="类模板成员函数的实例化"><a href="#类模板成员函数的实例化" class="headerlink" title="类模板成员函数的实例化"></a>类模板成员函数的实例化</h5><p>成员函数只有在被用到时才进行实例化。</p><img src="/blog/2021/02/22/C-模板与泛型编程（一）/类模板成员函数实例.png"><h5 id="在类代码内简化模板类名的使用"><a href="#在类代码内简化模板类名的使用" class="headerlink" title="在类代码内简化模板类名的使用"></a>在类代码内简化模板类名的使用</h5><p>在类模板自己的作用域中，可以直接使用模板名而不提供实参。</p><h5 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h5><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。</p><h5 id="令模板自己的类型参数成为友元"><a href="#令模板自己的类型参数成为友元" class="headerlink" title="令模板自己的类型参数成为友元"></a>令模板自己的类型参数成为友元</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> Type; <span class="comment">// 将访问权限授予用来实例化Bar的类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如，对于某个类型名 <code>Foo</code>，<code>Foo</code> 将成为 <code>Bar&lt;Foo&gt;</code> 的友元。</p><h5 id="模板类型别名"><a href="#模板类型别名" class="headerlink" title="模板类型别名"></a>模板类型别名</h5><p>实例化的模板版本可以使用类型别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br></pre></td></tr></table></figure><p>新标准下，可以对类模板定义一个类型别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors; <span class="comment">// authors是一个pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure><h5 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个 <code>Foo</code> 实例都有自己的 <code>static</code> 成员实例，所有的 <code>Foo&lt;X&gt;</code> 类型的对象共享相同的 <code>ctr</code> 对象和 <code>count</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有三个对象共享相同的Foo&lt;int&gt;::ctr和Foo&lt;int&gt;::count成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2, fi3;</span><br></pre></td></tr></table></figure><p><strong>一个 static 成员函数只有在使用时才会实例化</strong>。</p><h4 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h4><h5 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h5><p>模板参数遵循普通的作用域规则。</p><h5 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h5><p>声明必须包括模板参数。且声明中的模板参数名字不必与定义中相同。</p><h5 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h5><p>假设 T 是一个模板参数类型，编译器遇到 <code>T::mem</code> 时不知道 <code>mem</code> 是一个类型成员还是一个 <code>static</code> 数据成员，直至实例化时才知道。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个p变量 or 一个名为size_type的static数据成员与变量p相乘</span></span><br><span class="line"><span class="comment">// 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型</span></span><br><span class="line">T::size_type * p;</span><br></pre></td></tr></table></figure><p>如果希望使用一个模板类型参数的类型成员，必须显示的告诉编译器该名字是一个类型，使用关键字 <code>typename</code> 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp;c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!c.empty())</span><br><span class="line"><span class="keyword">return</span> c.back();</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>top</code> 函数期待一个容器类型的实参，使用 <code>typename</code> 指明其返回类型并在 <code>c</code> 空时生成一个值初始化的元素返回给调用者。</p><img src="/blog/2021/02/22/C-模板与泛型编程（一）/名字表示类型.png"><h5 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="默认模板实参"></a>默认模板实参</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare有一个默认模板实参less&lt;T&gt;和一个默认函数实参F()</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = F())&#123;</span><br><span class="line"><span class="keyword">if</span>(f(v1, v2)) <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(f(v2,v1))) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>F</code> 为可调用对象的类型，新的函数参数 <code>f</code> 绑定到一个可调用对象上。</p><h5 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt; <span class="title">class</span> <span class="title">Numbers</span>&#123;</span> <span class="comment">// T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Numbers(T v = <span class="number">0</span>): val(v);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure><h4 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h4><h5 id="普通类的成员模板"><a href="#普通类的成员模板" class="headerlink" title="普通类的成员模板"></a>普通类的成员模板</h5><p>成员模板以模板参数列表开始。</p><h5 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h5><p>同时提供类模板和成员模板的参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。</p><h5 id="实例化与成员模板"><a href="#实例化与成员模板" class="headerlink" title="实例化与成员模板"></a>实例化与成员模板</h5><p>实例化一个类模板的成员模板，必须同时提供类和函数模板的实参。</p><h4 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h4><p>相同的实例可能出现在多个对象文件中，造成额外的开销。新标准中通过<strong>显示实例化</strong>来避免这种开销：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure><p><code>declaration</code> 是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span> <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure><p>当编译器遇到 <code>extern</code> 模板声明时，它不会再本文件中生成实例化代码。将一个实例化声明为 <code>extern</code> 就表示承诺在程序的其他位置有该实例化的一个非 <code>extern</code> 声明。对于一个给定的实例化版本，可能有多个 <code>extern</code> 声明，但必须只有一个定义。</p><h5 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h5><img src="/blog/2021/02/22/C-模板与泛型编程（一）/实例化定义会实例化所有成员.png"><h4 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h4><p>通过<strong>在编译时绑定删除器</strong>， <code>unique_ptr</code> 避免了间接调用删除器的运行时开销。通过<strong>在运行时绑定删除器</strong>，<code>shared_ptr</code> 使用户重载删除器更为方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;函数模板&lt;/li&gt;
&lt;li&gt;类模板&lt;/li&gt;
&lt;li&gt;模板参数&lt;/li&gt;
&lt;li&gt;成员模板&lt;/li&gt;
&lt;li&gt;控制实例化&lt;/li&gt;
&lt;li&gt;效率与灵活性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="泛型" scheme="http://www.xingyuzhao.ltd/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1004-最大连续1的个数Ⅲ</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/19/LeetCode1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/19/LeetCode1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%A2/</id>
    <published>2021-02-19T06:26:39.000Z</published>
    <updated>2021-02-19T06:39:45.159Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>，我们最多可以将 <code>K</code> 个值从 0 变成 1 。</p><p>返回仅包含 1 的最长（连续）子数组的长度。</p><a id="more"></a><img src="/blog/2021/02/19/LeetCode1004-最大连续1的个数Ⅲ/1004.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用指针 <code>left</code> 表示当前的<strong>连续 1 的子数组</strong>的左端点，<code>right</code> 指针表示当前的<strong>连续1的子数组</strong>的右端点。</p><ul><li>如果 <code>A[right]</code> 为 0，并且此时 K 不为零，说明当前元素可以由 0 变为 1，并将次数减 1；</li><li>如果 <code>A[right]</code> 为 0，并且此时 K 为零，说明当前元素不可以由 0 变为 1，并且需要将窗口左端点右移：<ul><li>如果 <code>A[left]</code> 为 0，说明用使用过一次从 0 到 1。此时需要将这次值的改变“回收”，即 K++；</li><li>更新滑动窗口的最大长度，同时将左端点右移。</li></ul></li><li>如果 <code>A[right]</code> 为 0，右端点右移即可。</li></ul><p>最后一个连续 1 的子数组可能没被统计，所以需要再更新一次窗口最大长度。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; A.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[right] == <span class="number">1</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[right] == <span class="number">0</span> &amp;&amp; K != <span class="number">0</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                K--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[right] == <span class="number">0</span> &amp;&amp; K == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[left] == <span class="number">0</span>) K++;</span><br><span class="line">                ans = max(ans, right - left);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; ans &lt;&lt; " ";</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(right - left, ans); <span class="comment">// 最后一个值为1</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个由若干 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 组成的数组 &lt;code&gt;A&lt;/code&gt;，我们最多可以将 &lt;code&gt;K&lt;/code&gt; 个值从 0 变成 1 。&lt;/p&gt;
&lt;p&gt;返回仅包含 1 的最长（连续）子数组的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://www.xingyuzhao.ltd/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象程序设计（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/12/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/12/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-12T04:45:27.000Z</published>
    <updated>2021-02-25T14:21:02.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>抽象基类</li><li>访问控制与继承</li><li>继承中的类作用域</li><li>构造函数与拷贝控制</li></ol><a id="more"></a><h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p>含有（或者未经覆盖直接继承？）纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。</p><p>在函数体的位置（即声明语句的分号之前）书写 = 0 就可以将一个虚函数说明为纯虚函数。</p><h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><h5 id="受保护的成员protected"><a href="#受保护的成员protected" class="headerlink" title="受保护的成员protected"></a>受保护的成员protected</h5><ul><li>和私有成员类似，受保护的成员对类的用户是不可访问的。</li><li>和公有成员类似，受保护的成员对于派生类的成员和友元来说可访问。</li></ul><p>除此之外：</p><p><strong>派生类的成员和友元只能通过派生类对象来访问基类的受保护成员，而不能访问基类对象中的受保护成员。</strong></p><h5 id="公有、私有和受保护继承"><a href="#公有、私有和受保护继承" class="headerlink" title="公有、私有和受保护继承"></a>公有、私有和受保护继承</h5><img src="/blog/2021/02/12/C-面向对象程序设计（二）/继承1.png" style="zoom:67%;"><img src="/blog/2021/02/12/C-面向对象程序设计（二）/继承2.png" style="zoom:67%;"><img src="/blog/2021/02/12/C-面向对象程序设计（二）/继承3.png" style="zoom:67%;"><p>某个类对其继承而来的成员的访问权限受两个因素影响：</p><ol><li>基类中该成员的访问说明符；</li><li>派生类在派生列表中的访问说明符。</li></ol><p><strong>派生类访问说明符对派生类的成员及友元能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。</strong></p><p><strong>派生类访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限</strong>。</p><img src="/blog/2021/02/12/C-面向对象程序设计（二）/类的设计与受保护的成员.png"><h5 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h5><p>友元关系不能<strong>传递或继承</strong>，每个类负责控制各自成员的访问权限。</p><h5 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h5><p>使用 <code>using</code> 声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Derived的用户可以使用size成员</span></span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Derived的派生类可以使用n</span></span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的内部使用 <code>using </code>声明语句，将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。</p><ul><li><p>如果一条 <code>using</code> 声明语句出现在类的 <code>private</code> 部分,则该名字只能被类的成员和友元访问；</p></li><li><p>如果 <code>using</code> 声明语句位于 <code>public</code> 部分，则类的所有用户都能访问它；</p></li><li><p>如果 <code>using</code> 声明语句位于 <code>protected</code> 部分，则该名字对于成员、友元和派生类是可访问的。</p></li></ul><h5 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h5><p>默认情况下，使用 <code>class</code> 关键字定义的派生类是私有继承的；而使用 <code>struct</code> 关键字定义的派生类是公有继承的。</p><h4 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h4><h5 id="在编译时进行名字查找"><a href="#在编译时进行名字查找" class="headerlink" title="在编译时进行名字查找"></a>在编译时进行名字查找</h5><h5 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h5><p>派生类的成员将隐藏同名的基类成员。</p><h5 id="通过作用域运算符来使用隐藏的成员"><a href="#通过作用域运算符来使用隐藏的成员" class="headerlink" title="通过作用域运算符来使用隐藏的成员"></a>通过作用域运算符来使用隐藏的成员</h5><p>我们可以通过作用域运算符来使用一个被隐藏的基类成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base::mem; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/12/C-面向对象程序设计（二）/名字重用.png"><img src="/blog/2021/02/12/C-面向对象程序设计（二）/名字查找与继承.png" style="zoom:80%;"><h5 id="名字查找先于类型检查"><a href="#名字查找先于类型检查" class="headerlink" title="名字查找先于类型检查"></a>名字查找先于类型检查</h5><h5 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h5><p>基类与派生类中的虚函数必须有相同的形参列表。</p><h4 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h4><h5 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h5><p>基类通常应该定义一个虚析构函数。如果基类的析构函数不是虚函数，则 <code>delete</code> 一个指向派生类对象的基类指针将产生未定义的行为。</p><p><strong>虚析构函数将阻止合成移动操作</strong>。</p><h5 id="合成拷贝控制和继承"><a href="#合成拷贝控制和继承" class="headerlink" title="合成拷贝控制和继承"></a>合成拷贝控制和继承</h5><p>合成的成员负责使用<strong>直接基类</strong>中对应的操作对一个对象的<strong>直接基类部分</strong>进行初始化、赋值或销毁的操作。</p><h5 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h5><img src="/blog/2021/02/12/C-面向对象程序设计（二）/派生类的拷贝控制成员.png"><h6 id="定义派生类的拷贝或移动构造函数"><a href="#定义派生类的拷贝或移动构造函数" class="headerlink" title="定义派生类的拷贝或移动构造函数"></a>定义派生类的拷贝或移动构造函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">D(<span class="keyword">const</span> D&amp; d): Base(d) <span class="comment">// 拷贝基类成员</span></span><br><span class="line"><span class="comment">/* D的成员的初始值 */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">D(D&amp;&amp; d): Base(<span class="built_in">std</span>::move(d)) <span class="comment">// 移动基类成员</span></span><br><span class="line"><span class="comment">/* D的成员的初始值 */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/12/C-面向对象程序设计（二）/派生类的拷贝或移动构造函数.png"><h6 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base::operator=(const Base&amp;) 不会被自动调用</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)&#123;</span><br><span class="line">Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// 为基类部分赋值</span></span><br><span class="line"><span class="comment">// 为派生类的成员赋值</span></span><br><span class="line"><span class="comment">// 处理自赋值及释放已有资源等</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Base::Base 被自动调用执行</span></span><br><span class="line">~D() &#123; <span class="comment">/* 用户定义清楚派生类成员的操作 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派生类的析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。</p><h6 id="在构造函数和析构函数中调用虚函数"><a href="#在构造函数和析构函数中调用虚函数" class="headerlink" title="在构造函数和析构函数中调用虚函数"></a>在构造函数和析构函数中调用虚函数</h6><img src="/blog/2021/02/12/C-面向对象程序设计（二）/在构造函数和析构函数中调用虚函数.png"><h5 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h5><p>使用 <code>using</code> 声明语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Disc_quote::Disc_quote; <span class="comment">// 继承Disc_quote的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数</span></span><br><span class="line">derived(parms) : base(args) &#123; &#125;</span><br></pre></td></tr></table></figure><h6 id="继承的构造函数特点"><a href="#继承的构造函数特点" class="headerlink" title="继承的构造函数特点"></a>继承的构造函数特点</h6><p>与普通成员的 <code>using</code> 声明不同，一个构造函数的 <code>using</code> 声明不会改变该构造函数的访问级别。</p><p><code>using</code> 声明语句不能指定 <code>explicit</code> 或 <code>constexpr</code>。</p><p><strong>当一个基类构造函数含有默认实参时，这些实参并不会被继承</strong>。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p><p>例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：</p><ol><li><p>构造函数接受两个形参（没有默认实参），<strong>此时并未省略掉一个形参？</strong>；</p></li><li><p>构造函数只接受一个形参，它对应于基类中最左侧的<strong>没有默认值</strong>的那个形参。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;抽象基类&lt;/li&gt;
&lt;li&gt;访问控制与继承&lt;/li&gt;
&lt;li&gt;继承中的类作用域&lt;/li&gt;
&lt;li&gt;构造函数与拷贝控制&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="面向对象" scheme="http://www.xingyuzhao.ltd/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>2021，新年快乐！</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/12/2021%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/12/2021%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/</id>
    <published>2021-02-12T04:36:12.000Z</published>
    <updated>2021-02-12T04:47:46.305Z</updated>
    
    <content type="html"><![CDATA[<p>祝大家新年快乐，心想事成，牛年吉祥！</p><p>2021，新的一年，机遇与挑战并存。</p><p><strong>抓住机遇，迎接挑战！</strong>                                                    </p><p>​                        </p><p>​                                                                                          赵星宇</p><p>​                                                                                 2021.2.12  大年初一</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;祝大家新年快乐，心想事成，牛年吉祥！&lt;/p&gt;
&lt;p&gt;2021，新的一年，机遇与挑战并存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓住机遇，迎接挑战！&lt;/strong&gt;                                                    &lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++面向对象程序设计（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/08/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/08/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-08T14:19:04.000Z</published>
    <updated>2021-02-25T14:21:10.750Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>OOP：概述</li><li>定义基类和派生类</li><li>虚函数</li></ol><a id="more"></a><h4 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h4><p>面向对象程序设计的核心思想是<strong>数据抽象、继承和动态绑定</strong>。</p><p><strong>OOP</strong> 三大特征为：<strong>封装、继承、多态</strong>。</p><p>数据抽象：将类的接口与实现分离。</p><p>继承：可以定义相似的类型并对其相似关系建模。</p><p>动态绑定：在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象。</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>通过<strong>继承</strong>联系在一起的类构成一种层次关系。层次关系的根部有一个<strong>基类</strong>，负责定义层次关系中所有类共同拥有的成员。通过从基类继承得到的类称为<strong>派生类</strong>，每个派生类定义各自特有的成员。</p><p>如果某些函数基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派生类必须通过使用<strong>类派生列表</strong>明确指出它是从哪个（哪些）基类继承而来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++11 新标准允许派生类显式的注明它将使用哪个成员函数改写基类的虚函数，在该函数形参列表之后增加一个 <code>override</code> 关键字即可</strong>。而不用在函数前加上 <code>virtual</code> 关键字。</p><h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p>也称为<strong>运行时绑定</strong>，在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。</p><h4 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h4><h5 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h5><p>基类通常都需要定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p><h6 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h6><p>基类必须将它得两种成员函数区分开来：</p><ol><li>基类希望其派生类进行覆盖的函数，将其定义为虚函数。<ul><li>当使用指针或引用调用虚函数时，该调用将被动态绑定。</li><li>如果基类把一个函数声明为虚函数，则该函数的派生类中隐式的也是虚函数。</li></ul></li><li>基类希望直接继承而不需要改变的类。</li></ol><h6 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h6><p>派生类可以访问基类的公有成员。如果基类希望派生类可以访问成员，并且该成员禁止其他用户访问，这种成员应定义为<strong>受保护的（protected）</strong>。</p><h5 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h5><p>通过<strong>类派生列表</strong>，形式为：首先是一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前可以有：<code>public</code>、<code>protected</code> 或 <code>private</code> 中的一个。</p><h6 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h6><h6 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h6><p>可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；也可以把派生类对象的指针用在需要基类指针的地方。</p><h6 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h6><p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc): </span><br><span class="line">Quote(book, p), min_qty(qty), discount(disc) &#123; &#125;</span><br></pre></td></tr></table></figure><h6 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h6><img src="/blog/2021/02/08/C-面向对象程序设计（一）/遵循基类的接口.png"><h6 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h6><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p><h6 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h6><p>声明中包含类名但不包含它的派生列表。</p><h6 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h6><p>如果要将某个类用作基类，则该类必须已经定义而非仅仅声明。</p><h6 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h6><p>C++11 新标准提供关键字 <code>final</code> 防止继承发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> &#123;</span> <span class="comment">/* */</span> &#125;; <span class="comment">// NoDerived 不能作为基类</span></span><br></pre></td></tr></table></figure><h5 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h5><p>当使用基类的引用（或指针）时，实际上我们并不知道该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p><h6 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h6><p>静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。</p><h6 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h6><h6 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h6><p>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。</p><img src="/blog/2021/02/08/C-面向对象程序设计（一）/在对象之间不存在类型转换_note.png"><h6 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h6><img src="/blog/2021/02/08/C-面向对象程序设计（一）/转换规则.png"><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>无论是否被用到，每个虚函数都需要定义。</p><h5 id="对虚函数的调用可能运行时才被解析"><a href="#对虚函数的调用可能运行时才被解析" class="headerlink" title="对虚函数的调用可能运行时才被解析"></a>对虚函数的调用可能运行时才被解析</h5><p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。</p><h5 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h5><img src="/blog/2021/02/08/C-面向对象程序设计（一）/多态性.png"><h5 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h5><p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则<strong>它的形参类型必须与它覆盖的基类函数完全一致</strong>。一般来说，返回类型也应该一致，除非类的虚函数返回类型是类本身的指针或引用。</p><h5 id="final-和-override-说明符"><a href="#final-和-override-说明符" class="headerlink" title="final 和 override 说明符"></a>final 和 override 说明符</h5><p>如果使用 <code>override</code> 标记了某个函数，但是该函数并没有覆盖已存在的虚函数，此时编译器将报错。</p><p>如果将某个函数指定为 <code>final</code>，则之后任何尝试覆盖该函数的操作都将引发错误。</p><p>上述两个函数出现在形参列表（包括任何 <code>const</code> 或引用修饰符）以即尾置返回类型之后。</p><h5 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h5><p>如果某次函数调用使用了默认实参， 则该实参值由本次调用的静态类型决定。</p><p>如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参。</p><img src="/blog/2021/02/08/C-面向对象程序设计（一）/虚函数与默认实参.png"><h5 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h5><p>通常当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，需要回避虚函数机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强行调用基类中定义的函数版本而不管 baseP 的动态类型到底是什么</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/08/C-面向对象程序设计（一）/回避虚函数机制.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;OOP：概述&lt;/li&gt;
&lt;li&gt;定义基类和派生类&lt;/li&gt;
&lt;li&gt;虚函数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="面向对象" scheme="http://www.xingyuzhao.ltd/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode978-最长湍流子数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/08/LeetCode978-%E6%9C%80%E9%95%BF%E6%B9%8D%E6%B5%81%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/08/LeetCode978-%E6%9C%80%E9%95%BF%E6%B9%8D%E6%B5%81%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2021-02-08T03:14:38.000Z</published>
    <updated>2021-02-08T03:44:36.040Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>当 <code>A</code> 的子数组 <code>A[i], A[i+1], ..., A[j]</code> 满足下列条件时，我们称其为湍流子数组：</p><p>若 <code>i &lt;= k &lt; j</code>，当 <code>k</code> 为奇数时， <code>A[k] &gt; A[k+1]</code>，且当 <code>k</code> 为偶数时，<code>A[k] &lt; A[k+1]</code>；<br>或 若 <code>i &lt;= k &lt; j</code>，当 <code>k</code> 为偶数时，<code>A[k] &gt; A[k+1]</code> ，且当 <code>k</code> 为奇数时， <code>A[k] &lt; A[k+1]</code>。<br>也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。</p><p>返回 A 的最大湍流子数组的<strong>长度</strong>。</p><a id="more"></a><img src="/blog/2021/02/08/LeetCode978-最长湍流子数组/978.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果当前值同时小于其前一个值和后一个值，或者当前值同时大于其前一个值和后一个值，说明这三个元素可以构成湍流数组。</p><p>当无法构成湍流数组时，更新起始位置，并且更新最长长度。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="number">0</span>] == arr[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i - <span class="number">1</span>] &amp;&amp; arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>] &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] != arr[i - <span class="number">1</span>]) ans = max(ans, i + <span class="number">1</span> - start);</span><br><span class="line">                <span class="keyword">else</span> ans = max(ans, i - start);</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="comment">// 遍历最后一组元素处恰好能截取最后一个湍流数组</span></span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">2</span>) flag = <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在末尾未截取湍流数组，表示还存在最后一个湍流数组</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) ans = max(ans, len - start);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>一种动态规划的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(arr.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">down</span><span class="params">(arr.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">                up[i] = down[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])&#123;</span><br><span class="line">                down[i] = up[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, max(up[i], down[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/solution/yi-zhang-dong-tu-xiang-jie-dong-tai-gui-wrwvn/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-turbulent-subarray/solution/yi-zhang-dong-tu-xiang-jie-dong-tai-gui-wrwvn/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;当 &lt;code&gt;A&lt;/code&gt; 的子数组 &lt;code&gt;A[i], A[i+1], ..., A[j]&lt;/code&gt; 满足下列条件时，我们称其为湍流子数组：&lt;/p&gt;
&lt;p&gt;若 &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt;，当 &lt;code&gt;k&lt;/code&gt; 为奇数时， &lt;code&gt;A[k] &amp;gt; A[k+1]&lt;/code&gt;，且当 &lt;code&gt;k&lt;/code&gt; 为偶数时，&lt;code&gt;A[k] &amp;lt; A[k+1]&lt;/code&gt;；&lt;br&gt;或 若 &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt;，当 &lt;code&gt;k&lt;/code&gt; 为偶数时，&lt;code&gt;A[k] &amp;gt; A[k+1]&lt;/code&gt; ，且当 &lt;code&gt;k&lt;/code&gt; 为奇数时， &lt;code&gt;A[k] &amp;lt; A[k+1]&lt;/code&gt;。&lt;br&gt;也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。&lt;/p&gt;
&lt;p&gt;返回 A 的最大湍流子数组的&lt;strong&gt;长度&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode665-非递减序列</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/07/LeetCode665-%E9%9D%9E%E9%80%92%E5%87%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/07/LeetCode665-%E9%9D%9E%E9%80%92%E5%87%8F%E5%BA%8F%E5%88%97/</id>
    <published>2021-02-07T08:58:26.000Z</published>
    <updated>2021-02-07T15:36:04.385Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个长度为 <code>n</code> 的整数数组，请你判断在 <strong>最多</strong> 改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中所有的 <code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p><a id="more"></a><img src="/blog/2021/02/07/LeetCode665-非递减序列/665.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>记当前遍历到的位置为 <code>i</code>， 如果 <code>nums[i] &lt; nums[i - 1]</code>，此时需要修改数组：</p><ul><li>如果 <code>nums[i] &gt;= nums[i - 2]</code> ，说明需要将 <code>nums[i - 1]</code> 改小，为了方便起见，令 <code>nums[i - 1] = nums[i]</code>；</li><li>否则，说明需要将 <code>nums[i]</code> 改大，令 <code>nums[i] = nums[i - 1]</code>。</li></ul><p>对于 <code>i = 1</code> 时 <code>nums[i] &lt; nums[i - 1]</code>，应将 <code>nums[i - 1]</code> 改小，令<code>nums[i - 1] = nums[i]</code>，这样做的目的是<strong>使已遍历的序列尽可能的小，减小修改次数</strong>。比如 <code>2,1,1</code>，如果修改为 <code>2,2,1</code>，那么就不能一次修改得到非递减序列；修改为 <code>1,1,1</code>即可。</p><p>修改的同时进行计数，计数必须小于等于 1。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; nums[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span> || nums[i] &gt;= nums[i - <span class="number">2</span>])&#123;</span><br><span class="line">                    nums[i - <span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://leetcode-cn.com/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组，请你判断在 &lt;strong&gt;最多&lt;/strong&gt; 改变 &lt;code&gt;1&lt;/code&gt; 个元素的情况下，该数组能否变成一个非递减数列。&lt;/p&gt;
&lt;p&gt;我们是这样定义一个非递减数列的： 对于数组中所有的 &lt;code&gt;i&lt;/code&gt; &lt;code&gt;(0 &amp;lt;= i &amp;lt;= n-2)&lt;/code&gt;，总满足 &lt;code&gt;nums[i] &amp;lt;= nums[i + 1]&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周赛-227</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/07/LeetCode%E5%91%A8%E8%B5%9B-227/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/07/LeetCode%E5%91%A8%E8%B5%9B-227/</id>
    <published>2021-02-07T08:57:53.000Z</published>
    <updated>2021-02-07T12:39:25.726Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li>检查数组能否经排序和轮转得到</li><li>移除石子的最大得分</li><li>构造字典序最大的合并字符串</li><li>最接近目标值的子序列和</li></ol><a id="more"></a><h4 id="检查数组能否经排序和轮转得到"><a href="#检查数组能否经排序和轮转得到" class="headerlink" title="检查数组能否经排序和轮转得到"></a>检查数组能否经排序和轮转得到</h4><p>给你一个数组 <code>nums</code> 。<code>nums</code> 的源数组中，所有元素与 <code>nums</code> 相同，但按非递减顺序排列。</p><p>如果 <code>nums</code> 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>源数组中可能存在 <strong>重复项</strong> 。</p><p>注意：我们称数组 <code>A</code> 在轮转 <code>x</code> 个位置后得到长度相同的数组 <code>B</code> ，当它们满足 <code>A[i] == B[(i+x) % A.length]</code> ，其中 % 为取余运算。</p><h5 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h5><p>根据已有等式，从 0 开始递增 <code>x</code>，如果轮转 <code>x</code> 后可以从 <code>A</code> 得到 <code>B</code>，返回 <code>true</code>，否则返回 <code>false</code>。如果数组长度很大，则时间复杂度会很高。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> buf = nums;</span><br><span class="line">        sort(buf.begin(), buf.end());</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; len)&#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] != buf[(i + x) % len])&#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h5><p>如果出现 <code>nums[i] &gt; nums[(i + 1) % n]</code> ，表示找到了一个轮转位置，如果最终找到的轮转位置数不大于 1，说明可以轮转。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[(i + <span class="number">1</span>) % n])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="移除石子的最大得分"><a href="#移除石子的最大得分" class="headerlink" title="移除石子的最大得分"></a>移除石子的最大得分</h4><p>你正在玩一个单人游戏，面前放置着大小分别为 <code>a</code>、<code>b</code> 和 <code>c</code> 的 <strong>三堆</strong> 石子。</p><p>每回合你都要从两个 <strong>不同的非空堆</strong> 中取出一颗石子，并在得分上加 <code>1</code> 分。当存在 <strong>两个或更多</strong> 的空堆时，游戏停止。</p><p>给你三个整数 <code>a</code> 、<code>b</code> 和 <code>c</code> ，返回可以得到的 <strong>最大分数</strong> 。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul><li>较小的两个值之和等于较大的值，此时最多得 <strong>较大值</strong> 的分数；</li><li>较小的两个值之和大于较大的值，此时最多得分为： <strong>较大值</strong> 的分数加 <strong>较小值之和的一半</strong> 的分数之和；</li><li>较小的两个值之和小于较大的值，此时最多得 <strong>较小值之和</strong> 的分数；</li></ul><p>情况①：较小的两个值之和等于较大的值</p><p>两个较小值可以将较大值<strong>一一抵消</strong>。</p><p>情况②：较小的两个值之和大于较大的值</p><p>除了较大的值可以将两个较小的值抵消一部份外，剩下的两个较小值需要<strong>尽可能平分抵消后剩下的石子</strong>，目的是可以最大程度的拿掉更多的石子。这样做还可以获得的分数为<strong>抵消后两者之和的一半</strong>。</p><p>情况③：较小的两个值之和小于较大的值</p><p>那么较大的值最多可以将较小的两个值<strong>全部抵消</strong>。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;a, b, c&#125;;</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">if</span>(vec[<span class="number">0</span>] + vec[<span class="number">1</span>] == vec[<span class="number">2</span>]) <span class="keyword">return</span> vec[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vec[<span class="number">0</span>] + vec[<span class="number">1</span>] &gt; vec[<span class="number">2</span>]) <span class="keyword">return</span> vec[<span class="number">2</span>] + (vec[<span class="number">0</span>] + vec[<span class="number">1</span>] - vec[<span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> vec[<span class="number">0</span>] + vec[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造字典序最大的合并字符串"><a href="#构造字典序最大的合并字符串" class="headerlink" title="构造字典序最大的合并字符串"></a>构造字典序最大的合并字符串</h4><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。你需要按下述方式构造一个新字符串 <code>merge</code> ：如果 <code>word1</code> 或 <code>word2</code> 非空，选择 <strong>下面选项之一</strong> 继续操作：</p><p>如果 <code>word1</code> 非空，将 <code>word1</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word1</code> 中移除。<br>例如，<code>word1 = &quot;abc&quot;</code> 且 <code>merge = &quot;dv&quot;</code> ，在执行此选项操作之后，<code>word1 = &quot;bc&quot;</code> ，同时 <code>merge = &quot;dva&quot;</code> 。<br>如果 <code>word2</code> 非空，将 <code>word2</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word2</code> 中移除。<br>例如，<code>word2 = &quot;abc&quot;</code> 且 <code>merge = &quot;&quot;</code> ，在执行此选项操作之后，<code>word2 = &quot;bc&quot;</code> ，同时 <code>merge = &quot;a&quot;</code> 。<br>返回你可以构造的字典序 <strong>最大</strong> 的合并字符串 <code>merge</code> 。</p><p>长度相同的两个字符串 <code>a</code> 和 <code>b</code> 比较字典序大小，如果在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，<code>a</code> 中字符在字母表中的出现顺序位于 <code>b</code> 中相应字符之后，就认为字符串 <code>a</code> 按字典序比字符串 <code>b</code> 更大。例如，<code>&quot;abcd&quot;</code> 按字典序比 <code>&quot;abcc&quot;</code> 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 <code>d</code> 在字母表中的出现顺序位于 <code>c</code> 之后。</p><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>从 <code>word1</code> 和 <code>word2</code> 的首字符中挑选更大的一个加入到答案字符串中。如果字符相同，则比较两个字符串剩下的子串，选取字典序更大的一个字符串的首字符加入答案中，如果两者相等，则任取一个字符串中的首字符。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestMerge</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt; word1.size() &amp;&amp; index2 &lt; word2.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[index1] &gt; word2[index2])&#123;</span><br><span class="line">                ans += word1[index1];</span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(word1[index1] &lt; word2[index2])&#123;</span><br><span class="line">                ans += word2[index2];</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前字符相等，取字典序更大的子串中的第一个字符</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">string</span> word1Helper = word1.substr(index1, word1.size() - index1);</span><br><span class="line">                <span class="built_in">string</span> word2Helper = word2.substr(index2, word2.size() - index2);</span><br><span class="line">                <span class="keyword">if</span>(word1Helper &gt; word2Helper)&#123;</span><br><span class="line">                    ans += word1[index1++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(word1Helper &lt; word2Helper)&#123;</span><br><span class="line">                    ans += word2[index2++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果子串相等，任取一个字符</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += word1[index1++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index2 != word2.size()) ans += word2.substr(index2, word2.size() - index2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index1 != word1.size()) ans += word1.substr(index1, word1.size() - index1);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最接近目标值的子序列和"><a href="#最接近目标值的子序列和" class="headerlink" title="最接近目标值的子序列和"></a>最接近目标值的子序列和</h4><p>给你一个整数数组 <code>nums</code> 和一个目标值 <code>goal</code> 。</p><p>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 <code>sum</code> ，你需要 最小化绝对差 <code>abs(sum - goal)</code> 。</p><p>返回 <code>abs(sum - goal)</code> 可能的 最小值 。</p><h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><ol><li>将序列均分为两部分，分别求其相应的所有子集之和（这里使用<strong>位运算</strong>求子集）；</li><li>将其中的一个子集之和进行排序；</li><li>遍历另外一个子集之和，每个元素记为 <code>x</code>，求出每个 <code>goal - x</code>，在排好序的子集之和中进行二分查找，循环更新，找到差值绝对值的最小值。</li></ol><p>对于步骤 3：</p><p>设已排序数组元素为 <code>y</code>，未排序数组为 <code>x</code>，差值的绝对值为 <code>a</code>，则有：<br>$$<br>|goal - (x + y)|=a<br>$$<br>化简可得：<br>$$<br>goal - x = y + \pm a<br>$$<br>即：步骤 3 中找到的就是 <code>y</code>，找到后将其与 <code>goal - x</code> 作差，再取绝对值就是当前<strong>差值绝对值的最小值</strong>。</p><p>由于使用 <code>lower_bound</code> 查找的值不一定存在，需要比较 <code>goal - x</code> 与<strong>插入位置的值</strong>和<strong>插入位置之前的值</strong>的差值中哪个的绝对值更小一点；如果插入位置为起点或者末尾，则只需要与插入位置的值进行对比即可。以上都是更新差值绝对值的最小值：<br>$$<br>ans = min(ans, {待比较值})<br>$$<br><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="comment">// 分成两部分</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.begin(), nums.begin() + len / <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums2</span><span class="params">(nums.begin() + len / <span class="number">2</span>, nums.end())</span></span>;</span><br><span class="line">        <span class="comment">// 分别求和的子集</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum1;</span><br><span class="line">        subVecSum(nums1, sum1);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum2;</span><br><span class="line">        subVecSum(nums2, sum2);</span><br><span class="line">        sort(sum1.begin(), sum1.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : sum2)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = goal - x;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(sum1.begin(), sum1.end(), val);</span><br><span class="line">            <span class="comment">// 注意如何更新ans</span></span><br><span class="line">            <span class="keyword">if</span>(it == sum1.begin()) ans = min(ans, <span class="built_in">abs</span>(val - *it));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(it == sum1.end()) ans = min(ans, <span class="built_in">abs</span>(val - *--it));</span><br><span class="line">            <span class="keyword">else</span> ans = min(ans, min(<span class="built_in">abs</span>(val - *it), <span class="built_in">abs</span>(val - *--it)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subVecSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vecSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = vec.size();</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span> &lt;&lt; len;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(mask; mask &lt; end; ++mask)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; i) &amp; mask)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    sum += vec[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) vecSum.push_back(sum);</span><br><span class="line">            <span class="keyword">else</span> vecSum.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;检查数组能否经排序和轮转得到&lt;/li&gt;
&lt;li&gt;移除石子的最大得分&lt;/li&gt;
&lt;li&gt;构造字典序最大的合并字符串&lt;/li&gt;
&lt;li&gt;最接近目标值的子序列和&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode周赛" scheme="http://www.xingyuzhao.ltd/categories/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
      <category term="位运算" scheme="http://www.xingyuzhao.ltd/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="分治算法" scheme="http://www.xingyuzhao.ltd/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1423-可获得的最大点数</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/06/LeetCode1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/06/LeetCode1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/</id>
    <published>2021-02-06T12:41:49.000Z</published>
    <updated>2021-02-06T12:53:00.644Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p><a id="more"></a><img src="/blog/2021/02/06/LeetCode1423-可获得的最大点数/1423.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于每次都是从端点取数，所以取到的数是连续的（将数组首尾连接为一个循环数组）。</p><p>可以维护一个长度为 <code>n - k</code> 的窗口在 <code>cardPoints</code> 数组上滑动，当窗口内值的和最小时，剩下的 <code>k</code> 个数和最大，也就是可以获得的最大点数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cardPoints.size() == <span class="number">1</span>) <span class="keyword">return</span> cardPoints[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = cardPoints.size() - k;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(cardPoints.begin(), cardPoints.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> windowSum = accumulate(cardPoints.begin(), cardPoints.begin() + len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(right != cardPoints.size() - <span class="number">1</span>)&#123; <span class="comment">// 注意最后一次未比较</span></span><br><span class="line">            ans = max(ans, sum - windowSum);</span><br><span class="line">            windowSum -= cardPoints[left++];</span><br><span class="line">            windowSum += cardPoints[++right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一组窗口的和还没进行比较，这里需要再比较一次</span></span><br><span class="line">        ans = max(ans, sum - windowSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;几张卡牌 &lt;strong&gt;排成一行&lt;/strong&gt;，每张卡牌都有一个对应的点数。点数由整数数组 &lt;code&gt;cardPoints&lt;/code&gt; 给出。&lt;/p&gt;
&lt;p&gt;每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 &lt;code&gt;k&lt;/code&gt; 张卡牌。&lt;/p&gt;
&lt;p&gt;你的点数就是你拿到手中的所有卡牌的点数之和。&lt;/p&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;cardPoints&lt;/code&gt; 和整数 &lt;code&gt;k&lt;/code&gt;，请你返回可以获得的最大点数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://www.xingyuzhao.ltd/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1208-尽可能使字符串相等</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/05/LeetCode1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/05/LeetCode1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</id>
    <published>2021-02-05T06:51:59.000Z</published>
    <updated>2021-02-05T09:15:52.764Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p><p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p><p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p><a id="more"></a><img src="/blog/2021/02/05/LeetCode1208-尽可能使字符串相等/1208.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用一个变量 <code>cost</code> 记录当前子串的总消耗，<code>start</code> 和 <code>end</code> 分别为子串的起始位置和终点位置。如果此时：</p><ul><li><code>cost &gt; maxCost</code>，更新字符串的长度，选择之前子串与当前子串中长度更大的一个。同时从总消耗 <code>cost</code> 中减去当前子串起始位置 <code>start</code> 的消耗，并使起始位置 <code>start</code> 加 1。</li><li><code>cost &lt;= maxCost</code>，满足消耗要求时，使终点位置 <code>end</code> 加 1，同时加上此时 <code>end</code> 处的消耗。</li><li>循环上述步骤，直到 <code>end</code> 到达字符串尾。</li></ul><p>如果此时 <code>cost &lt;= maxCost</code>，说明还剩下最后一个子串消耗符合要求，选择<strong>此时的子串长度</strong>和<strong>之前子串长度最大值</strong>中较大的一个，即为答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="built_in">abs</span>(s[<span class="number">0</span>] - t[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; maxCost)&#123;</span><br><span class="line">                maxLen = max(maxLen, end - start);</span><br><span class="line">                cost -= <span class="built_in">abs</span>(t[start] - s[start]);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">            cost += <span class="built_in">abs</span>(t[end] - s[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cost &lt;= maxCost) <span class="keyword">return</span> max(end - start, maxLen);</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>一开始把题目想复杂了，导致这道题花了一个小时，还需要继续努力！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你两个长度相同的字符串，&lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;s&lt;/code&gt; 中的第 &lt;code&gt;i&lt;/code&gt; 个字符变到 &lt;code&gt;t&lt;/code&gt; 中的第 &lt;code&gt;i&lt;/code&gt; 个字符需要 &lt;code&gt;|s[i] - t[i]|&lt;/code&gt; 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。&lt;/p&gt;
&lt;p&gt;用于变更字符串的最大预算是 &lt;code&gt;maxCost&lt;/code&gt;。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。&lt;/p&gt;
&lt;p&gt;如果你可以将 &lt;code&gt;s&lt;/code&gt; 的子字符串转化为它在 &lt;code&gt;t&lt;/code&gt; 中对应的子字符串，则返回可以转化的最大长度。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;s&lt;/code&gt; 中没有子字符串可以转化成 &lt;code&gt;t&lt;/code&gt; 中对应的子字符串，则返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
