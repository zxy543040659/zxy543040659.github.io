<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2020-09-06T05:34:44.613Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并查集(Union Find)</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/09/06/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/09/06/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find/</id>
    <published>2020-09-06T02:47:39.000Z</published>
    <updated>2020-09-06T05:34:44.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h3><ol><li>并查集的基本概念及实现(Quick_Find/Quick_Union)</li><li>基于size优化与基于rank优化</li><li>路径压缩</li></ol><a id="more"></a><h3 id="并查集的基本概念及实现"><a href="#并查集的基本概念及实现" class="headerlink" title="并查集的基本概念及实现"></a>并查集的基本概念及实现</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>并查集是一种特殊的图，较图论而言要简单一些。对于图论来说，主要解决的问题是<strong>连接问题和路径问题</strong>，而并查集只是回答前者——连接问题。比如网络节点间的连接状态，数学中集合类的实现等。</p><p>并查集支持两个动作（合并两个节点，查询某个节点）：</p><ul><li>union(p, q)</li><li>find(p)</li></ul><p>用来回答一个问题（两个节点是否相连接）：</p><ul><li>isConnected(p, q)</li></ul><p>并查集可以用数组来表示，基本数据表示如下（0<del>4，5</del>9互相连接）：</p><table><thead><tr><th align="center"></th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><h4 id="基本实现-Quick-Find"><a href="#基本实现-Quick-Find" class="headerlink" title="基本实现(Quick_Find)"></a>基本实现(Quick_Find)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *id;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind1(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UnionFind1()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uoionElement</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pID = find(p);</span><br><span class="line">        <span class="keyword">int</span> qID = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pID == qID) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 让p指向q，复杂度O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(id[i] == pID)</span><br><span class="line">                id[i] = qID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="基本实现-Quick-Union"><a href="#基本实现-Quick-Union" class="headerlink" title="基本实现(Quick_Union)"></a>基本实现(Quick_Union)</h4><p>将每一个元素，看作是一个节点：</p><img src="/blog/2020/09/06/并查集-Union-Find/quickUnion.png" style="zoom:67%;"><p>对于上图，将7和3连接，只需要把7的根节点指向3的根节点（反过来也行）。</p><table><thead><tr><th align="center">i</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">parent</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td></tr></tbody></table><p><code>parent[i]</code>表示<code>i</code>指向的父亲元素是谁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind2</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *parent;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind2(<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UnionFind2()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">        <span class="comment">// 寻找根节点，复杂度O(n)</span></span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uoionElement</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 让p指向q，复杂度O(1)</span></span><br><span class="line">        parent[pRoot] = qRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h3><h4 id="基于size的优化"><a href="#基于size的优化" class="headerlink" title="基于size的优化"></a>基于size的优化</h4><p>之前实现的并查集中<code>Union(p, q)</code>操作都是让p的根节点指向q，如下图：</p><img src="/blog/2020/09/06/并查集-Union-Find/size1.png" style="zoom: 80%;"><p>如果实现<code>union(9, 4)</code>，那么9的根节点9将指向4的根节点8；相应的如果实现<code>union(4, 9)</code>则会出现将4的根节点8指向了9，如此一来，查找4的根节点需要的时间就更多了，我们完全可以在<code>union</code>操作之前进行判断，将元素少的集合的根节点指向元素多的集合的根节点，用一个数组<code>sz[i]</code>来表示以i为根集合中元素的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind3</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *parent;</span><br><span class="line">    <span class="keyword">int</span> *sz;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind3(<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UnionFind3()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] parent;</span><br><span class="line">        <span class="keyword">delete</span> [] sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">        <span class="comment">// 寻找根节点，复杂度O(n)</span></span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uoionElement</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 基于size优化</span></span><br><span class="line">        <span class="keyword">if</span>(sz[pRoot] &lt; sz[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            sz[qRoot] += sz[pRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            sz[pRoot] += sz[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="基于rank的优化"><a href="#基于rank的优化" class="headerlink" title="基于rank的优化"></a>基于rank的优化</h4><p>基于size的优化会出现下面一个问题：</p><img src="/blog/2020/09/06/并查集-Union-Find/rank1" style="zoom:80%;"><p>根节点为7的size是大于根节点为8的size的，所以基于size的优化会使8指向7，如下图：</p><img src="/blog/2020/09/06/并查集-Union-Find/rank2" style="zoom:80%;"><p>这样一来，这棵树的层数变成了4，一种更合理的方式是根据当前根节点的树的高度来进行优化，如下图，这样树的层数为3：</p><img src="/blog/2020/09/06/并查集-Union-Find/rank3" style="zoom:80%;"><p>我们可以用一个数组<code>rang[i]</code>表示根节点为i的树的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind4</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *parent;</span><br><span class="line">    <span class="keyword">int</span> *rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind4(<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = count;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~UnionFind4()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] parent;</span><br><span class="line">        <span class="keyword">delete</span> [] rank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">        <span class="comment">// 寻找根节点，复杂度O(n)</span></span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uoionElement</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 基于size优化</span></span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            <span class="comment">// 不用维护层数</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            <span class="comment">// 不用维护层数</span></span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">            <span class="comment">// 层数加1</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径压缩-Path-Compression"><a href="#路径压缩-Path-Compression" class="headerlink" title="路径压缩(Path Compression)"></a>路径压缩(Path Compression)</h3><p>之前我们的<code>find(p)</code>操作中，递归查找的复杂度为<code>O(1)</code>，如下图，要查找4的根节点需要4次递归：</p><img src="/blog/2020/09/06/并查集-Union-Find/pathcompression1" style="zoom:80%;"><table><thead><tr><th align="center"></th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">parent</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr></tbody></table><p>如果将4指向3的父节点2（指向其父节点的父节点），会得到下图：</p><img src="/blog/2020/09/06/并查集-Union-Find/pathcompression2"><p>由于根节点指向自己，所以不会出现无效的情况，继续将p更新为<code>parent[p]</code>，得到下图：</p><img src="/blog/2020/09/06/并查集-Union-Find/pathcompression3"><p>这样一来，所有节点的路径都进行了压缩，查找的时间复杂度近乎是<code>O(1)</code>的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">    <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="keyword">while</span>(p != parent[p])&#123;</span><br><span class="line">        parent[p] = parent[parent[p]];</span><br><span class="line">        p = parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">    <span class="keyword">if</span>(p != parent[p])</span><br><span class="line">        parent[p] = find(parent[p]);</span><br><span class="line">    <span class="keyword">return</span> parent[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>对每种并查集的工程执行100w次<code>union</code>操作和100w次<code>find</code>操作：</p><img src="/blog/2020/09/06/并查集-Union-Find/test" style="zoom:80%;"><p>区别还是很明显的。</p><h3 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h3><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;并查集的基本概念及实现(Quick_Find/Quick_Union)&lt;/li&gt;
&lt;li&gt;基于size优化与基于rank优化&lt;/li&gt;
&lt;li&gt;路径压缩&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序(Quick sort)</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/08/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/08/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort/</id>
    <published>2020-08-15T15:20:58.000Z</published>
    <updated>2020-09-06T02:49:22.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h3><ol><li>快速排序基本实现及优化</li><li>双路快速排序</li><li>三路快速排序</li></ol><a id="more"></a><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>快速排序的基本思想很简单，对于<code>l</code>处的数<code>val</code>，与<code>j</code>处的数进行交换，使得坐标小于<code>j</code>的所有数都小于<code>val</code>，而位于<code>j</code>之后的数都应该大于<code>val</code>，如下图所示：</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-1" style="zoom:80%;"><p>而实现这一操作的过程称为<code>partition</code>，具体过程如下：</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-2"><ol><li>对于上图，<code>arr[l+1...j] &lt; v</code>，<code>arr[j+1...i-1] &gt; v</code>，当前位置<code>i</code>的值为<code>e</code>；</li></ol><ul><li><p>如果<code>e &gt; v</code>，将<code>e</code>放在<code>&gt; v</code>后面，同时<code>i++</code>；</p></li><li><p>如果<code>e &lt; v</code>，将<code>i</code>处的值<code>e</code>与<code>j</code>下一个位置的值进行交换，然后<code>j++,i++</code>；</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-3"><img src="/blog/2020/08/15/快速排序-quick-sort/1-4"></li></ul><ol start="2"><li>继续步骤1，会得到以下结果：</li></ol><img src="/blog/2020/08/15/快速排序-quick-sort/1-5"><ol start="3"><li>此时满足<code>arr[l+1...j] &lt; v</code>，<code>arr[j+1...i-1] &gt; v</code>，再将<code>l</code>和<code>j</code>位置进行交换：</li></ol><img src="/blog/2020/08/15/快速排序-quick-sort/1-6"><ol start="4"><li>重复步骤1-3，直到递归结束。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zxy on 2020/8/16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sortHelper.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p，使arr[l...p-1] &lt; arr[p]; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="comment">// arr[l+1...j] &lt; v; arr[j+1...i) &gt; v</span></span><br><span class="line">    <span class="comment">// 初始状态时两个区间都为空</span></span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i)&#123;</span><br><span class="line">        <span class="comment">// 实际上当前值大于等于v时，将e都直接放在&lt;v后面</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; v)&#123;</span><br><span class="line">            swap(arr[j + <span class="number">1</span>], arr[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[l], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, l, r);</span><br><span class="line">    __quickSort(arr, l, p - <span class="number">1</span>);</span><br><span class="line">    __quickSort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    __quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(<span class="number">10</span>, <span class="number">1</span>, <span class="number">50</span>); <span class="comment">// 产生10个1到50间的随机数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printArray(arr, <span class="number">10</span>); <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    quickSort(arr, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printArray(arr, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-7"><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>对于上述的快速排序算法有一个很大的缺点，如果数组近乎有序，复杂度可能退化至O(n^2)，大于<code>v</code>或者小于<code>v</code>的部分分配不均匀。比如对于数组<code>[3,1,1,2,2,2]</code>，经过第一次<code>partition</code>时，3放在了数组的末尾，左边5个数全部小于3，而右边没有大于3的数。</p><p>对于这种情况，我们可以不取数组<code>l</code>处的值作为<code>v</code>，而是在数组中随机取一个值作为分界点<code>v</code>，然后再进行<code>partition</code>操作，此时快速排序复杂度的数学期望为O(nlogn)，具体的推导百度一下。修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">    swap(arr[rand() % (r - l + <span class="number">1</span>) + l], arr[l]);</span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="comment">// arr[l+1...j] &lt; v; arr[j+1...i) &gt; v</span></span><br><span class="line">    <span class="comment">// 初始状态时两个区间都为空</span></span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; v)&#123;</span><br><span class="line">            swap(arr[j + <span class="number">1</span>], arr[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[l], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直观的对比一下两种思路对完全随机数组和近乎有序数组的排序速度（其中<code>swap time</code>表示对于产生一个有序数组，随机取两个数进行交换，一共交换的次数）：</p><img src="/blog/2020/08/15/快速排序-quick-sort/1-8"><h3 id="双路快速排序"><a href="#双路快速排序" class="headerlink" title="双路快速排序"></a>双路快速排序</h3><p>虽然解决了近乎有序数组的排序问题，但是对于数组中存在大量重复键值时，复杂度也可能退化为O(n^2)，如下图所示：</p><img src="/blog/2020/08/15/快速排序-quick-sort/2-1"><p>我们之前的<code>partition</code>操作中，当前值大于等于v时，将e都直接放在小于v最后一个的后面，所以可能出现上述情况。现在我们对于等于v时两边都可以进行收缩，使得<code>partition</code>操作更加均匀：</p><img src="/blog/2020/08/15/快速排序-quick-sort/2-2"><p>话不多说，看代码更容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    swap(arr[rand() % (r - l + <span class="number">1</span>) + l], arr[l]);</span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="comment">// arr[l+1...i) &lt;= v; arr(j...r] =&gt; v</span></span><br><span class="line">    <span class="comment">// 初始状态时两个区间都为空</span></span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r &amp;&amp; arr[i] &lt; v) i++;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= l + <span class="number">1</span> &amp;&amp; arr[j] &gt; v) j--;</span><br><span class="line">        <span class="comment">// 此时i指向第一个大于等于v的位置，j指向最后一个小于等于v的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr[i], arr[j]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[l], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition2(arr, l, r);</span><br><span class="line">    __quickSort2(arr, l, p - <span class="number">1</span>);</span><br><span class="line">    __quickSort2(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    __quickSort2(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2020/08/15/快速排序-quick-sort/2-3"><h3 id="三路快速排序"><a href="#三路快速排序" class="headerlink" title="三路快速排序"></a>三路快速排序</h3><p>要给含有大量重复键值的数组排序同时避免对等于v的值进行交换，还可以进行三路的快速排序：</p><img src="/blog/2020/08/15/快速排序-quick-sort/3-1"><p>现在根据v将数组分为三个部分，分别是：<code>arr[l+1...lt] &lt; v</code>，<code>arr[lt+1...i-1] == v</code>，<code>arr[gt...r] &gt; v</code>。</p><ul><li>如果<code>e == v</code>，<code>i++</code>；</li><li>如果<code>e &lt; v</code>，将e和<code>lt+1</code>位置交换，同时<code>lt++，i++</code>；</li><li>如果<code>e &gt; v</code>，将e和<code>gt-1</code>位置交换，成为大于v的第一个位置，<code>gt--</code>；</li><li>最后将<code>l</code>和<code>lt</code>位置交换，再对小于v部分和大于v部分继续排序。</li></ul><img src="/blog/2020/08/15/快速排序-quick-sort/3-2"><img src="/blog/2020/08/15/快速排序-quick-sort/3-3"><p>数组中<code>arr[l...lt-1] &lt; v</code>，<code>arr[lt...gt-1] == v</code>，<code>arr[gt...r] &gt; v</code>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort3(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    swap(arr[l], arr[rand() % (r - l +<span class="number">1</span> ) + l]);</span><br><span class="line">    T v = arr[l];</span><br><span class="line">    <span class="keyword">int</span> lt = l;     <span class="comment">// arr[l+1...lt] &lt; v</span></span><br><span class="line">    <span class="keyword">int</span> gt = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; v</span></span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>;    <span class="comment">// arr[lt+1...i) == v</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; gt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; v)&#123;</span><br><span class="line">            swap(arr[i], arr[lt+<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">            lt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; v)&#123;</span><br><span class="line">            swap(arr[i], arr[gt<span class="number">-1</span>]);</span><br><span class="line">            gt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> i++; <span class="comment">// arr[i] == v</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap( arr[l] , arr[lt] );</span><br><span class="line">    __quickSort3(arr, l, lt<span class="number">-1</span>);</span><br><span class="line">    __quickSort3(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort3( arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2020/08/15/快速排序-quick-sort/3-4"><p>双路快速排序和三路快速排序都是在对近乎有序数组优化的基础上，对数组存在大量重复键值时进行优化，所以时间复杂度都是O(nlogn)。</p><h3 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h3><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;快速排序基本实现及优化&lt;/li&gt;
&lt;li&gt;双路快速排序&lt;/li&gt;
&lt;li&gt;三路快速排序&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++11之lambda表达式</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/08/02/C-11%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/08/02/C-11%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-08-02T02:34:49.000Z</published>
    <updated>2020-08-02T15:19:15.095Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++11标准中的新特性——lambda表达式</p><a id="more"></a><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><hr><p>如果需要sort按照自己定义的方式进行排序，需要使用其第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个<strong>谓词</strong>。</p><hr><h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><ol><li>定义：谓词是一个<strong>可以调用的表达式</strong>，返回的结果可以被调用</li><li>分类：一元谓词和二元谓词<ol><li>一元谓词：只接受单一的参数</li><li>二元谓词：接受两个参数</li></ol></li><li>接受谓词的算法对输入序列中的<strong>元素</strong>调用谓词，因此<strong>元素</strong>必须能转换为谓词的参数类型</li></ol><p><code>sort</code>函数接受一个<strong>二元谓词</strong>，假如我们要按字符串的长度升序排序，可以定义一个比较函数<code>isShorter</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数，用来按长度排序单词</span></span><br><span class="line"><span class="comment">// 必须是引用类型！！！</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按长度由短至长排序words</span></span><br><span class="line">sort(words.begin(), words.end(), isShorter);</span><br><span class="line"></span><br><span class="line"><span class="meta"># words = &#123;<span class="meta-string">"foxs"</span>, <span class="meta-string">"jumps"</span>, <span class="meta-string">"end"</span>, <span class="meta-string">"kid"</span>&#125;</span></span><br><span class="line"># 输出结果为end kid foxs jumps</span><br></pre></td></tr></table></figure><p><strong><em>注：针对同一长度的单词，<code>sort</code>是不稳定的，如果要保持对应的字典序，可以调用<code>stable_sort</code></em></strong></p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>对于一个对象或者表达式，如果对其可以使用调用运算符<code>()</code>，则称它为可调用的，可以将其传入算法。一个<code>lambda</code>表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。</p><hr><p><strong>与任何函数相似，一个<code>lambda</code>具有一个返回类型，一个参数列表和一个函数体</strong></p><p><strong>不同的是，<code>lambda</code>可以定义在函数内部</strong></p><hr><p>一个<code>lambda</code>表达式具有如下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (parameter <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><ul><li><code>[capture list]</code>（捕获列表）是一个<code>lambda</code><strong>所在函数中</strong>定义的局部变量的列表（通常为空）</li><li><code>return type</code>、<code>parameter list</code>和<code>function body</code>与普通函数一样，分别为返回类型，参数列表和函数体，但是<code>lambda</code>必须使用尾置返回</li></ul><p>我们可以忽略参数列表和返回类型，但必须永远包括捕获列表和函数体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们定义了一个可调用对象f，它不接受参数，返回42</span></span><br><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure><p><code>lambda</code>的调用方式与普通函数相同，使用调用运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出42</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>在此例中，当调用<code>f</code>时，参数列表为空并且忽略了返回类型，<code>lambda</code>根据函数体代码确定返回类型，如果函数体只有一个<code>return</code>语句，则返回类型从返回表达式的类型推断而来，否则返回<code>void</code>。</p><p><strong><em>注：如果函数体中包含任何单一<code>return</code>语句之外的内容，且未指定返回类型，返回<code>void</code></em></strong></p><h4 id="向lambda传递参数"><a href="#向lambda传递参数" class="headerlink" title="向lambda传递参数"></a>向lambda传递参数</h4><p>与一个普通函数调用类似，调用一个<code>lambda</code>给定实参被用来初始化<code>lambda</code>形参，类型需要匹配。但是<code>lambda</code>不能有默认参数（比如：<code>int fun(int a = 1, int b = 1) { return a + b; }</code>）。因此，一个<code>lambda</code>调用的实参数目永远和形参数目相等，一旦形参初始化完毕，就可以执行函数体了。</p><p>我们可以写出来一个与<code>isShorter</code>功能完全一样的<code>lambda</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span><br><span class="line">&#123; <span class="keyword">return</span> s1.size() &lt; s2.size(); &#125;</span><br></pre></td></tr></table></figure><p>空捕获列表表示不使用函数中的局部变量，如下所示，之前的<code>sort</code>函数可以改写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(words.begin(), words.end(), </span><br><span class="line">[] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span><br><span class="line">&#123; <span class="keyword">return</span> s1.size() &lt; s2.size(); &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h4><p>假如我们现在要找到<code>words</code>中第一个长度大于<code>sz</code>的单词的位置，可以编写一个可以传递给<code>find_if</code>的可调用表达式。一个<code>lambda</code>表达式<strong>只能使用明确指明的变量</strong>，在下面的例子中，<code>lambda</code>会捕获<code>sz</code>，，并只有单一的<code>string</code>参数（因为<code>find_if</code>只支持一元谓词），其函数体会将<code>string</code>的大小与捕获的<code>sz</code>进行比较：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sz] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;;</span><br></pre></td></tr></table></figure><h5 id="调用find-if函数"><a href="#调用find-if函数" class="headerlink" title="调用find_if函数"></a>调用<code>find_if</code>函数</h5><p>使用此<code>lambda</code>，查到第一个长度大于等于给定<code>sz</code>元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">     [sz] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">     &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;);</span><br><span class="line"><span class="comment">// 输出满足size &gt;= sz第一个元素的值和位置</span></span><br><span class="line"><span class="comment">// 如果没有找到，返回words.end()的一个拷贝</span></span><br><span class="line"><span class="comment">// 取sz = 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"value:"</span> &lt;&lt; *wc &lt;&lt; <span class="string">"position:"</span> &lt;&lt; wc - words.begin();</span><br><span class="line"><span class="meta"># value:foxs    position:2</span></span><br></pre></td></tr></table></figure><h5 id="for-each算法"><a href="#for-each算法" class="headerlink" title="for_each算法"></a><code>for_each</code>算法</h5><p>打印出长度大于等于<code>sz</code>的所有单词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.end(), [] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line"><span class="meta"># foxs jumps</span></span><br></pre></td></tr></table></figure><h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>我们可以认为，当向一个函数传递一个<code>lambda</code>时，同时定义了一个新类型和该类型的对象，传递的参数就是此编译器生成的<strong>类的类型</strong>的<strong>未命名对象</strong>。</p><p><strong>默认情况下，由<code>lambda</code>生成的类，数据成员包含捕获列表中的变量，在<code>lambda</code>对象创建时被初始化。</strong></p><h4 id="值捕获（后面更改不会影响值）"><a href="#值捕获（后面更改不会影响值）" class="headerlink" title="值捕获（后面更改不会影响值）"></a>值捕获（后面更改不会影响值）</h4><p>与参数传递不同之处在于，被捕获的变量的值在<code>lambda</code>创建时拷贝，而不是调用时拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>; <span class="comment">// 局部变量</span></span><br><span class="line"><span class="keyword">auto</span> f = [v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = f();</span><br><span class="line"><span class="meta"># j为42；f保存我们创建它时的拷贝，因此修改v1不会影响lambda内对应的值</span></span><br></pre></td></tr></table></figure><h4 id="引用捕获（后面更改会影响变量值）"><a href="#引用捕获（后面更改会影响变量值）" class="headerlink" title="引用捕获（后面更改会影响变量值）"></a>引用捕获（后面更改会影响变量值）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v2 = <span class="number">42</span>; <span class="comment">// 局部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;v2] &#123; <span class="keyword">return</span> v2; &#125;;</span><br><span class="line">v2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> jj = f2();</span><br><span class="line"><span class="meta"># jj为0；f2保存v1的引用</span></span><br><span class="line"># 需要注意的是必须确保被引用的对象在lambda执行的时候是存在的</span><br><span class="line"># 如果可能的话，避免捕获指针或引用（C++ Primer <span class="number">351</span>页）</span><br></pre></td></tr></table></figure><h4 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h4><p>我们可以让编译器根据<code>lambda</code>函数体中的代码来推断我们要使用哪些变量，在捕获列表中写一个<code>&amp;</code>表示捕获引用，<code>=</code>表示采用值捕获方式，我们可以重写<code>find_if</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sz为隐式值捕获</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">     [=] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">     &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure><p>如果想对一部分变量使用值捕获，一部分使用引用捕获，可以混合使用隐式捕获和显示捕获：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;os = <span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">' '</span>;</span><br><span class="line"><span class="comment">// os隐式引用捕获，c显示值捕获</span></span><br><span class="line">for_each(wc, words.end(), [&amp;, c] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; os &lt;&lt; s &lt;&lt; c;&#125;);</span><br><span class="line"><span class="comment">// os显示引用捕获，c隐式值捕获</span></span><br><span class="line">for_each(wc, words.end(), [=, &amp;os] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; os &lt;&lt; s &lt;&lt; c;&#125;);</span><br></pre></td></tr></table></figure><ol><li><strong>当我们使用混合捕获时，捕获列表第一个变量必须是一个&amp;或者=，定义了默认捕获方式为引用或值。</strong></li><li><strong>混合捕获时，显示捕获的变量必须使用与隐式捕获不同的方式，即：显示引用捕获，隐式值捕获或者显示值捕获，隐式引用捕获。</strong></li></ol><h4 id="指定lambda返回类型"><a href="#指定lambda返回类型" class="headerlink" title="指定lambda返回类型"></a>指定lambda返回类型</h4><p>标准库函数<code>transform</code>：接受三个迭代器和一个可调用对象，前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中的每个元素调用可调用对象，并将结果写到目的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取绝对值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vv1&#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-20</span>, <span class="number">7</span>&#125;;</span><br><span class="line">transform(vv1.begin(), vv1.end(), vv1.begin(),</span><br><span class="line">          [] (<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i; &#125;);</span><br><span class="line"># <span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">20</span>,<span class="number">7</span></span><br></pre></td></tr></table></figure><p>如果写成以下形式就会产生编译错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(vv1.begin(), vv1.end(), vv1.begin(),</span><br><span class="line">          [] (<span class="keyword">int</span> i) &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure><p>这是因为函数体中不止一个<code>return</code>语句，<code>lambda</code>无法判断返回类型。如果我们需要为其定义返回类型，必须用尾置的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform(vv1.begin(), vv1.end(), vv1.begin(),</span><br><span class="line">          [] (<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><hr><p>对于只在一两个地方使用的函数，使用<code>lambda</code>是很方便的，多次使用或者函数体比较长的话定义一个函数来实现更好。但是对于捕获局部变量的<code>lambda</code>表达式来说，用函数代替就不太容易了。</p><hr><p>在之前的<code>find_if</code>函数中，我们可以容易写出来一个相同功能的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="built_in">string</span>::size_type sz)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.size() &gt;= sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>find_if</code>函数只支持一元谓词，直接使用肯定是不可以的。</p><h4 id="标准库bind函数"><a href="#标准库bind函数" class="headerlink" title="标准库bind函数"></a>标准库bind函数</h4><p>使用<code>bind</code>函数可以解决上述问题，此函数定义在头文件<code>functional</code>中，可以将<code>bind</code>函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。</p><p>调用形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list)</span><br></pre></td></tr></table></figure><ul><li><code>newCallable</code>本身是一个可调用对象</li><li><code>arg_list</code>是一个逗号分隔的参数列表，对应给定<code>callable</code>的参数</li></ul><p>当我们调用<code>newCallable</code>时，<code>newCallable</code>会调用<code>callable</code>，并传递给它<code>arg_list</code>中的参数。</p><p><code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，其中<code>n</code>是一个整数，称为<strong>占位符</strong>，表示占据了传递给<code>newCallable</code>参数的位置。</p><h5 id="绑定check-size的sz参数"><a href="#绑定check-size的sz参数" class="headerlink" title="绑定check_size的sz参数"></a>绑定<code>check_size</code>的<code>sz</code>参数</h5><p>一个简单的例子，使用<code>bind</code>生成一个调用<code>check_size</code>的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check4是一个可调用对象，接受一个string类型的参数</span></span><br><span class="line"><span class="comment">// 使用此string和值4调用check_size</span></span><br><span class="line"><span class="comment">// 注意要使用using std::placeholder::_1或using namespace std::placeholders</span></span><br><span class="line"><span class="keyword">auto</span> check4 = bind(check_size, _1, <span class="number">4</span>);</span><br><span class="line"># 此bind调用只有一个占位符，表示check4只接受单一参数</span><br><span class="line"># 占位符在arg_list的第一个位置，表示check4的此参数对应check_size的第一个参数，是<span class="keyword">const</span> <span class="built_in">string</span>&amp;</span><br><span class="line"># 因此调用check4必须传递给它一个<span class="built_in">string</span>类型的参数，check4将其传给check_size</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">bool</span> b1 = check4(s);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"># <span class="number">1</span></span><br></pre></td></tr></table></figure><p>此时我们可以改写<code>find_if</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wcc = find_if(words.begin(), words.end(),</span><br><span class="line">     bind(check_size, _1, sz));</span><br><span class="line">for_each(wcc, words.end(), [] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line"><span class="meta"># foxs jumps</span></span><br><span class="line"><span class="comment">// 对比之前的find_if</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">     [sz] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">     &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>《C++ Primer》370-383</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习C++11标准中的新特性——lambda表达式&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="lambda" scheme="http://www.xingyuzhao.ltd/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode63-不同路径Ⅱ</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/</id>
    <published>2020-07-26T02:09:11.000Z</published>
    <updated>2020-07-26T03:08:14.322Z</updated>
    
    <content type="html"><![CDATA[<p>本题与<a href="http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more"><strong>97交错字符串</strong></a>，<a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener"><strong>174-地下城游戏</strong></a>分析与解法相似</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/question" style="zoom:80%;"><a id="more"></a><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/question1" style="zoom:;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于输入为二维数组的题目中出现了只能向下或者向右移动的字眼，一般来说考虑动态规划。这道题的不同之处是设置了障碍物，如果遇到了1则表示<strong>不可达</strong>，假如<code>m = 2, n = 2</code>，并且无障碍物，我们可以得到下图：</p><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/solution1" style="zoom:80%;"><p>那么对于<code>(0,1)</code>和<code>(1,0)</code>位置，都只有一条通路可达：</p><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/solution2" style="zoom:80%;"><p>最后对于末尾处<code>(1,1)</code>，它的上边和左边可以到达，所以到达它的路径为<code>1 + 1 = 2</code>条：</p><img src="/blog/2020/07/26/LeetCode63-不同路径Ⅱ/solution3" style="zoom:80%;"><p>通过观察我们发现，在不遮挡的情况下，可以到达当前位置的路径数就是当前位置的上边和左边路径数的总和。</p><p>对于存在障碍物的情况，我们直接令到达它的路径数为0，这样也就满足的题目的要求。</p><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p>根据上述分析，<code>dp[i][j]</code>表示有多少条路径可以到达<code>(i,j)</code>，如果网格中此处值为1，也就是有障碍的情况下，<code>dp[i][j] = 0</code>。表示无法到达，路径数为0。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在<strong>交错字符串</strong>中使用的是从前往后遍历的思想，这里换一种思路，从后往前进行遍历。对于最后一个位置<code>dp[m-1][n-1]</code>，如果第<code>m - 1</code>行或者<code>n - 1</code>列其他位置可以到达最后位置，则为1，否则为0，只要在网格中往回走遇到了1，在那之后<code>dp</code>数组的值都为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[m][n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后一行到end初始化为1</span></span><br><span class="line"><span class="comment">// 注意有有一个为1，后面都被阻挡</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[m - <span class="number">1</span>][j] == <span class="number">0</span>; --j)&#123;</span><br><span class="line">dp[m - <span class="number">1</span>][j] = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后一列到end初始化为1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][n - <span class="number">1</span>] == <span class="number">0</span>; --i)&#123;</span><br><span class="line">dp[i][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">    dp[i][j] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size();</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 从后往前必须long long</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一行到end初始化为1</span></span><br><span class="line">        <span class="comment">// 注意有有一个为1，后面都被阻挡</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[m - <span class="number">1</span>][j] == <span class="number">0</span>; --j)&#123;</span><br><span class="line">                dp[m - <span class="number">1</span>][j] = <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一列到end初始化为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][n - <span class="number">1</span>] == <span class="number">0</span>; --i)&#123;</span><br><span class="line">                dp[i][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/jian-dan-dpbi-xu-miao-dong-by-sweetiee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii/solution/jian-dan-dpbi-xu-miao-dong-by-sweetiee/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题与&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more&quot;&gt;&lt;strong&gt;97交错字符串&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;https://leetcode-cn.com/problems/dungeon-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;174-地下城游戏&lt;/strong&gt;&lt;/a&gt;分析与解法相似&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
&lt;img src=&quot;/blog/2020/07/26/LeetCode63-不同路径Ⅱ/question&quot; style=&quot;zoom:80%;&quot;&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode97-交错字符串</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-07-18T15:47:04.000Z</published>
    <updated>2020-07-19T10:20:07.368Z</updated>
    
    <content type="html"><![CDATA[<p>在看了题解之后才慢慢意识到，这道题和<a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener"><strong>63-不同路径Ⅱ</strong></a>，<a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener"><strong>174-地下城游戏</strong></a>是非常相似的，题目虽然具有一定难度，但都是有迹可循。它们都可以抽象为在二维数组中，从起始到末尾找路径的问题。上面两个问题还未更新，跳转位置是题目链接。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定三个字符串 <em>s1</em>, <em>s2</em>, <em>s3</em>, 验证 <em>s3</em> 是否是由 <em>s1</em> 和 <em>s2</em> 交错组成的。</p><a id="more"></a><img src="/blog/2020/07/18/LeetCode97-交错字符串/question1"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>交错的意思是：如果第一次取了<code>s1</code>，那么第二次必须取<code>s2</code>，反之亦然。取多少和哪一个先取都是不一定的，只是要求交错即可。</p><p>对于<code>s1 = &quot;bacc&quot;, s2 = &quot;aabcce&quot;, s3 = &quot;abaacbccec&quot;</code>，这个示例是可以匹配的，按照<strong>可以匹配</strong>的过程分析如下：</p><ol><li>首先只能取<code>s2</code>中的<code>a</code>，再继续往下取<code>a</code>时，与<code>s3</code>已经无法匹配了；</li><li><strong>再取<code>s1</code>中的<code>b</code>或者<code>ba</code>都是可以的</strong>，这里取<code>b</code></li><li>再取<code>s2</code>中的<code>a</code>，此时匹配到<code>aba</code></li><li>再取<code>s1</code>中的<code>ac</code>，此时匹配到<code>abaac</code></li><li>再取<code>s2</code>中的<code>bcce</code>，此时匹配到<code>abaacbbe</code></li><li>再取<code>s1</code>中的<code>c</code>，此时完全匹配</li></ol><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p><code>dp[i][j]</code>表示<code>s1</code>的前<code>i</code>个字符和<code>s2</code>的前<code>j</code>个字符是否匹配，我们可以将刚才的分析表示为下图：</p><img src="/blog/2020/07/18/LeetCode97-交错字符串/question1_dp" style="zoom:80%;"><p>上图是不是很像一个路径问题，而且只能向右或者向下移动，进一步说明是用动态规划来解决，如果还可以往上或者左，那就不能用动态规划来做了，得考虑<code>dfs</code>之类的算法。</p><p>分析中的第二步，也就是图中<code>true</code>的其他可能。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 都为空时匹配</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">// 对于第一行和第一列，当前值若无法匹配，则当前值和之后的都无法匹配</span></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>) dp[<span class="number">0</span>][j] = s2[<span class="number">0</span>,j) == s3[<span class="number">0</span>,j)</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][<span class="number">0</span>] = s2[<span class="number">0</span>,i) == s3[<span class="number">0</span>,i)</span><br></pre></td></tr></table></figure><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])</span><br><span class="line">|| (dp[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.size(), n = s2.size();</span><br><span class="line">        <span class="keyword">if</span>(m + n != s3.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// bool dp[m + 1][n + 1] = &#123;false&#125;;</span></span><br><span class="line">        <span class="keyword">bool</span> **dp = <span class="keyword">new</span> <span class="keyword">bool</span>*[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; (s2.substr(<span class="number">0</span>, j) == s3.substr(<span class="number">0</span>, j)); ++j) </span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &amp;&amp; (s1.substr(<span class="number">0</span>, i) == s3.substr(<span class="number">0</span>, i)); ++i) </span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>])) ||</span><br><span class="line">                            (dp[i][j - <span class="number">1</span>] &amp;&amp; (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看了题解之后才慢慢意识到，这道题和&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;63-不同路径Ⅱ&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;https://leetcode-cn.com/problems/dungeon-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;174-地下城游戏&lt;/strong&gt;&lt;/a&gt;是非常相似的，题目虽然具有一定难度，但都是有迹可循。它们都可以抽象为在二维数组中，从起始到末尾找路径的问题。上面两个问题还未更新，跳转位置是题目链接。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定三个字符串 &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt;, &lt;em&gt;s3&lt;/em&gt;, 验证 &lt;em&gt;s3&lt;/em&gt; 是否是由 &lt;em&gt;s1&lt;/em&gt; 和 &lt;em&gt;s2&lt;/em&gt; 交错组成的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Verilog基础2</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/07/14/Verilog%E5%9F%BA%E7%A1%802/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/07/14/Verilog%E5%9F%BA%E7%A1%802/</id>
    <published>2020-07-14T07:33:07.000Z</published>
    <updated>2020-07-15T00:55:00.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Verilog基础"><a href="#Verilog基础" class="headerlink" title="Verilog基础"></a>Verilog基础</h2><p>学习verilog基础语法2</p><a id="more"></a><h3 id="第五章-FPGA基本实践"><a href="#第五章-FPGA基本实践" class="headerlink" title="第五章 FPGA基本实践"></a>第五章 FPGA基本实践</h3><h4 id="流水灯实践"><a href="#流水灯实践" class="headerlink" title="流水灯实践"></a>流水灯实践</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> v1(</span><br><span class="line">    <span class="keyword">input</span> clk,<span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="keyword">input</span> rst,<span class="comment">// 复位信号</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] led<span class="comment">// LED输出</span></span><br><span class="line">    );</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] ledtemp = <span class="number">8'b0000_0001</span>;<span class="comment">// led初始值</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">23</span>:<span class="number">0</span>] divclk_cnt = <span class="number">0</span>;<span class="comment">// 24位计数值</span></span><br><span class="line"><span class="keyword">reg</span> divclk = <span class="number">0</span>;<span class="comment">// 低频时钟</span></span><br><span class="line"><span class="keyword">assign</span> led = ledtemp;<span class="comment">// 实现将寄存器变量值赋给LED输出</span></span><br><span class="line"><span class="keyword">parameter</span> halfduty_cntvalue = <span class="number">12500000</span>;</span><br><span class="line"><span class="keyword">always</span> @ ( <span class="keyword">posedge</span> clk )<span class="comment">// 把系统时钟分频50Mhz/25000000 = 2Hz</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>( divclk_cnt == halfduty_cntvalue)<span class="comment">// 计数满后翻转</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">divclk = ~divclk;</span><br><span class="line">divclk_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">divclk_cnt = divclk_cnt + <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span> @ ( <span class="keyword">posedge</span> divclk )</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>( !rst )</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">ledtemp = <span class="number">8'b0000_0001</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ledtemp[<span class="number">7</span>] == <span class="number">1</span> )</span><br><span class="line">ledtemp = <span class="number">8'b0000_0001</span>;<span class="comment">// 瀹炵幇寰幆绉讳綅</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ledtemp = ledtemp &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>仿真代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sim3;</span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">reg</span> rst;</span><br><span class="line"><span class="keyword">wire</span> led;</span><br><span class="line"></span><br><span class="line">v1 uut( clk, rst, led );</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line">    rst = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">10</span> clk = ~clk; <span class="comment">// 每隔10ns反转，周期是20ns，频率也就是50MHz</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>仿真图如下：</p><img src="/blog/2020/07/14/Verilog基础2/image1"><p>从<strong>ledtemp</strong>可以看出进行了左移的操作</p><img src="/blog/2020/07/14/Verilog基础2/image2"><p>完成一次循环之后回到<strong>00000001</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Verilog基础&quot;&gt;&lt;a href=&quot;#Verilog基础&quot; class=&quot;headerlink&quot; title=&quot;Verilog基础&quot;&gt;&lt;/a&gt;Verilog基础&lt;/h2&gt;&lt;p&gt;学习verilog基础语法2&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="http://www.xingyuzhao.ltd/categories/FPGA/"/>
    
    
  </entry>
  
  <entry>
    <title>Verilog基础1</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/07/14/Verilog%E5%9F%BA%E7%A1%801/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/07/14/Verilog%E5%9F%BA%E7%A1%801/</id>
    <published>2020-07-14T07:33:00.000Z</published>
    <updated>2020-07-15T00:55:10.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Verilog基础"><a href="#Verilog基础" class="headerlink" title="Verilog基础"></a>Verilog基础</h2><p>学习verilog基础语法1</p><a id="more"></a><h2 id="第二章-基本语法"><a href="#第二章-基本语法" class="headerlink" title="第二章 基本语法"></a>第二章 基本语法</h2><h4 id="数据类型及变量"><a href="#数据类型及变量" class="headerlink" title="数据类型及变量"></a>数据类型及变量</h4><p>查找表<strong>LUT</strong></p><ol><li>线网型变量wire<ol><li>信号间连接作用，只能将其连接到某处而不能进行赋值</li><li>没有时序限定，与其它块语句并行执行</li><li>不保存状态，值随时可以改变，不受时钟信号限制</li><li>input和output默认位wire</li><li>wire是组合逻辑的赋值，在时序控制always<strong>块外</strong>并使用<strong>assign</strong>进行赋值</li></ol></li><li>寄存器类型reg<ol><li>值可以改变</li><li>常用来表示时序控制always块内的指定信号</li></ol></li><li>符号常量parameter</li></ol><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><ol><li><p>连续赋值语句<strong>assign</strong></p><p>assign语句用于对wire型变量赋值，例如<code>assign c = a &amp; b</code>，a，b是wire型变量或寄存器变量，c必须是wire型变量或其他线网型变量。</p></li><li><p>过程赋值语句<strong><code>=</code>和<code>&lt;=</code></strong></p><ol><li>用于对reg型变量赋值，在过程块中使用过程赋值语句</li><li>非阻塞(<code>&lt;=</code>)：多条非阻塞赋值在过程块中同时完成赋值操作，多条语句相当于同时执行</li><li>阻塞(<code>=</code>)：在一个块语句中，如果有多条阻塞赋值语句，在前面的赋值语句没有完成之前，后面的语句就不能执行<code>=</code></li><li>对于阻塞，在当前时钟就赋值了，而非阻塞是在下一个时钟进行赋值</li></ol></li><li><p>过程说明语句<strong>always</strong></p><ol><li>always块包含一个或一个以上的语句（如：过程赋值语句、条件语句和循环语句等），在运行的过程中，在时钟控制下被反复执行，也就是说，时钟有效边沿来了就执行</li><li>在always块中被赋值的只能是寄存器reg型变量</li><li>书写方法：<code>always @ (敏感信号表达式)</code></li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @ (clk) <span class="comment">// 只要clk发生变化就触发</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="comment">// clk上升沿触发</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> clk) <span class="comment">// clk下降沿触发</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> clk1 <span class="keyword">or</span> <span class="keyword">posedge</span> clk2) <span class="comment">// clk1下降沿或者clk2上升沿触发</span></span><br><span class="line"><span class="keyword">always</span> @ (*) <span class="comment">// 任何输入信号变化了都触发</span></span><br></pre></td></tr></table></figure></li><li><p>结构说明语句initial</p></li></ol><p>initial语句用于对寄存器变量赋予初值</p><ol start="5"><li><p>条件语句<strong>if-else</strong></p></li><li><p>条件语句<strong>case</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case(表达式)&lt;case分支项&gt;endcase</span><br><span class="line">case 分支项的一般格式：</span><br><span class="line">分支表达式：语句；</span><br><span class="line">默认项(default)  语句；</span><br></pre></td></tr></table></figure></li><li><p>循环语句</p><ol><li><strong>forever</strong>语句：连续执行的语句</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式: forever begin 语句块 end</span><br><span class="line">forever常用于仿真代码中</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>repeat</strong></li><li><strong>while</strong></li><li><strong>for</strong> 尽量少用，循环次数固定</li></ol></li></ol><h2 id="第三章-组合逻辑电路"><a href="#第三章-组合逻辑电路" class="headerlink" title="第三章 组合逻辑电路"></a>第三章 组合逻辑电路</h2><h4 id="多数表决器的实现"><a href="#多数表决器的实现" class="headerlink" title="多数表决器的实现"></a>多数表决器的实现</h4><ol><li><p><strong>逻辑表达式</strong>：<code>f = a&amp;b|a&amp;c|b&amp;C</code></p></li><li><p><strong>RTL分析</strong>：在左侧的流程导航器<code>Flow Navigator</code>中的详细设计<code>Elaborated Design</code> 部分按右键，在弹出的菜单中选<code>New Elaborated Design</code>之后得到RTL电路图（RTL意思是寄存器传输级，生成寄存器传输级别的电路，并非综合后的电路），在开发过程中RTL分析不是必须的，但是能帮助我们检测错误。</p></li><li><p><strong>综合</strong>：将RTL级别的设计描述转换成逻辑门级的逻辑描述。单击流程导航窗口综合<code>Synthesis</code>项下的<code>Run Synthesis</code>进入综合，综合完毕后点击<code>Schematic</code>打开原理图。</p></li><li><p><strong>仿真</strong>：新建仿真文件，然后编辑内容，再点击<code>Run Simulation</code></p></li><li><p><strong>编程和调试</strong>：首先生成比特流，然后再进行硬件调试</p></li></ol><h4 id="3-8译码器设计和IP核"><a href="#3-8译码器设计和IP核" class="headerlink" title="3-8译码器设计和IP核"></a><strong>3-8译码器设计和IP核</strong></h4><ol><li>译码器设计步骤与多数表决器相同，也是组合逻辑电路</li><li><strong>IP核</strong>：点击顶部的<strong>Tools</strong>，然后点击<strong>Create and Package IP</strong>项，之后一直<strong>Next</strong>，进入以下页面：</li></ol><img src="/blog/2020/07/14/Verilog基础1/image1" style="zoom:80%;"><p>没什么问题后点击<strong>Review and Package</strong>中的<strong>Package IP</strong></p><h4 id="调用IP核实现多数表决器"><a href="#调用IP核实现多数表决器" class="headerlink" title="调用IP核实现多数表决器"></a>调用IP核实现多数表决器</h4><h2 id="第四章-时序逻辑电路"><a href="#第四章-时序逻辑电路" class="headerlink" title="第四章 时序逻辑电路"></a>第四章 时序逻辑电路</h2><p>时钟同步状态机：时序电路的状态变化发生的时间有一个统一的时钟信号的指定边沿来激励。</p><h4 id="实现11001序列发生器"><a href="#实现11001序列发生器" class="headerlink" title="实现11001序列发生器"></a>实现11001序列发生器</h4><ol><li>画出状态转移图</li></ol><img src="/blog/2020/07/14/Verilog基础1/image2"><ol start="2"><li>画出状态转移表</li></ol><table><thead><tr><th align="center">Q0 Q1 Q2</th><th align="center">Q0* Q1* Q2*</th><th align="center">Z</th></tr></thead><tbody><tr><td align="center">000</td><td align="center">001</td><td align="center">1</td></tr><tr><td align="center">001</td><td align="center">010</td><td align="center">1</td></tr><tr><td align="center">010</td><td align="center">011</td><td align="center">0</td></tr><tr><td align="center">011</td><td align="center">100</td><td align="center">0</td></tr><tr><td align="center">100</td><td align="center">000</td><td align="center">1</td></tr></tbody></table><ol start="3"><li>根据状态转移表画卡诺图求解。（未使用的状态用无关项表示）</li></ol><table><thead><tr><th align="center">Q2/Q0Q1</th><th align="center">00</th><th align="center">01</th><th align="center">11</th><th align="center">10</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">001/1</td><td align="center">011/0</td><td align="center">ddd/d</td><td align="center">000/1</td></tr><tr><td align="center">1</td><td align="center">010/1</td><td align="center">100/0</td><td align="center">ddd/d</td><td align="center">ddd/d</td></tr></tbody></table><ol start="4"><li><p>得到转移方程和输出方程</p><ol><li><p>转移方程：<br>$$<br>Q0* = Q1Q2\<br>Q1* = Q1’Q2 + Q1Q2’\<br>Q2* = Q0’Q2’<br>$$</p></li><li><p>输出方程</p></li></ol><p>$$<br>Z = Q1’<br>$$</p></li><li><p>判断自启动，FPGA设计可以给出初始态，所以可以忽略</p></li><li><p>使用D触发器，写出激励方程<br>$$<br>D0 = Q0* = Q1Q2\<br>D1 = Q1* = Q1’Q2 + Q1Q2’\<br>D2 = Q2* = Q0’Q2’<br>$$</p></li><li><p>建立工程编写程序</p></li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> seq_11001_1(</span><br><span class="line"><span class="keyword">input</span>  clk,</span><br><span class="line"><span class="keyword">output</span> led</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] divclk_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span> divclk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span> q0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span> q1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span> q2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @ ( <span class="keyword">posedge</span> clk )</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(divclk_cnt == <span class="number">25</span>) <span class="comment">// 50分频 25低25高 默认32位宽</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">divclk = ~divclk;</span><br><span class="line">divclk_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">divclk_cnt = divclk_cnt + <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> led = ~q1;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> divclk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">q0 &lt;= q1&amp;q2;</span><br><span class="line">q1 &lt;= ~q1&amp;q2|q1&amp;~q2;</span><br><span class="line">q2 &lt;= ~q0&amp;~q2;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>仿真文件：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sim1;</span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">wire</span> led;</span><br><span class="line">seq_11001_1 uut( clk, led );</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ol start="8"><li>仿真</li></ol><img src="/blog/2020/07/14/Verilog基础1/image3"><p>从图可知，和状态转移表一致</p><h4 id="状态图直接描述法实现序列发生器"><a href="#状态图直接描述法实现序列发生器" class="headerlink" title="状态图直接描述法实现序列发生器"></a>状态图直接描述法实现序列发生器</h4><p>根据上部分<strong>1</strong>中的状态转移图可以直接实现<strong>11001</strong>序列发生器，实现代码如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> seq_11001_2(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> led</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">reg</span> led;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] divclk_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span> divclk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state = state_A;</span><br><span class="line"><span class="keyword">parameter</span> <span class="comment">// 符号常量</span></span><br><span class="line">state_A = <span class="number">3'b000</span>,state_B = <span class="number">3'b001</span>,state_C = <span class="number">3'b010</span>,state_D = <span class="number">3'b011</span>,state_E = <span class="number">3'b100</span>;</span><br><span class="line"><span class="keyword">always</span> @ ( <span class="keyword">posedge</span> clk )</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(divclk_cnt == <span class="number">25</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">divclk = ~divclk;</span><br><span class="line">divclk_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">divclk_cnt = divclk_cnt + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span> @ ( <span class="keyword">posedge</span> divclk )</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>( state )</span><br><span class="line">state_A:<span class="keyword">begin</span></span><br><span class="line">state &lt;= state_B;</span><br><span class="line">led &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">state_B:<span class="keyword">begin</span></span><br><span class="line">state &lt;= state_C;</span><br><span class="line">led &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">state_C:<span class="keyword">begin</span></span><br><span class="line">state &lt;= state_D;</span><br><span class="line">led &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">state_D:<span class="keyword">begin</span></span><br><span class="line">state &lt;= state_E;</span><br><span class="line">led &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">state_E:<span class="keyword">begin</span></span><br><span class="line">state &lt;= state_A;</span><br><span class="line">led &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">        <span class="comment">// 表示当前状态不属于以上状态，让状态回到state_A</span></span><br><span class="line"><span class="keyword">default</span>:<span class="keyword">begin</span></span><br><span class="line">state &lt;= state_A;</span><br><span class="line">led &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>仿真图如下：</p><img src="/blog/2020/07/14/Verilog基础1/image4"><p>当<code>state = 000</code>时，在<code>divclk</code>的下一个上升沿时<code>led = 1</code>，以此类推</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Verilog基础&quot;&gt;&lt;a href=&quot;#Verilog基础&quot; class=&quot;headerlink&quot; title=&quot;Verilog基础&quot;&gt;&lt;/a&gt;Verilog基础&lt;/h2&gt;&lt;p&gt;学习verilog基础语法1&lt;/p&gt;
    
    </summary>
    
    
      <category term="FPGA" scheme="http://www.xingyuzhao.ltd/categories/FPGA/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode718-最长重复子数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/07/03/LeetCode718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/07/03/LeetCode718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-03T15:35:56.000Z</published>
    <updated>2020-08-16T15:06:21.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p><a id="more"></a><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/示例.png" style="zoom: 80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目的意思很好理解，如示例所示，公共的子数组除了单一的数值<code>[1],[2],[3]</code>，也有<code>[2,1],[3,2,1]</code>这些数组，其中最长的就是<code>[3,2,1]</code>这个数组，长度为3。像题目出现<strong>最长，最短</strong>之类的字都可以考虑用动态规划去解决。</p><h4 id="一、定义dp数组的含义"><a href="#一、定义dp数组的含义" class="headerlink" title="一、定义dp数组的含义"></a>一、定义dp数组的含义</h4><p>数组A长5，数组B长5，我们假设存在一个<code>6×6</code>的<code>dp</code>矩阵，使得矩阵坐标从1开始，同时保证边界位置上的计算，并初始化所有值为0。<strong>矩阵表示固定A的值时，到B数组的当前值与到A固定值的公共数组长度</strong>：</p><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index.png"><p>我们固定A数组，然后去遍历B数组。假如<code>A[i]=B[j]</code>时，公共数组的长度在上一次长度的基础上+1，否则不变，在后续分析中可以看到。</p><p>比如说<code>A[0]=1</code>，此时遍历B数组，<code>B[0]=3</code>，两个值不等。因为我们建立数组时候起始坐标是从1开始的，所以<code>dp[1][1] = 0</code>。继续遍历B数组，可以得到以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[1][2] = 0</span><br><span class="line">dp[1][3] = 1</span><br><span class="line">dp[1][4] = 0</span><br><span class="line">dp[1][5] = 0</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index1.png"><p>接下来改变A值，<code>A[1]=2</code>，可以得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[2][1] = 0</span><br><span class="line">dp[2][2] = 1</span><br><span class="line">dp[2][3] = 0</span><br><span class="line">dp[2][4] = 0</span><br><span class="line">dp[2][5] = 0</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index2.png"><p>同理<code>A[2]=3</code>：</p><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index3.png"><p>当<code>A[3]=2,B[1]=2</code>时，此时满足<code>value(A)==value(B)</code>，所以<code>dp[4][2] = dp[3][1] + 1 = 2</code>，如图：</p><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index4.png"><p>当<code>A[4]=1,B[2]=1</code>时，此时满足<code>value(A)==value(B)</code>，所以<code>dp[5][3] = dp[4][2] + 1 = 3</code>，如图：</p><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index5.png"><p>遍历完一次B数组后更新最大长度，所以最后最大的公共数组长度就是3。</p><h4 id="二、状态转移方程"><a href="#二、状态转移方程" class="headerlink" title="二、状态转移方程"></a>二、状态转移方程</h4><p>根据上述分析，可以得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>])</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> **dp = <span class="keyword">new</span> <span class="keyword">int</span>*[A.size()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[B.size()+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size() + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从前往后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                res = max(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给两个整数数组 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，返回两个数组中公共的、长度最长的子数组的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>堆排序(heap sort)</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/27/%E5%A0%86%E6%8E%92%E5%BA%8F-heap-sort/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/27/%E5%A0%86%E6%8E%92%E5%BA%8F-heap-sort/</id>
    <published>2020-06-27T03:27:56.000Z</published>
    <updated>2020-09-06T05:38:55.756Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序是一种特殊的排序算法，涉及到了优先级的概念</p><p>更新于2020/7/12</p><h3 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h3><ol><li>了解优先队列的一些概念</li><li>堆排序概念及实现</li></ol><a id="more"></a><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul><li>普通队列：FIFO</li><li>优先队列：出队顺序与入队无关，与优先级有关</li></ul><p>为什么选择优先队列？</p><p>比如：在10000000个元素中选择前100名？(在N个元素中选择前M个)</p><ul><li>排序算法复杂度 O(NlogN)</li><li>优先队列 O(NlogM)</li></ul><p>优先队列的实现方法：</p><img src="/blog/2020/06/27/堆排序-heap-sort/实现方式.png" style="zoom:80%;"><p>使用普通数组在出队时需要遍历一次找到优先级最高的元素；顺序数组在每次插入的时候也要遍历一次找到相应的位置；使用堆这种结构可以让入队出队复杂度都为O(logN)。</p><h3 id="堆的基本实现"><a href="#堆的基本实现" class="headerlink" title="堆的基本实现"></a>堆的基本实现</h3><h4 id="二叉堆-Binary-Heap"><a href="#二叉堆-Binary-Heap" class="headerlink" title="二叉堆(Binary Heap)"></a>二叉堆(Binary Heap)</h4><p>二叉堆类似于二叉树，是一种树状结构，可以用数组来存储二叉堆，以最大堆为例。</p><p>最大堆：</p><ul><li><strong>堆中的某个节点值不大于其父亲节点(不意味着层数越高，数值越大)</strong></li><li><strong>堆总是一棵完全二叉树(这也是可以用数组表示的原因)</strong></li></ul><img src="/blog/2020/06/27/堆排序-heap-sort/二叉堆1.png" style="zoom:80%;"><p>给每个节点按照从上到小，从左到右进行编号，可以有以下的性质：</p><ul><li><strong>左节点的序号是父节点的二倍</strong></li><li><strong>右边序号为父节点的二倍加1</strong></li></ul><img src="/blog/2020/06/27/堆排序-heap-sort/二叉堆2.png" style="zoom:80%;"><p>用1来做起始标号是经典实现办法，数组对应的标号就是节点的索引：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组1.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 找到i的父节点序号</span><br><span class="line">parent[i] = i / <span class="number">2</span></span><br><span class="line"># i节点的孩子节点序号</span><br><span class="line">leftChild[i] = <span class="number">2</span> * i</span><br><span class="line">rightChild[i] = <span class="number">2</span> * i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>构建堆的基本结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="添加元素-Shift-Up"><a href="#添加元素-Shift-Up" class="headerlink" title="添加元素(Shift Up)"></a>添加元素(Shift Up)</h4><p>由于是用数组实现的堆，所以添加一个新的元素相当于在数组的末尾添加了一个元素：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组2.png"><p>相应的树形结构如下：</p><img src="/blog/2020/06/27/堆排序-heap-sort/shiftup1.png" style="zoom:80%;"><p>显然此时不符合最大堆的定义，新加入的52大于其父节点16，所以两个需要交换位置，以此类推，将52放在合适的位置，如下图所示：</p><img src="/blog/2020/06/27/堆排序-heap-sort/shiftup2.png" style="zoom: 67%;"><p>最终数组里的值为下图：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组3.png"><p><strong>Shift Up</strong>代码实现(在基本结构基础上)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 孩子节点大于父节点需要交换，并更新节点位置</span></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k] )&#123;</span><br><span class="line">            swap( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="comment">//添加新元素</span></span><br><span class="line">        data[count+<span class="number">1</span>] = item;</span><br><span class="line">        count ++;</span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="取出元素-Shift-Down"><a href="#取出元素-Shift-Down" class="headerlink" title="取出元素(Shift Down)"></a>取出元素(Shift Down)</h4><p>对于堆来说，每次只能取根节点的那个元素，在这里就是取最大的元素。</p><p>取出最大的元素后，根节点的位置就空出来了，这时候把最后一个元素补充到根节点处(保证仍然是一棵完全二叉树)，此时作为计数的变量<code>count--</code>，最后一个数组中的元素可以不动，使用<code>count</code>来卡住边界。</p><img src="/blog/2020/06/27/堆排序-heap-sort/shiftdown1.png" style="zoom:80%;"><p>此时数组中的元素为：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组4.png"><p>此时16也不满足最大堆的定义，接下来要调整这些元素的位置。将16一步一步的向下挪，直到合适的位置，所以叫<strong>Shift Down</strong>，不过每次下挪，有两个方向可以走，具体怎么选？<strong>需要找到子节点中更大的那个值进行交换</strong>，这样就可以保证子节点一定是不大于父节点的，过程如下：</p><img src="/blog/2020/06/27/堆排序-heap-sort/shiftdown2.png" style="zoom:80%;"><p>此时数组中的元素为：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组5"><p><strong>Shift Down</strong>代码实现(在基本结构基础上)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断k是否有孩子</span></span><br><span class="line">        <span class="comment">// 对于完全二叉树，有左孩子就代表一定有孩子</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="comment">// j+1为右孩子，需要判断是否存在</span></span><br><span class="line">            <span class="comment">// 再判断应该和哪个孩子交换</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] ) <span class="comment">// 右孩子大</span></span><br><span class="line">                j ++; <span class="comment">// j代表右孩子，否则为左孩子</span></span><br><span class="line">            <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            swap( data[k] , data[j] );</span><br><span class="line">            k = j; <span class="comment">// 交换后的新节点，继续Shift Down</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Heapify-将普通数组变为堆"><a href="#Heapify-将普通数组变为堆" class="headerlink" title="Heapify(将普通数组变为堆)"></a>Heapify(将普通数组变为堆)</h4><img src="/blog/2020/06/27/堆排序-heap-sort/数组6.png"><p>对于以上数组，可以直接构建成堆，不用先进行插入元素，二叉树形式为下图：</p><img src="/blog/2020/06/27/堆排序-heap-sort/heapify1.png" style="zoom:80%;"><p>对于上图的树来说，所有的叶子节点都是一个最大堆：</p><img src="/blog/2020/06/27/堆排序-heap-sort/heapify2" style="zoom:80%;"><p>第一个非叶子节点的位置为<code>count/2</code>，即<code>10/2=5</code>，对于每个非叶子节点进行<strong>Shift Down</strong>操作。</p><img src="/blog/2020/06/27/堆排序-heap-sort/heapify3" style="zoom: 67%;"><p><strong>Heapify</strong>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断k是否有孩子</span></span><br><span class="line">        <span class="comment">// 对于完全二叉树，有左孩子就代表一定有孩子</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k; </span><br><span class="line">            <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="comment">// j+1为右孩子，需要判断是否存在</span></span><br><span class="line">            <span class="comment">// 再找到值更大的孩子</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] ) </span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// 如果孩子中最大值小于等于父节点的值，就不用交换了</span></span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            swap( data[k] , data[j] );</span><br><span class="line">            <span class="comment">// 交换后的新节点，继续Shift Down</span></span><br><span class="line">            k = j; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据数组直接构造最大堆</span></span><br><span class="line">    MaxHeap(Item arr[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="原地堆排序-从小到大"><a href="#原地堆排序-从小到大" class="headerlink" title="原地堆排序(从小到大)"></a>原地堆排序(从小到大)</h3><p>在之前构建一个堆需要额外的n个空间，实际上给定数组时候在原地也可以进行堆排序，过程如图所示：</p><img src="/blog/2020/06/27/堆排序-heap-sort/原地1.png" style="zoom:80%;"><ul><li>先对数组进行<code>Heapify</code>操作，则V就是最大值，V和W进行交换，此时最大值在末尾</li><li>此时V之前的数组不再是最大堆，对W进行<code>ShiftDown</code>操作使之前的数组再次成为最大堆</li><li>再次把此时的V和W(倒数第二个元素)进行交换，以此类推。</li></ul><p><strong>此时的索引是从0开始的</strong>，所以最后一个非叶子节点的索引为<code>(count-1)/2</code>，对于节点<strong>i</strong>，有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent[i] = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">left child[i] = <span class="number">2</span> × i + <span class="number">1</span>;</span><br><span class="line">right child[i] = <span class="number">2</span> × i + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><img src="/blog/2020/06/27/堆排序-heap-sort/原地2.png" style="zoom:80%;"><p>对应的数组为：</p><img src="/blog/2020/06/27/堆排序-heap-sort/原地3.png"><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// heapify</span></span><br><span class="line">    <span class="comment">// from 第一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        __shiftDown(arr, n, i);</span><br><span class="line">    <span class="comment">// i最后为1，当只有也给元素时无需进行操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        __shiftDown(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">void</span> __shiftDown(T arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="comment">// 从0开始索引，k为父节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> * k + <span class="number">1</span> &lt; n)&#123; <span class="comment">// 如果左孩子存在</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 以下操作是为了与左右孩子中更大的那个交换</span></span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j])</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[k] &gt;= arr[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr[k], arr[j]);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125; </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="索引堆-Index-Heap"><a href="#索引堆-Index-Heap" class="headerlink" title="索引堆(Index Heap)"></a>索引堆(Index Heap)</h3><p>当进行堆排序之后，坐标和值的关系也就不复存在了，如果我们要继续使用坐标和值之间的关系，就需要对索引进行堆排序，以最大索引堆为例：</p><img src="/blog/2020/06/27/堆排序-heap-sort/index_heap1.png" style="zoom:80%;"><ul><li><code>data</code>数组并未改变，只有<code>index</code>数组发生了改变(<strong>根据data改变index</strong>)</li><li>堆顶的元素<code>index[1] = 10</code>，表示堆顶的元素是<strong>10索引</strong>所指向的<code>data[10]</code>，即62</li><li>同理可得，<code>index[2] = 9</code>表示62的左孩子是<strong>9索引</strong>所指向的<code>data[9] = 41</code>，<code>index[3] = 7</code>表示62的右孩子是<strong>7索引</strong>所指向的<code>data[7] = 28</code>，以此类推</li></ul><p><strong>优点</strong>：只有索引<code>index整型</code>数组发生了改变，<code>data</code>并未改变，<code>data</code>的类型并没有限制</p><p>对于<code>shiftDown</code>和<code>shiftUp</code>变化不大，同时可以支持返回最大值的索引值，也可以根据索引值就直接返回<code>data</code>，最重要的操作是修改数据内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    data[i] = newItem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到indexes[j] = i, j表示data[i]在堆中的位置</span></span><br><span class="line">    <span class="comment">// 之后shiftUp(j), 再shiftDown(j)，再次将index构建为最大堆</span></span><br><span class="line"><span class="comment">// 这里用的是遍历，复杂度较高O(n + logn)</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= count ; j ++ )</span><br><span class="line">        <span class="keyword">if</span>( indexes[j] == i )&#123;</span><br><span class="line">            shiftUp(j);</span><br><span class="line">            shiftDown(j);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化-change"><a href="#优化-change" class="headerlink" title="优化(change)"></a>优化(change)</h4><img src="/blog/2020/06/27/堆排序-heap-sort/index_heap2.png"><ul><li><code>reverse[i]</code>表示索引<code>i</code>在<code>index</code>中的位置</li><li>比如我们要查找<code>i = 4</code>这个索引在<code>index</code>中的位置，先找到<code>rev[4] = 9</code>，那么索引<code>i = 4</code>就在<code>index[9]</code>处，时间复杂度为O(1)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indexes[i] = j;</span><br><span class="line">reverse[j] = i;</span><br><span class="line"></span><br><span class="line">indexes[reverse[i]] = i;</span><br><span class="line">reverse[indexes[i]] = i;</span><br></pre></td></tr></table></figure><p>在<code>swap</code>操作中需要修改<code>reverse</code></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IndexMaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化为0，代表不存在</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= capacity ; i ++ )</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    ~IndexMaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">        <span class="keyword">delete</span>[] reverse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count+<span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 抽取最大的元素</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        <span class="comment">// 此时最后一个元素没有意义了</span></span><br><span class="line">        <span class="comment">// 此时的堆顶的第一个元素的reverse需要更新</span></span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 抽取最大元素的坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回最大元素的值</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回最大元素的坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 保证不越界</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回i处的元素值</span></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( contain(i) );</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 改变i处的元素值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        assert( contain(i) );</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = reverse[i];</span><br><span class="line">        shiftUp( j );</span><br><span class="line">        shiftDown( j );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]] &lt; data[indexes[k]] )&#123;</span><br><span class="line">            swap( indexes[k/<span class="number">2</span>] , indexes[k] );</span><br><span class="line">            reverse[indexes[k/<span class="number">2</span>]] = k/<span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]] &gt; data[indexes[j]] )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]] &gt;= data[indexes[j]] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap( indexes[k] , indexes[j] );</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            reverse[indexes[j]] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="用堆解决第一节问题思路"><a href="#用堆解决第一节问题思路" class="headerlink" title="用堆解决第一节问题思路"></a>用堆解决第一节问题思路</h3><p>使用堆实现优先队列，动态选择优先级最高的任务执行。</p><p>第一节中的问题，在10000000个元素中选出前100名(在N个元素中选前M个元素)，维护一个优先队列(长度为100)，每次把最小的移除，遍历完成后，最后剩下的100个元素就是前100个元素。</p><h3 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h3><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆排序是一种特殊的排序算法，涉及到了优先级的概念&lt;/p&gt;
&lt;p&gt;更新于2020/7/12&lt;/p&gt;
&lt;h3 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;了解优先队列的一些概念&lt;/li&gt;
&lt;li&gt;堆排序概念及实现&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://www.xingyuzhao.ltd/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>string操作总结(不定期更新)</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/25/string%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/25/string%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-25T09:25:18.000Z</published>
    <updated>2020-06-25T12:50:31.442Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下C++中string的常见用法，包括但不局限于：</p><ol><li>初始化</li><li>string对象上的操作（包括取子串）</li><li>查找/删除/替换</li><li>与数值的相互转换</li></ol><a id="more"></a><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化，s1为空</span></span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="comment">//用s1初始化s2</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="comment">//s3为字面值"value"的副本，直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;</span><br><span class="line"><span class="comment">//与上述等价，不同之处在于这里是拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"value"</span>;</span><br><span class="line"><span class="comment">//类似vector，n个'c'组成字符串s4</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从is读取一行给s，返回is</span></span><br><span class="line">getline(is, s)</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line">s.empty()</span><br><span class="line"><span class="comment">//s的长度</span></span><br><span class="line">s.size() / s.length()</span><br><span class="line"><span class="comment">//完全一样则相等，大小写敏感</span></span><br><span class="line">s1 == s2</span><br><span class="line"><span class="comment">//字典序比较，大小写敏感</span></span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=</span><br></pre></td></tr></table></figure><h4 id="两个string对象相加"><a href="#两个string对象相加" class="headerlink" title="两个string对象相加"></a>两个string对象相加</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello, "</span>, s2 = <span class="string">"world"</span>;</span><br><span class="line"><span class="comment">//s3 = "hello, world"</span></span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2;</span><br><span class="line"><span class="comment">//s1 = "hello, world"</span></span><br><span class="line">s1 += s2;</span><br></pre></td></tr></table></figure><h4 id="字面值和string对象相加"><a href="#字面值和string对象相加" class="headerlink" title="字面值和string对象相加"></a>字面值和string对象相加</h4><p>当把string对象和字符字面值及字符串字面值混在一起相加时，必须确保<code>+</code>的两侧运算对象至少有一个string：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">","</span>; <span class="comment">//√</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hello"</span> + <span class="string">","</span><span class="comment">//×</span></span><br></pre></td></tr></table></figure><p>注意：字符串字面值与string是不同类型，以上操作是自动进行了类型转换。</p><h4 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在头文件cctype中</span></span><br><span class="line"><span class="built_in">isalnum</span>(c)<span class="comment">//当c是字母或数字为真</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)<span class="comment">//当c是字母为真</span></span><br><span class="line"><span class="built_in">iscntrl</span>(c)<span class="comment">//当c是控制字符为真，ASCII码前32</span></span><br><span class="line"><span class="built_in">isdigit</span>(c)<span class="comment">//当c是数字为真</span></span><br><span class="line"><span class="built_in">islower</span>(c)<span class="comment">//当c是小写字母为真</span></span><br><span class="line"><span class="built_in">isupper</span>(c)<span class="comment">//当c是大写字母为真</span></span><br><span class="line"><span class="built_in">ispunct</span>(c)<span class="comment">//当c是标点符号为真</span></span><br><span class="line"><span class="built_in">isspace</span>(c)<span class="comment">//当c是空白为真(空格，回车，制表符等)</span></span><br><span class="line"><span class="built_in">tolower</span>(c)<span class="comment">//如果c为大写字母，转为小写，否则不变</span></span><br><span class="line"><span class="built_in">toupper</span>(c)<span class="comment">//如果c为小写字母，转为大写，否则不变</span></span><br></pre></td></tr></table></figure><p><strong>范围for语句</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印s1的所有内容</span></span><br><span class="line"><span class="comment">//仅访问时可加上const</span></span><br><span class="line"><span class="comment">//简化类型名可用auto代替</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"zhaoxingyu"</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span> s : s1)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line"><span class="comment">//同时修改s1内容全为a</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span> &amp;s : s1)</span><br><span class="line">    s = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h4 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s.substr(pos, n)</span></span><br><span class="line"><span class="comment">//取s中从pos开始长度为n的子串</span></span><br><span class="line"><span class="comment">//如果pos超过s.size()则抛出out_of_range异常</span></span><br><span class="line"><span class="comment">//如果pos+n超过s.size()则substr自动调整n值，只拷贝到s末尾</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">string</span> str = s.substr(<span class="number">0</span>, <span class="number">5</span>);<span class="comment">//str = "hello"</span></span><br></pre></td></tr></table></figure><h3 id="查找-删除-替换"><a href="#查找-删除-替换" class="headerlink" title="查找/删除/替换"></a>查找/删除/替换</h3><h4 id="查找函数find"><a href="#查找函数find" class="headerlink" title="查找函数find"></a>查找函数find</h4><p>string中的find函数返回子串/字符第一次出现在母串中的位置，类型为size_t，可以把它视为一个范围很大的int类型。如果没有找到，返回一个npos标记，是一个很大的整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size_t pos = s.find(str, startPos)</span></span><br><span class="line"><span class="comment">//str为子串或字符，startPos为开始搜索位置，缺省时默认为0</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">size_t</span> pos = s.find(str);<span class="comment">//等价于pos = s.find("world")，返回6</span></span><br><span class="line"><span class="keyword">size_t</span> pos1 = s.find(<span class="string">"c"</span>);<span class="comment">//等价于pos1 = s.find('c')，返回npos</span></span><br></pre></td></tr></table></figure><p>还可以从后往前反向查找，函数为rfind</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">size_t</span> pos = s.rfind(<span class="string">"l"</span>); <span class="comment">//返回9</span></span><br></pre></td></tr></table></figure><p>其他一些find函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回子串首次出现位置</span></span><br><span class="line">pos = s.find_first_of(str);</span><br><span class="line"><span class="comment">//返回字串最后出现位置</span></span><br><span class="line">pos = s.find_last_of(str);</span><br></pre></td></tr></table></figure><h4 id="删除函数erase"><a href="#删除函数erase" class="headerlink" title="删除函数erase"></a>删除函数erase</h4><p>string中提供的成员函数可以用来删除字符串中的字符，这里主要介绍<code>erase</code>方法</p><ol><li>从给定位置pos开始删除长度为n的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//basic_string &amp; erase(size_type pos=0, size_type n=npos)</span></span><br><span class="line"><span class="comment">//n缺省时默认为删除到末尾</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line">s.erase(<span class="number">5</span>);<span class="comment">//从位置5开始全部删除，s = "hello";</span></span><br><span class="line">s.erase(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">//从0开始删除长度为2的字符串，s = "llo"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>删除迭代器位置处的单个字符，并返回<strong>下个元素</strong>的迭代器</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterator erase(const_iterator position)</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line">s.erase(s.begin());<span class="comment">//s = "ello world";</span></span><br></pre></td></tr></table></figure><ol start="3"><li>删除迭代器<code>[first, last)</code>区间的所有字符,返回一个指向被删除的最后一个元素的下一个字符的迭代器.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterator erase(const_iterator first, const_iterator last)</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">//iter = s.erase(s.begin() + 1, s.end() - 1);  //可以直接删除</span></span><br><span class="line"><span class="keyword">auto</span> iter = s.erase(s.begin() + <span class="number">1</span>, s.end() - <span class="number">1</span>); <span class="comment">//删除并返回迭代器</span></span><br><span class="line"><span class="comment">//s = "hd"，*iter = d</span></span><br></pre></td></tr></table></figure><p><strong>注：也可以用pop_back()删除最后一个元素</strong></p><h4 id="替换函数replace"><a href="#替换函数replace" class="headerlink" title="替换函数replace"></a>替换函数replace</h4><ol><li>用str替换指定字符串从pos开始长度为len的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp; replace(size_t pos, size_t len, const string&amp; str)</span></span><br><span class="line"><span class="comment">//注意这里的str必须是string对象，不能是char字符</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">s = s.replace(<span class="number">0</span>, <span class="number">5</span>, str);<span class="comment">//s = "# world"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>用str替换迭代器起始位置到终止位置的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp; replace(const_iterator it1, const_iterator it2, const string&amp; str)</span></span><br><span class="line"><span class="comment">//注意这里的str必须是string对象，不能是char字符</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">s = s.replace(s.begin(), s.begin() + <span class="number">5</span>, str);<span class="comment">//s = "# world"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>用重复n次的c字符替换从指定位置pos长度为len的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp; replace(size_t pos, size_t len, size_t n, char c)</span></span><br><span class="line"><span class="comment">//注意这里的c必须是char类型，不能是string对象</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'#'</span>;</span><br><span class="line">s = s.replace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, c);<span class="comment">//s = "## world"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>用重复n次的c字符替换从指定迭代器位置到终止位置的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp; replace (const_iterator i1, const_iterator i2, size_t n, char c)</span></span><br><span class="line"><span class="comment">//注意这里的c必须是char类型，不能是string对象</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'#'</span>;</span><br><span class="line">s = s.replace(s.begin(), s.end(), <span class="number">2</span>, c);<span class="comment">//s = "## world"</span></span><br></pre></td></tr></table></figure><h3 id="string与int相互转换"><a href="#string与int相互转换" class="headerlink" title="string与int相互转换"></a>string与int相互转换</h3><h4 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># string直接转int</span></span><br><span class="line"><span class="comment">//stoi(s, pos, b) 把字符串s从pos开始转换成b进制的int</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//a = 123，如果里面含有非数字，那么从pos开始连续的字符串型数字才会被转为数字</span></span><br><span class="line"><span class="keyword">int</span> a = stoi(s, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//stol(s,p,b)把字符串s从p开始转换成b进制的long</span></span><br><span class="line"><span class="comment">//stoul(s,p,b)把字符串s从p开始转换成b进制的unsigned long</span></span><br><span class="line"><span class="comment">//stoll(s,p,b)把字符串s从p开始转换成b进制的long long</span></span><br><span class="line"><span class="comment">//stoull(s,p,b)把字符串s从p开始转换成b进制的unsigned long long</span></span><br><span class="line"><span class="comment">//stof(s,p)把字符串s从p开始转换成float</span></span><br><span class="line"><span class="comment">//stod(s,p)把字符串s从p开始转换成double</span></span><br><span class="line"><span class="comment">//stold(s,p)把字符串s从p开始转换成long double</span></span><br><span class="line"><span class="meta"># char型数组字符串转int</span></span><br><span class="line"><span class="comment">//c_str()函数返回一个指向正规C字符串的指针, 内容与string串相同</span></span><br><span class="line"><span class="comment">//string类对象的成员函数c_str()把string转换为c类型字符串</span></span><br><span class="line"><span class="comment">//如果string不是数字形式的则转换结果为0</span></span><br><span class="line"><span class="comment">//实际步骤为string-&gt;char*-&gt;int</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> a = atoi(s.c_str());<span class="comment">//a = 123</span></span><br></pre></td></tr></table></figure><h4 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//to_string(val) 将val转为string</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">string</span> s = to_string(val);<span class="comment">//s = "100"</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>查找/删除/替换：</p><ol><li><p><a href="https://www.cnblogs.com/xzxl/p/7243490.html" target="_blank" rel="noopener">https://www.cnblogs.com/xzxl/p/7243490.html</a></p></li><li><p><a href="https://blog.csdn.net/cai_niaocainiao/article/details/81260902?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/cai_niaocainiao/article/details/81260902?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase</a></p></li><li><p><a href="https://blog.csdn.net/u010472607/article/details/80431604" target="_blank" rel="noopener">https://blog.csdn.net/u010472607/article/details/80431604</a></p></li></ol><p>字符串转数值</p><p><a href="https://blog.csdn.net/sinat_40872274/article/details/81367815" target="_blank" rel="noopener">https://blog.csdn.net/sinat_40872274/article/details/81367815</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下C++中string的常见用法，包括但不局限于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;li&gt;string对象上的操作（包括取子串）&lt;/li&gt;
&lt;li&gt;查找/删除/替换&lt;/li&gt;
&lt;li&gt;与数值的相互转换&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="string" scheme="http://www.xingyuzhao.ltd/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>git提交失败-ssh重置</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/25/git%E6%8F%90%E4%BA%A4%E5%A4%B1%E8%B4%A5-ssh%E9%87%8D%E7%BD%AE/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/25/git%E6%8F%90%E4%BA%A4%E5%A4%B1%E8%B4%A5-ssh%E9%87%8D%E7%BD%AE/</id>
    <published>2020-06-25T09:13:36.000Z</published>
    <updated>2020-07-15T00:59:06.015Z</updated>
    
    <content type="html"><![CDATA[<p>一段时间不提交，就容易出现“Please make sure you have the correct access rights and the repository exists.”，原因是ssh key出现了问题，记录一下解决方法，省的每次都去百度细节。</p><p><strong>用手机热点可以提交成功，尚不清楚原因(updated：2020/7/15)</strong> </p><a id="more"></a><ol><li><p>重新配置身份信息</p><ul><li><code>git config --global user.name &quot;yourname&quot;</code></li><li><code>git config --global user.email &quot;your@email.com&quot;</code></li></ul></li><li><p>删除.ssh文件夹下的所有文件</p></li><li><p>输入命令<code>ssh-keygen -t rsa -C &quot;your@email.com&quot;</code>，出现提示直接回车</p></li><li><p>此时在.ssh文件夹下生成<strong>id_rsa</strong>和<strong>id_rsa.pub</strong>，用记事本打开<strong>id_rsa.pub</strong>并复制所有内容</p></li><li><p>打开github主页并进入到<code>SSH and GPG keys</code>中，新建shh，把刚才复制的内容粘贴进去</p></li><li><p>输入命令<code>ssh -T git@github.com</code>，出现提示输入<code>yes</code>，不是直接回车</p></li><li><p><strong>重新打开</strong>git进行提交</p></li></ol><p>以上所有git操作都在hexo根目录下</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一段时间不提交，就容易出现“Please make sure you have the correct access rights and the repository exists.”，原因是ssh key出现了问题，记录一下解决方法，省的每次都去百度细节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用手机热点可以提交成功，尚不清楚原因(updated：2020/7/15)&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="常见问题" scheme="http://www.xingyuzhao.ltd/categories/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode139-单词拆分</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/25/LeetCode139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/25/LeetCode139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</id>
    <published>2020-06-25T08:03:33.000Z</published>
    <updated>2020-06-25T13:00:07.411Z</updated>
    
    <content type="html"><![CDATA[<p>这道题我一开始没想到可以用动态规划来做，先试着用暴力做了，结果通过34/36，看似只剩下3个没通过，但是问题很大，不好修改，具体原因后面分析。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><a id="more"></a><img src="/blog/2020/06/25/LeetCode139-单词拆分/示例.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题题意还是挺好理解的，给定字符串s，从字典wordDict中取出单个或多个字符串（可重复），最后如果可以拼接成s，返回true，反之返回false。</p><p>一开始暴力的思路就是遍历字典中的每一个字符串看是否出现在s中，如果出现了，那么用#号来代替s中的出现的子串，并且继续搜索，搜索完成后，将s中的#号清空，如果此时s为空，那么代表s可以被拆分，返回true。但是对于以下的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abbbc"</span></span><br><span class="line">wordDict = [<span class="string">"ab"</span>, <span class="string">"b"</span>, <span class="string">"bbc"</span>]</span><br></pre></td></tr></table></figure><p>s可以由ab+bbc组合而成。但是用暴力法，只会搜到ab+b+b，再往下就搜索不到了，返回了false。如果需要修改，要用到dfs的思想，进行深搜，但是不剪枝也容易超时。在看了答案之后才知道可以用动态规划来做，而且很好理解。</p><p>按照第二个示例来说，<code>s = &quot;applepenapple&quot;, wordDcit = [&quot;apple&quot;, &quot;pen&quot;]</code>，从s的第一个字符<code>a</code>开始遍历：</p><ul><li>当等于<code>apple</code>时候，存在与字典中，就可以认为在第5个字符处是可以拆的；</li><li>继续向后遍历，当得到<code>applepen</code>时，增加了字符串<code>pen</code>，且它存在于字典中，所以可以知道第8个字符处也是可拆的；</li><li>直到<code>applepenapple</code>时，增加了<code>apple</code>，且它存在于字典中，最后一个字符即第13个字符处可拆。</li></ul><p>从上述分析可以知道，如果最后一个字符处可拆，就返回true，否则返回false。</p><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p>首先，<code>dp</code>数组应该是<code>bool</code>类型，长度为<code>s.length()+1</code>，并且<code>dp[0]=true</code>，否则dp数组全是false。<strong>dp数组含义为当前位置的字符是否可以被拆分</strong>。</p><p>如果<code>dp[j]</code>代表当前位置，<code>dp[i]</code>是某一起始位置，那么就需要检查从<code>i</code>到<code>j</code>的子串是否在字典中，如果在，并且<code>dp[i]</code>是可以拆分的，那么<code>dp[j]</code>也应该是可以拆分的，否则<code>dp[j]=false</code>。</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>根据上面的分析，可以容易写出以下的状态转移方程，同时将字典放入<code>unordered_map</code>中方便查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = dp[i] &amp;&amp; dict.count(s.substr(i, j - i))</span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存入字典，方便查找</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; dict; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;word : wordDict) dict[word] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 初始化dp数组，如果s为空，返回true</span></span><br><span class="line">        <span class="comment">// 实际上只初始化dp[0]即可</span></span><br><span class="line">        <span class="keyword">bool</span> *dp = <span class="keyword">new</span> <span class="keyword">bool</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                dp[j] = dp[i] &amp;&amp; dict.count(s.substr(i, j - i));</span><br><span class="line">                <span class="keyword">if</span>(dp[j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-ju-jue-zhuang-xcong-jian-dan-de-xi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-ju-jue-zhuang-xcong-jian-dan-de-xi/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题我一开始没想到可以用动态规划来做，先试着用暴力做了，结果通过34/36，看似只剩下3个没通过，但是问题很大，不好修改，具体原因后面分析。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拆分时可以重复使用字典中的单词。&lt;/li&gt;
&lt;li&gt;你可以假设字典中没有重复的单词。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode739-每日温度</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/13/LeetCode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/13/LeetCode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</id>
    <published>2020-06-13T03:39:44.000Z</published>
    <updated>2020-06-13T05:11:31.542Z</updated>
    
    <content type="html"><![CDATA[<p>这次主要学习一下单调栈这种数据结构，同时用此数据结构解决739题</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><a id="more"></a><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>先学习一下单调栈这种数据结构，单调栈就是栈的基础上使用一定的逻辑，使栈中的元素单调递增或者递减，一般只处理一种典型的问题，叫做<strong>下一个更大的元素</strong>，这个问题是说：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。举例如下：给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。</p><p>可以这样思考，把数组元素想象成人，如何求2的下一个更大的元素呢？如果2的下一个人比2还低或者一样高，那么就会被2遮挡住，直到第一个比他高的人，他挡不住了，就是答案。</p><img src="/blog/2020/06/13/LeetCode739-每日温度/人.jpg" style="zoom: 30%;"><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; <span class="comment">// 判定个子高矮，nums在s之前</span></span><br><span class="line">            s.pop(); <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">-1</span> : s.top(); <span class="comment">// 这个元素身后的第一个高个</span></span><br><span class="line">        s.push(nums[i]); <span class="comment">// 入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2020/06/13/LeetCode739-每日温度/栈.png" style="zoom: 80%;"><p>以上图是栈中元素的变化情况，只有当新的高个子来临，才会有出栈的操作。</p><h3 id="分析及代码实现"><a href="#分析及代码实现" class="headerlink" title="分析及代码实现"></a>分析及代码实现</h3><p>上面已经把单调栈阐述了一遍，本题唯一的区别是要返回还需要多少天，而不是那天的温度，所以要用栈来存储一下温度的坐标，根据当前温度的坐标与栈顶温度坐标的差作为返回值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 这里放元素索引，而不是元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = T.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">0</span> : (s.top() - i); <span class="comment">// 得到索引间距</span></span><br><span class="line">        s.push(i); <span class="comment">// 加入索引，而不是元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展：如何处理循环数组"><a href="#扩展：如何处理循环数组" class="headerlink" title="扩展：如何处理循环数组"></a>扩展：如何处理循环数组</h3><p>同样是<strong>下一个更大的元素</strong>，现在假设给你的数组是个环形的，如何处理？</p><p>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 。通过取模运算符%就可以模拟环形数组的效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = arr.length(), index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr[index % n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种方法是将数组翻倍，然后进行取模运算，节省空间的做法是直接将循环的坐标变成之前的2倍，代码看起来更容易理解，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>; <span class="comment">// 存放结果</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 假装这个数组长度翻倍了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])</span><br><span class="line">            s.pop();</span><br><span class="line">        res[i % n] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《labuladong的算法小抄》 单调栈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次主要学习一下单调栈这种数据结构，同时用此数据结构解决739题&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。&lt;/p&gt;
&lt;p&gt;例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。&lt;/p&gt;
&lt;p&gt;提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="单调栈" scheme="http://www.xingyuzhao.ltd/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode126-单词接龙2</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/07/LeetCode126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%992/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/07/LeetCode126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%992/</id>
    <published>2020-06-07T14:48:42.000Z</published>
    <updated>2020-06-08T02:35:20.149Z</updated>
    
    <content type="html"><![CDATA[<p>这是今天的每日一题，难度为hard，不过与之前软挑赛的题目有很多相似之处，但是我还是没做出来，还是要多总结。最后看了别人的答案，用BFS+DFS才解决这个问题。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明</strong>：</p><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><a id="more"></a><img src="/blog/2020/06/07/LeetCode126-单词接龙2/示例.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于beginWord，一次只能更改一个字母，同时更改后的字母必须出现在wordList中，所以考虑将wordList放入一个集合中，方便每次判断是否在集合内。一开始我考虑的是直接用DFS解决，虽然DFS可以找到所有路径，然后从中挑选最短，但是它无法直接找到最短路径。如果某条长度过长，很容易出现超时，事实上在刷题群里很多大佬已经出现了这个问题，所以只能找别的办法。直接用BFS是可以的，在找最短的同时记录路径，我没有尝试，之后可以再试试，我选择了使用BFS+DFS的方法，使用BFS建立逆邻接表，使用DFS在逆邻接表基础上搜索答案。</p><h4 id="BFS建立逆邻接表"><a href="#BFS建立逆邻接表" class="headerlink" title="BFS建立逆邻接表"></a>BFS建立逆邻接表</h4><p>使用BFS可以找到最短的路径，可以建立一个逆邻接表，用来表示可以到达当前节点的所有节点(当然这些节点必须是出现在wordList之中的)，<strong>我们用curr代表当前节点，temp代表更改一个字母后的节点</strong>。</p><p>使用<code>unordered_map&lt;string, vector&lt;string&gt;&gt; neighbor</code>来表示，就拿示例1来说，如下图所示：<img src="/blog/2020/06/07/LeetCode126-单词接龙2/邻接表.png"></p><p>上图表示可以到达cog的节点为dog和log，具体的实现还是需要一个记录当前节点深度的哈希表<code>unordered_map&lt;string, int&gt; depth</code>，用来判断curr是否可达temp，同时省去一些不必要的遍历。具体操作是：首先队列弹出curr节点，检查和它相差一个字母的temp是否在wordList中出现，如果出现了：</p><ul><li>没有记录过(<code>depth[temp] = 0</code>)，记录<code>curr-&gt;temp</code>，同时<code>depth[temp] = depth[curr] + 1</code>，将temp入队</li><li>记录过并且相邻(<code>depth[temp] = depth[curr] + 1</code>)，同时避免不是直接相邻的遍历，也避免了往回遍历。如下表，遍历改变pot一个字母的节点时，可能再次出现hot，但是此时<code>depth[hot] = 1 != depth[pot] + 1 = 2</code>所以避免了再次遍历hot。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   hot</span><br><span class="line"> /       \</span><br><span class="line"><span class="attribute">pot</span>     hit</span><br><span class="line"> \        /</span><br><span class="line">    pit</span><br></pre></td></tr></table></figure><p>通过以上步骤就可以建立逆临界表，代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; depth;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; neighbor;</span><br><span class="line"><span class="comment">//将wordList添加至集合中</span></span><br><span class="line"><span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordList.begin(),wordList.end())</span></span>;</span><br><span class="line"><span class="comment">//使用BFS建立逆邻接表</span></span><br><span class="line">depth[beginWord]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; Q;</span><br><span class="line">Q.push(beginWord);</span><br><span class="line"><span class="comment">//从begin到end建图</span></span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line"><span class="built_in">string</span> curr=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;curr.size();++i)&#123;</span><br><span class="line">        <span class="built_in">string</span> temp=curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">'a'</span>;c&lt;=<span class="string">'z'</span>;++c)&#123;</span><br><span class="line">            temp[i]=c;</span><br><span class="line">            <span class="comment">//如果修改后的这个temp是在集合里面</span></span><br><span class="line">            <span class="keyword">if</span>(wordSet.count(temp))&#123;</span><br><span class="line">           <span class="comment">//这个temp还没被添加进neighbor</span></span><br><span class="line">                <span class="keyword">if</span>(depth[temp] == <span class="number">0</span>)&#123; </span><br><span class="line">                    Q.push(temp);</span><br><span class="line">                    depth[temp]=depth[curr]+<span class="number">1</span>;<span class="comment">//更新深度</span></span><br><span class="line">                    neighbor[temp].push_back(curr);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//已经被添加并且相邻</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(depth[temp]==depth[curr]+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    neighbor[temp].push_back(curr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DFS从逆邻接表中搜索答案"><a href="#DFS从逆邻接表中搜索答案" class="headerlink" title="DFS从逆邻接表中搜索答案"></a>DFS从逆邻接表中搜索答案</h4><p>在上一步的BFS中已经存储了每个点的逆邻接点，我们从endWord沿着neighbor往回进行搜索，直到到达beginWord，将已经记录的路径(path)进行反转，存入最终的res中；如果无法到达，则DFS执行至末尾，将path重置(省去了使用&amp;path引用的pop_back()操作)。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;begin, <span class="built_in">string</span> &amp;curr, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;neighbor, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(curr == begin)&#123;</span><br><span class="line">        path.push_back(curr);</span><br><span class="line">        reverse(path.begin(), path.end());</span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(curr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;word : neighbor[curr])&#123;</span><br><span class="line">        dfs(begin, word, path, neighbor, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">findLadders</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">//如果wordList中没有endWord，则返回空</span></span><br><span class="line">        <span class="keyword">if</span>(find(wordList.begin(), wordList.end(), endWord) == wordList.end())</span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;<span class="comment">//记录路径</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; depth;<span class="comment">//记录深度</span></span><br><span class="line">        <span class="comment">//存储节点的逆邻接</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; neighbor;</span><br><span class="line">        <span class="comment">//将wordList添加至集合中</span></span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordset</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        depth[beginWord] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; Q;</span><br><span class="line">        Q.push(beginWord);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> curr = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.size(); i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> temp = curr;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++)&#123;</span><br><span class="line">                    temp[i] = c;</span><br><span class="line">                    <span class="comment">//如果修改后的这个temp是在集合里面</span></span><br><span class="line">                    <span class="keyword">if</span>(wordset.count(temp))&#123;</span><br><span class="line">                        <span class="comment">//这个temp还没被添加进neighbor</span></span><br><span class="line">                        <span class="keyword">if</span>(depth[temp] == <span class="number">0</span>)&#123;</span><br><span class="line">                            Q.push(temp);</span><br><span class="line">                            depth[temp] = depth[curr] + <span class="number">1</span>;<span class="comment">//更新深度</span></span><br><span class="line">                            neighbor[temp].push_back(curr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//已经被添加并且相邻</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(depth[temp] == depth[curr] + <span class="number">1</span>)&#123;</span><br><span class="line">                            neighbor[temp].push_back(curr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(beginWord, endWord, path, neighbor, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;begin, <span class="built_in">string</span> &amp;curr, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;neighbor, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前点已经等于beginWord</span></span><br><span class="line">        <span class="keyword">if</span>(curr == begin)&#123;</span><br><span class="line">            path.push_back(curr);</span><br><span class="line">            reverse(path.begin(), path.end());<span class="comment">//反转</span></span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;word : neighbor[curr])&#123;</span><br><span class="line">            dfs(begin, word, path, neighbor, res);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果没有逆邻接，则执行完毕此函数后，path还原为上一次的值，即省去了pop_back()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/word-ladder-ii/solution/zhe-ti-you-xie-nan-bie-ren-de-dai-ma-zuo-xia-zhu-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder-ii/solution/zhe-ti-you-xie-nan-bie-ren-de-dai-ma-zuo-xia-zhu-s/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是今天的每日一题，难度为hard，不过与之前软挑赛的题目有很多相似之处，但是我还是没做出来，还是要多总结。最后看了别人的答案，用BFS+DFS才解决这个问题。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次转换只能改变一个字母。&lt;/li&gt;
&lt;li&gt;转换过程中的中间单词必须是字典中的单词。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不存在这样的转换序列，返回一个空列表。&lt;/li&gt;
&lt;li&gt;所有单词具有相同的长度。&lt;/li&gt;
&lt;li&gt;所有单词只由小写字母组成。&lt;/li&gt;
&lt;li&gt;字典中不存在重复的单词。&lt;/li&gt;
&lt;li&gt;你可以假设 beginWord 和 endWord 是非空的，且二者不相同。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="BFS" scheme="http://www.xingyuzhao.ltd/tags/BFS/"/>
    
      <category term="DFS" scheme="http://www.xingyuzhao.ltd/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode837-新21点</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/06/LeetCode837-%E6%96%B021%E7%82%B9/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/06/LeetCode837-%E6%96%B021%E7%82%B9/</id>
    <published>2020-06-06T02:53:13.000Z</published>
    <updated>2020-06-06T03:39:57.280Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p><p>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？</p><a id="more"></a><img src="/blog/2020/06/06/LeetCode837-新21点/示例.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题一看不太明白什么意思，看过港片的都知道，在牌面加起来不大于21点时候，谁的牌面最大，谁就能获胜。这道题其实是求爱丽丝获胜的概率，不过点数为N，可以把规则复述一下：</p><ol><li>她可以从<code>[1,W]</code>的牌中任意取一张，可以无限重复取，也就是说取到范围中某张牌的概率一直是<code>1/W</code>；</li><li>如果她手上的牌总额小于K时，她就会继续抽牌，大于等于K时就停止抽牌；</li><li>停止抽牌后，和N进行比较，当小于等于N时，她就获胜了，求获胜的概率。</li></ol><h4 id="定义dp数组的含义"><a href="#定义dp数组的含义" class="headerlink" title="定义dp数组的含义"></a>定义dp数组的含义</h4><p>定义<code>dp[x]</code>为她手上牌面为x时，能获胜的概率。因为每次从<code>[1,W]</code>中抽取的机会都是均等的，所以<code>dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W])</code>。x最多可以到<code>K-1</code>，因为x等于K时会停止抽牌，所以当抽牌结束后，她可能达到的最大牌面是<code>K-1+W</code>，开始时她的牌面为0，所以用长度为K+W的dp数组就够了，最后<code>dp[0]</code>，也就是爱丽丝还没有抽牌时的胜率就是最终答案。</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>其实上一步已经提到了状态转移方程：<code>dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W])</code>，但是dp数组具体应该怎么算呢，可以把它看成一个填格子的游戏，如下图：</p><img src="/blog/2020/06/06/LeetCode837-新21点/image1.png" style="zoom:80%;"><p>将格子分为两个部分，在橘黄色的格子中，爱丽丝是可以抽牌的，而在蓝色的格子中是不可以的。我们每次需要W个格子的结果进行状态转移。</p><p>在蓝色的格子中，对于<code>[K,K+W-1]</code>中小于等于N的值，相应的<code>dp[i]</code>概率就是1，反之为0，在初始化时候进行。</p><img src="/blog/2020/06/06/LeetCode837-新21点/image2.png" style="zoom:80%;"><p>接下来，从K-1处根据状态转移方程进行dp数组的计算。在计算K-2处概率值时，在上一步用一个中间变量<code>sumw</code>保存<code>[K,K+W-1]</code>的概率之和，这样新的概率和<code>sumw = sumw - dp[K-1+W] + dp[K-1]</code>，提高效率。这样从最右边橘黄色格子一直填到最左边，就是最后的结果dp[0]。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(K + W, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">double</span> sumw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K; i &lt;= K + W - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= N) dp[i] = <span class="number">1</span>;</span><br><span class="line">            sumw += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i] = (<span class="keyword">double</span>)<span class="number">1</span> / W * sumw; <span class="comment">//概率可能是小数，需要强制类型转换</span></span><br><span class="line">            sumw = sumw - dp[i+W] + dp[i]; </span><br><span class="line">            <span class="comment">//这里就是减去最右边概率dp[i+W]，加上最左边概率dp[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://leetcode-cn.com/problems/new-21-game/solution/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/new-21-game/solution/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：&lt;/p&gt;
&lt;p&gt;爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。&lt;/p&gt;
&lt;p&gt;当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode877-石子游戏</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/05/28/LeetCode877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/05/28/LeetCode877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</id>
    <published>2020-05-28T11:20:24.000Z</published>
    <updated>2020-05-28T11:56:57.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p><p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p><p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p><a id="more"></a><img src="/blog/2020/05/28/LeetCode877-石子游戏/877.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个题其实一定是先手获胜，为了更具有一般性，假设<strong>石头的堆数可以是任意正整数</strong>，那么就能打破先手必定获胜的局面了，比如<code>piles = [1, 100, 3]</code>，先手不管拿1还是3，能够决胜的100都会被后手拿走，后手获胜。</p><p><strong>博弈问题的难点在于，两个人要轮流进行选择，而且都很精明，应该如何编程表示这个过程呢？</strong>首先明确 dp 数组的含义，只要找到「状态」和「选择」，一切就水到渠成了。</p><h4 id="一、定义-dp-数组的含义"><a href="#一、定义-dp-数组的含义" class="headerlink" title="一、定义 dp 数组的含义"></a>一、定义 dp 数组的含义</h4><p>先看一下dp数组的最终样子，再介绍其含义</p><img src="/blog/2020/05/28/LeetCode877-石子游戏/dp.png" style="zoom:50%;"><p>定义dp数组是二维的，并且每个单元包含first和second两个属性，将这两个属性简写为fir和sec。如按上图的数据，我们说 <code>dp[1][3].fir = 10</code>，<code>dp[0][1].sec = 3</code>。</p><p><strong>以下是对 dp 数组含义的解释：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。</span><br><span class="line">dp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。</span><br><span class="line"></span><br><span class="line">举例理解一下，假设 piles = [<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>]，索引从 <span class="number">0</span> 开始</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>].fir = <span class="number">9</span> 意味着：面对石头堆 [<span class="number">3</span>, <span class="number">9</span>]，先手最终能够获得 <span class="number">9</span> 分。</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">3</span>].sec = <span class="number">2</span> 意味着：面对石头堆 [<span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>]，后手最终能够获得 <span class="number">2</span> 分。</span><br></pre></td></tr></table></figure><p>我们想求的答案是先手和后手最终分数哪个更大，按照这个定义也就是 <code>dp[0][n-1].fir</code>和<code>dp[0][n-1].sec</code>哪个更大。</p><h4 id="二、状态转移方程"><a href="#二、状态转移方程" class="headerlink" title="二、状态转移方程"></a>二、状态转移方程</h4><p>要写状态转移方程，需要找到所有<strong>状态</strong>和每个状态可以做出的<strong>选择</strong>，然后择优。</p><p>根据前面对 dp 数组的定义，<strong>状态</strong>显然有三个：<strong>开始的索引 i，结束的索引 j，当前轮到的人。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j][fir <span class="keyword">or</span> sec]</span><br><span class="line">其中：</span><br><span class="line"><span class="number">0</span> &lt;= i &lt; piles.length</span><br><span class="line">i &lt;= j &lt; piles.length</span><br></pre></td></tr></table></figure><p>对于这个问题的每个状态，可以做的<strong>选择</strong>有两个：<strong>选择最左边的那堆石头，或者选择最右边的那堆石头。</strong></p><p>这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？根据我们对 dp 数组的定义，很容易解决这个难点，<strong>写出状态转移方程：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j].fir = max(piles[i] + dp[i+<span class="number">1</span>][j].sec, piles[j] + dp[i][j<span class="number">-1</span>].sec)</span><br><span class="line">left = piles[i] + dp[i+<span class="number">1</span>][j].sec <span class="comment">//选择最左边的石头堆</span></span><br><span class="line">right = piles[j] + dp[i][j<span class="number">-1</span>].sec <span class="comment">//选择最右边的石头堆</span></span><br><span class="line"># 解释：我作为先手，面对 piles[i...j] 时，有两种选择：</span><br><span class="line"># 要么我选择最左边的那一堆石头，然后面对 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 在上一轮中，我是作为后手的；</span><br><span class="line"># 要么我选择最右边的那一堆石头，然后面对 piles[i...j<span class="number">-1</span>]</span><br><span class="line"># 在上一轮中，我是作为后手的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 先手选择左边:</span><br><span class="line">    dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir</span><br><span class="line"><span class="keyword">if</span> 先手选择右边:</span><br><span class="line">    dp[i][j].sec = dp[i][j<span class="number">-1</span>].fir</span><br><span class="line"># 解释：我作为后手，要等先手先选择，有两种情况：</span><br><span class="line"># 如果先手选择了最左边那堆，给我剩下了 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 此时轮到我，我变成了先手；</span><br><span class="line"># 如果先手选择了最右边那堆，给我剩下了 piles[i...j<span class="number">-1</span>]</span><br><span class="line"># 此时轮到我，我变成了先手。</span><br><span class="line">根据 dp 数组的定义，我们也可以找出base <span class="keyword">case</span>，也就是最简单的情况：</span><br><span class="line"></span><br><span class="line">dp[i][j].fir = piles[i]</span><br><span class="line">dp[i][j].sec = <span class="number">0</span></span><br><span class="line">其中 <span class="number">0</span> &lt;= i == j &lt; n</span><br><span class="line"># 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]，i != j时可以不需要初始化</span><br><span class="line"># 那么显然先手的得分为 piles[i]</span><br><span class="line"># 后手没有石头拿了，得分为 <span class="number">0</span></span><br></pre></td></tr></table></figure><img src="/blog/2020/05/28/LeetCode877-石子游戏/dp1.png" style="zoom:50%;"><p>这里需要注意一点，我们发现 base case 是斜着的，而且我们推算<code>dp[i][j]</code>时需要用到<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>:</p><img src="/blog/2020/05/28/LeetCode877-石子游戏/dp2.png" alt="dp2" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 举例：若i = <span class="number">0</span>, j = <span class="number">1</span></span><br><span class="line"># dp[i][j].fir = <span class="built_in">max</span>(piles[i] + dp[i+<span class="number">1</span>][j].sec, piles[j] + dp[i][j<span class="number">-1</span>].sec)</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>].fir = <span class="built_in">max</span>(piles[<span class="number">0</span>] + dp[<span class="number">1</span>][<span class="number">1</span>].sec, piles[<span class="number">1</span>] + dp[<span class="number">0</span>][<span class="number">0</span>].sec)</span><br><span class="line">     = <span class="built_in">max</span>(<span class="number">3</span> + <span class="number">0</span>, <span class="number">9</span> + <span class="number">0</span>) = <span class="number">9</span></span><br><span class="line"># 先手选择右边第一堆</span><br><span class="line"># <span class="keyword">if</span> 先手选择右边: dp[i][j].sec = dp[i][j<span class="number">-1</span>].fir</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>].sec = dp[<span class="number">0</span>][<span class="number">0</span>].fir = <span class="number">3</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = &#123;<span class="number">9</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>所以说算法不能简单的一行一行遍历 dp 数组，<strong>而要斜着遍历数组：</strong></p><img src="/blog/2020/05/28/LeetCode877-石子游戏/dp3.png" style="zoom:50%;"><p>如何斜着遍历二维数组是个问题，这里我不是很会，只是有个框架，具体的细节还需要再消化消化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 遍历的是橘黄色的部分</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = l + i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/*操作段*/</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><p>实现fir和sec这个单元可以用pair容器，也可以用<code>dp[n][n][2]</code>这种三维数组，我在这里使用了结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> fir;</span><br><span class="line">        <span class="keyword">int</span> sec;</span><br><span class="line">        Pair() &#123;&#125;;</span><br><span class="line">        Pair(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;fir = a;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sec = b;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        Pair** dp = <span class="keyword">new</span> Pair*[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> Pair[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][i].fir = piles[i];</span><br><span class="line">            dp[i][i].sec = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = l + i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> left = dp[i+<span class="number">1</span>][j].sec + piles[i];</span><br><span class="line">                <span class="keyword">int</span> right = dp[i][j<span class="number">-1</span>].sec + piles[j];</span><br><span class="line">                <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                    dp[i][j].fir = left;</span><br><span class="line">                    dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j].fir = right;</span><br><span class="line">                    dp[i][j].sec = dp[i][j<span class="number">-1</span>].fir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>][n<span class="number">-1</span>].fir &gt; dp[<span class="number">0</span>][n<span class="number">-1</span>].sec) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《labuladong的算法小抄》 动态规划之博弈问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。&lt;/p&gt;
&lt;p&gt;游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。&lt;/p&gt;
&lt;p&gt;亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。&lt;/p&gt;
&lt;p&gt;假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode300-最长上升子序列</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/05/26/LeetCode300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/05/26/LeetCode300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-05-26T01:43:18.000Z</published>
    <updated>2020-05-28T12:02:57.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><a id="more"></a><img src="/blog/2020/05/26/LeetCode300-最长上升子序列/sl.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道动态规划的经典入门题，这里的子序列不一定是连续的。比如示例中<code>[2, 3, 7, 101]</code>，只要是递增的，就是上升子序列，我需要找到这里面最长的上升子序列的长度。</p><p>动态规划一般是由历史信息推断当前信息的，并且历史信息是是独立的子问题，相互之间不会影响。现在考虑一个dp数组，如果说dp[0]到dp[i-1]都可以得到了，如果可以推出dp[i]，就可以得到dp数组的全部结果。</p><h4 id="一、定义dp数组的含义"><a href="#一、定义dp数组的含义" class="headerlink" title="一、定义dp数组的含义"></a>一、定义dp数组的含义</h4><p>我们可以定义dp[i]表示以nums[i]这个数结尾的最长上升子序列的长度。举两个例子：</p><img src="/blog/2020/05/26/LeetCode300-最长上升子序列/ex1.png" style="zoom:80%;"><p>根据这个定义，最终结果(子序列的最大长度)就是dp数组中的最大值。</p><h4 id="二、状态转移方程"><a href="#二、状态转移方程" class="headerlink" title="二、状态转移方程"></a>二、状态转移方程</h4><p>这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：</p><p>我们已经知道了 dp[0]到dp[4] 的所有结果，我们如何通过这些已知结果推出 dp[5] 呢？</p><img src="/blog/2020/05/26/LeetCode300-最长上升子序列/ex2.png" style="zoom:80%;"><p>根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。</p><p>nums[5] = 7，既然是递增子序列，我们只要找到前面那些结尾比 7 小的子序列，然后把 7 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p><p>当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[j]) </span><br><span class="line">        dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta"># dp数组需要初始化为1，因为自己本身也算一个序列</span></span><br><span class="line"># 当i = <span class="number">5</span>时</span><br><span class="line"># nums[<span class="number">5</span>] &gt; nums[<span class="number">2</span>] dp[<span class="number">5</span>] = max&#123;dp[<span class="number">5</span>], dp[<span class="number">2</span>] + <span class="number">1</span>&#125; = max&#123;<span class="number">1</span>, <span class="number">2</span>&#125; = <span class="number">2</span></span><br><span class="line"># nums[<span class="number">5</span>] &gt; nums[<span class="number">3</span>] dp[<span class="number">5</span>] = max&#123;dp[<span class="number">5</span>], dp[<span class="number">3</span>] + <span class="number">1</span>&#125; = max&#123;<span class="number">2</span>, <span class="number">2</span> + <span class="number">1</span>&#125; = <span class="number">3</span></span><br><span class="line"># nums[<span class="number">5</span>] &gt; nums[<span class="number">4</span>] dp[<span class="number">5</span>] = max&#123;dp[<span class="number">5</span>], dp[<span class="number">4</span>] + <span class="number">1</span>&#125; = max&#123;<span class="number">3</span>, <span class="number">2</span> + <span class="number">1</span>&#125; = <span class="number">3</span></span><br><span class="line"># 所以dp[<span class="number">5</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>根据上述的状态转移公式，就可以得到dp数组的所有值，我们再取其中的最大值，就是答案。</p><h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = max(dp[i],dp[j] + <span class="number">1</span>); </span><br><span class="line">                <span class="comment">//dp[i]是指历史中的最大长度，否则后面的长度+1小于历史最大长度时，会覆盖</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《labuladong的算法小抄》 动态规划设计：最长递增子序列</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2020学习/工作计划</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/04/30/2020%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/04/30/2020%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2020-04-30T11:38:26.000Z</published>
    <updated>2020-05-28T14:49:21.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ol><li>写在前面</li><li>疫情期间的工作</li><li>反思自己的不足</li><li>2020学习/工作计划</li></ol><a id="more"></a><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>2020年已经过去了四分之一，我才意识到需要做一个全年计划。这几个月来，小计划不断，但是都没有很好的完成，并且很容易受到外界因素的干扰，自己不知道自己到底<strong>需要做什么</strong>，于是看似做了不少东西，但是意义不大。我觉得全年的学习生活应该有一个基调，一年中总是要完成一些事情的。最近几周一直后悔来到西电读研，觉得为什么当初不选择一个985，我觉得我还是可以考上的，去年也没有下定决心再来一年，所以这可能是一辈子的遗憾了，反正读博是不存在的。也许等以后工作了才能慢慢释然吧。</p><h4 id="疫情期间都做了什么？"><a href="#疫情期间都做了什么？" class="headerlink" title="疫情期间都做了什么？"></a>疫情期间都做了什么？</h4><ol><li><p>首先是帮助师兄改了一个polar码的scl译码方法，其实到现在我对其原理也不是很明白，只是知道代码怎么用…</p></li><li><p>开始刷leetcode的题目，目前大概刷了100+，还是有一定的作用的。完成了</p><ul><li>数据结构部分：队列和栈，数组和字符串，二分查找(83%)，链表(46%)</li><li>算法：BFS，DFS，双指针</li><li>C++中vector，map，set等容器的使用，发现自己掌握的真是冰山一角</li></ul></li><li><p>阅读了机器学习的几篇论文，主要是了解了随机梯度下降(SGD)方法，后面还需要进一步学习</p></li><li><p>很有限的学习了机器学习，矩阵论相关的内容</p></li><li><p>参加了华为的软件精英挑战赛，西北赛区第十名，进入复赛</p></li></ol><h4 id="自己的不足"><a href="#自己的不足" class="headerlink" title="自己的不足"></a>自己的不足</h4><p>真正认识自己的不足也是在比赛期间，当你看到你辛辛苦苦半个月做出来的成果别人只需要几天，并且成绩还比你好的多的时候，你就越发的感觉到自己的渺小，我后悔的事情太多了，本科时候没有参加ACM是最大的错误，无论是数学建模或者是电赛，对于以后要进军互联网来说都没有ACM的奖牌作用大。不过我也意识到了这是教育之间的差异，有些人在中学的时候就开始接触比赛了，到了大学继续比赛那肯定更加熟练。我在高中的时候谈到计算机估计想的就是装个软件，换个内存条什么的，编程这个词都不知道啥意思，更不用说参加信息类的比赛了。。。为社么别人可以做到那些，我做不到，这并不全是自己的问题，种一棵树从现在开始也不迟，<strong>虽然已经知道和别人的差距很大，但是只要是能缩小差距，那就是自己的进步</strong>！还有一年的时间，一年是很快的，而且还有实验室的事情需要忙，所以时间很紧迫，千万不能再浪费了！</p><h4 id="2020学习-工作计划"><a href="#2020学习-工作计划" class="headerlink" title="2020学习/工作计划"></a>2020学习/工作计划</h4><ol><li>继续刷leetcode，学习了新算法，新思路或者新的函数之后在博客中进行总结，至少一周一篇，并且要做好题目的分类，算法和思路在tags中注明算法/思路，函数在tags中注明函数，在分类中注明C++。其中保证每周做7题以上，对于过于简单的题不计算在内，书籍<strong>《算法》</strong>。</li><li>继续学习C++，把<strong>《C++ Prime》</strong>过一遍，每周在博客总结一次，标签：C++ Prime，分类：C++；辅助阅读<strong>《STL源码剖析》</strong>和<strong>《Effective C++》</strong>标签：书名，分类：C++</li><li><strong>《计算机网络 自顶向下方法》</strong>前四章内容</li><li><strong>《UNIX 网络编程》《UNIX 环境高级编程》</strong> 辅助书籍<strong>《Unix/Linux 编程实践教程》</strong></li><li><strong>《深入理解计算机系统》</strong>三四章可以先不看</li><li>机器学习的相关课程：吴恩达机器学习基础课程，CS231n计算机视觉课程，适应阅读英文论文，加强英语的学习</li><li>积极参加有水平的比赛</li><li>阅读一本非专业的书籍，陶冶陶冶情操？</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;写在前面&lt;/li&gt;
&lt;li&gt;疫情期间的工作&lt;/li&gt;
&lt;li&gt;反思自己的不足&lt;/li&gt;
&lt;li&gt;2020学习/工作计划&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="生活随笔" scheme="http://www.xingyuzhao.ltd/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="计划" scheme="http://www.xingyuzhao.ltd/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode17-电话号码的字母组合</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/02/16/LeetCode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/02/16/LeetCode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</id>
    <published>2020-02-16T06:40:09.000Z</published>
    <updated>2020-02-16T08:07:08.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>已知数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><a id="more"></a><img src="/blog/2020/02/16/LeetCode17-电话号码的字母组合/1.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>字符串的长度不确定，所以用循环直接解决不实际；</p><p>可以由下至上进行递归来求解，以“23”为例，如图：</p><pre class="mermaid">graph TDA[2] -->|a| B[3]A[2] -->|b| C[3]A[2] -->|c| D[3]B[3] -->|d| E[ad]B[3] -->|f| F[af]B[3] -->|g| G[ag]C[3] -->|d| H[bd]C[3] -->|f| I[bf]C[3] -->|g| J[bg]D[3] -->|d| K[cd]D[3] -->|f| L[cf]D[3] -->|g| M[cg]</pre><p>记数字2为第0层，那么数字3为第1层，需要一个变量level，记录当前遍历数字的位置。递归表现在：如果选择了’a’，那么就需要再进行三次选择‘d’ ‘f’ ‘g’后才可以输出，再选择’b’，以此类推。即递归到最后一层，输出一次递归结果，全部递归完成，得到最终结果。</p><p>具体算法如下：</p><ul><li>建立一个<strong>map</strong>，用来存储数字与其对应的字符串，当然，这里的数字是char类型。</li><li>递归函数中，首先判断<strong>level</strong>，如果等于<strong>digits</strong>中数字的个数，那么将当前的结果并入<strong>res</strong>，然后返回。</li><li>否则通过<strong>digits</strong>中的数字找到对应的字符串，然后遍历取出整个字符串，将每个字符串都加到当前的组合后面，再调用递归函数。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; num_str&#123;&#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,&#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;,&#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,&#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;,&#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        combin(digits,num_str,<span class="number">0</span>,<span class="string">""</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combin</span><span class="params">(<span class="built_in">string</span> digits,<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; num_str,<span class="keyword">int</span> level,<span class="built_in">string</span> out,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(level == digits.length())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> buf = num_str[digits[level]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buf.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            combin(digits,num_str,level+<span class="number">1</span>,out+buf[i],res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。&lt;br&gt;已知数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="递归" scheme="http://www.xingyuzhao.ltd/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>转载：时间复杂度O(logn)意味着什么？（侵删）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/01/01/%E8%BD%AC%E8%BD%BD%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-logn-%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E4%BE%B5%E5%88%A0%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/01/01/%E8%BD%AC%E8%BD%BD%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-logn-%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E4%BE%B5%E5%88%A0%EF%BC%89/</id>
    <published>2020-01-01T15:15:50.000Z</published>
    <updated>2020-05-28T14:48:46.503Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;</p><ul><li>原文地址：https://github.com/xitu/gold-miner/blob/master/TODO/what-does-the-time-complexity-o-log-n-actually-mean.md</li>    <li>原文作者：<a href="https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F%40maazrk" rel="noopener" target="_blank">Maaz</a></li>    <li>译文出自：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner" rel="noopener" target="_blank">掘金翻译计划</a></li>    <li>译者：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcdpath" rel="noopener" target="_blank">cdpath</a></li>    <li>校对者：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fzaraguo" rel="noopener" target="_blank">zaraguo (zaraguo)</a>,&nbsp;<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwhatbeg" rel="noopener" target="_blank">whatbeg (Qiu Hu)</a></li></ul><p>&nbsp;</p><a id="more"></a><p><em>友情提示：如果图片挂了，请翻墙或者点击原文地址阅读。</em></p><p>&nbsp;</p><p>预先知道算法的复杂度是一回事，了解其后的原理是另一件事情。</p><p>&nbsp;</p><p>不管你是计算机科班出身还是想有效解决最优化问题，如果想要用自己的知识解决实际问题，你都必须理解时间复杂度。</p><p>先从简单直观的 O(1) 和 O(n) 复杂度说起。O(1) 表示一次操作即可直接取得目标元素（比如字典或哈希表），O(n) 意味着先要检查 n 个元素来搜索目标，但是 O(log n) 是什么意思呢？</p><p>你第一次听说 O(log n) 时间复杂度可能是在学二分搜索算法的时候。二分搜索一定有某种行为使其时间复杂度为 log n。我们来看看是二分搜索是如何实现的。</p><p>因为在最好情况下二分搜索的时间复杂度是 O(1)，最坏情况（平均情况）下 O(log n)，我们直接来看最坏情况下的例子。已知有 16 个元素的有序数组。</p><p>举个最坏情况的例子，比如我们要找的是数字 13。</p><p><img alt class="has" src="https://img-blog.csdnimg.cn/20191121164646526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70"></p><p>十六个元素的有序数组</p><p><img alt class="has" src="https://img-blog.csdnimg.cn/20191121164704291.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70"></p><p>选中间的元素作为中心点（长度的一半）</p><p><img alt class="has" height="191" src="https://img-blog.csdnimg.cn/20191121164715238.jpeg" width="628"></p><p>13 小于中心点，所以不用考虑数组的后一半</p><p><img alt class="has" height="134" src="https://img-blog.csdnimg.cn/20191121164726473.jpeg" width="411"></p><p>重复这个过程，每次都寻找子数组的中间元素</p><p>&nbsp;</p><p><img alt class="has" height="101" src="https://img-blog.csdnimg.cn/20191121164751215.jpeg" width="285"></p><p><img alt class="has" height="91" src="https://img-blog.csdnimg.cn/20191121164811565.jpeg" width="223"></p><p>每次和中间元素比较都会使搜索范围减半。</p><p>所以为了从 16 个元素中找到目标元素，我们需要把数组平均分割 4 次，也就是说，</p><p><img alt class="has" height="141" src="https://img-blog.csdnimg.cn/20191121164824637.png" width="288"></p><p>简化后的公式</p><p>类似的，如果有 n 个元素，</p><p><img alt class="has" height="141" src="https://img-blog.csdnimg.cn/20191121164908192.png" width="301"></p><p>&nbsp;</p><p>归纳一下</p><p><img alt class="has" height="141" src="https://img-blog.csdnimg.cn/20191121164916433.png" width="275"></p><p>分子和分母代入指数</p><p><img alt class="has" height="141" src="https://img-blog.csdnimg.cn/20191121164930660.png" width="275"></p><p>等式两边同时乘以 2^k</p><p><img alt class="has" height="100" src="https://img-blog.csdnimg.cn/20191121164955503.png" width="285"></p><p>最终结果</p><p>现在来看看「对数」的定义：</p><blockquote><p>为使某数（底数）等于一给定数而必须取的乘幂的幂指数。</p></blockquote><p>也就是说可以写成这种形式</p><p><img alt class="has" height="87" src="https://img-blog.csdnimg.cn/2019112116500667.png" width="331"></p><p>对数形式</p><p>所以 log n 的确是有意义的，不是吗？没有其他什么可以表示这种行为。</p><p>就这样吧，我希望我讲得这些你都搞懂了。在从事计算机科学相关的工作时，了解这类知识总是有用的（而且很有趣）。说不定就因为你知道算法的原理，你成了小组里能找出问题的最优解的人呢，谁知道呢。祝好运！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原文地址：https://github.com/xitu/gold-miner/blob/master/TODO/what-does-the-time-complexity-o-log-n-actually-mean.md&lt;/li&gt;
    &lt;li&gt;原文作者：&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F%40maazrk&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Maaz&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;译文出自：&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;译者：&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcdpath&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;cdpath&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;校对者：&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fzaraguo&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;zaraguo (zaraguo)&lt;/a&gt;,&amp;nbsp;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwhatbeg&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;whatbeg (Qiu Hu)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://www.xingyuzhao.ltd/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="数据结构" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
