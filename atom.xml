<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2021-01-10T09:11:46.000Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode228-汇总区间</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/10/LeetCode228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/10/LeetCode228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</id>
    <published>2021-01-10T09:05:25.000Z</published>
    <updated>2021-01-10T09:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p><p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><a id="more"></a><img src="/blog/2021/01/10/LeetCode228-汇总区间/228.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果序列满足 <code>nums[i] == nums[i - 1]</code> 代表它们是同一个区间。</p><p>需要记录区间的起始位置的终止位置，使用双指针，<code>i</code> 代表当前区间的起始位置， <code>j</code> 代表当前区间的终止位置。</p><p>遍历结束时，还需要<strong>把最后一个区间加入答案中</strong>，如果最后一个区间的 <code>j - i == 1</code>，说明最后一个区间只有一个数，否则，需要再加入一个新的区间。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i + <span class="number">1</span>)&#123;</span><br><span class="line">                    ret.push_back(to_string(nums[i]));</span><br><span class="line">                    j++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ret.push_back(to_string(nums[i]) + <span class="string">"-&gt;"</span> + to_string(nums[j - <span class="number">1</span>]));</span><br><span class="line">                    i = j;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == j - <span class="number">1</span>) ret.push_back(to_string(nums[i]));</span><br><span class="line">        <span class="keyword">if</span>(i != j - <span class="number">1</span>) ret.push_back(to_string(nums[i]) + <span class="string">"-&gt;"</span> + to_string(nums[j - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个无重复元素的有序整数数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;返回 &lt;strong&gt;恰好覆盖数组中所有数字&lt;/strong&gt; 的 &lt;strong&gt;最小有序&lt;/strong&gt; 区间范围列表。也就是说，&lt;code&gt;nums&lt;/code&gt; 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 &lt;code&gt;nums&lt;/code&gt; 的数字 &lt;code&gt;x&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;列表中的每个区间范围 &lt;code&gt;[a,b]&lt;/code&gt; 应该按如下格式输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a-&amp;gt;b&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a != b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a == b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode189-旋转数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/08/LeetCode189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/08/LeetCode189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2021-01-08T15:12:16.000Z</published>
    <updated>2021-01-10T09:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>进阶</strong>：</p><ul><li>尽可能想出更多的解决方案，<del>至少有三种不同的方法可以解决这个问题</del>。</li><li>你可以使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法解决这个问题吗？</li></ul><a id="more"></a><img src="/blog/2021/01/08/LeetCode189-旋转数组/189.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据 <code>k</code> 值，将 <code>nums</code> 数组分为前后两个部分。将后 <code>k</code> 个值截取出来得到的数组，拼接到剩余数组之前即可。空间复杂度为 <code>O(n)</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 99% 9%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size(); <span class="comment">// 如果k大于nums的长度，取余之后再进行处理</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buf1</span><span class="params">(nums.begin() + nums.size() - k, nums.end())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buf2</span><span class="params">(nums.begin(), nums.begin() + nums.size() - k)</span></span>;</span><br><span class="line">        buf1.insert(buf1.end(), buf2.begin(), buf2.end());</span><br><span class="line">        nums = buf1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>上述的空间复杂度为 <code>O(n)</code>，可以进一步压缩空间，使空间复杂度降为 <code>O(1)</code>。</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>具体思路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k = 3;</span><br><span class="line">----&gt;--&gt; 移动后得到 --&gt;----&gt;</span><br><span class="line">可以对原始序列进行如下操作：</span><br><span class="line">----&gt;--&gt; 反转后 &lt;--&lt;----</span><br><span class="line">其中&lt;-- 反转后 --&gt;&lt;----</span><br><span class="line">其中&lt;---- 反转后 --&gt;----&gt;</span><br></pre></td></tr></table></figure><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库函数 50.50% 84.77%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.begin() + k);</span><br><span class="line">        reverse(nums.begin() + k, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 非库函数 50.50% 74.88%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然速度慢了点（实际上为 <code>O(2n) = O(n)</code> ），不过空间使用较之前还是低了很多。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解及其评论区：<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 &lt;code&gt;k&lt;/code&gt; 个位置，其中 &lt;code&gt;k&lt;/code&gt; 是非负数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能想出更多的解决方案，&lt;del&gt;至少有三种不同的方法可以解决这个问题&lt;/del&gt;。&lt;/li&gt;
&lt;li&gt;你可以使用空间复杂度为 O(1) 的 &lt;strong&gt;原地&lt;/strong&gt; 算法解决这个问题吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>内存管理（五）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2021-01-08T09:41:08.000Z</published>
    <updated>2021-01-10T15:32:06.303Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>虚拟内存基本概念</li><li>请求分页管理方式</li><li>页面置换算法</li><li>页面分配策略</li></ol><a id="more"></a><h4 id="虚拟内存基本概念"><a href="#虚拟内存基本概念" class="headerlink" title="虚拟内存基本概念"></a>虚拟内存基本概念</h4><h5 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h5><p>传统存储管理特点：</p><ol><li>一次性：作业必须<strong>一次性全部装入内存</strong>才能开始运行。</li><li>驻留性：一旦作业被装入内存，就<strong>会一直驻留在内存中</strong>。</li></ol><p>很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。</p><h5 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h5><ul><li>时间局部性</li><li>空间局部性</li></ul><h5 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h5><p>虚拟内存：若内存空间不够，由<strong>操作系统</strong>负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong>。虚拟性体现在：实际的物理内存大小没有变，只是在逻辑上进行了扩充。</p><ul><li>虚拟内存最大容量：计算机的地址结构（CPU寻址范围）确定。</li><li>虚拟内存实际容量：<em>min</em>(内存和外存容量之和，CPU寻址范围)。</li></ul><p>虚拟内存有以下三个特征：</p><ol><li>多次性（对应一次性）：允许作业被分成多次调入内存。</li><li>对换性（对应驻留性）：允许作业运行中，将作业换出、换入内存。</li><li>虚拟性：从逻辑上扩充了内存的容量。</li></ol><h5 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h5><img src="/blog/2021/01/08/内存管理（五）/虚拟内存的实现.png"><p>虚拟内存技术基于<strong>离散分配</strong>的内存管理方式。<strong>请求分页存储管理</strong>与<strong>基本分页存储管理</strong>的<strong>主要区别</strong>是：操作系统需要提供<strong>请求调页</strong>和<strong>页面置换</strong>功能。</p><ul><li>请求调页：程序执行过程中，当所访问信息<strong>不在内存中</strong>时，由操作系统负责<strong>将所需信息从外存调入内存</strong>。</li><li>页面置换：若内存空间不够，由操作系统将<strong>内存中暂时用不到的信息换出到外存</strong>。</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/虚拟内存基本概念小结.png" style="zoom:120%;"><h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><img src="/blog/2021/01/08/内存管理（五）/请求分页管理方式.png"><h5 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h5><ul><li>为了实现<strong>请求调页</strong>，操作系统需要知道每个页面是否已经调入内存；如果没调入，那么也需要知道该页面在外存中存放的位置。</li><li>为了实现<strong>内存置换</strong>，操作系统需要通过某些指标来决定到底换出哪个页面。需要记录各个页面是否被修改过，修改过才需要换出，将外存中的旧数据覆盖。</li></ul><img src="/blog/2021/01/08/内存管理（五）/页表机制.png"><h5 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h5><p>请求分页系统中，若访问页面<strong>不在内存中</strong>时，便产生一个<strong>缺页中断</strong>。然后由操作系统的<strong>缺页中断处理程序</strong>处理中断。此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><ul><li><p>如果内存中<strong>有空闲块</strong>，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中对应页表项。</p></li><li><p>如果内存中<strong>无空闲块</strong>，则由<strong>页面置换算法</strong>选择<strong>淘汰</strong>一个页面，若该页面在内存期间被<strong>修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</p></li></ul><p>缺页中断是由于当前指令想要访问的目标页面未调入内存而产生的，因此属于<strong>内中断</strong>。一条指令在执行期间，可能产生<strong>多次</strong>缺页中断。</p><img src="/blog/2021/01/08/内存管理（五）/缺页中断机构.png"><h5 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h5><img src="/blog/2021/01/08/内存管理（五）/地址变化机构.png"><ul><li>新增步骤1：请求调页（查到页表项时进行判断）。</li><li>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）。</li><li>新增步骤3：需要修改请求页表中新增的表项。</li></ul><img src="/blog/2021/01/08/内存管理（五）/地址变化机构步骤.png" style="zoom:120%;"><p>补充：</p><ol><li>换入/换出页面需要启动慢速I/O操作，如果过于频繁，会有很大开销。</li><li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li></ol><p>在具有快表的请求分页系统中，访问一个逻辑地址时，若发生缺页，地址变换步骤为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查快表（未命中）-&gt;查慢表（发现未调入内存）-&gt;调页（调入的页面对应的表项会直接加入快表）</span><br><span class="line">-&gt;查快表（命中）-&gt;访问目标内存单元</span><br></pre></td></tr></table></figure><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/地址变化机构小结.png" style="zoom:120%;"><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><img src="/blog/2021/01/08/内存管理（五）/页面置换算法.png" style="zoom:80%;"><h5 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h5><p>每次选择淘汰的页面<strong>以后永不使用</strong>或<strong>最长时间内不再被访问</strong>，保证最低缺页率。</p><p>缺点：只有进程执行的过程中才能知道接下来会访问到哪个页面，操作系统无法提前预判访问序列。因此，最佳置换算法<strong>无法实现</strong>。</p><h5 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h5><p>每次选择淘汰的页面是<strong>最早进入内存的页面</strong>。</p><p>Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>缺点：只有FIFO算法会产生<strong>Belady异常</strong>，虽然其实现简单，但是与进程实际运行时规律不适应，因为先进入的页面也有可能最经常被访问。因此算法<strong>性能差</strong>。</p><h5 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h5><p>每次选择淘汰的页面是<strong>最近最久未使用的页面</strong>。用每个页面页表项中的<strong>访问字段</strong>记录该页面自上次被访问以来所经历的时间 t 。淘汰时选择 t 最大的页面。</p><p>缺点：实现需要专门的硬件支持，虽然算法性能好，但<strong>实现困难，开销大</strong>。</p><h5 id="时钟置换算法（CLOCK）"><a href="#时钟置换算法（CLOCK）" class="headerlink" title="时钟置换算法（CLOCK）"></a>时钟置换算法（CLOCK）</h5><p>此算法是一种性能和开销较均衡的算法，也称<strong>最近未用算法（NRU，Not Recently Used）</strong>。</p><p>简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个<strong>循环队列</strong>。当某页被访问时，其<strong>访问位置为1</strong>。<strong>当需要淘汰一个页面时，只需检查页的访问位</strong>。</p><img src="/blog/2021/01/08/内存管理（五）/简单clock.png"><ul><li>如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面。</li><li>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）。</li></ul><h6 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h6><p>简单的CLOCK算法<strong>仅考虑一个页面最近是否被访问过</strong>，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过，才需要写回外存</strong>。</p><p>因此，在其他条件都相同时，应<strong>优先淘汰没有修改过的页面</strong>，避免I/O操作。修改位为0时表示没有修改过，修改位为1，表示页面被修改过。</p><p>改进型CLOCK置换算法选择一个淘汰页面最多会进行<strong>四轮扫描</strong>。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/页面置换算法小结.png"><h4 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h4><h5 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h5><p>驻留集：请求分页存储管理中给进程分配的物理块的集合。驻留集大小一般小于进程的总大小。</p><ul><li>若驻留集太小，会导致缺页频繁。</li><li>若驻留集太大，会导致多道程序并发度下降。</li></ul><p>固定分配：操作系统为每个进程分配一组固定数目的物理块。进程运行期间驻留集<strong>大小不变</strong>。</p><p>可变分配：驻留集<strong>大小可变</strong>。</p><p>局部置换：缺页时只能选进程自己的物理块进行置换。</p><p>全局置换：操作系统保留的空闲物理块和别的进程持有的物理块（先置换到外存）都可以分配给缺页进程。</p><img src="/blog/2021/01/08/内存管理（五）/页面置换策略.png"><p>可变分配<strong>全局</strong>置换：只要缺页就给分配新物理块。</p><p>可变分配<strong>局部</strong>置换：根据<strong>缺页的频率</strong>来动态地增加或减少进程的物理块。</p><h5 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h5><ol><li>预调页策略：根据空间局部性，一次调入若干相邻的页面可能比一次调入一个页面更高效。主要用于<strong>进程的首次调入</strong>，由程序员指出（<strong>运行前调入</strong>）。</li><li>请求调页策略：进程在<strong>运行期间</strong>发现缺页时才将所缺页面调入内存。I/O开销较大（每次只能调入一页，每次调页都要进行磁盘I/O）。</li></ol><h5 id="何处调入页面"><a href="#何处调入页面" class="headerlink" title="何处调入页面"></a>何处调入页面</h5><h6 id="系统拥有足够的对换区空间"><a href="#系统拥有足够的对换区空间" class="headerlink" title="系统拥有足够的对换区空间"></a>系统拥有足够的对换区空间</h6><img src="/blog/2021/01/08/内存管理（五）/何处调入1.png"><h6 id="系统缺少足够的对换区空间"><a href="#系统缺少足够的对换区空间" class="headerlink" title="系统缺少足够的对换区空间"></a>系统缺少足够的对换区空间</h6><img src="/blog/2021/01/08/内存管理（五）/何处调入2.png"><h6 id="UNIX方式"><a href="#UNIX方式" class="headerlink" title="UNIX方式"></a>UNIX方式</h6><img src="/blog/2021/01/08/内存管理（五）/何处调入3.png"><h5 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h5><p>刚换出的页面马上要换入内存，或刚换入的需要换出，这种频繁的页面调度行为称为<strong>抖动（颠簸）</strong>。主要原因是进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）。</p><h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合。</p><p>工作集：指在某段时间间隔里，进程实际访问页面的集合。</p><img src="/blog/2021/01/08/内存管理（五）/工作集.png"><p><strong>窗口尺寸为4</strong>。</p><p><strong>工作集大小</strong>可能小于窗口尺寸，一般来说，驻留集大小不能<strong>小于</strong>工作集大小，否则进程运行过程中将频繁缺页。</p><h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/页面分配策略小结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;虚拟内存基本概念&lt;/li&gt;
&lt;li&gt;请求分页管理方式&lt;/li&gt;
&lt;li&gt;页面置换算法&lt;/li&gt;
&lt;li&gt;页面分配策略&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="虚拟内存" scheme="http://www.xingyuzhao.ltd/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode547-省份数量</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/07/LeetCode547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/07/LeetCode547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</id>
    <published>2021-01-07T12:58:59.000Z</published>
    <updated>2021-01-07T13:30:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><a id="more"></a><img src="/blog/2021/01/07/LeetCode547-省份数量/547.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题的核心问题是<strong>节点之间是否相连</strong>。如果找到了这个核心点，就可以想到两种解决方案。一种是图论中，计算<strong>连通分量</strong>的个数；另一种是并查集，找到大家的<strong>公共祖先</strong>的个数。</p><p>考虑到我们并不需要知道节点与节点之间<strong>如何连接</strong>，只需要知道节点与节点之间<strong>是否连接</strong>，所以使用<strong>并查集</strong>来解决这个问题就足够了。</p><p>并查集的相关知识可参考<a href="%5Bhttp://www.xingyuzhao.ltd/blog/2020/09/06/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find/">这里</a>，建议先看！</p><p>输入矩阵的长或者宽（其实就是一个邻接矩阵）的大小就是城市的个数，所以对于并查集的初始化，我们只需要设置长度与城市个数相等的<code>parent</code>数组即可，并且指向自身，同时可以初始化当前祖先的总数，即城市的个数。</p><p>在遍历<code>isconnected</code>矩阵时，遇到<code>isconnected[i][j]</code>为 1 时，代表<code>i, j</code>两节点相连，进行<code>union(i, j)</code>操作。同时祖先数减去 1 。否则不相连，不进行任何操作。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            count++;</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根不同，将其相连，计数减1</span></span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot; <span class="comment">// 随便指一个</span></span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isConnected.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(isConnected)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> m = isConnected.size();</span><br><span class="line">        <span class="keyword">int</span> n = isConnected[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    uf.unionElem(i, j);</span><br><span class="line">                &#125;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个城市，其中一些彼此相连，另一些没有相连。如果城市 &lt;code&gt;a&lt;/code&gt; 与城市 &lt;code&gt;b&lt;/code&gt; 直接相连，且城市 &lt;code&gt;b&lt;/code&gt; 与城市 &lt;code&gt;c&lt;/code&gt; 直接相连，那么城市 &lt;code&gt;a&lt;/code&gt; 与城市 &lt;code&gt;c&lt;/code&gt; 间接相连。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;省份&lt;/strong&gt; 是一组直接或间接相连的城市，组内不含其他没有相连的城市。&lt;/p&gt;
&lt;p&gt;给你一个 &lt;code&gt;n x n&lt;/code&gt; 的矩阵 &lt;code&gt;isConnected&lt;/code&gt; ，其中 &lt;code&gt;isConnected[i][j] = 1&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个城市和第 &lt;code&gt;j&lt;/code&gt; 个城市直接相连，而 &lt;code&gt;isConnected[i][j] = 0&lt;/code&gt; 表示二者不直接相连。&lt;/p&gt;
&lt;p&gt;返回矩阵中 &lt;strong&gt;省份&lt;/strong&gt; 的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode399-除法求值</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/06/LeetCode399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/06/LeetCode399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</id>
    <published>2021-01-06T12:02:07.000Z</published>
    <updated>2021-01-06T13:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。</p><p><strong>注意</strong>：输入总是有效的。你可以假设除法运算中不会出现除数为 <code>0</code> 的情况，且不存在任何矛盾的结果。</p><a id="more"></a><img src="/blog/2021/01/06/LeetCode399-除法求值/399.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先得理解题目意思：</p><ul><li><code>equations</code>和<code>values</code>：<code>equations</code>中每个一维序列表示一对数进行相除（前 / 后），得到的结果就是<code>values</code>中相应位置的值，以上作为已知条件。</li><li><code>queries</code>：包含两个元素，目的是要我们求：第一个元素 / 第二个元素 = ？</li></ul><p>我们可以将其抽象为一个<strong>带权图</strong>问题，对于<code>queries</code>中的两个元素 <code>x</code>, <code>y</code> ，是否有一条路径可以从 <code>x</code> 到 <code>y</code> ，并求出经过这条路径的消耗是多少。由于两个元素的比值是一个常量，所以<strong>如果有多条路径，消耗是一样的</strong>，选其中一条就可以。</p><p>以示例1为例，对于<code>a/c</code>，可以由<code>a/b * b/c</code>得到，也就是<code>a-&gt;b</code>与<code>b-&gt;c</code>两条路径的权值相乘得到，所以路径上的消耗，就是<strong>所走过的每条路径的权值之积</strong>。</p><p>由于每个基本元素类型都是<code>string</code>，所以先对所有的元素映射到数字域，方便查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将equations中的string映射到0，1，2，3...</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : equations)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">map</span>.count(ch)) <span class="built_in">map</span>[ch] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步就是建图，使用邻接表，并且路径之间是<strong>双向</strong>的，权值<strong>互为倒数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; W;</span><br><span class="line">G = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">W = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); ++i)&#123;</span><br><span class="line">    G[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]);</span><br><span class="line">    W[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(values[i]);</span><br><span class="line">    G[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]);</span><br><span class="line">    W[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="number">1</span> / values[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建好图之后，就可以用<strong>深度优先搜索（DFS）</strong>和<strong>回溯算法</strong>来找路了，需要用一个数组记录走过的节点，防止重复走过，还需要一个变量<code>flag</code>表示起点与终点之间是否存在路径：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 初始为0，表示起点与终点之间没有路径。设置为全局变量，在函数中不用调用。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="built_in">map</span>.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; querie : queries) &#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = querie[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">string</span> s2 = querie[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 如果两个元素相同并且存在于map中，结果就是1</span></span><br><span class="line">    <span class="keyword">if</span> (s1 == s2 &amp;&amp; <span class="built_in">map</span>.count(s1)) &#123;</span><br><span class="line">        res.push_back(<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有一个元素不存在于map中，结果就是-1，因为没有这条路径</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">map</span>.count(s1) || !<span class="built_in">map</span>.count(s2)) &#123;</span><br><span class="line">        res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将起点标记为已使用</span></span><br><span class="line">    vis[<span class="built_in">map</span>[s1]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 参数：图，权值，标记数组，起点，终点，当前计算结果（初始为1）</span></span><br><span class="line">    dfs(G, W, vis, <span class="built_in">map</span>[s1], <span class="built_in">map</span>[s2], <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用过后，再次标记为未使用</span></span><br><span class="line">    vis[<span class="built_in">map</span>[s1]] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 没有路径，结果为-1</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">    <span class="comment">// 已经有路径，将flag置为0，结果已经在DFS中记录过，所以不用再次记录了</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS+回溯：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; &amp;W, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;vis, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">        res.push_back(val);</span><br><span class="line">        <span class="comment">// 有路径，flag为1</span></span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[start].size(); ++i)&#123;</span><br><span class="line">        <span class="comment">// 如果flag已经为1了，说明找到一条路径了，就不需要再找了</span></span><br><span class="line">        <span class="comment">// 剩下的就是一般的回溯算法</span></span><br><span class="line">        <span class="keyword">if</span>(vis[G[start][i]] || flag == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        vis[G[start][i]] = <span class="literal">true</span>;</span><br><span class="line">        val *= W[start][i];</span><br><span class="line">        dfs(G, W, vis, G[start][i], end, val);</span><br><span class="line">        val /= W[start][i];</span><br><span class="line">        vis[G[start][i]] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; W;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="comment">// set&lt;pair&lt;int, int&gt;&gt; set;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : equations)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">map</span>.count(ch)) <span class="built_in">map</span>[ch] = cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; map.size();</span></span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        G = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">        W = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">        vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); ++i)&#123;</span><br><span class="line">            G[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; map[equations[i][0]] &lt;&lt; " " &lt;&lt; map[equations[i][1]];</span></span><br><span class="line">            W[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(values[i]);</span><br><span class="line">            G[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]);</span><br><span class="line">            W[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="number">1</span> / values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto &amp;g : G)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;gg : g)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; gg &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; "    ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for(auto &amp;w : W)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;ww : w)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; ww &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; "    ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;querie : queries)&#123;</span><br><span class="line">            <span class="built_in">string</span> s1 = querie[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">string</span> s2 = querie[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s1 == s2 &amp;&amp; <span class="built_in">map</span>.count(s1))&#123;</span><br><span class="line">                res.push_back(<span class="number">1.0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.count(s1) || !<span class="built_in">map</span>.count(s2))&#123;</span><br><span class="line">                res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[<span class="built_in">map</span>[s1]] = <span class="literal">true</span>;</span><br><span class="line">            dfs(G, W, vis, <span class="built_in">map</span>[s1], <span class="built_in">map</span>[s2], <span class="number">1</span>);</span><br><span class="line">            vis[<span class="built_in">map</span>[s1]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>) res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int count = queries.size() - res.size();</span></span><br><span class="line">        <span class="comment">// while(count--)&#123;</span></span><br><span class="line">        <span class="comment">//     res.insert(res.begin(), -1.0);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; &amp;W, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;vis, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            res.push_back(val);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; val &lt;&lt; " ";</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[start].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[G[start][i]] || flag == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            vis[G[start][i]] = <span class="literal">true</span>;</span><br><span class="line">            val *= W[start][i];</span><br><span class="line">            dfs(G, W, vis, G[start][i], end, val);</span><br><span class="line">            val /= W[start][i];</span><br><span class="line">            vis[G[start][i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h4><p>可以使用并查集解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个变量对数组 &lt;code&gt;equations&lt;/code&gt; 和一个实数值数组 &lt;code&gt;values&lt;/code&gt; 作为已知条件，其中 &lt;code&gt;equations[i] = [Ai, Bi]&lt;/code&gt; 和 &lt;code&gt;values[i]&lt;/code&gt; 共同表示等式 &lt;code&gt;Ai / Bi = values[i]&lt;/code&gt; 。每个 &lt;code&gt;Ai&lt;/code&gt; 或 &lt;code&gt;Bi&lt;/code&gt; 是一个表示单个变量的字符串。&lt;/p&gt;
&lt;p&gt;另有一些以数组 &lt;code&gt;queries&lt;/code&gt; 表示的问题，其中 &lt;code&gt;queries[j] = [Cj, Dj]&lt;/code&gt; 表示第 &lt;code&gt;j&lt;/code&gt; 个问题，请你根据已知条件找出 &lt;code&gt;Cj / Dj = ?&lt;/code&gt; 的结果作为答案。&lt;/p&gt;
&lt;p&gt;返回 所有问题的答案 。如果存在某个无法确定的答案，则用 &lt;code&gt;-1.0&lt;/code&gt; 替代这个答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：输入总是有效的。你可以假设除法运算中不会出现除数为 &lt;code&gt;0&lt;/code&gt; 的情况，且不存在任何矛盾的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="DFS" scheme="http://www.xingyuzhao.ltd/tags/DFS/"/>
    
      <category term="图" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE/"/>
    
      <category term="回溯算法" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode830-较大分组的位置</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/05/LeetCode830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/05/LeetCode830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-01-05T10:08:58.000Z</published>
    <updated>2021-01-05T12:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p><p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p><a id="more"></a><img src="/blog/2021/01/05/LeetCode830-较大分组的位置/830.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>寻找每个重复字符出现的起始位置和终止位置，如果长度大于等于3，记录一下结果就可以了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">largeGroupPositions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = s[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="comment">// 此位置的前一个位置就是上一个重复字符的终止位置</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] != ch)&#123;</span><br><span class="line">                ch = s[i];</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> - start + <span class="number">1</span> &gt;= <span class="number">3</span>) res.push_back(&#123;start, i - <span class="number">1</span>&#125;);</span><br><span class="line">                <span class="comment">// 更新起始位置</span></span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 字符重复</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> - start + <span class="number">1</span> &gt;= <span class="number">3</span>) res.push_back(&#123;start, i - <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一个由小写字母构成的字符串 &lt;code&gt;s&lt;/code&gt; 中，包含由一些连续的相同字符所构成的分组。&lt;/p&gt;
&lt;p&gt;例如，在字符串 &lt;code&gt;s = &amp;quot;abbxxxxzyy&amp;quot;&lt;/code&gt; 中，就含有 &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;bb&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;z&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;yy&amp;quot;&lt;/code&gt; 这样的一些分组。&lt;/p&gt;
&lt;p&gt;分组可以用区间 &lt;code&gt;[start, end]&lt;/code&gt; 表示，其中 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 分别表示该分组的起始和终止位置的下标。上例中的 &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt; 分组用区间表示为 &lt;code&gt;[3,6]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;我们称所有包含大于或等于三个连续字符的分组为 &lt;strong&gt;较大分组&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;找到每一个 &lt;strong&gt;较大分组&lt;/strong&gt; 的区间，&lt;strong&gt;按起始位置下标递增顺序排序后&lt;/strong&gt;，返回结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode509-斐波那契数</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/04/LeetCode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/04/LeetCode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2021-01-04T10:08:27.000Z</published>
    <updated>2021-01-05T12:21:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>斐波那契数，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><a id="more"></a><img src="/blog/2021/01/04/LeetCode509-斐波那契数/509.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这个算是动态规划的入门题目。给定 $F(0)$ 和 $F(1)$ 之后，后面的数都是前面两个数之和。比如 $F(2)=F(0)+F(1)$，$F(3)=F(1)+F(2)$…</p><p>基于此，其实已经告诉了我们状态转移方程：<br>$$<br>dp[i]=dp[i-1]+dp[i-2]\quad i\geq2<br>$$<br>当 $i=0,1$ 时，函数值已经给定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上只用三个变量就可以表示每种状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        <span class="keyword">int</span> fin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i - 2]</span></span><br><span class="line">        <span class="keyword">int</span> fir = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="keyword">int</span> sec = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fin = fir + sec;</span><br><span class="line">            fir = sec;</span><br><span class="line">            sec = fin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;斐波那契数，通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示，形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) = 0，F(1) = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(n) = F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;给你 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>内存管理（四）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/04/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2021-01-04T09:36:59.000Z</published>
    <updated>2021-01-10T15:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>基本分段存储管理方式</li><li>段页式管理方式</li></ol><a id="more"></a><h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><p>与分页存储管理方式区别为：离散分配时所分配地址空间的基本单位不同。</p><h5 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h5><p>进程的地址空间：按照程序<strong>自身的逻辑</strong>关系划分为若干个段，每个段都有一个段名，每段从0开始编址。</p><p>内存分配规则：以段位单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><img src="/blog/2021/01/04/内存管理（四）/分段-逻辑编程.png"><p>分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）组成：</p><img src="/blog/2021/01/04/内存管理（四）/分段逻辑地址.png"><ul><li>段号的位数决定每个进程最多可分几个段。</li><li>段内地址位数决定了每个段的最大长度是多少。</li></ul><h5 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h5><img src="/blog/2021/01/04/内存管理（四）/段表.png"><h5 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h5><img src="/blog/2021/01/04/内存管理（四）/地址变换.png"><p>④处与<strong>分页存储</strong>不同。</p><h5 id="分段、分页管理对比"><a href="#分段、分页管理对比" class="headerlink" title="分段、分页管理对比"></a>分段、分页管理对比</h5><h6 id="基本单位"><a href="#基本单位" class="headerlink" title="基本单位"></a>基本单位</h6><ul><li><strong>页是信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要,完全是系统行为，<strong>对用户是不可见的</strong>。</li><li><strong>段是信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li></ul><h6 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h6><ul><li>页的大小<strong>固定</strong>且由<strong>系统</strong>决定。</li><li>段的长度却<strong>不固定</strong>，决定于<strong>用户编写的程序</strong>。</li></ul><h6 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h6><ul><li>分页的用户进程地址空间是<strong>一维</strong>的，程序员只需给出一个记忆符即可表示一个地址。</li><li>分段的用户进程地址空间是<strong>二维</strong>的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li></ul><p>分段比分页<strong>更容易实现信息的共享和保护</strong>。不能被修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（不属于临界资源），这样的代码可以共享，可修改的代码不可共享。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/04/内存管理（四）/分段存储管理小结.png" style="zoom:120%;"><h4 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h4><img src="/blog/2021/01/04/内存管理（四）/段页式管理方式.png" style="zoom:80%;"><h5 id="分页、分段优缺点分析"><a href="#分页、分段优缺点分析" class="headerlink" title="分页、分段优缺点分析"></a>分页、分段优缺点分析</h5><img src="/blog/2021/01/04/内存管理（四）/分页、分段优缺点分析.png"><h5 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h5><img src="/blog/2021/01/04/内存管理（四）/段页式管理.png"><p>将进程按逻辑模块分段，再将各段分页，再装入大小相同的内存块（页框/页帧/物理块）中。</p><h5 id="段页式管理的逻辑地址结构"><a href="#段页式管理的逻辑地址结构" class="headerlink" title="段页式管理的逻辑地址结构"></a>段页式管理的逻辑地址结构</h5><img src="/blog/2021/01/04/内存管理（四）/段页式管理的逻辑地址结构.png"><ul><li>段号的位数决定每个进程最多可分几个段。</li><li>页号位数决定了每个段最大有多少页。</li><li>页内偏移量决定了页面大小、内存块大小是多少。</li></ul><p><strong>分段</strong>对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将<strong>各段</strong>进行<strong>分页</strong>对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此段页式管理的地址结构是二维的。</p><h5 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h5><img src="/blog/2021/01/04/内存管理（四）/段表、页表.png"><p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，<strong>段号是隐含的</strong>。</p><p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，<strong>页号是隐含的</strong>。</p><img src="/blog/2021/01/04/内存管理（四）/段表、页表寻址.png"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/04/内存管理（四）/段页式管理方式小结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;基本分段存储管理方式&lt;/li&gt;
&lt;li&gt;段页式管理方式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分段存储" scheme="http://www.xingyuzhao.ltd/tags/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode86-分隔链表</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/03/LeetCode86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/03/LeetCode86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</id>
    <published>2021-01-03T10:06:47.000Z</published>
    <updated>2021-01-05T12:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个链表和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有小于 <code>x</code> 的节点都出现在大于或等于 <code>x</code> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><a id="more"></a><img src="/blog/2021/01/03/LeetCode86-分隔链表/86.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将链表一分为二，为小于 <code>x</code> 的部分和大于等于 <code>x</code> 的部分分别建立一个新链表，然后再将小链表的表尾连接至大链表的表头即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *dummyNodeSmall = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *dummyNodeLarge = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *small = dummyNodeSmall;</span><br><span class="line">        ListNode *large = dummyNodeLarge;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = head; iter != <span class="literal">nullptr</span>; iter = iter-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;val &lt; x)&#123;</span><br><span class="line">                small-&gt;next = iter;</span><br><span class="line">                small = small-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                large-&gt;next = iter;</span><br><span class="line">                large = large-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        large-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        small-&gt;next = dummyNodeLarge-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyNodeSmall-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/partition-list/solution/fen-ge-lian-biao-by-leetcode-solution-7ade/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-list/solution/fen-ge-lian-biao-by-leetcode-solution-7ade/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个链表和一个特定值 &lt;code&gt;x&lt;/code&gt; ，请你对链表进行分隔，使得所有小于 &lt;code&gt;x&lt;/code&gt; 的节点都出现在大于或等于 &lt;code&gt;x&lt;/code&gt; 的节点之前。&lt;/p&gt;
&lt;p&gt;你应当保留两个分区中每个节点的初始相对位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode239-滑动窗口的最大值</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/02/LeetCode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/02/LeetCode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2021-01-02T10:06:14.000Z</published>
    <updated>2021-01-05T12:44:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><a id="more"></a><img src="/blog/2021/01/02/LeetCode239-滑动窗口的最大值/239.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先使用优先队列存储 <code>nums</code> 的前 <code>k</code> 个值，队首就是第一个窗口最大的值。</p><p>接着从第 <code>k</code> 个位置开始，将序列入队，每次最大的值都出现在队首。但是<strong>当前的队首不一定是当前窗口中的元素</strong>，此时队列的长度可能大于 <code>k</code>。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = &#123;3,1,1&#125;, k = 2;</span><br><span class="line">1. &#123;3,1&#125; max = 3; // 队列中元素为3,1</span><br><span class="line">2. &#123;1,1&#125; max = 1; // 队列中元素为3,1,1，此时需要将3出队</span><br></pre></td></tr></table></figure><p>如果不是当前窗口中的元素，只有可能是上一个窗口中的最大值，它一定是在当前窗口左端点的左侧，就需要将队首出队，直到队首元素在当前窗口内。</p><p>所以优先队列需要同时存储当前序列的值和坐标。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            q.push(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans&#123;q.top().first&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            q.push(&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="comment">// 队首元素不在当前窗口内</span></span><br><span class="line">            <span class="keyword">while</span>(q.top().second &lt;= i - k)&#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，有一个大小为 &lt;code&gt;k&lt;/code&gt; 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 &lt;code&gt;k&lt;/code&gt; 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="优先队列" scheme="http://www.xingyuzhao.ltd/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode605-种花问题</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/01/LeetCode605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/01/LeetCode605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-01T10:05:37.000Z</published>
    <updated>2021-01-05T12:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组  <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>。</p><a id="more"></a><img src="/blog/2021/01/01/LeetCode605-种花问题/605.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>除了首尾位置，只要当前位置的前一个位置和下一个位置没有种花，那么当前位置就可以种花。</p><p>对于首尾位置，只有其相邻位置没有种花，在它的位置就可以种花。</p><p><strong>当前位置如果没有种花，才需要考虑上述问题</strong>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed.size() == <span class="number">1</span>) <span class="keyword">return</span> flowerbed[<span class="number">0</span>] == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i + <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == flowerbed.size() - <span class="number">1</span> &amp;&amp; flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != flowerbed.size() - <span class="number">1</span> &amp;&amp; flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>] != <span class="number">1</span> &amp;&amp; flowerbed[i + <span class="number">1</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。&lt;/p&gt;
&lt;p&gt;给你一个整数数组  &lt;code&gt;flowerbed&lt;/code&gt; 表示花坛，由若干 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 组成，其中 &lt;code&gt;0&lt;/code&gt; 表示没种植花，&lt;code&gt;1&lt;/code&gt; 表示种植了花。另有一个数 &lt;code&gt;n&lt;/code&gt; ，能否在不打破种植规则的情况下种入 &lt;code&gt;n&lt;/code&gt; 朵花？能则返回 &lt;code&gt;true&lt;/code&gt; ，不能则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode435-无重叠区间</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/31/LeetCode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/31/LeetCode435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</id>
    <published>2020-12-31T02:10:32.000Z</published>
    <updated>2021-01-08T01:50:35.445Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意</strong>:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><a id="more"></a><img src="/blog/2020/12/31/LeetCode435-无重叠区间/435.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先对二维数组排序，对其中的每个一维数组，先按照元素的第一个升序排列，如果第一个元素相同，再按照第二个升序排列。</p><p>如此一来，为了使移除的区间数最小，那么就需要<strong>从重叠的区间中选出右端点最小的一个</strong>，那样就可以尽可能留下更多不重叠的空间（所以说只按照第二个元素升序排列也是可以的）。</p><p>排序后，如果前一个数组的第二个元素在第二个数组范围之内，就留下前一个数组，用它把第二个数组覆盖；如果前一个数组第二个元素大于第二个数组的后一个元素，那么留下第二个数组，不用进行覆盖，但是前一个数组是需要移除的。这两种情况下，都需要移除操作。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) -&gt; <span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v1[<span class="number">0</span>] == v2[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> v1[<span class="number">1</span>] &lt; v2[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// sort(intervals.begin(), intervals.end());</span></span><br><span class="line">        <span class="comment">// for(auto &amp;v1 : intervals)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;v2 : v1)</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; v2 &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>] &amp;&amp; intervals[i - <span class="number">1</span>][<span class="number">1</span>] &lt;= intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                intervals[i][<span class="number">0</span>] = intervals[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                intervals[i][<span class="number">1</span>] = intervals[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>] &amp;&amp; intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>C++ STL sort作用于二维vector 效果和应用：</p><p><a href="https://blog.csdn.net/y625658683/article/details/104154089" target="_blank" rel="noopener">https://blog.csdn.net/y625658683/article/details/104154089</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>对于二维数组，<code>sort</code>是把<code>vector&lt;int&gt;</code>作为一个一维数组对象，整体进行比较和排序。</p><p>默认比较两个<code>int</code>向量的规则是：</p><p>从第一个元素开始比，第一个元素小的，整个向量就小，如果第一个元素一样，再比较第二个，第二个元素小的，整个向量小，依此类推。<code>sort</code>默认按从小到大排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;可以认为区间的终点总是大于它的起点。&lt;br&gt;区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1046-最后一块石头的重量</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/30/LeetCode1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/30/LeetCode1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/</id>
    <published>2020-12-30T01:58:07.000Z</published>
    <updated>2020-12-30T02:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><p>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；<br>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p><a id="more"></a><h4 id="思路及代码"><a href="#思路及代码" class="headerlink" title="思路及代码"></a>思路及代码</h4><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p>每次寻找最大的两个石头重量进行碰撞，直到链表为空或只剩下一个元素：</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stones.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> stones.empty() ? <span class="number">0</span> : stones[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">li</span><span class="params">(stones.begin(), stones.end())</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!li.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> it1 = max_element(li.begin(), li.end());</span><br><span class="line">            <span class="keyword">int</span> val1 = *it1;</span><br><span class="line">            li.erase(it1);</span><br><span class="line">            <span class="keyword">auto</span> it2 = max_element(li.begin(), li.end());</span><br><span class="line">            <span class="keyword">int</span> val2 = *it2;</span><br><span class="line">            <span class="keyword">if</span>(val2 != val1)</span><br><span class="line">                *it2 = <span class="built_in">abs</span>(val1 - val2);</span><br><span class="line">            <span class="keyword">else</span> li.erase(it2);</span><br><span class="line">            <span class="keyword">if</span>(li.size() == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> li.empty() ? <span class="number">0</span> : *li.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><h6 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h6><p>大顶堆，每次前两个出队元素就是石头中重量最大的两个。</p><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; p_q(stones.begin(), stones.end());</span><br><span class="line">        <span class="keyword">while</span>(!p_q.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p_q.size() == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> v1 = p_q.top();</span><br><span class="line">            p_q.pop();</span><br><span class="line">            <span class="keyword">int</span> v2 = p_q.top();</span><br><span class="line">            p_q.pop();</span><br><span class="line">            <span class="keyword">int</span> v = <span class="built_in">abs</span>(v1 - v2);</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="number">0</span>) p_q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p_q.empty() ? <span class="number">0</span> : p_q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;有一堆石头，每块石头的重量都是正整数。&lt;/p&gt;
&lt;p&gt;每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;，且 &lt;code&gt;x &amp;lt;= y&lt;/code&gt;。那么粉碎的可能结果如下：&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;x == y&lt;/code&gt;，那么两块石头都会被完全粉碎；&lt;br&gt;如果 &lt;code&gt;x != y&lt;/code&gt;，那么重量为 &lt;code&gt;x&lt;/code&gt; 的石头将会完全粉碎，而重量为 &lt;code&gt;y&lt;/code&gt; 的石头新重量为 &lt;code&gt;y-x&lt;/code&gt;。&lt;br&gt;最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="优先队列" scheme="http://www.xingyuzhao.ltd/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode330-按要求补齐数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/29/LeetCode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/29/LeetCode330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-12-29T02:51:41.000Z</published>
    <updated>2020-12-29T14:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 <code>[1, n]</code> 区间内选取任意个数字补充到 $nums$ 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><a id="more"></a><img src="/blog/2020/12/29/LeetCode330-按要求补齐数组/330.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果区间 $[1,x)$ 的所有数都被覆盖了：</p><ul><li>如果$nums[i]\in[1,x)$，那么区间 $[1+nums[i],x+nums[i])$ 中所有数也会被覆盖。由于 $nums[i]\geq1$ ，则此时 $x\in[1+nums[i],x+nums[i])$，覆盖区间可以更新为 $[1,x+nums[i])$。</li><li>如果 $nums[i]$ 恰好等于 $x$ ，那么覆盖区间变为 $[1,x+nums[i])$。不需要补充 $x$ 。</li><li>否则，补充 $x$ ，则区间 $[1,x]$ 全部覆盖；并且可以得到覆盖区间 $[1+x,x+x)=[x+1,2x)$。两者取交集得到此时覆盖数字区间 $[1,2x)$，此时覆盖的数字最多（如果取小于 $x$ 的数，覆盖区间会变小，这是不希望看到的， $x$ 不能取两次，每个数字只能取一次）。</li><li>当 $x&gt;n$ 时，就可以结束了。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始区间为空，表示已经覆盖</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; nums.size() &amp;&amp; nums[index] &lt; x)&#123;</span><br><span class="line">                x += nums[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; nums.size() &amp;&amp; nums[index] == x)&#123;</span><br><span class="line">                x += nums[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个已排序的正整数数组 $nums$，和一个正整数 $n$ 。从 &lt;code&gt;[1, n]&lt;/code&gt; 区间内选取任意个数字补充到 $nums$ 中，使得 &lt;code&gt;[1, n]&lt;/code&gt; 区间内的任何数字都可以用 $nums$ 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode309-最佳买卖股票时机含冷冻期</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</id>
    <published>2020-12-28T13:43:28.000Z</published>
    <updated>2021-01-08T09:50:07.438Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组，其中第 $i$ 个元素代表了第 $i$ 天的股票价格 。</p><ul><li><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p></li><li><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p></li></ul><a id="more"></a><img src="/blog/2020/12/28/LeetCode309-最佳买卖股票时机含冷冻期/309.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题与其他股票问题不同之处在于<strong>卖出之后至少间隔一天才能够买入</strong>，可以多次买入卖出。</p><h5 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h5><p>$dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益。</p><p>$dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。</p><h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul><li><p>如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：<br>$$<br>dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])<br>$$</p></li><li><p>如果当天持有股票，那么前一天可以持有股票或者前两天未持有股票，当天买入（如果前一天持有且卖出股票，当天就不能买入了；前一天如果未持有且没有卖出股票，就与前两天未持有，当天买入等价了）：<br>$$<br>dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i])<br>$$</p></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。假设有第零天，那么收益应也为 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">-1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 用dp_0 = 0代替</span></span><br></pre></td></tr></table></figure><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp_0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], (i - <span class="number">2</span> &lt; <span class="number">0</span> ? dp_0 : dp[i - <span class="number">2</span>][<span class="number">0</span>]) - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h5><p>由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(profit1, profit - prices[i]);</span><br><span class="line">            profit = profit0;</span><br><span class="line">            profit0 = new0;</span><br><span class="line">            profit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">LeetCode121-买卖股票的最佳时机</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/">LeetCode122-买卖股票的最佳时机II</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/">LeetCode122-买卖股票的最佳时机III</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/">LeetCode122-买卖股票的最佳时机IV</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/">LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/">LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个整数数组，其中第 $i$ 个元素代表了第 $i$ 天的股票价格 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;br&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode121-买卖股票的最佳时机</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2020-12-28T12:55:32.000Z</published>
    <updated>2021-01-08T09:49:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p><strong>注意</strong>：你不能在买入股票前卖出股票。</p><a id="more"></a><img src="/blog/2020/12/28/LeetCode121-买卖股票的最佳时机/121.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h5><h6 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h6><p>从前往后遍历找到最小的价格买入，再往后找到最大的价格卖出即可。</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        st.push(prices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt;= st.top())</span><br><span class="line">            &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                st.push(prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> m = prices[i] - st.top();</span><br><span class="line">                res = res &gt; m ? res : m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>本题是<a href>LeetCode122-买卖股票的最佳时机II</a>的简化版，这道题与其最大的区别在于限制交易次数为 <strong>一次</strong>，找到最小的起点之后，再去找最大的终点即可。</p><h6 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h6><p>$dp[i][0]$ 表示第 $i$ 天不持有股票可获得的最大收益。</p><p>$dp[i][1]$ 表示第 $i$ 天持有股票可获得的最大收益。</p><h6 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h6><ul><li><p>如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：<br>$$<br>dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])<br>$$</p></li><li><p>如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入（只能持有一次，所以第一次持有时的利润为$-prices[i]$）：<br>$$<br>dp[i][1]=max(dp[i-1][1],-prices[i])<br>$$</p></li></ul><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h6><p>由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(profit1, -prices[i]);</span><br><span class="line">            profit0 = new0;</span><br><span class="line">            profit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">LeetCode121-买卖股票的最佳时机</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/">LeetCode122-买卖股票的最佳时机II</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/">LeetCode122-买卖股票的最佳时机III</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/">LeetCode122-买卖股票的最佳时机IV</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/">LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/">LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你不能在买入股票前卖出股票。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
      <category term="栈" scheme="http://www.xingyuzhao.ltd/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode123-买卖股票的最佳时机III</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/</id>
    <published>2020-12-28T12:37:14.000Z</published>
    <updated>2021-01-09T03:13:43.973Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意</strong>: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><a id="more"></a><img src="/blog/2020/12/28/LeetCode123-买卖股票的最佳时机III/123.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题是<a href>LeetCode122-买卖股票的最佳时机II</a>的升级版，这道题与其最大的区别在于限制交易次数为 <strong>两次</strong>，所以选择哪两次交易至关重要。</p><h5 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h5><p>需要记录当前还剩下多少次交易次数，还有当天是否持有股票（ $k=0,1,2$ ）。</p><p>$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。</p><p>$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。</p><h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul><li><p>第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：<br>$$<br>dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);<br>$$</p></li><li><p>第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：<br>$$<br>dp[i][j][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);<br>$$</p></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剩余交易i次，获得收益初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">2</span> + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span> + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = max(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = max(dp[j][<span class="number">1</span>], dp[j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">LeetCode121-买卖股票的最佳时机</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/">LeetCode122-买卖股票的最佳时机II</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/">LeetCode122-买卖股票的最佳时机III</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/">LeetCode122-买卖股票的最佳时机IV</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/">LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/">LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 &lt;strong&gt;两笔&lt;/strong&gt; 交易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode122-买卖股票的最佳时机II</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</id>
    <published>2020-12-28T08:20:58.000Z</published>
    <updated>2021-01-08T09:49:32.487Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><a id="more"></a><img src="/blog/2020/12/28/LeetCode122-买卖股票的最佳时机II/122.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h5><h6 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h6><p>本题要求尽可能地完成更多地交易，所以可以使用贪心策略，在局部价格最低时买入，在局部价格最高时卖出，重复此操作直到最后一天，最后一天不持有股票时收益最大。</p><ul><li>局部最低：如果后一天价格低于前一天价格，更新局部最低，否则已经是局部最低</li><li>局部最高：在持有股票后，当前价格的下一天价格降低，说明已经达到局部最高</li></ul><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt;= val) &#123;</span><br><span class="line">                val = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; prices.size() &amp;&amp; prices[i + <span class="number">1</span>] &lt; prices[i])&#123;</span><br><span class="line">                    res += prices[i] - val;</span><br><span class="line">                    val = prices[i + <span class="number">1</span>];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 最后一天如果还持有股票应该卖出</span></span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> == prices.size())&#123;</span><br><span class="line">                    res += prices[i] - val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="另一种策略"><a href="#另一种策略" class="headerlink" title="另一种策略"></a>另一种策略</h6><p>把股票的交易价格看成曲线图，找出图中上升的部分，即为交易获利。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size()<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; prices[i + <span class="number">1</span>])</span><br><span class="line">            sum += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><h6 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h6><p>每天的状态可以为持有股票或不持有股票，所以使用 $dp[i][0]$ 表示第 $i$ 天不持有股票时的最大收益； $dp[i][1]$ 表示第 $i$ 天持有股票时的最大收益。本题交易次数 <strong>+∞</strong> 。</p><h6 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h6><ul><li><p>如果当天未持有股票，那么前一天可以未持有股票或者前一天持有股票，当天卖出：<br>$$<br>dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i])<br>$$</p></li><li><p>如果当天持有股票，那么可以前一天持有股票或者前一天未持有股票，当天买入：<br>$$<br>dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])<br>$$</p></li></ul><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h6><p>由于当天的状态只依赖于前一天，所以用两个变量来表示当天持有或者未持有的最大收益：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(profit1, profit0 - prices[i]);</span><br><span class="line">            profit0 = new0;</span><br><span class="line">            profit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">LeetCode121-买卖股票的最佳时机</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/">LeetCode122-买卖股票的最佳时机II</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/">LeetCode122-买卖股票的最佳时机III</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/">LeetCode122-买卖股票的最佳时机IV</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/">LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/">LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数组，它的第 $i$ 个元素是一支给定股票第 $i$ 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode188-买卖股票的最佳时机IV</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/</id>
    <published>2020-12-28T08:19:36.000Z</published>
    <updated>2021-01-09T03:17:15.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><a id="more"></a><img src="/blog/2020/12/28/LeetCode188-买卖股票的最佳时机IV/188.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题是<a href>LeetCode122-买卖股票的最佳时机II</a>的升级版，这道题与其最大的区别在于限制交易次数为 <strong>k</strong> 次，所以选择在何时交易至关重要。</p><p>因为买入卖出至少得两天，所以最大的交易次数不会超过 $prices.size()/2$ 。如果 $k\geq{prices.size()/2}$ ，那么本题就退化为122题。</p><h5 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h5><p>需要记录当前还剩下多少次交易次数，还有当天是否持有股票。</p><p>$dp[i][k][0]$ 表示第 $i$ 天交易 $k$ 次且不持有股票可获得的最大收益。</p><p>$dp[i][k][1]$ 表示第 $i$ 天交易 $k$ 次且持有股票可获得的最大收益。</p><h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul><li><p>第 $i$ 天不持有，前一天不持有或前一天持有今天卖出：<br>$$<br>dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);<br>$$</p></li><li><p>第 $i$ 天持有，前一天持有或前一天不持有今天买入，买入要减少一次交易次数：<br>$$<br>dp[i][j][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);<br>$$</p></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>在第一天时，如果买入股票收益为$-prices[0]$ ，没有买入时收益为 $0$。每一笔交易都需要初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剩余交易i次，获得收益初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在没有进行股票交易时不允许持有股票</span></span><br><span class="line"><span class="comment">// 这个系列中没有用到，记录学习一下</span></span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = -INF;</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -INF;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.size() / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxprofit(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)))</span></span>;</span><br><span class="line">        <span class="comment">// 最多交易i次，获得的收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="comment">// 第i天不持有，前一天不持有或前一天持有今天卖出</span></span><br><span class="line">                dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">// 第i天持有，前一天持有或前一天不持有今天买入</span></span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxprofit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(profit0, profit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(profit1, profit0 - prices[i]);</span><br><span class="line">            profit0 = new0;</span><br><span class="line">            profit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>由于当天的状态只依赖于前一天，所以可以将三维压缩为二维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.size() / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxprofit(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 最多交易i次，获得的收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="comment">// 第i天不持有，前一天不持有或前一天持有今天卖出</span></span><br><span class="line">                dp[j][<span class="number">0</span>] = max(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                <span class="comment">// 第i天持有，前一天持有或前一天不持有今天买入</span></span><br><span class="line">                dp[j][<span class="number">1</span>] = max(dp[j][<span class="number">1</span>], dp[j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxprofit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fit0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fit1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> new0 = max(fit0, fit1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new1 = max(fit1, fit0 - prices[i]);</span><br><span class="line">            fit0 = new0;</span><br><span class="line">            fit1 = new1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fit0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>股票问题系列通解（转载翻译）：<a href="https://leetcode-cn.com/circle/article/qiAgHn/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/qiAgHn/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>结束时持有 0 份股票的收益一定大于持有 1 份股票的收益？</p><p>如果结束时持有 1 份股票，可能有两种情况，一是在最后一天买入，二是在之前买入。 如果是第一种情况，则最后一天选择不买入，收益一定更高，因为不用付出购买股票的钱。 如果是第二种情况，则一定可以在最后一天卖出，卖出操作一定会增加收益。 因此，无论是哪种情况，持有 0 份股票的收益一定大于持有 1 份股票的收益。</p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">LeetCode121-买卖股票的最佳时机</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/">LeetCode122-买卖股票的最佳时机II</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/">LeetCode122-买卖股票的最佳时机III</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/">LeetCode122-买卖股票的最佳时机IV</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/28/LeetCode309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/">LeetCode309-最佳买卖股票时机含冷冻期</a></p><p><a href="http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/">LeetCode714-买卖股票的最佳时机含手续费</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;prices&lt;/code&gt; ，它的第 &lt;code&gt;i&lt;/code&gt; 个元素 &lt;code&gt;prices[i]&lt;/code&gt; 是一支给定的股票在第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 &lt;strong&gt;k&lt;/strong&gt; 笔交易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode205-同构字符串</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/27/LeetCode205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/27/LeetCode205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-12-27T02:29:59.000Z</published>
    <updated>2020-12-27T02:36:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，判断它们是否是同构的。</p><p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong><em>t</em></strong> ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p>本题是<a href="http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more">LeetCode290-单词规律</a>的简化版。</p><a id="more"></a><img src="/blog/2020/12/27/LeetCode205-同构字符串/205.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>与<a href="http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more">LeetCode290-单词规律</a>基本一致。</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>此题字母大小写均可，数组初始化时为0，每对字符都应唯一映射为同一个数。如果两个数不同，返回<code>false</code>，否则返回<code>true</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; map1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; map2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            map1[s[i]].insert(t[i]);</span><br><span class="line">            map2[t[i]].insert(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(map1[s[i]].size() &gt; <span class="number">1</span> || map2[t[i]].size() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> map1[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> map2[<span class="number">256</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1[s[i]] != map2[t[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            map1[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            map2[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解评论区：</p><p><a href="https://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt;，判断它们是否是同构的。&lt;/p&gt;
&lt;p&gt;如果 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 中的字符可以被替换得到 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt; ，那么这两个字符串是同构的。&lt;/p&gt;
&lt;p&gt;所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。&lt;/p&gt;
&lt;p&gt;本题是&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/#more&quot;&gt;LeetCode290-单词规律&lt;/a&gt;的简化版。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://www.xingyuzhao.ltd/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
