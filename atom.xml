<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2020-12-20T12:26:58.182Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode316-去除重复字母</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/20/LeetCode316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/20/LeetCode316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</id>
    <published>2020-12-20T11:21:12.000Z</published>
    <updated>2020-12-20T12:26:58.182Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p><a id="more"></a><img src="/blog/2020/12/20/LeetCode316-去除重复字母/316.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对于一个字符串来说，如果 $s[i]&gt;s[i+1]$ ，去除此时的 $s[i]$ 可以使剩下的字符串字典序最小。我们将 $s[i]$ 称为<strong>关键字符</strong>。</p><p>从前往后遍历字符串。假定在 $s[i-1]$ 之前所有的<strong>关键字符</strong>都已经去除，那么在扫描 $s[i]$ 时，新出现的<strong>关键字符</strong>只能出现在 $s[i]$ 或者其后的位置。</p><p>所以用栈来维护去除<strong>关键字符</strong>后得到的字符串。如果栈顶字符大于 $s[i]$ ，说明栈顶字符应当被去除，此时新的栈顶字符就与 $s[i]$ 相邻（保持相对位置）。重复此操作，直到栈为空或者栈顶字符不大于 $s[i]$ 。</p><p>还需要满足 $s$ 中的每个字符都出现在新字符串中且只出现一次，所以还需要考虑：</p><ul><li>如果字符 $s[i]$ 已经存在于栈中，则不再将此字符加入栈，所以需要记录字符是否被使用过</li><li>弹出栈顶字符时，如果后面再没有此字符（此字符剩余数量为0），则不能弹出，所以需要记录每个字符出现的次数；如果可以弹出，需要将此字符再次置为未使用的状态</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 记录字符使用次数</span></span><br><span class="line">        <span class="built_in">bitset</span>&lt;26&gt; vis; <span class="comment">// 记录字符是否被使用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s) cnt[ch - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">            <span class="comment">// 如果字符没被使用</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[ch - <span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="comment">// 如果栈不为空且栈顶字符大于当前字符，需要看是否弹出</span></span><br><span class="line">                <span class="keyword">while</span>(!st.empty() &amp;&amp; st.top() &gt; ch)&#123;</span><br><span class="line">                    <span class="comment">// 如果此字符串剩余次数不为0，可以弹出，并且此字符置为「未使用」</span></span><br><span class="line">                    <span class="keyword">if</span>(cnt[st.top() - <span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        vis[st.top() - <span class="string">'a'</span>] = <span class="number">0</span>;</span><br><span class="line">                        st.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前字符入栈，并且置为「已使用」</span></span><br><span class="line">                vis[ch - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">                st.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前字符被使用了一次</span></span><br><span class="line">            cnt[ch - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出栈中字符并输出</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            res += st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：</p><p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 &lt;strong&gt;返回结果的字典序最小&lt;/strong&gt;（要求不能打乱其他字符的相对位置）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="单调栈" scheme="http://www.xingyuzhao.ltd/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>C++泛型算法（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/19/C-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/19/C-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-12-19T15:37:38.000Z</published>
    <updated>2020-12-20T12:49:02.989Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>再探迭代器</li><li>泛型算法结构</li><li>特定容器算法</li></ol><a id="more"></a><h4 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h4><p>标准库在头文件<code>iterator</code>中还定义了额外集中迭代器。包括：</p><ul><li><strong>插入迭代器（insert iterator）</strong>：这些迭代器被绑定在一个容器上，可用来向容器插入元素。</li><li><strong>流迭代器（stream iterator）</strong>：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</li><li><strong>反向迭代器（reverse iterator）</strong>：这些迭代器向前而不是向后移动（<strong>书上写的是向后而不是向前，疑问？</strong>），除了<code>forward_list</code>之外的标准库容器都有反向迭代器。</li><li><strong>移动迭代器（move iterator）</strong>：这些专用的迭代器不是拷贝其中的元素，而是移动它们。后面会提到。</li></ul><h5 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h5><p>插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。</p><p>插入器有三种类型，差异在于元素插入的位置：</p><ul><li><strong>back_inserter</strong>：创建一个使用<code>push_back</code>的迭代器。</li><li><strong>front_inserter</strong>：创建一个使用<code>push_front</code>的迭代器。</li><li><strong>inserter</strong>创建一个使用<code>insert</code>的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。<strong>元素将被插入到给定得到所表示的元素之前</strong>。</li></ul><img src="/blog/2020/12/19/C-泛型算法（二）/插入迭代器_note.png"><p>当调用<code>inserter(c, iter)</code>时，会得到一个迭代器，接下来使用它时，会将元素插入到<code>iter</code>原来所指向的元素之前的位置。即，如果<code>it</code>是由<code>iterator</code>生成的迭代器，则下面两段代码效果一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*it = val;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">it = c.insert(it, val); <span class="comment">// it指向新加入的元素</span></span><br><span class="line">++it; <span class="comment">// 递增it使它指向原来的元素</span></span><br></pre></td></tr></table></figure><p><code>front_inserter</code>生成的迭代器的行为于<code>inserter</code>生成的迭代器完全不一样。当我们使用<code>front_inserter</code>时，元素总是插入到容器第一个元素之前。即使我们传递给<code>inserter</code>的位置原来是指向第一个元素的，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2, lst3; <span class="comment">// 空list</span></span><br><span class="line"><span class="comment">// 拷贝完成后，lst2包含4 3 2 1</span></span><br><span class="line">copy(lst.begin(), lst.end(), front_inserter(lst2));</span><br><span class="line"><span class="comment">// 拷贝完成后，lst3包含1 2 3 4</span></span><br><span class="line">copy(lst.begin(), lst.end(), inserter(lst3, lsr3.begin());</span><br></pre></td></tr></table></figure><h5 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h5><p>虽然<code>iostream</code>不是迭代器，但标准库定义了一个可以用于这些IO类型对象的迭代器。<strong>iostream_iterator</strong>读入输入流，<strong>ostream_iterator</strong>向一个输出流写数据。这些迭代器将它们对应的流当作一个特定的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。</p><h6 id="istream-iterator操作"><a href="#istream-iterator操作" class="headerlink" title="istream_iterator操作"></a>istream_iterator操作</h6><p>当创建一个流迭代器时，必须指定将要读写的对象类型。一个<code>istream_iterator</code>使用<code>&gt;&gt;</code>来读取流。因此，<code>istream_iterator</code>要读取的类型必须定义了输入运算符。当创建一个<code>istream_iterator</code>时，我们可以将它绑定到一个流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">// 从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof; <span class="comment">// 尾后迭代器</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"afile"</span>)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; str_it; <span class="comment">// 从"afile"读取字符串</span></span><br></pre></td></tr></table></figure><p>下面是一个用<code>istream_iterator</code>从标准输入读取数据，存入一个<code>vector</code>的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">// 从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof; <span class="comment">// istream尾后迭代器</span></span><br><span class="line"><span class="keyword">while</span>(in_iter != eof)&#123;</span><br><span class="line">    <span class="comment">// 后置递增运算读取流，返回迭代器的旧值</span></span><br><span class="line">    <span class="comment">// 解引用迭代器，获得从流读取的前一个值</span></span><br><span class="line">    vec.push_back(*in_iter++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eof</code>被定义为空的<code>istream_iterator</code>，从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等。</p><p>上述程序可以改写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in_iter(cin), eof; // 从cin读取int</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>; <span class="comment">// 从迭代器范围构造vec</span></span><br></pre></td></tr></table></figure><img src="/blog/2020/12/19/C-泛型算法（二）/istream_iterator操作.png" style="zoom: 80%;"><h6 id="使用算法操作流迭代器"><a href="#使用算法操作流迭代器" class="headerlink" title="使用算法操作流迭代器"></a>使用算法操作流迭代器</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in(cin), eof;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(in, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>此调用会计算出从标准输入读取的值的和。</p><h6 id="istream-iterator允许使用懒惰求值"><a href="#istream-iterator允许使用懒惰求值" class="headerlink" title="istream_iterator允许使用懒惰求值"></a>istream_iterator允许使用懒惰求值</h6><p>当我们将一个<code>istream_iterator</code>绑定到一个流时，标准库并不保证迭代器立即从流读取数据。可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。</p><h6 id="ostream-iterator操作"><a href="#ostream-iterator操作" class="headerlink" title="ostream_iterator操作"></a>ostream_iterator操作</h6><p>我们可以对具有输出运算符<code>&lt;&lt;</code>的类型定义<code>ostream_iterator</code>。创建一个<code>ostream_iterator</code>时，可选第二个参数，它是一个<strong>C</strong>风格字符串（<strong>即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）</strong>。在输出的每个元素之后都会打印此字符串。并且必须将<code>ostream_iterator</code>绑定到一个指定的流，不允许空的或表示尾后位置的<code>ostream_iterator</code>。</p><img src="/blog/2020/12/19/C-泛型算法（二）/ostream_iterator操作.png" style="zoom:80%;"><p>我们可以用<code>ostream_iterator</code>来输出值的序列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">" "</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : vec)</span><br><span class="line">*out_iter++ = e; <span class="comment">// 赋值语句实际上将元素写到cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 下面的也行，但不推荐</span></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">" "</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : vec)</span><br><span class="line">out_iter = e; <span class="comment">// 赋值语句将元素写到cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运算符<code>*</code>和<code>++</code>不对<code>ostream_iterator</code>对象做任何操作。第一种写法流迭代器的使用与其他迭代器的使用保持一致。</p><p>可以通过<code>copy</code>来打印<code>vec</code>中的元素，更简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy(vec.begin(), vec.end(), out_iter);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h6 id="使用流迭代器处理类类型"><a href="#使用流迭代器处理类类型" class="headerlink" title="使用流迭代器处理类类型"></a>使用流迭代器处理类类型</h6><p>对于之前的<code>Sales_item</code>既有输入运算符也有输出运算符，可以使用IO迭代器重写书店程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始程序</span></span><br><span class="line">Sales_item total; <span class="comment">// 保存下一条交易记录的变量</span></span><br><span class="line"><span class="comment">// 读入第一条交易记录，并确保有数据可以处理</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span> &gt;&gt; total)&#123;</span><br><span class="line">    Sales_item trans; <span class="comment">// 保存和的变量</span></span><br><span class="line">    <span class="comment">// 读入并处理剩余交易记录</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; trans)&#123;</span><br><span class="line">        <span class="comment">// 如果我们仍在处理相同的书</span></span><br><span class="line">        <span class="keyword">if</span>(total.isbn() == trans.isbn())</span><br><span class="line">            totao += trans; <span class="comment">// 更新销售总额</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 打印前一本书的结果</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            total = trans; <span class="comment">// total现在表示下一本书的销售额</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用IO迭代器重写</span></span><br><span class="line">istream_iterator&lt;Sales_item&gt; item_iter(cin), eof;</span><br><span class="line"><span class="function">ostream_iterator&lt;Sales_item&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">"\n"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 将第一笔交易记录存在sum中，并读取下一条记录</span></span><br><span class="line">Sales_item sum = *item_iter++;</span><br><span class="line"><span class="keyword">while</span>(item_iter != eof)&#123;</span><br><span class="line">    <span class="comment">// 如果当前交易记录（存在item_iter中）有相同的ISBN号</span></span><br><span class="line">    <span class="keyword">if</span>(item_iter-&gt;isbn() == sum.isbn())</span><br><span class="line">        sum += *item_iter++;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        out_iter = sum;</span><br><span class="line">        sum = *item_iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">out_iter = sum;</span><br></pre></td></tr></table></figure><h5 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h5><p>顾名思义，反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增和递减含义会颠倒过来。递增一个反向迭代器（<code>++it</code>）会移动到前一个元素；递减一个反向迭代器（<code>--it</code>）会移动到后一个元素。反向迭代器也有<code>const</code>和非<code>const</code>版本。</p><img src="/blog/2020/12/19/C-泛型算法（二）/反向迭代器.png" style="zoom:80%;"><p>下面是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> r_iter = vec.crbegin(); r_iter != vec.crend(); ++r_iter)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *r_iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 打印6，5，4，3，2，1</span></span><br></pre></td></tr></table></figure><p>可以通过向<code>sort</code>传递一对反向迭代器来将<code>vector</code>整理为递减：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(vec.begin(), vec.end()); <span class="comment">// 递增</span></span><br><span class="line">sort(vec.rbegin(), vec.rend()); <span class="comment">// 递减</span></span><br></pre></td></tr></table></figure><h6 id="反向迭代器和其他迭代器间的关系"><a href="#反向迭代器和其他迭代器间的关系" class="headerlink" title="反向迭代器和其他迭代器间的关系"></a>反向迭代器和其他迭代器间的关系</h6><p>假定有一个名为<code>line</code>的<code>string</code>，保存着以逗号分隔的单词列表，我们希望打印<code>line</code>中的第一个单词，可以使用<code>find</code>完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> comma = find(line.cbegin(), line.cend(), <span class="string">','</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(line.cbegin(), comma) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>如果<code>line</code>中有逗号，那么<code>comma</code>将指向这个逗号，否则它指向<code>line.cend()</code>。如果希望打印最后一个单词：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> rcomma = find(line.crbegin(), line.crend(), <span class="string">','</span>);</span><br></pre></td></tr></table></figure><p>当我们试图打印找到的单词时，不能用以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，对于FIRST,MIDDLE,LAST会打印出TSAL</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(line.crbegin(), rcomma) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>需要做的是，将<code>rcomma</code>转换为一个普通迭代器，能在<code>line</code>中正向移动。可以调用<code>reverse_iterator</code>中的<code>base</code>成员来完成这一转换，此成员函数会返回其对应的普通迭代器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(rcomma.base(), line.cend()) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><img src="/blog/2020/12/19/C-泛型算法（二）/反向迭代器_使用base.png" style="zoom:80%;"><p>需要注意的是：</p><img src="/blog/2020/12/19/C-泛型算法（二）/反向迭代器_note.png" style="zoom: 80%;"><h4 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h4><p>算法所要求的迭代器操作可以分为5个迭代器类别：</p><img src="/blog/2020/12/19/C-泛型算法（二）/迭代器类别.png" style="zoom:80%;"><h5 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h5><p>对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。<strong>而这种错误很多编译器不会给出任何警告和提示</strong>。</p><h6 id="输入迭代器（input-iterator）"><a href="#输入迭代器（input-iterator）" class="headerlink" title="输入迭代器（input iterator）"></a>输入迭代器（input iterator）</h6><p>可以读取序列中的元素。一个输入迭代器必须支持：</p><ul><li>用于比较两个迭代器的相等和不相等运算符（<code>==、!=</code>）</li><li>用于推进迭代器的前置和后置递增运算（<code>++</code>）</li><li>用于读取元素的解引用运算符（<code>*</code>）；解引用只会出现在赋值运算符的右侧</li><li>箭头运算符（<code>-&gt;</code>），等价于<code>(*it).member</code>，即，解引用迭代器，并提取对象的成员</li></ul><p>输入迭代器只用于顺序访问，只能用于单边扫描算法。算法<code>find</code>和<code>accumulate</code>要求输入迭代器；而<code>istream_iterator</code>是一种输入迭代器。</p><h6 id="输出迭代器（output-iterator）"><a href="#输出迭代器（output-iterator）" class="headerlink" title="输出迭代器（output iterator）"></a>输出迭代器（output iterator）</h6><p>可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：</p><ul><li>用于推进迭代器的前置和后置递增运算（<code>++</code>）</li><li>解引用运算符（<code>*</code>），只出现在赋值运算符的左侧</li></ul><p>例如，<code>copy</code>函数的第三个参数就是输出迭代器；<code>ostream_iterator</code>是一种输出迭代器。</p><h6 id="前向迭代器（forward-iterator）"><a href="#前向迭代器（forward-iterator）" class="headerlink" title="前向迭代器（forward iterator）"></a>前向迭代器（forward iterator）</h6><p>可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法<code>replace</code>要求前向迭代器， <code>forward_list</code>上的迭代器是前向迭代器。</p><h6 id="双向迭代器（bidirectional-iterator）"><a href="#双向迭代器（bidirectional-iterator）" class="headerlink" title="双向迭代器（bidirectional iterator）"></a>双向迭代器（bidirectional iterator）</h6><p>可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（<code>--</code>）。算法<code>reverse</code>要求双向迭代器，除了<code>forward_list</code>之外，其他标准库都提供符合双向迭代器要求的迭代器.</p><h6 id="随机访问迭代器（random-access-iterator）"><a href="#随机访问迭代器（random-access-iterator）" class="headerlink" title="随机访问迭代器（random-access iterator）"></a>随机访问迭代器（random-access iterator）</h6><p>提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，还支持以下操作：</p><ul><li>用于比较两个迭代器相对位置的关系运算符（<code>&lt;、&lt;=、&gt;</code>和<code>&gt;=</code>) </li><li>迭代器和一个整数值的加减运算（<code>+、+=、-</code>和<code>-=</code>），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置</li><li>用于两个迭代器上的减法运算符（<code>-</code>），得到两个迭代器的距离</li><li>下标运算符<code>iter[n]</code>，与<code>*(iter[n])</code>等价</li></ul><p>算法<code>sort</code>要求随机访问迭代器。<code>array、deque、string、vector</code>的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。</p><h5 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h5><p>大多数算法具有如下4种形式之一：</p><ul><li><strong><em>alg</em></strong> ( beg, end, <strong><em>other args</em></strong>)</li><li><strong><em>alg</em></strong> ( beg, end, dest, <strong><em>other args</em></strong>)</li><li><strong><em>alg</em></strong> ( beg, end, beg2, <strong><em>other args</em></strong>)</li><li><strong><em>alg</em></strong> ( beg, end, be2, end2, <strong><em>other args</em></strong>)</li></ul><h5 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h5><p>如何提供一个操作代替默认的<code>&lt;</code>或<code>==</code>运算符，以及算法是将输出数据写入输入序列，还是写入分离的目的位置等问题。</p><h6 id="一些算法使用重载形式传递一个谓词"><a href="#一些算法使用重载形式传递一个谓词" class="headerlink" title="一些算法使用重载形式传递一个谓词"></a>一些算法使用重载形式传递一个谓词</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique(beg, end); <span class="comment">// 使用 == 运算符比较元素</span></span><br><span class="line">unique(beg, end, comp); <span class="comment">// 使用comp比较元素</span></span><br></pre></td></tr></table></figure><h6 id="if版本的算法"><a href="#if版本的算法" class="headerlink" title="_if版本的算法"></a>_if版本的算法</h6><p>接受一个元素值得算法通常有另一个不同名的版本（非重载），该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的<code>_if</code>前缀：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val); <span class="comment">// 查找输入范围种val第一次出现的位置</span></span><br><span class="line">find_if(beg, end, pred);<span class="comment">// 查找第一个令pred为真的元素</span></span><br></pre></td></tr></table></figure><h6 id="区分拷贝元素的版本和不拷贝的版本"><a href="#区分拷贝元素的版本和不拷贝的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝的版本"></a>区分拷贝元素的版本和不拷贝的版本</h6><p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个<code>_copy</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse(beg, end); <span class="comment">// 反转输入范围中元素的顺序</span></span><br><span class="line">reverse_copy(beg, end ,dest); <span class="comment">// 将元素按逆序拷贝到dest</span></span><br></pre></td></tr></table></figure><p>一些算法同时提供<code>_if</code>和<code>_copy</code>版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从v1中删除奇数元素</span></span><br><span class="line">remove_if(v1.begin(), v1.end(), </span><br><span class="line">          [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span>; &#125;);</span><br><span class="line"><span class="comment">// 将偶数元素从v1拷贝到v2，v1不变</span></span><br><span class="line">remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),</span><br><span class="line">              [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i % <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h4><p>与其他容器不同，链表类型<code>list</code>和<code>forward_list</code>定义了几个成员函数形式的算法，它们定义了独有的<code>sort、merge、remove、reverse、unique</code>，这些独有的版本比通用版本好得多。</p><img src="/blog/2020/12/19/C-泛型算法（二）/特定容器算法.png" style="zoom:80%;"><p>算法如下：</p><img src="/blog/2020/12/19/C-泛型算法（二）/list.png" style="zoom:80%;"><h5 id="splice成员"><a href="#splice成员" class="headerlink" title="splice成员"></a>splice成员</h5><img src="/blog/2020/12/19/C-泛型算法（二）/splice.png" style="zoom:80%;"><h5 id="链表特有的操作会改变容器"><a href="#链表特有的操作会改变容器" class="headerlink" title="链表特有的操作会改变容器"></a>链表特有的操作会改变容器</h5><p>链表特有版本会改变底层的容器，例如<code>remove</code>会删除指定的元素。<code>unique</code>会删除第二个和后继的重复元素。</p><p>类似的，通用版本<code>merge</code>将合并的序列写到一个给定的目的迭代器，两个输入序列是不变的。而链表版本的<code>merge</code>会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用<code>merge</code>的链表对象中。在<code>merge</code>之后，来自两个链表中的元素依然存在，但它们都已在同一个链表中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;再探迭代器&lt;/li&gt;
&lt;li&gt;泛型算法结构&lt;/li&gt;
&lt;li&gt;特定容器算法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++泛型算法（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/19/C-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/19/C-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-12-19T15:37:19.000Z</published>
    <updated>2020-12-20T12:35:54.151Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>概述</li><li>初识泛型算法</li><li>定制操作</li></ol><a id="more"></a><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>大多数算法都定义在头文件<code>algorithm</code>中。标准库还在头文件<code>numeric</code>中定义了一组数值泛型算法。</p><h5 id="算法永远不会执行容器的操作"><a href="#算法永远不会执行容器的操作" class="headerlink" title="算法永远不会执行容器的操作"></a>算法永远不会执行容器的操作</h5><p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。算法永远<strong>不会改变</strong>底层容器的大小。算法可能<strong>改变</strong>容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p><p>标准库定义了一类特殊的迭代器，称为插入器（inserter）。它们会在底层的容器上执行插入操作。当一个算法操作这样的一个迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身<strong>不会</strong>做这样的操作。</p><h4 id="初识泛型算法"><a href="#初识泛型算法" class="headerlink" title="初识泛型算法"></a>初识泛型算法</h4><p>标准库算法都对一个范围内的元素进行操作。此范围称为“输入范围”。输入范围使用两个参数：要处理的第一个元素和尾元素之后的位置的迭代器。</p><h5 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h5><p>此类算法只会读取其输入范围内的元素，而从不改变元素。如<code>find</code>，<code>count</code>。定义在<code>numeric</code>中有只读算法<code>accumulate</code>，前两个指出需要求和的元素的范围，第三个参数是和的初值。最好用<code>cbegin()</code>和<code>cend()</code>，除非打算用返回的迭代器来改变元素的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对vec中的元素求和，和的初值为0</span></span><br><span class="line"><span class="keyword">int</span> sum = accumulate(v.cbegin(), v.cend(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h6 id="算法和元素类型"><a href="#算法和元素类型" class="headerlink" title="算法和元素类型"></a>算法和元素类型</h6><p><code>accumulate</code>第三个参数为求和起点，包含了一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须和第三个参数匹配。由于<code>string</code>定义了<code>+</code>操作，所以可以将<code>vector</code>中的所有<code>string</code>连接起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="built_in">string</span>(<span class="string">""</span>));</span><br></pre></td></tr></table></figure><p>将空串当作一个字符串字面值传递给第三个参数是不可以的，会导致编译错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：const char*上没有定义+运算符</span></span><br><span class="line"><span class="built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="string">""</span>);</span><br></pre></td></tr></table></figure><h6 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h6><p>只读算法<code>equal</code>用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素和第二个序列中的对应元素逐个比较，如果都相等返回<code>true</code>，否则返回<code>false</code>。此算法接受三个迭代器：前两个表示第一个序列范围，第三个表示第二个序列的首元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roster2中的元素数目应该至少于roster1一样多</span></span><br><span class="line">equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());</span><br></pre></td></tr></table></figure><p><code>equal</code>基于假设：第二个序列至少与第一个序列一样长。</p><p>*<strong>注意！！！**</strong>那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。*</p><h5 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h5><p>一些算法将新值赋予序列中的元素，需要确保序列原大小至少不小于要求算法写入的元素数目。例如<code>fill</code>接受一对迭代器表示一个范围，还接受一个值作为第三个参数，将范围内的值置为第三个参数的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fill(vec.begin(), vec.end(), <span class="number">0</span>); <span class="comment">// 将每个元素重置为0</span></span><br><span class="line"><span class="comment">// 将容器的一个子序列设置为10</span></span><br><span class="line">fill(vec.begin(), vec.begin() + vec.size() / <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h6 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h6><p>一些算法接受一个迭代器来指出一个单独的目的位置，从目的位置开始，将新值赋予一个序列中的元素。例如<code>fill_n</code>接受一个单迭代器、一个计数值和一个值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill_n(dest, n, val);</span><br></pre></td></tr></table></figure><p><code>fill_n</code>假定<code>dest</code>指向一个元素，从<code>dest</code>开始的序列至少包含n个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">// 空vector</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">fill_n(vec.begin(), vec.size(); <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 错误,vec并没有10个元素</span></span><br><span class="line">fill_n(vec.begin(), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h6 id="介绍back-inserter"><a href="#介绍back-inserter" class="headerlink" title="介绍back_inserter"></a>介绍back_inserter</h6><p><code>back_inserter</code>定义在头文件<code>iterator</code>中，其接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it = back_inserter(vec);</span><br><span class="line">*it = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>常常使用<code>back_inserter</code>创建一个迭代器，作为算法的目的位置来使用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill_n(back_inserter(vec), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h6 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h6><p>此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。算法将输入范围中的元素拷贝到目的序列中。<strong>传递给<code>copy</code>的目的序列至少要包含与输入序列一样多的元素</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="keyword">sizeof</span>(a1) / <span class="keyword">sizeof</span>(*a1)];</span><br><span class="line"><span class="keyword">auto</span> ret = copy(begin(a1), end(a1), a2);</span><br></pre></td></tr></table></figure><p><code>copy</code>返回其目的位置迭代器（递增后）的值，即<code>ret</code>恰好指向拷贝到<code>a2</code>的尾元素之后的位置。</p><p>多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放在输入序列的末尾，而是创建一个新序列保存这些结果。</p><p>如<code>replace</code>，其读入一个序列，并将其中所有等于给定值元素都改为另一个值，此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有值为0的元素改为42</span></span><br><span class="line">replace(ilist.begin(), ilist.end(), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>对于它的“拷贝”版本<code>replace_copy</code>，此算法接受额外第三个迭代器参数，指出点整后序列的保存位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用back_inserter按需要增长目标序列</span></span><br><span class="line">replace_copy(ilist.cbegin(), ilist.cend(),</span><br><span class="line">             back_inserter(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>经过此调用，<code>ilist</code>并未改变，<code>ivec</code>包含<code>ilist</code>的一份拷贝，不过原来在<code>ilist</code>中值为0的元素在<code>ivec</code>中都变为42。</p><h5 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h5><p>假定已经有一个<code>vector</code>，保存了多个故事的文本，简化这个<code>vector</code>，使得每个单词只出现一次。输入如下：</p><img src="/blog/2020/12/19/C-泛型算法（一）/重排_输入.png" style="zoom:80%;"><p>要求得到的结果如下：</p><img src="/blog/2020/12/19/C-泛型算法（一）/重排_输出.png"><p>为了消除重复单词，先对<code>vector</code>排序，使得重复的单词相邻出现，之后可以使用另一个称为<code>unique</code>的标准库算法来重排<code>vector</code>，使得不重复的元素出现在<code>vector</code>的开始部分。由于算法不能执行容器的操作，可以使用<code>vector</code>的成员<code>erase</code>来完成真正的删除操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</span><br><span class="line">sort(words.begin(), words.end());</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">end_unique</span><span class="params">(words.begin(), words.end())</span></span>;</span><br><span class="line">    words.erase(end_unique, words.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>words</code>排序完毕后，使用<code>unique</code>算法重排输入序列，将相邻的重复项”消除“，并<strong>返回一个指向最后一个不重复元素之后的位置的迭代器</strong>。调用<code>unique</code>后，<code>vector</code>将变为：</p><img src="/blog/2020/12/19/C-泛型算法（一）/after_unique.png"><p>如上图所示，<code>unique</code>并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列的开始部分。<code>unique</code>返回的迭代器位置之后的元素依旧存在，但不知道是什么。</p><p><strong>标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元。素</strong></p><p>最后，使用<code>erase</code>删除从<code>end_unique</code>开始至<code>words</code>末尾的范围内的所有元素。即使<code>words</code>中没有重复单词，调用<code>erase</code>也是安全的，删除空的范围没什么不良后果。</p><h4 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h4><p>详见<a href="http://www.xingyuzhao.ltd/blog/2020/08/02/C-11%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">C++11之lambda表达式</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;初识泛型算法&lt;/li&gt;
&lt;li&gt;定制操作&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode48-旋转图像</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/19/LeetCode48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/19/LeetCode48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2020-12-19T02:05:48.000Z</published>
    <updated>2020-12-20T12:56:07.564Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个 $n × n$ 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><a id="more"></a><img src="/blog/2020/12/19/LeetCode48-旋转图像/48.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>不好意思，一开始我还是用了新的数组。</p><p>从最后一列往前，从第一行往后，每一列都是由相应的行复制过来，如下图（示例二）：</p><img src="/blog/2020/12/19/LeetCode48-旋转图像/48_思路.png" style="zoom:80%;"><p>新建数组保存原始数组的拷贝，然后再根据原始数组拷贝来修改原始数组。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> scale = matrix.size();</span><br><span class="line">        <span class="keyword">auto</span> matrixHelper = matrix;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// 表示当前遍历到拷贝数组的第pos行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = scale - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; ++i)&#123;</span><br><span class="line">                <span class="comment">// 前面的i表示原始数组的行，后面的i表示拷贝数组的列</span></span><br><span class="line">                matrix[i][j] = matrixHelper[pos][i];</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度和空间复杂度都是$O(N^2)$。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>仔细观察旋转后的图：</p><img src="/blog/2020/12/19/LeetCode48-旋转图像/48_思路.png" style="zoom:80%;"><p>对于矩阵中第 $i$ 行的第 $j$ 个元素，在旋转后，它出现在倒数第 $i $ 列的第 $j$ 个位置。即：<br>$$<br>matrix_{new}[col][n-row-1]=matrix[row][col]<br>$$<br>这样可以得到以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">auto</span> matrixHelper = matrix;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = matrixHelper[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样也不是原地修改，但是可以得到上面那个重要等式。</p><p>如果对矩阵先进行水平轴翻转，再进行主对角线翻转，也可以得到旋转后的矩阵，以示例二为例：</p><ol><li>水平翻转：</li></ol><p>$$<br>\left[<br>\begin{matrix}<br>    5 &amp; 1 &amp; 9 &amp; 11 \\<br>    2 &amp; 4 &amp; 8 &amp; 10 \\<br>    13 &amp; 3 &amp; 6 &amp; 7 \\<br>    15 &amp; 14 &amp; 12 &amp; 16<br>    \end{matrix}<br>    \right]\stackrel{\Large水平翻转}{\huge\longrightarrow}<br>\left[<br>\begin{matrix}<br>    15 &amp; 14 &amp; 12 &amp; 16\\<br>    13 &amp; 3 &amp; 6 &amp; 7 \\<br>    2 &amp; 4 &amp; 8 &amp; 10 \\<br>    5 &amp; 1 &amp; 9 &amp; 11<br>    \end{matrix}<br>    \right]<br>$$</p><p>$$<br>matrix[row][col]=matrix[n-row-1][col]<br>$$</p><ol start="2"><li>主对角线翻转：</li></ol><p>$$<br>\left[<br>\begin{matrix}<br>    15 &amp; 14 &amp; 12 &amp; 16 \\<br>    13 &amp; 3 &amp; 6 &amp; 7 \\<br>    2 &amp; 4 &amp; 8 &amp; 10 \\<br>    5 &amp; 1 &amp; 9 &amp; 11<br>    \end{matrix}<br>    \right]\stackrel{\Large主对角线翻转}{\huge\longrightarrow}<br>\left[<br>\begin{matrix}<br>    15 &amp; 13 &amp; 2 &amp; 5 \\<br>    14 &amp; 3 &amp; 4 &amp; 1 \\<br>    12 &amp; 6 &amp; 8 &amp; 9 \\<br>    16 &amp; 7 &amp; 10 &amp; 11<br>    \end{matrix}<br>    \right]<br>$$</p><p>$$<br>matrix[row][col]=matrix[col][row]<br>$$</p><p>综合以上两式，可以得到：<br>$$<br>matrix[row][col]\stackrel{\large水平翻转}{\large\longrightarrow}matrix[n-row-1][col]<br>$$</p><p>$$<br>matrix[n-row-1][col]\stackrel{\large主对角线翻转}{\large\longrightarrow}matrix[col][n-row-1]<br>$$</p><p>即：<br>$$<br>matrix[row][col]=matrix_{new}[col][n-row-1]<br>$$<br>这就与之前得到的重要等式相同了。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：</p><p><a href="https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个 $n × n$ 的二维矩阵表示一个图像。&lt;/p&gt;
&lt;p&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;你必须在&lt;strong&gt;原地&lt;/strong&gt;旋转图像，这意味着你需要直接修改输入的二维矩阵。&lt;strong&gt;请不要&lt;/strong&gt;使用另一个矩阵来旋转图像。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode389-找不同</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/18/LeetCode389-%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/18/LeetCode389-%E6%89%BE%E4%B8%8D%E5%90%8C/</id>
    <published>2020-12-18T01:54:31.000Z</published>
    <updated>2020-12-18T01:58:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，它们只包含小写字母。</p><p>字符串 <strong><em>t</em></strong> 由字符串 <strong><em>s</em></strong> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <strong><em>t</em></strong> 中被添加的字母。</p><a id="more"></a><img src="/blog/2020/12/18/LeetCode389-找不同/389.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用一个长为26的数组记录在 <strong><em>t</em></strong> 中所有字母的出现次数，然后再去遍历 <strong><em>s</em></strong> ，对每次遇到的字母对应的次数减一，最后再遍历这个数组，如果有出现次数为1的字母，那么这就是 <strong><em>t</em></strong> 中被添加的字母。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : t)&#123;</span><br><span class="line">            <span class="built_in">map</span>[ch - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">            <span class="built_in">map</span>[ch - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">char</span>(i + <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">char</span>(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt;，它们只包含小写字母。&lt;/p&gt;
&lt;p&gt;字符串 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt; 由字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 随机重排，然后在随机位置添加一个字母。&lt;/p&gt;
&lt;p&gt;请找出在 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt; 中被添加的字母。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode714-买卖股票的最佳时机含手续费</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/17/LeetCode714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</id>
    <published>2020-12-17T03:46:09.000Z</published>
    <updated>2020-12-20T12:56:46.674Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 $prices$，其中第 $i$ 个元素代表了第 $i$ 天的股票价格；非负整数 $fee$ 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><a id="more"></a><img src="/blog/2020/12/17/LeetCode714-买卖股票的最佳时机含手续费/714.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="定义-dp-数组"><a href="#定义-dp-数组" class="headerlink" title="定义$dp$数组"></a>定义$dp$数组</h5><p>使用两个数组 $dp1[i]$ 和 $dp2[i]$ 分别表示当天持有股票or当天不持有股票时的最大收益。</p><h5 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h5><ul><li>$dp1[i]$表示第 $i$ 天未持有的最大收益，由上一天未持有或者上一天持有当天卖出得到：</li></ul><p>$$<br>dp1[i] = max(dp1[i - 1], dp2[i - 1] + prices[i] - fee)<br>$$</p><ul><li>$dp2[i] $表示第 $i$ 天持有的最大收益，由上一天持有或者上一天不持有今天买入得到：</li></ul><p>$$<br>dp2[i] = max(dp2[i - 1], dp1[i - 1] - prices[i])<br>$$</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li>第一天未持有股票时，收益为0，$dp1[0] = 0$。</li><li>第一天持有股票时，收益为当天买入所需要的钱，$dp2[0] = -prices[0]$。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(prices.size())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp2</span><span class="params">(prices.size())</span></span>;</span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp2[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            dp1[i] = max(dp1[i - <span class="number">1</span>], dp2[i - <span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp2[i] = max(dp2[i - <span class="number">1</span>], dp1[i - <span class="number">1</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1[prices.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>注意到 $dp1[i]$ 和 $dp2[i]$ 只会从 $dp1[i-1]$ 和 $dp2[i-1]$ 转移而来，所以用两个变量 $sell$ 以及 $buy$ 分别表示 $dp1[i]$ 和 $dp2[i]$，空间复杂度降为 $O(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = sell;</span><br><span class="line">            sell = max(sell, buy + prices[i] - fee);</span><br><span class="line">            buy = max(buy, sell - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>评论区：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/comments/</a></p><p>官方题解：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个整数数组 $prices$，其中第 $i$ 个元素代表了第 $i$ 天的股票价格；非负整数 $fee$ 代表了交易股票的手续费用。&lt;/p&gt;
&lt;p&gt;你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。&lt;/p&gt;
&lt;p&gt;返回获得利润的最大值。&lt;/p&gt;
&lt;p&gt;注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="股票问题" scheme="http://www.xingyuzhao.ltd/tags/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode290-单词规律</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/16/LeetCode290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</id>
    <published>2020-12-16T03:47:07.000Z</published>
    <updated>2020-12-17T08:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。</p><p>这里的 <code>遵循</code> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><a id="more"></a><img src="/blog/2020/12/16/LeetCode290-单词规律/290.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>字母和单词一一对应时返回true，否则返回false。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">istr</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str;</span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">while</span>(istr &gt;&gt; word)&#123;</span><br><span class="line">            str.push_back(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern.size() != str.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&gt; map1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; map2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.size(); ++i)&#123;</span><br><span class="line">            map1[pattern[i]].insert(str[i]);</span><br><span class="line">            map2[str[i]].insert(pattern[i]);</span><br><span class="line">            <span class="comment">// 如果不是一一对应，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(map1[pattern[i]].size() &gt; <span class="number">1</span> || map2[str[i]].size() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一种规律 &lt;code&gt;pattern&lt;/code&gt; 和一个字符串 &lt;code&gt;str&lt;/code&gt; ，判断 &lt;code&gt;str&lt;/code&gt; 是否遵循相同的规律。&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;遵循&lt;/code&gt; 指完全匹配，例如， &lt;code&gt;pattern&lt;/code&gt; 里的每个字母和字符串 &lt;code&gt;str&lt;/code&gt; 中的每个非空单词之间存在着双向连接的对应规律。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode738-单调递增的数字</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/15/LeetCode738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/15/LeetCode738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-12-15T01:25:29.000Z</published>
    <updated>2020-12-20T12:55:51.505Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个非负整数 <code>N</code>，找出小于或等于 <code>N</code> 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。（当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是单调递增的。）</p><a id="more"></a><img src="/blog/2020/12/15/LeetCode738-单调递增的数字/738.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这种思路太繁琐，不想看的话直接转至<strong>更进一步</strong>。</p><hr><p>输入是一个非负整数，所以第一步要将其转换成可以遍历的形式，可以先将整数转换为字符串序列。</p><p>从<strong>输入序列</strong>的第一个数开始，一个一个数的建立起<strong>答案序列</strong>。</p><ol><li><strong>输入序列单调不减</strong>，答案序列的当前值最大可以取到输入序列的当前值。如输入为1234，那么答案序列的第一个位置最大可以取到1，继续遍历，取到当前位置最大值时，一直会大于等于上一个取到的值，所以最终可以得到答案1234：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums; <span class="comment">// 输入序列</span></span><br><span class="line"><span class="built_in">string</span> res; <span class="comment">// 答案序列</span></span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">-1</span>; <span class="comment">// 初始化为-1，保证第一个值可以取到</span></span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">    cur = nums[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur &gt;= pre)&#123;</span><br><span class="line">        res += to_string(cur);</span><br><span class="line">        pre = nums[i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>输入序列非单调不减</strong>，如果当前值小于上一个可以取到的最大值，就需要回退，直到当前值不小于上一个可以取到的最大值。如输入332。<ol><li>当取到2时小于上一个取到的值3，上一个值减去1作为当前值（得到2），<code>res</code>出栈一次，如果出栈后<code>res</code>为空，那么存下当前值并退出。否则，上一个值取<code>res</code>末尾的值（第一个3）。</li><li>当前值为2，上一个值为第一个3，由于2小于3，那么再将上一个值减1作为当前值得到2），出栈一次，遍历回退一次，那么当前值变为2，此时<code>res</code>为空，记录2并且退出遍历。</li></ol></li></ol><ul><li>使用一个<code>flag</code>标记是否回退。</li><li>如果<code>res == &quot;0&quot;</code>，说明第一个数为0，此时答案长度为输入序列的长度减去1，全部为9；否则，就在<code>res</code>后补充9直到和输入序列长度相同。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> nums = to_string(N);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                cur = nums[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= pre)&#123;</span><br><span class="line">                    res += to_string(cur);</span><br><span class="line">                    pre = nums[i] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    pre--;</span><br><span class="line">                    res.pop_back();</span><br><span class="line">                    <span class="keyword">if</span>(res.empty())&#123;</span><br><span class="line">                        res += to_string(pre);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = pre;</span><br><span class="line">                    pre = res.back() - <span class="string">'0'</span>;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur &gt;= pre)&#123;</span><br><span class="line">                    res += to_string(cur);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre--;</span><br><span class="line">                res.pop_back();</span><br><span class="line">                <span class="keyword">if</span>(res.empty())&#123;</span><br><span class="line">                    res += to_string(pre);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = pre;</span><br><span class="line">                pre = res.back() - <span class="string">'0'</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> resVal;</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="string">"0"</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">buf</span><span class="params">(n, <span class="string">'9'</span>)</span></span>;</span><br><span class="line">            resVal = stoi(buf, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = res.size(); j &lt; nums.size(); ++j)&#123;</span><br><span class="line">                res += <span class="string">'9'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            resVal = stoi(res, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种思路实现起来太繁琐了（我是sb）。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>局部最优：遇到<code>nums[i - 1] &gt; nums[i]</code>的情况，让<code>nums[i - 1]--</code>，然后<code>nums[i]</code>值为9，可以保证这两位变成最大单调不减整数。</p><p>全局最优：尽量使<code>nums[i - 1]--</code>靠后，这样做可以使整数尽可能的大，因为越后面减去1，对整数的损失越小，所以从后往前遍历。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> nums = to_string(N);</span><br><span class="line">        <span class="keyword">int</span> flag = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; nums[i])&#123;</span><br><span class="line">                nums[i - <span class="number">1</span>]--;</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(flag; flag &lt; nums.size(); ++flag)&#123;</span><br><span class="line">            nums[flag] = <span class="string">'9'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stoi(nums, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>题解：</p><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/solution/738-dan-diao-di-zeng-de-shu-zi-tan-xin-s-vq4r/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/monotone-increasing-digits/solution/738-dan-diao-di-zeng-de-shu-zi-tan-xin-s-vq4r/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个非负整数 &lt;code&gt;N&lt;/code&gt;，找出小于或等于 &lt;code&gt;N&lt;/code&gt; 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。（当且仅当每个相邻位数上的数字 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 满足 &lt;code&gt;x &amp;lt;= y&lt;/code&gt; 时，我们称这个整数是单调递增的。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode49-字母异位词分组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/14/LeetCode49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/14/LeetCode49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</id>
    <published>2020-12-14T07:20:32.000Z</published>
    <updated>2020-12-20T12:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><a id="more"></a><img src="/blog/2020/12/14/LeetCode49-字母异位词分组/49.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>主要是理解哈希表的 $key$ 和 $value$ 表示什么数或者集合。对于字母构造相同的几个<code>string</code>，它们进行排序后的结果是一致的，所以可以将排序后的结果作为哈希表的 $key$，而对应的 $value$ 来存储排序后等于此 $key$ 的所有<code>string</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> str = strs[i];</span><br><span class="line">            sort(str.begin(), str.end());</span><br><span class="line">            <span class="built_in">map</span>[str].push_back(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;m : <span class="built_in">map</span>)</span><br><span class="line">            res.push_back(m.second);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p><strong>唯一分解定理</strong>：任何一个大于1的<strong>自然数</strong>N,如果N不为<strong>质数</strong>，那么N可以唯一分解成<strong>有限个质数</strong>的乘积。</p><p>用质数表示26个字母，把字符串的各个字母相乘，这样可保证字母异位词的乘积必定是相等的。并且每个乘积只能是由这几个质数相乘得到。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">double</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">double</span> value[<span class="number">26</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">double</span> v = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : strs[i])&#123;</span><br><span class="line">                v *= value[ch - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[v].push_back(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;m : <span class="built_in">map</span>)</span><br><span class="line">            res.push_back(m.second);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>评论区<a href="https://leetcode-cn.com/problems/group-anagrams/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams/comments/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>内存管理（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-12-12T14:40:20.000Z</published>
    <updated>2020-12-18T08:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li><p>连续分配管理方式</p></li><li><p>动态分区分配算法</p><a id="more"></a></li></ol><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><p>连续分配：指为用户进程分配的必须是一个<strong>连续的空间</strong>。</p><img src="/blog/2020/12/12/内存管理（二）/连续分配.png"><h5 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h5><p>单一连续分配方式中，内存被分为<strong>系统区</strong>和<strong>用户区</strong>。</p><img src="/blog/2020/12/12/内存管理（二）/单一连续分配.png" style="zoom:80%;"><p>特点：内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。</p><p>优点：实现简单，<strong>无外部碎片</strong>；可采用覆盖技术扩充内存；不一定需要采取内存保护</p><p>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>；存储器利用率极低。</p><p><em>分配给某进程的内存区域中，如果有些部分没有用上，就是<strong>内部碎片</strong></em>。</p><h5 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h5><p>将<strong>用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，每个分区中<strong>只装入一道作业</strong>。</p><p>有两种形式：分区大小相等和分区大小不等</p><img src="/blog/2020/12/12/内存管理（二）/固定分区分配.png" style="zoom:80%;"><ul><li>分区大小相等：缺乏灵活性，适用于一台计算机控制多个相同模块的场合。</li><li>分区大小不等：增加灵活性，可以满足不同大小进程需求。</li></ul><h6 id="分区说明表"><a href="#分区说明表" class="headerlink" title="分区说明表"></a>分区说明表</h6><p>操作系统需要建立一个数据结构—分区说明表，每个表包括对应分区的<strong>大小、起始地址、状态</strong>：</p><img src="/blog/2020/12/12/内存管理（二）/固定分区分配-分区说明表.png"><p>当某用户程序要装入内存时，操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将其分配给该程序，然后修改状态为“已分配”。</p><p>优点：实现简单，无外部碎片。</p><p>缺点：用户程序太大时，所有分区都不能满足需求，此时得采用覆盖技术，会降低性能；会产生内部碎片，内存利用率低。</p><h5 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h5><p>动态分区分配也称可变分区分配，这种方法不会预先划分内存分区，而是<strong>在进程装入内存时，根据进程的大小动态的建立分区</strong>，使分区的大小正好适合进程的需要。</p><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构.png" style="zoom:80%;"><h6 id="使用什么数据结构？"><a href="#使用什么数据结构？" class="headerlink" title="使用什么数据结构？"></a>使用什么数据结构？</h6><ol><li>空闲分区表：每个空闲分区对应一个表项，表项中包含分区号、分区大小、分区起始地址等信息。</li></ol><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-空闲分区表.png"><ol start="2"><li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可以记录分区大小等信息。</li></ol><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-空闲分区链.png"><h6 id="选择哪个分区？"><a href="#选择哪个分区？" class="headerlink" title="选择哪个分区？"></a>选择哪个分区？</h6><p>动态分区分配算法，之后会提到。</p><h6 id="如何进行分区的分配与回收？"><a href="#如何进行分区的分配与回收？" class="headerlink" title="如何进行分区的分配与回收？"></a>如何进行分区的分配与回收？</h6><ol><li>分配</li></ol><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-分配1.png" style="zoom:80%;"><p>如果此时一个大小为5MB的进程到来，按照一定的分配算法，将分区1的一部分分配给它运行，分区表更新如下：</p><p><img src="/blog/2020/12/12/内存管理（二）/zxy543040659.github.io\source_posts\内存管理（二）\动态分配数据结构-分配2.png" alt="image-20201218113548211"></p><p>还有一种情况，如果到来的进程大小为4MB，且将分区3分配给它，那么分区表更新如下：</p><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-分配3.png"><ol start="2"><li><p>回收</p><ol><li>情况一，回收区的后面有一个相邻的空闲分区：</li></ol><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-回收1.png" style="zoom: 80%;"><p>此时进程4执行完毕，释放其占用的4MB内存，更新分区表如下（二合一）：</p><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-回收2.png"></li></ol><ol start="2"><li><p>情况二，回收区的前面有一个相邻的空闲分区：</p><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-回收3.png" style="zoom:80%;"><p>此时进程3执行完毕，释放其占用的18MB内存，更新分区表如下（二合一）：</p><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-回收4.png"></li><li><p>情况三，回收区的前、后各有一个相邻的空闲分区：</p><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-回收5.png" style="zoom:80%;"><p>此时进程4执行完毕，释放其占用的4MB内存，更新分区表如下（三合一）：</p><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-回收6.png"></li><li><p>情况四，回收区的前、后都没有相邻的空闲分区：</p><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-回收7.png" style="zoom:85%;"><p>此时进程2执行完毕，释放其占用的14MB内存，更新分区表如下（新增一）：</p><img src="/blog/2020/12/12/内存管理（二）/动态分配数据结构-回收8.png"></li></ol><p><em>各表项的顺序不一定按照地址递增顺序，具体由动态分区分配算法确定。</em></p><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><p>动态分区分配<strong>没有内部碎片</strong>，但是有<strong>外部碎片</strong>。</p><ul><li>内部碎片：分配给某进程的内存区域中，有些部分没有用上。</li><li>外部碎片：指内存中某些空闲分区由于太小而难以利用。</li></ul><p>如果内存中空闲空间的总和本来可以满足某进程的要求，但是进程需要一整块连续的内存空间，而碎片不连续，可以通过<strong>紧凑（拼凑，Compaction）</strong>技术解决外部碎片。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/12/内存管理（二）/连续分配小结.png" style="zoom:120%;"><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p>在动态分区分配方式中，当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？</p><img src="/blog/2020/12/12/内存管理（二）/动态分配算法.png" style="zoom:80%;"><h5 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h5><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>如何实现：<strong>空闲分区以地址递增的次序排列</strong>。每次分配内存时顺序查找<strong>空闲分区链（或空闲分区表）</strong>，找到大小能满足要求的第一个空闲分区。</p><h5 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h5><p>算法思想：尽可能多的留下大片的空闲区，优先使用更小的空闲区。</p><p>如何实现：<strong>空闲分区以容量递增次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链（或空闲分区表）</strong>，找到大小能满足要求的第一个空闲分区（能够满足但大小最小）。</p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多外部碎片。</p><h5 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h5><p>又称最大适应算法。</p><p>算法思想：每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小。</p><p>如何实现：<strong>空闲分区以容量递减次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链（或空闲分区表）</strong>，找到大小能满足要求的第一个空闲分区。</p><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。之后如果有“大进程”到达，就没有内存分区可用了。</p><h5 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h5><p>算法思想：在首次适应算法基础上，每次都从上次查找结束的位置开始检索，减小查找的开销。</p><p>如何实现：<strong>空闲分区以地址递增的顺序排列（可排成一个循环链表）</strong>。每次分配内存时<strong>从上次查找结束的位置开始查找空闲分区链（或空闲分区表）</strong>，找到大小能满足要求的第一个空闲分区。</p><p><strong>首次适应算法</strong>每次都会从头查找，每次都需要检索低地址的小分区。这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来。</p><p><strong>邻近适应算法</strong>的规则可能导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，被划分为小分区，最后导致无大分区可用。</p><p><strong>综合来看，首次适应算法的效果反而最好</strong>。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/12/内存管理（二）/动态分配算法小结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;连续分配管理方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态分区分配算法&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-12-12T09:46:39.000Z</published>
    <updated>2020-12-12T14:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>内存的基础知识</li><li>内存管理的概念</li><li>覆盖与交换</li></ol><a id="more"></a><h4 id="内存的基本知识"><a href="#内存的基本知识" class="headerlink" title="内存的基本知识"></a>内存的基本知识</h4><h5 id="什么是内存？有何作用？"><a href="#什么是内存？有何作用？" class="headerlink" title="什么是内存？有何作用？"></a>什么是内存？有何作用？</h5><p><strong>内存</strong>是用于存放数据的硬件。程序执行前<strong>需要先放到内存中才能被CPU处理。</strong></p><p>在多道程序环境下，系统中会有多个程序并发执行，会有多个程序的数据需要同时放到内存中。如何区分各个程序的数据在什么地方？——给内存的存储单元编地址。</p><p><strong>内存地址</strong>从0开始，每个地址对应一个存储单元。如果计算机按<strong>字节</strong>编址，则每个存储单元大小为1字节；如果<strong>字长为16位</strong>的计算机按<strong>字</strong>编址，则每个存储单元大小位1个字，也就是16个二进制位。</p><p>常用的几个数量单位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2^10 = 1K</span><br><span class="line">2^20 = 1M</span><br><span class="line">2^30 = 1G</span><br></pre></td></tr></table></figure><h5 id="逻辑地址与物理地址"><a href="#逻辑地址与物理地址" class="headerlink" title="逻辑地址与物理地址"></a>逻辑地址与物理地址</h5><p>编译时产生的指令只关心<strong>相对地址</strong>，实际放入内存中再想办法根据起始位置得到<strong>绝对地址</strong>。</p><p>eg：编译时只需确定变量x的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程<em>起始地址+100</em>即可。</p><p><strong>相对地址</strong>又称<strong>逻辑地址</strong>，<strong>绝对地址</strong>又称<strong>物理地址</strong>。</p><h5 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h5><img src="/blog/2020/12/12/内存管理（一）/程序的执行.png" style="zoom:120%;"><p>编译：由编译程序将用户源代码编译成若干个目标模块（高级语言-&gt;机器语言）。</p><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。</p><p>装入（装载）：由装入程序将装入模块装入内存运行。</p><h5 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h5><img src="/blog/2020/12/12/内存管理（一）/三种装入方式.png" style="zoom:120%;"><h6 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h6><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p>绝对装入<strong>只适用于单道程序环境</strong>。</p><p>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</p><h6 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h6><p>又称<strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址仅从<strong>重定位</strong>，将逻辑地址变换为物理地址（地址变换实在装入时一次完成的）。</p><p>静态重定位的特点是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</p><h6 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h6><p>又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行。</strong>因此装入内存后所有的地址依然是逻辑地址，这种方式需要一个<strong>重定位寄存器支持</strong>。</p><img src="/blog/2020/12/12/内存管理（一）/重定位寄存器.png" style="zoom:120%;"><ul><li>采取动态重定位时<strong>允许程序在内存中发生移动</strong>；</li><li>可将程序分配到<strong>不连续</strong>的存储区中；</li><li>程序运行前只需装入部分代码即可投入运行；</li><li>运行期间根据需要动态申请分配内存。</li></ul><h5 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h5><h6 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h6><p>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</p><img src="/blog/2020/12/12/内存管理（一）/静态链接.png" style="zoom: 80%;"><h6 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h6><p>将各目标模块装入内存时，边装入边链接的链接方式。</p><img src="/blog/2020/12/12/内存管理（一）/装入时动态链接.png" style="zoom:85%;"><h6 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h6><p>在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p><img src="/blog/2020/12/12/内存管理（一）/运行时动态链接.png" style="zoom:90%;"><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/12/内存管理（一）/内存的基本知识小节.png" style="zoom:120%;"><h4 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h4><ol><li><p>操作系统负责<strong>内存空间的分配与回收</strong>。</p></li><li><p>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong>。</p></li><li><p>操作系统需要提供<strong>地址转换</strong>功能，负责程序的<strong>逻辑地址</strong>与<strong>物理地址</strong>的转换。</p></li><li><p>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰。</p></li></ol><p>内存保护的两种方法：</p><ol><li>在CPU中设置一对<strong>上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li><li>采用<strong>重定位寄存器（基址寄存器）</strong>和<strong>界地址寄存器（限长寄存器）</strong>进行越界检查。重定位寄存器存放进程的<strong>起始物理地址</strong>。界地址寄存器存放进程的<strong>最大逻辑地址</strong>。</li></ol><img src="/blog/2020/12/12/内存管理（一）/内存保护方法二.png" style="zoom:80%;"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/12/内存管理（一）/内存管理的概念.png" style="zoom:100%;"><h4 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h4><h5 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h5><p>引入<strong>覆盖技术</strong>，解决<strong>程序大小超过物理内存总和</strong>的问题。</p><p>覆盖技术的思想：将<strong>程序分为多个段（多个模块）</strong>。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为<strong>一个固定区</strong>和<strong>若干个覆盖区</strong>。</p><ul><li>需要常驻内存的段放在<strong>固定区</strong>中，<strong>调入后就不再调出（除非运行结束）</strong>。</li><li>不常用的段放在<strong>覆盖区</strong>，<strong>需要用到时调入内存，用不到时调出内存</strong>。</li></ul><img src="/blog/2020/12/12/内存管理（一）/覆盖技术.png" style="zoom:80%;"><p><em>必须由程序员声明覆盖结构</em>，操作系统完成自动覆盖。</p><p><strong>缺点</strong>：对用户不透明，增加了用户编程负担，已成为历史。</p><h5 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h5><p>交换技术的思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）。进行了中级调度（内存调度）：决定将哪个处于挂起状态的进程重新调入内存。</p><ol><li><p>应该在外存（磁盘）的什么位置保存被换出的进程？</p><p>具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用<strong>离散分配</strong>方式；<strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用<strong>连续分配</strong>方式。总之，对换区的<code>I/O</code>速度比文件区的更快。</p></li><li><p>什么时候应该交换？</p><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p></li><li><p>应该换出哪些进程？</p><p>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。</p></li></ol><p><em>PCB会常驻内存</em>，不会被换成外存。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2020/12/12/内存管理（一）/覆盖与交换小结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;内存的基础知识&lt;/li&gt;
&lt;li&gt;内存管理的概念&lt;/li&gt;
&lt;li&gt;覆盖与交换&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode376-摆动序列</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/12/LeetCode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/12/LeetCode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</id>
    <published>2020-12-12T03:41:37.000Z</published>
    <updated>2020-12-17T08:02:52.729Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><a id="more"></a><img src="/blog/2020/12/12/LeetCode376-摆动序列/376.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以找每次的拐点进行计数，最后再加上首尾两个点即可，比如序列$[1,7,4,9,2,5]$，有4个拐点，加上首尾一共6个点：</p><img src="/blog/2020/12/12/LeetCode376-摆动序列/1.png" style="zoom:80%;"><p>需要考虑特殊情况：</p><ol><li>连续几个相同的数恰好都是拐点，如$[1,12,12,12,1]$：</li></ol><img src="/blog/2020/12/12/LeetCode376-摆动序列/2.png" style="zoom:80%;"><ol start="2"><li>输入的序列没有拐点且全部是同一个数，如$[1,1,1]$：</li></ol><img src="/blog/2020/12/12/LeetCode376-摆动序列/3.png" style="zoom:80%;"><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> guaidian = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; nums[i] &amp;&amp; nums[i + <span class="number">1</span>] &gt; nums[i])&#123;</span><br><span class="line">                guaidian++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &lt; nums[i] &amp;&amp; nums[i + <span class="number">1</span>] &lt; nums[i])&#123;</span><br><span class="line">                guaidian++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这一步是为了去除相同的点，如果nums[i]与nums[i + 1]相同，</span></span><br><span class="line">            <span class="comment">// 那么就让nums[i]等于nums[i - 1]，</span></span><br><span class="line">            <span class="comment">// 可以保证nums[i + 1]与改变之后的nums[i]不同。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">1</span> &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">                nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(guaidian == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> f = unique(nums.begin(), nums.end());</span><br><span class="line">            <span class="comment">// 输入的序列全部都是同一个数</span></span><br><span class="line">            <span class="keyword">if</span>(f - <span class="number">1</span> == nums.begin())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> guaidian + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。&lt;/p&gt;
&lt;p&gt;例如， &lt;code&gt;[1,7,4,9,2,5]&lt;/code&gt; 是一个摆动序列，因为差值 &lt;code&gt;(6,-3,5,-7,3)&lt;/code&gt; 是正负交替出现的。相反, &lt;code&gt;[1,4,7,2,5]&lt;/code&gt; 和 &lt;code&gt;[1,7,4,5,5]&lt;/code&gt; 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。&lt;/p&gt;
&lt;p&gt;给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode649-Dota2参议院</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/11/LeetCode649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/11/LeetCode649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/</id>
    <published>2020-12-11T13:25:10.000Z</published>
    <updated>2020-12-17T08:06:32.476Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Dota2 的世界里有两个阵营：<code>Radiant</code>(天辉)和 <code>Dire</code>(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p><ol><li><code>禁止一名参议员的权利</code>：</li></ol><p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p><ol start="2"><li><code>宣布胜利</code>：</li></ol><p>如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</p><a id="more"></a><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 <code>Radiant</code>（天辉）和 <code>Dire</code>（夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是 <code>n</code>。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 <code>Radiant</code> 或 <code>Dire</code>。</p><img src="/blog/2020/12/11/LeetCode649-Dota2参议院/649.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>只想到了暴力法解决。首先记录$senate$中R和D出现次数，再用一个长与$senate$相同的$bool$数组来记录当前字母是否被<strong>消灭</strong>了，初始化都为0，代表没有被<strong>消灭</strong>。遍历$senate$，如果遇到了R，就从R开始找第一个D的位置，直到下一轮循环到它之前的位置；对于D也是一样。这样保证它们能行使自己的权力，除非自己的阵营已经获胜了。</p><p><strong>消灭的策略是：尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴。</strong></p><p>这样做的时间复杂度会很高，用时1452ms。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">predictPartyVictory</span><span class="params">(<span class="built_in">string</span> senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> D_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = senate.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">isUsed</span><span class="params">(senate.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : senate)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'R'</span>) R_cnt++;</span><br><span class="line">            <span class="keyword">else</span> D_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(R_cnt != <span class="number">0</span> &amp;&amp; D_cnt != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; senate.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isUsed[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(senate[i] == <span class="string">'R'</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> m = i + <span class="number">1</span>; m &lt; i + len; ++m)&#123;</span><br><span class="line">                        <span class="keyword">int</span> j = m % len;</span><br><span class="line">                        <span class="keyword">if</span>(senate[j] == <span class="string">'D'</span> &amp;&amp; isUsed[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                            isUsed[j] = <span class="literal">true</span>;</span><br><span class="line">                            D_cnt--;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> m = i + <span class="number">1</span>; m &lt; i + len; ++m)&#123;</span><br><span class="line">                        <span class="keyword">int</span> j = m % len;</span><br><span class="line">                        <span class="keyword">if</span>(senate[j] == <span class="string">'R'</span> &amp;&amp; isUsed[j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                            isUsed[j] = <span class="literal">true</span>;</span><br><span class="line">                            R_cnt--;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(R_cnt == <span class="number">0</span> || D_cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R_cnt != <span class="number">0</span> ? <span class="string">"Radiant"</span> : <span class="string">"Dire"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>使用一个变量来记录当前参议员之前有几个对手，从而判断自己是否被消灭了。</p><p>这里使用$count&gt;0$表示<strong>R在D前面，R可以消灭D</strong>，用$count&lt;0$表示<strong>D在R前面，D可以消灭R</strong>。</p><p>执行用时：4ms。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">predictPartyVictory</span><span class="params">(<span class="built_in">string</span> senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> R = <span class="literal">true</span>, D = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(R &amp;&amp; D)&#123;</span><br><span class="line">            R = <span class="literal">false</span>;</span><br><span class="line">            D = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; senate.size(); ++i)&#123;</span><br><span class="line">                <span class="comment">// 如果没被完全消灭，本轮循环结束R和D都为true</span></span><br><span class="line">                <span class="keyword">if</span>(senate[i] == <span class="string">'R'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count &lt; <span class="number">0</span>) senate[i] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">else</span> R = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 如果被消灭了计数加一，代表抵挡了一次攻击</span></span><br><span class="line">                    <span class="comment">// 如果没有被消灭，代表有多了一次消灭敌方机会</span></span><br><span class="line">                    <span class="comment">// 无论如何都是需要++的，下面的--同</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(senate[i] == <span class="string">'D'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count &gt; <span class="number">0</span>) senate[i] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">else</span> D = <span class="literal">true</span>;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R != <span class="number">0</span> ? <span class="string">"Radiant"</span> : <span class="string">"Dire"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://leetcode-cn.com/problems/dota2-senate/solution/649-dota2-can-yi-yuan-tan-xin-suan-fa-ji-siha/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dota2-senate/solution/649-dota2-can-yi-yuan-tan-xin-suan-fa-ji-siha/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;Dota2 的世界里有两个阵营：&lt;code&gt;Radiant&lt;/code&gt;(天辉)和 &lt;code&gt;Dire&lt;/code&gt;(夜魇)&lt;/p&gt;
&lt;p&gt;Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;禁止一名参议员的权利&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;code&gt;宣布胜利&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode860-柠檬水找零</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/10/LeetCode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/10/LeetCode860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</id>
    <published>2020-12-10T03:09:50.000Z</published>
    <updated>2020-12-17T08:07:37.079Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。</p><p>顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><a id="more"></a><img src="/blog/2020/12/10/LeetCode860-柠檬水找零/860.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>每位顾客付款只有5、10、20美元的选项：</p><ul><li><p>收到5元时记录5元零钱的个数；</p></li><li><p>收到10元时需要找零5元并记录10元的个数；</p></li><li><p>收到20元需要找零15元，但不用记录20元个数，因为不会发生找零20元的情况。</p></li></ul><p><em>收到20元找零时应首先选10元零钱，10元用完后再选5元的。比如找零15元，如果只剩下两张5元，一张10元，先从5元开始无法刚好找零15（5+5+10）。</em></p><p><em>需要找零的总数必须大于等于当前用到的零钱的面值，详见代码。</em></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lemonadeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bills.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="built_in">map</span>[<span class="number">5</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;   </span><br><span class="line">                <span class="keyword">int</span> val = bills[i] - <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">10</span>; j &gt;= <span class="number">5</span>; j /= <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="comment">// 需要找零的总数必须大于等于当前用到的零钱的面值，val &gt;= j</span></span><br><span class="line">                    <span class="keyword">while</span>(<span class="built_in">map</span>[j] != <span class="number">0</span> &amp;&amp; val &gt; <span class="number">0</span> &amp;&amp; val &gt;= j)&#123;</span><br><span class="line">                        val -= j;</span><br><span class="line">                        <span class="built_in">map</span>[j]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(val == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(bills[i] &lt;= <span class="number">10</span>) <span class="built_in">map</span>[bills[i]]++;</span><br><span class="line">                <span class="keyword">if</span>(val != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在柠檬水摊上，每一杯柠檬水的售价为 &lt;code&gt;5&lt;/code&gt; 美元。&lt;/p&gt;
&lt;p&gt;顾客排队购买你的产品，（按账单 &lt;code&gt;bills&lt;/code&gt; 支付的顺序）一次购买一杯。&lt;/p&gt;
&lt;p&gt;每位顾客只买一杯柠檬水，然后向你付 &lt;code&gt;5&lt;/code&gt; 美元、&lt;code&gt;10&lt;/code&gt; 美元或 &lt;code&gt;20&lt;/code&gt; 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 &lt;code&gt;5&lt;/code&gt; 美元。&lt;/p&gt;
&lt;p&gt;注意，一开始你手头没有任何零钱。&lt;/p&gt;
&lt;p&gt;如果你能给每位顾客正确找零，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode62-不同路径</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/09/LeetCode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/09/LeetCode62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2020-12-09T01:49:46.000Z</published>
    <updated>2020-12-17T08:08:34.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p>与此类似：<a href="http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/">LeetCode-不同路径Ⅱ</a>，<a href="http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more">LeetCode97-交错字符串</a>，<a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">LeetCode174-地下城游戏</a>。</p><a id="more"></a><img src="/blog/2020/12/09/LeetCode62-不同路径/62.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>机器人只能往右或者往下，考虑动态规划（如果四个方向都可以走就不可以用动态规划了，得用DFS或者BFS），对于机器人所在的行和列，都只有一条路径可以到达，初始化为1。而除此之外的位置都是可以由其上边和其左边到达，以此类推得到可以到达最终位置的路径总数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;一个机器人位于一个 &lt;code&gt;m x n&lt;/code&gt; 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;与此类似：&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/07/26/LeetCode63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/&quot;&gt;LeetCode-不同路径Ⅱ&lt;/a&gt;，&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/07/18/LeetCode97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/#more&quot;&gt;LeetCode97-交错字符串&lt;/a&gt;，&lt;a href=&quot;https://leetcode-cn.com/problems/dungeon-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode174-地下城游戏&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode842-将数组拆分成斐波那契序列</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/08/LeetCode842-%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/08/LeetCode842-%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/</id>
    <published>2020-12-08T10:10:01.000Z</published>
    <updated>2020-12-17T08:05:11.316Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数字字符串 <code>S</code>，比如 <code>S = &quot;123456579&quot;</code>，我们可以将它分成斐波那契式的序列 <code>[123, 456, 579]​</code>。</p><p>形式上，斐波那契式序列是一个非负整数列表 <code>F​</code>，且满足：</p><ul><li><code>0 &lt;= F[i] &lt;= 2^31 - 1​</code>，（也就是说，每个整数都符合 32 位有符号整数类型）</li><li><code>F.length &gt;= 3​</code>；</li><li>对于所有的 <code>0 &lt;= i &lt; F.length - 2​</code>，都有 ​<code>F[i] + F[i+1] = F[i+2]​</code>成立。</li></ul><p><strong>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</strong></p><p>返回从 <code>S</code> 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 <code>[]</code>。</p><a id="more"></a><img src="/blog/2020/12/08/LeetCode842-将数组拆分成斐波那契序列/842.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>不断地截取字符串，看当前字符串对应的数能不能和之前的两个数构成斐波那契序列，如果可以就继续找下一个，不行的话就进行回退。截取完最后一个字符后，如果截取到的数字的个数大于等于3，则说明此数组可以拆分成斐波那契序列。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">splitIntoFibonacci</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">        backTrack(S, buf, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">string</span> &amp;S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;buf, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(buf.size() &gt;= <span class="number">3</span> &amp;&amp; index == S.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; S.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 不能以0开头</span></span><br><span class="line">            <span class="keyword">if</span>(S[index] == <span class="string">'0'</span> &amp;&amp; i &gt; index)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 取从index开始到i的字符串并转换为数字</span></span><br><span class="line">            <span class="built_in">string</span> s = S.substr(index, i - index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> num = stol(s, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 如果取出的数大于INT_MAX直接终止</span></span><br><span class="line">            <span class="keyword">if</span>(num &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> len = buf.size();</span><br><span class="line">            <span class="comment">// 如果截取的数字大于前两个数字之后，直接终止，因为后面只会越取越大</span></span><br><span class="line">            <span class="keyword">if</span>(len &gt;= <span class="number">2</span> &amp;&amp; num &gt; (<span class="keyword">long</span>)buf[len - <span class="number">1</span>] + (<span class="keyword">long</span>)buf[len - <span class="number">2</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 刚开始时buf里不到2个数时，将num加入buf中</span></span><br><span class="line">            <span class="comment">// 或者buf已经有2个及以上的数了，如果num等于buf的后两个数之和，加入buf中</span></span><br><span class="line">            <span class="keyword">if</span>(len &lt;= <span class="number">1</span> || num == (<span class="keyword">long</span>)buf[len - <span class="number">1</span>] + (<span class="keyword">long</span>)buf[len - <span class="number">2</span>])&#123;</span><br><span class="line">                buf.push_back(num);</span><br><span class="line">                <span class="keyword">if</span>(backTrack(S, buf, i + <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 如果没找到，就将当前的num移除掉</span></span><br><span class="line">                buf.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/javahui-su-suan-fa-tu-wen-xiang-jie-ji-b-vg5z/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数字字符串 &lt;code&gt;S&lt;/code&gt;，比如 &lt;code&gt;S = &amp;quot;123456579&amp;quot;&lt;/code&gt;，我们可以将它分成斐波那契式的序列 &lt;code&gt;[123, 456, 579]​&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;形式上，斐波那契式序列是一个非负整数列表 &lt;code&gt;F​&lt;/code&gt;，且满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= F[i] &amp;lt;= 2^31 - 1​&lt;/code&gt;，（也就是说，每个整数都符合 32 位有符号整数类型）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F.length &amp;gt;= 3​&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;对于所有的 &lt;code&gt;0 &amp;lt;= i &amp;lt; F.length - 2​&lt;/code&gt;，都有 ​&lt;code&gt;F[i] + F[i+1] = F[i+2]​&lt;/code&gt;成立。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回从 &lt;code&gt;S&lt;/code&gt; 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 &lt;code&gt;[]&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="贪心算法" scheme="http://www.xingyuzhao.ltd/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯算法" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>进程管理（四）-死锁</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/07/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%AD%BB%E9%94%81/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/07/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%AD%BB%E9%94%81/</id>
    <published>2020-12-07T01:32:09.000Z</published>
    <updated>2020-12-20T12:47:12.638Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>死锁的概念</li><li>预防死锁</li><li>避免死锁</li><li>死锁的检测和解除</li></ol><a id="more"></a><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><h5 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h5><p>在并发的环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法推进的现象，就是<strong>死锁</strong>。发生死锁后若无外力干涉，这些进程都将无法向前推进。</p><h5 id="死锁、饥饿、死循环区别"><a href="#死锁、饥饿、死循环区别" class="headerlink" title="死锁、饥饿、死循环区别"></a>死锁、饥饿、死循环区别</h5><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁、饥饿、死循环区别.png" style="zoom:120%;"><h5 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h5><p>产生死锁必须同时满足以下四个条件：</p><ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放。</li><li>请求和保持条件：进程<strong>已经保持了至少一个资源</strong>，但又提出了新的资源要求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</li><li>循环等待条件：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p><em>注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁。</em></p><h5 id="什么时候会发生死锁？"><a href="#什么时候会发生死锁？" class="headerlink" title="什么时候会发生死锁？"></a>什么时候会发生死锁？</h5><ol><li>对系统资源的竞争。</li><li>进程推进顺序非法。</li><li>信号量的使用不当。</li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h5 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h5><ol><li>预防死锁：破坏死锁产生的四个必要条件中的一个。</li><li>避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。</li><li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁的概念.png" style="zoom:120%;"><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><h5 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h5><p>如果把只能互斥使用的资源改造成允许共享使用，则系统不会进入死锁状态。如：<code>SPOOLing</code>技术。</p><p>缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</p><h5 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h5><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。</p><p>缺点：</p><ol><li>实现复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法只适合已保存和恢复状态的资源，如CPU。</li><li>反复的申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，只要暂时得不到某个资源，之前获得的资源都要放弃，以后再重新申请。如果持续发生这种情况，会导致进程饥饿。</li></ol><h5 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h5><p>可以采用<strong>静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行后，资源归其所有，该进程就不会再请求别的资源了。</p><p>缺点：有些资源可能使用很短的时间，如果进程执行期间一直保持所有资源，就会造成严重的资源浪费，资源利用率极低。另外也可能导致某些进程饥饿。</p><h5 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h5><p>可采用<strong>顺序资源分配法</strong>，给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>，同类资源（即编号相同的资源）一次申请完。</p><p>原理：一个进程只有占有小编号的资源时才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p><p>缺点：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号。</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源的浪费。</li><li>必须按规定的次序申请资源，用户编程麻烦。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/预防死锁.png" style="zoom:120%;"><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>不破坏死锁的必要条件，而是在在资源动态分配的过程中，防止系统进入不安全状态。</p><h5 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h5><p>指系统能按某种推进顺序（P1,P2,…,Pn）为每个进程Pi分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称P1,P2,…,Pn为安全序列，若系统无法找到一个安全序列，则称系统处于不安全状态。</p><p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。</p><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>数据结构：</p><ul><li>长度为m的一维数组Avaliable表示还有多少可用资源。</li><li>n*m矩阵Max表示各进程对资源的最大需求数。</li><li>n*m矩阵Allocation表示已经给各进程分配了多少资源。</li><li>Max - Alllcation = Need 矩阵表示各进程最多还需要多少资源。</li><li>长度为m的一维数组Request表示进程此次申请的各种资源数。</li></ul><p>银行家算法步骤：</p><ol><li>检查此次申请是否超过了之前声明的最大需求数。</li><li>检查此时系统剩余的可用资源是否还能满足这次请求。</li><li>试探着分配，更改各数据结构。</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态。</li></ol><p>安全性算法步骤：</p><p>检查当前的剩余可用资源能否满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程只有的资源全部回收。</p><p>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><p><em>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。</em></p><p><strong>举例（后面更新）：</strong></p><h4 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h4><p>当可能发生死锁时，系统应当提供两个算法：</p><ol><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li></ol><h5 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h5><p>为了能对系统是否已发生了死锁进行检测，必须：</p><ol><li>用<strong>某种数据结构</strong>来保存资源的请求和分配信息。</li><li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁的检测.png" style="zoom:120%;"><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁的检测1.png" style="zoom:80%;"><p>检测死锁的算法：</p><ol><li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi (即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中己有空闲资源数景。如下图中，R1没有空闲资源，R2有 —个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中P1是满足这一条件的进程结点，于是将P1的所有边消去。</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/死锁的检测2.png" style="zoom:80%;"><p><strong>死锁定理</strong>：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时系统死锁。</p><h5 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h5><p>—旦检测出死锁的发生，就应该立即解除死锁。<br>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程 。<br>解除死锁的主要方法有：</p><ol><li><p>资源剥夺法。挂起（哲时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</p></li><li><p>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能己经运行了很长时间，己经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</p></li><li><p>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程历史信息，设罝还原点。</p></li></ol><p>如何决定”对谁动手“？</p><ol><li>进程优先级：牺牲优先级低的。</li><li>已执行多长时间：牺牲执行时间短的。</li><li>还要多久完成：让快结束的优先获得资源。</li><li>进程已经使用了多少资源：拥有更多资源的先牺牲。</li><li>进程是交互式的还是批处理式的？：先牺牲批处理式的。</li></ol><img src="/blog/2020/12/07/进程管理（四）-死锁/总结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;死锁的概念&lt;/li&gt;
&lt;li&gt;预防死锁&lt;/li&gt;
&lt;li&gt;避免死锁&lt;/li&gt;
&lt;li&gt;死锁的检测和解除&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="死锁" scheme="http://www.xingyuzhao.ltd/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>进程管理（三）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/12/04/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/12/04/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-12-04T15:26:34.000Z</published>
    <updated>2020-12-14T08:15:20.127Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>进程同步、进程互斥</li><li>进程互斥软件/硬件实现方法</li><li>信号量机制及用其实现进程同步等</li><li>管程</li></ol><a id="more"></a><h4 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h4><h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><p>进程异步性：指各并发执行的进程以各自独立的、不可预知的速度向前推进。</p><p>进程同步：指为完成某种任务而建立的两个或多个进程，这些进程因为需要再某些位置上协调它们的工作次序而产生制约关系。</p><h5 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h5><p>临界资源：一个时间段内只允许一个进程使用的资源。如摄像头、打印机等。对临界资源的访问必须<strong>互斥</strong>的进行。</p><p>进程互斥：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。</p><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">entry section; <span class="comment">// 进入区</span></span><br><span class="line">    critical section; <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section; <span class="comment">// 退出区</span></span><br><span class="line">    remainder section;<span class="comment">// 剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ol><li>进入区：检查是否可以进入临界区，若可以进入，则设置正在访问临界资源的标志（上锁），防止其他进程同时进入临界区。</li><li>临界区：访问临界资源的代码。</li><li>退出区：解除正在访问临界资源的标志（解锁）。</li><li>剩余区：做其他处理。</li></ol><p><em>临界区时进程中访问临界资源的代码段。</em></p><p><em>进入区和退出区是负责实现互斥的代码段。</em></p><p>实现对临界资源的互斥访问需要遵循以下四项原则：</p><ol><li>空闲让进。</li><li>忙则等待。</li><li>有限等待，请求访问的进程在有限时间内进入临界区（保证不会饥饿）。</li><li>让权等待，进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><img src="/blog/2020/12/04/进程管理（三）/同步与互斥.png" style="zoom:120%;"><h4 id="进程互斥软件-硬件实现方法"><a href="#进程互斥软件-硬件实现方法" class="headerlink" title="进程互斥软件/硬件实现方法"></a>进程互斥软件/硬件实现方法</h4><h5 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h5><h6 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h6><p>实现思想：两个进程在<strong>访问完临界区后</strong>会把临界区的使用权转交给另一个进程，<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</p><p>主要问题：违背<strong>空闲让进</strong>原则。</p><h6 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h6><p>实现思想：<strong>设置</strong>一个布尔型数组<code>flag[]</code>，数组中各个元素用来<strong>标记各进程想要进入临界区的意愿</strong>，比如<code>flag[0]=true</code>表示着0号进程P0想要进入临界区。每个进程在进入临界区之前先看有没有别的进程想要进入临界区，没有就将自身的<code>flag[i]</code>置为<code>true</code>，之后开始访问临界区。</p><p>主要问题：违反<strong>忙则等待</strong>原则。原因在于进入区的检查和上锁不是一气呵成的，在<strong>检查后，上锁前</strong>可能发生进程切换。</p><h6 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h6><p>实现思想：对比双标志先检查法，先进行上锁再进行检查。</p><p>主要问题：虽然解决了<strong>忙则等待</strong>，但是违背了<strong>空闲让进</strong>和<strong>有限等待</strong>原则，会因各进程都长期无法访问临界资源而产生<strong>饥饿</strong>现象。</p><h6 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h6><p>实现思想：对比双标志后检查法，如果双方都争着想进入临界区，可以让进程主动让对方先使用临界区。</p><p>主要问题：违背了<strong>让权等待</strong>原则。</p><img src="/blog/2020/12/04/进程管理（三）/进程互斥的软件实现方法.png" style="zoom:120%;"><h5 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h5><h6 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h6><p>实现思想：利用”开/关中断指令“实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">关中断；// 关中断后不允许当前进程被中断，也必然不会发生进程切换</span><br><span class="line">临界区；</span><br><span class="line">开中断；// 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li>优点：简单、高效。</li><li>缺点：不适用于对处理机；只适用于操作系统内核进程，不适用于用户进程。</li></ul><h6 id="TestAndSet-TS指令-TSL指令"><a href="#TestAndSet-TS指令-TSL指令" class="headerlink" title="TestAndSet(TS指令/TSL指令)"></a>TestAndSet(TS指令/TSL指令)</h6><p>简称TS指令，也称TestAndSetLock指令，或TSL指令。</p><p>主要思想：使用硬件实现，将上锁和检查操作变为原子操作，执行过程中不允许被中断。</p><ul><li>优点：实现简单，适用于多处理机环境。</li><li>缺点：不满足<strong>让权等待</strong>原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“。</li></ul><h6 id="Swap指令-XCHG指令"><a href="#Swap指令-XCHG指令" class="headerlink" title="Swap指令(XCHG指令)"></a>Swap指令(XCHG指令)</h6><p>也叫Exchange指令，或者XCHG指令。</p><p>逻辑上与TS指令相同。</p><img src="/blog/2020/12/04/进程管理（三）/进程互斥的硬件实现方法.png" style="zoom:120%;"><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量机制时一种功能较强的机制，可以用来解决互斥和同步问题，它只能被两个标准的原语<code>wait(S)</code>和<code>signal(S)</code>访问，简称<strong>P操作</strong>和<strong>V操作</strong>。</p><p>信号量其实就是一个变量，可以是一个整数，也可以是更复杂的记录型变量，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>。</p><h5 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h5><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S = <span class="number">1</span>; <span class="comment">// 表示当前系统中可用的打印机数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123; <span class="comment">// wait原语，相当于进入区</span></span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>); <span class="comment">// 资源不够，等待</span></span><br><span class="line">    S = S - <span class="number">1</span>; <span class="comment">// 资源够，占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123; <span class="comment">// signal原语，相当于退出区 </span></span><br><span class="line">    S = S + <span class="number">1</span>; <span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。</li><li><strong>检查</strong>和<strong>上锁</strong>一气呵成，避免并发、异步导致的问题。</li><li>存在问题：不满足<strong>让权等待</strong>原则，会发生<strong>忙等</strong>。</li></ol><h5 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h5><p>用记录型数据结构表示的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span><span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*某进程需要资源时，通过wait原语申请*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="comment">// 如果剩余资源不够，使用block原语使进程由运行态进入阻塞态</span></span><br><span class="line">    <span class="comment">// 并将其挂到信号量S的等待队列（即阻塞队列）中</span></span><br><span class="line">    <span class="comment">// 遵循了让权等待原则，不会出现忙等</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">block(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*进程使用完资源后，通过signal原语释放*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="comment">// 释放完资源后，若还有别的进程在等待这种资源</span></span><br><span class="line">    <span class="comment">// 则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">wakeup(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="用信号量机制实现进程互斥、同步、前驱关系"><a href="#用信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量机制实现进程互斥、同步、前驱关系"></a>用信号量机制实现进程互斥、同步、前驱关系</h5><h6 id="进程互斥-1"><a href="#进程互斥-1" class="headerlink" title="进程互斥"></a>进程互斥</h6><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）。</li><li>设置<strong>互斥信号量</strong>mutex，<strong>初始值为1</strong>。</li><li>在临界区之前执行P(mutex)。</li><li>在临界区之后执行V(mutex)。</li></ol><p><em>注意：对不同的临界资源需要设置不同的互斥信号量，P、V操作必须成对出现</em>。</p><h6 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h6><ol><li>分析什么地方需要实现”同步关系“，即必须保证”一前一后“执行的两个操作（或两句代码）。</li><li>设置<strong>同步信号量</strong>S，<strong>初始值为0</strong>。</li><li>在”前操作”之后执行V(S)。</li><li>在”后操作“之前执行P(S)。</li></ol><h6 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h6><p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后操作）。</p><ol><li>要为每一对前驱关系各设置一个同步变量。</li><li>在”前操作“之后对相应的同步变量执行V操作。</li><li>在”后操作“之前对相应的同步变量执行P操作。</li></ol><img src="/blog/2020/12/04/进程管理（三）/信号量实现同步与互斥.png" style="zoom:120%;"><p>常见的使用场景</p><ul><li>生产者消费者问题</li><li>多生产者—多消费者模型</li><li>吸烟者问题</li><li>读者—写者问题</li><li>哲学家进餐问题</li></ul><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>引入管程的原因：信号量机制编写程序困难，易出错而导致死锁。</p><p>管程是一种特殊的软件模块，由这些部分组成：</p><ol><li>局部于管程的共享数据结构说明。</li><li>对该数据结构进行操作的一组过程（或函数）。</li><li>对局部于管程的共享数据设置的一组过程。</li><li>管程的名称。</li></ol><p>基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问。</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据。</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程，即同一时刻只有一个进程在管程内执行某个函数。</strong></li></ol><img src="/blog/2020/12/04/进程管理（三）/管程.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;进程同步、进程互斥&lt;/li&gt;
&lt;li&gt;进程互斥软件/硬件实现方法&lt;/li&gt;
&lt;li&gt;信号量机制及用其实现进程同步等&lt;/li&gt;
&lt;li&gt;管程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>C++顺序容器</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/25/C-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/25/C-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2020-11-25T13:17:11.000Z</published>
    <updated>2020-11-28T14:39:06.851Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>顺序容器概述</li><li>容器库概览</li><li>顺序容器操作</li><li><code>vector</code>对象是如何增长的</li><li>额外的<code>string</code>操作</li><li>容器适配器</li></ol><a id="more"></a><h4 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h4><img src="/blog/2020/11/25/C-顺序容器/概述.png" style="zoom:120%;"><p>选择容器的基本原则：</p><ul><li>尽量使用<code>vector</code>。</li><li>要求随机访问元素，使用<code>vector</code>或者<code>deque</code>。</li><li>要求在中间插入或删除元素，使用<code>list</code>或者<code>forward_list</code>。</li><li>要求在首尾插入或删除元素且不会在中间插入或者删除，使用<code>deque</code>。</li><li>如果程序要读取输入，且必须在中间插入，使用<code>list</code>，随后拷贝到<code>vector</code>。</li></ul><h4 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h4><img src="/blog/2020/11/25/C-顺序容器/容器操作.png" style="zoom:120%;"><img src="/blog/2020/11/25/C-顺序容器/容器操作1.png" style="zoom:120%;"><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p><code>forward_list</code>迭代器不支持递减运算符。</p><h6 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h6><p><strong>左闭合区间</strong>：<code>[begin, end)</code>，表示范围自<code>begin</code>开始，于<code>end</code>之前结束。</p><ul><li>如果<code>begin</code>与<code>end</code>相等，则范围为空。</li><li>如果<code>begin</code>与<code>end</code>不等，则范围至少包含一个元素，且<code>begin</code>指向该范围中的第一个元素。</li><li>可以对<code>begin</code>递增若干次，使得<code>begin==end</code>。</li></ul><h5 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::difference_type count</span><br></pre></td></tr></table></figure><h5 id="begin与end成员"><a href="#begin与end成员" class="headerlink" title="begin与end成员"></a>begin与end成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; a = &#123;<span class="string">"abc"</span>, <span class="string">"bcd"</span>, <span class="string">"cde"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.begin(); <span class="comment">// list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.rbegin(); <span class="comment">// list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.cbegin(); <span class="comment">// list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.crbegin(); <span class="comment">// list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure><h5 id="容器定义及初始化"><a href="#容器定义及初始化" class="headerlink" title="容器定义及初始化"></a>容器定义及初始化</h5><img src="/blog/2020/11/25/C-顺序容器/初始化.png" style="zoom:120%;"><p><strong>array的使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia1; <span class="comment">// 10个默认初始化的int</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia3 = &#123;<span class="number">42</span>&#125;; <span class="comment">// ia3[0]为42， 其余为0</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia4 = &#123;&#125;; <span class="comment">// 初始化为0</span></span><br></pre></td></tr></table></figure><h5 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h5><img src="/blog/2020/11/25/C-顺序容器/assign.png" style="zoom:120%;"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assign第一种用法</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle; <span class="comment">// 错误，容器类型不匹配</span></span><br><span class="line"><span class="comment">// 正确，可以将const char*转为string</span></span><br><span class="line">names.assign(oldstyle.cbegin(), oldstyle.cend()); </span><br><span class="line"><span class="comment">// assign的第二种用法</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist1</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 1个元素，为空string</span></span><br><span class="line">slist1.assign(<span class="number">10</span>, <span class="string">"Hiya!"</span>); <span class="comment">// 10个元素，每个都是"Hiya"</span></span><br></pre></td></tr></table></figure><h6 id="使用swap"><a href="#使用swap" class="headerlink" title="使用swap"></a>使用swap</h6><p>swap操作交换两个相同类型容器的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line">swap(svec1, svec2);</span><br><span class="line"><span class="comment">// 元素本身并未交换，swap只是交换了两个容器的内部数据结构</span></span><br></pre></td></tr></table></figure><p><strong>除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间完成</strong>。<strong>对array会真正交换它们的元素</strong>。</p><h5 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h5><p><code>size</code>：返回容器中元素数目。</p><p><code>empty</code>：容器是否为空。</p><p><code>max_size</code>：返回一个大于或等于该类型容器所能容纳的最大元素数的值。</p><p>注：<code>forward_list</code>不支持<code>size</code>。</p><h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">// v1 &lt; v2 true，在v1[2] &lt; v2[2]</span></span><br><span class="line"><span class="comment">// v1 &lt; v3 false，所有元素相等，但是v3元素更少</span></span><br><span class="line"><span class="comment">// v1 == v4 true，元素对应相等且长度相同</span></span><br><span class="line"><span class="comment">// v1 == v2 false，v2元素比v1少</span></span><br></pre></td></tr></table></figure><h4 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h4><img src="/blog/2020/11/25/C-顺序容器/添加元素.png" style="zoom:120%;"><h5 id="使用emplace操作"><a href="#使用emplace操作" class="headerlink" title="使用emplace操作"></a>使用emplace操作</h5><p>当调用一个<code>emplace</code>成员函数时，将参数传递给元素类型的构造函数。<code>emplace</code>成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定c保存Sales_data元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.emplace_back(<span class="string">"978-0590353403"</span>, <span class="number">24</span>, <span class="number">15.99</span>);</span><br><span class="line">c.push_back(Sales_data(<span class="string">"978-0590353403"</span>, <span class="number">24</span>, <span class="number">15.99</span>));</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">c.push_back(<span class="string">"978-0590353403"</span>, <span class="number">24</span>, <span class="number">15.99</span>);</span><br></pre></td></tr></table></figure><h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><img src="/blog/2020/11/25/C-顺序容器/访问元素.png" style="zoom:120%;"><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><img src="/blog/2020/11/25/C-顺序容器/删除元素.png" style="zoom:120%;"><h5 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h5><img src="/blog/2020/11/25/C-顺序容器/改变容器大小.png" style="zoom:120%;"><h5 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h5><p>向容器中添加/删除元素可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。</p><p>在向容器添加元素后：</p><ul><li>容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但插入位置之后的迭代器、指针和引用将会失效。</li><li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，指向存在元素的引用和指针不会失效。</li><li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器、指针和引用仍有效。</li></ul><p>删除元素时，指向被删除元素的迭代器、指针和引用都会失效。</p><ul><li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针都有效。</li><li>对于<code>deque</code>，在首尾之外的任何位置删除元素，指向被删除元素外其他元素的迭代器、指针或引用也会失效。删除尾，尾后迭代器会失效，但其他迭代器、引用和指针不受影响；删除首，也不受影响。</li><li>对于<code>vector</code>和<code>string</code>，指向被删元素之前元素的迭代器、引用和指针仍有效。</li></ul><p><em>注意：当我们删除元素时，尾后迭代器总会失效</em>。</p><h4 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h4><p><code>vector</code>会分配比新的空间需求更大的内存空间，作为备用。</p><h5 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h5><img src="/blog/2020/11/25/C-顺序容器/管理vector.png" style="zoom:120%;"><p><em><code>reserve</code>不改变容器中元素的数量，只影响<code>vector</code>预先分配多大的内存空间。</em></p><h4 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h4><img src="/blog/2020/11/25/C-顺序容器/额外string.png" style="zoom:120%;"><p>这些构造函数接受一个<code>string</code>或一个<code>const char*</code>参数，还接受（可选的）指定拷贝多少个字符的参数。</p><p>从<code>const char*</code>创建<code>string</code>时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。且：</p><ul><li>如果同时传一个计数值，就不必以空字符结尾。</li><li>如果未传递计数值且数组未以空字符结尾，或者计数值大于数组大小，则构造函数未定义。</li></ul><p>从<code>string</code>拷贝时，可选开始位置和计数值。位置大于<code>size</code>，构造函数抛出一个<em>out of range</em>异常。计数值代表从当前位置拷贝这么多个字符，最多拷贝到<code>string</code>结尾。</p><h5 id="sbustr"><a href="#sbustr" class="headerlink" title="sbustr"></a>sbustr</h5><img src="/blog/2020/11/25/C-顺序容器/substr.png" style="zoom:120%;"><h5 id="aapend和replace"><a href="#aapend和replace" class="headerlink" title="aapend和replace"></a>aapend和replace</h5><ol><li><code>append</code>操作是在<code>string</code>末尾进行插入操作的一种简写形式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.append(<span class="string">"123abc"</span>); <span class="comment">// 将"123abc"追加在s之后</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>replace</code>操作是调用<code>erase</code>和<code>insert</code>的一种简写形式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.erase(<span class="number">11</span>, <span class="number">3</span>);</span><br><span class="line">s.insert(<span class="number">11</span>, <span class="string">"5th"</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">s.replace(<span class="number">11</span>, <span class="number">3</span>, <span class="string">"5th"</span>);</span><br></pre></td></tr></table></figure><p>还有<code>assign</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.assign(arg); <span class="comment">// 将s中字符替换未arg，返回指向s的引用</span></span><br></pre></td></tr></table></figure><p><code>assign</code>总是替换<code>string</code>中所有内容。</p><h5 id="string的搜索操作"><a href="#string的搜索操作" class="headerlink" title="string的搜索操作"></a>string的搜索操作</h5><img src="/blog/2020/11/25/C-顺序容器/string_find.png" style="zoom:120%;"><img src="/blog/2020/11/25/C-顺序容器/string_find_form.png" style="zoom:120%;"><p><em><code>string</code>搜索返回<code>string::size_type</code>类型，是无符号的，因此用<code>int</code>表示不是很好的选择。</em></p><h5 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h5><img src="/blog/2020/11/25/C-顺序容器/compare.png" style="zoom:120%;"><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"pi = 3.14"</span>;</span><br><span class="line"><span class="comment">// 转换s中以数字开始的第一个字串，d=3.14</span></span><br><span class="line">d = stod(s.substr(s.find_first_of(<span class="string">"+-.0123456789"</span>)));</span><br></pre></td></tr></table></figure><p><em>如果<code>string</code>不能转换为数值，抛出<code>invalid_argument</code>异常。如果转换的数值无法用任何类型表示，则抛出一个<code>out_of_range</code>异常</em>。</p><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p><strong>适配器</strong>是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。比如：<code>stack</code>、<code>queue</code>、<code>priority_queue</code>。</p><img src="/blog/2020/11/25/C-顺序容器/容器适配器.png" style="zoom:120%;"><p>每个适配器都定义了两个构造函数：</p><ol><li>默认构造函数创建一个空对象，接受一个容器的构造函数拷贝来初始化适配器。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定dep使一个deque&lt;int&gt;</span></span><br><span class="line"><span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stk</span><span class="params">(dep)</span></span>; <span class="comment">// 从deq拷贝元素到stk</span></span><br></pre></td></tr></table></figure><ol start="2"><li>默认情况下，<code>stack</code>和<code>queue</code>基于<code>deque</code>实现，<code>priority_deque</code>基于<code>vector</code>。创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于vector实现空栈</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">// str_stk2在vector上实现，初始化时保存svec的拷贝</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec);</span><br></pre></td></tr></table></figure><h5 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h5><p><code>stack</code>类型定义在<code>stack</code>头文件中。</p><img src="/blog/2020/11/25/C-顺序容器/stack.png" style="zoom:120%;"><h5 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h5><p><code>queue</code>和<code>priority_queue</code>适配器定义在<code>queue</code>头文件中。</p><img src="/blog/2020/11/25/C-顺序容器/queue.png" style="zoom:120%;"><img src="/blog/2020/11/25/C-顺序容器/queue1.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;顺序容器概述&lt;/li&gt;
&lt;li&gt;容器库概览&lt;/li&gt;
&lt;li&gt;顺序容器操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;对象是如何增长的&lt;/li&gt;
&lt;li&gt;额外的&lt;code&gt;string&lt;/code&gt;操作&lt;/li&gt;
&lt;li&gt;容器适配器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode148-排序链表</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/11/22/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-11-22T02:27:25.000Z</published>
    <updated>2020-12-17T08:14:30.633Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你链表的头结点 <code>head</code> ，请将其按 升序 排列并返回 排序后的链表 。</p><p><strong>进阶</strong>：</p><p>你可以在<code>O(nlogn)</code>时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p>本题可与<a href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more">LeetCode147-对链表进行插入排序</a>，<a href="http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/">LeetCode143-重排链表</a>共同学习。</p><a id="more"></a><img src="/blog/2020/11/22/LeetCode148-排序链表/示例.png" style="zoom:80%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目要求用<code>O(nlogn)</code>的时间复杂度来进行排序，所以不能用<a href="http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more">LeetCode147-对链表进行插入排序</a>的方法来进行解，所以采用归并排序的思想对链表进行排序。</p><p>使用归并排序首先得找到链表的中间节点，找到中间节点，根据中间节点的位置将链表分为两个部分，再进行归并排序。<strong>中间节点在链表前半部分的末尾，将链表拆开后，要让中间节点的下一个指向空</strong>，再分别对两个链表进行归并排序，最后再合并两个排序好的链表，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode* __mergeSort(ListNode *node)&#123;</span><br><span class="line">    <span class="comment">// 如果节点为空或只有一个节点，返回当前节点即可</span></span><br><span class="line">    <span class="keyword">if</span>(!node || !node-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    ListNode *fast = node;</span><br><span class="line">    ListNode *slow = node;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *l2 = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* left = __mergeSort(node);</span><br><span class="line">    ListNode* right = __mergeSort(l2);</span><br><span class="line">    <span class="keyword">return</span> __merge(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并的操作需要创建一个新的链表，新的链表根据两个链表的值建立。如果$l1$的值小于$l2$，那么将插入$l1$新的链表中，同时$l1$移动到它的下一个节点；否则将$l2$插入新的链表中，同时$l2$移动到它的下一个节点。插入操作结束后，再将新链表向后移动一个节点（也就是新插入的节点）。<strong>如果两个链表长度不一样（两个链表长度最多差一个），还要判断插入操作结束后哪个链表不为空，如果不为空，它就是新链表的最后一个节点</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ListNode* __merge(ListNode *l1, ListNode *l2)&#123;</span><br><span class="line">    ListNode *dummyNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode *cur = dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; l2-&gt;val;</span></span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = l1 != <span class="literal">nullptr</span> ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __mergeSort(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其余两个函数</span></span><br><span class="line">ListNode* __mergeSort(ListNode *node);</span><br><span class="line">ListNode* __merge(ListNode *l1, ListNode *l2);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你链表的头结点 &lt;code&gt;head&lt;/code&gt; ，请将其按 升序 排列并返回 排序后的链表 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;你可以在&lt;code&gt;O(nlogn)&lt;/code&gt;时间复杂度和常数级空间复杂度下，对链表进行排序吗？&lt;/p&gt;
&lt;p&gt;本题可与&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/11/21/LeetCode147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#more&quot;&gt;LeetCode147-对链表进行插入排序&lt;/a&gt;，&lt;a href=&quot;http://www.xingyuzhao.ltd/blog/2020/10/27/LeetCode143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/&quot;&gt;LeetCode143-重排链表&lt;/a&gt;共同学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="链表" scheme="http://www.xingyuzhao.ltd/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="归并排序" scheme="http://www.xingyuzhao.ltd/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
