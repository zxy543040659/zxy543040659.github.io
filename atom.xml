<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>工欲善其事，必先利其器</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2021-07-12T02:38:47.445Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Zxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer_1_20</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/07/12/%E5%89%91%E6%8C%87offer-1-20/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/07/12/%E5%89%91%E6%8C%87offer-1-20/</id>
    <published>2021-07-12T02:30:12.000Z</published>
    <updated>2021-07-12T02:38:47.445Z</updated>
    
    <content type="html"><![CDATA[<p>剑指 Offer 01~20</p><a id="more"></a><h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指 Offer 04. 二维数组中的查找</a></h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例：</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>从右上角往左下角看，是一棵二叉搜索树。从右上角开始遍历，如果当前值小于 <code>target</code> ，那么需要将列递减；如果当前值大于 <code>target</code>，就需要将行递增，直到找到 <code>target</code>。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; matrix.size() &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt; target)</span><br><span class="line">                col--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>前序遍历的第一个元素便是二叉树的根节点，由于元素不重复，那么在中序遍历中找到该节点，就可以将中序遍历分为 <strong>「左子树|根节点|右子树」</strong> 三部分，再根据中序遍历中左子树和右子树的元素的个数，将前序遍历分为<strong>「根节点|左子树|右子树」</strong>三部分。建立根节点，再用根节点指向左子树和右子树。</p><p>算法如下：</p><ol><li>根据前序遍历记录根节点在中序遍历中出现的位置；</li><li>在中序遍历中，根据根节点将左右子树分开，使根节点分别指向左子树和右子树；</li><li>根据中序遍历中左子树和右子树的元素长度，将前序遍历分为根节点、左子树、右子树三部分，然后再对左子树和右子树分别建树。</li></ol><p>详见注释。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n  = preorder.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">map</span>[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = build(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序数组，中序数组。左/右子树在前序遍历和中序遍历中起点，终点。</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2, <span class="keyword">int</span> left1, <span class="keyword">int</span> right1, <span class="keyword">int</span> left2, <span class="keyword">int</span> right2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left1 &gt; right1 || left2 &gt; right2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到根节点</span></span><br><span class="line">        <span class="keyword">int</span> root = v1[left1];</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="built_in">map</span>[root];</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(root);</span><br><span class="line">        <span class="comment">// 前序遍历左子树起点，终点；中序遍历左子树起点，终点</span></span><br><span class="line">        node-&gt;left = build(v1, v2, left1 + <span class="number">1</span>, left1 + pos - left2, left2, pos - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 前序遍历右子树起点，终点；中序遍历右子树起点，终点</span></span><br><span class="line">        node-&gt;right = build(v1, v2, left1 + pos - left2 + <span class="number">1</span>, right1, pos + <span class="number">1</span>, right2);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>使用 s1 存储新元素。当需要实现出队时，如果 s2 非空，直接出队即可；如果 s2 为空，将 s1 中的所有元素出栈并放入 s2 中，再将 s2 栈顶弹出，保证出队顺序。</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    CQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">                s2.push(s1.top());</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> v = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a></h4><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>注意边界。</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> f0 = <span class="number">0</span>, f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fn = f0 % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>) + f1 % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>与上题类似，注意边界。</p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> fn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fn = f1 % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>) + f2 % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn % (<span class="keyword">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 11. 旋转数组的最小数字</a></h4><h5 id="题目描述※"><a href="#题目描述※" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>二分查找。详见注释。</p><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 此条件下说明最小元素坐标i范围是left &lt;= i &lt;= mid</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &lt; numbers[right])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此条件下说明最小元素坐标i范围是mid + 1 &lt;= i &lt;= right </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; numbers[right])&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// [1,3,3],[3,3,1,3]等情况，使right处于数组的较小部分</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 12. 矩阵中的路径</a></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><ul><li>找到可以匹配 <code>word</code> 第一个字符的位置，更新 <code>pos</code> 和 <code>vis</code>；</li><li>从匹配的位置进行 DFS，寻找下一个匹配的位置，如果此路不通，需要将 <strong>坐标和是否访问</strong> “归还”（回溯思想）。</li><li>如果 <code>pos == word.size()</code> 说明存在此条路线，记录此时状态。</li></ul><p>其中：</p><ul><li>使用 <code>pos</code> 标记当前 <code>word</code> 中应该对比的字符的位置；</li><li>使用 <code>vis[i][j]</code> bool型数组记录当前坐标是否被访问。</li></ul><h5 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h5><ol><li>上述解题思路 2 中，<strong>寻找匹配位置</strong>是一种剪枝方法，避免走其他路线；</li><li>当已经存在一条路线时，就不需要继续找了，设置<strong>全局变量</strong>记录是否存在路线。</li></ol><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">vis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word[<span class="number">0</span>])&#123;</span><br><span class="line">                    vis[i][j] = <span class="number">1</span>;</span><br><span class="line">                    dfs(board, word, <span class="number">1</span>, i, j, vis);</span><br><span class="line">                    vis[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> &amp;word, <span class="keyword">int</span> pos, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.size())&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">4</span>; ++m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> x = i + dx[m];</span><br><span class="line">            <span class="keyword">int</span> y = j + dy[m];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.size() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].size()</span><br><span class="line">                &amp;&amp; board[x][y] == word[pos] &amp;&amp; !vis[x][y])&#123;</span><br><span class="line">                vis[x][y] = <span class="number">1</span>;</span><br><span class="line">                dfs(board, word, pos + <span class="number">1</span>, x, y, vis);</span><br><span class="line">                vis[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指 Offer 13. 机器人的运动范围</a></h4><h5 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h5><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>深度优先搜索。从（0，0）开始，找到所有的可能性。</p><h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">vis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        dfs(m, n, <span class="number">0</span>, <span class="number">0</span>, k, vis);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i1, <span class="keyword">int</span> j1, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;vis)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 主要针对只有初始点是可以进去的</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[i1][j1])&#123;</span><br><span class="line">            vis[i1][j1] = <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i1 + dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = j1 + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 数位求和，这里可以简化，懒得弄了就直接转string处理了</span></span><br><span class="line">            <span class="built_in">string</span> x_s = to_string(x);</span><br><span class="line">            <span class="built_in">string</span> y_s = to_string(y);</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : x_s) n1 += ch - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : y_s) n2 += ch - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; !vis[x][y] &amp;&amp; n1 + n2 &lt;= k)&#123;</span><br><span class="line">                vis[x][y] = <span class="number">1</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">                dfs(m, n, x, y, k, vis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一种并查集做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> m, <span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                parent.push_back(i * n + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : p = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        parent[pRoot] = qRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(m, n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isValid(i, j, k)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; <span class="number">4</span>; ++idx)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[idx];</span><br><span class="line">                    <span class="keyword">int</span> y = j + dy[idx];</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; isValid(x, y, k))&#123;</span><br><span class="line">                        uf.unionElem(i * n + j, x * n + y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="built_in">map</span>[uf.find(i * n + j)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;m : <span class="built_in">map</span>)&#123;</span><br><span class="line">            ans = max(ans, m.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += y % <span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 14- I. 剪绳子</a></h4><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 14- II. 剪绳子 II</a></p><h5 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h5><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><h5 id="思路1：动态规划"><a href="#思路1：动态规划" class="headerlink" title="思路1：动态规划"></a>思路1：动态规划</h5><p><code>dp[i]</code> 表示长度等于 i 时的绳子可获得成绩的最大值，可以拆解为两部分的乘积：<br>$$<br>dp[i] = dp[j] \times dp[i - j]\ \ \ \ \ \ j = 1…i/2<br>$$<br>当 n 小于等于 3 时，返回 <code>n - 1</code>。</p><h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路2：数学方法"><a href="#思路2：数学方法" class="headerlink" title="思路2：数学方法"></a>思路2：数学方法</h5><ol><li>任何大于 1 的数都可以由 2 和 3 相加而成；</li><li>使用 3 作为因数比使用 2 作为因数乘积更大；</li><li>当 n 大于 4 时，将绳子不断减去 3，并进行累乘。</li></ol><p>至于为什么不是 n 大于 3，因为 n 等于 4 时，将绳子切为两段 2 比切为 1 和 3 更优。</p><h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            sum *= <span class="number">3</span>;</span><br><span class="line">            sum %= <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum * n % <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，$x^n$）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>快速幂运算，只需要在奇数时将结果与平方数相乘。</p><h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = n &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> nn = n;</span><br><span class="line">        nn = <span class="built_in">abs</span>(nn);</span><br><span class="line">        <span class="comment">// 快速幂</span></span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(nn)&#123;</span><br><span class="line">            <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">if</span>(nn &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                sum *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            nn &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? <span class="number">1</span> / sum : sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">剑指 Offer 19. 正则表达式匹配</a></h4><h5 id="题目描述※-1"><a href="#题目描述※-1" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>请实现一个函数用来匹配包含 <code>&#39;. &#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式。模式中的字符 <code>&#39;.&#39;</code> 表示任意一个字符，而 <code>&#39;*&#39;</code> 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 <code>&quot;aaa&quot;</code> 与模式 <code>&quot;a.a&quot;</code> 和 <code>&quot;ab*ac*a&quot;</code> 匹配，但与 <code>&quot;aa.a&quot;</code> 和 <code>&quot;ab*a&quot;</code> 均不匹配。</p><img src="/blog/2021/07/12/剑指offer-1-20/offer-19.png"><h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>假设主串为 A，长度为 n；匹配串为 B，长度为 m。关注 B 的<strong>最后一个字符</strong>是什么，有三种可能：正常字符， <code>*</code> 和 <code>.</code>。</p><ol><li>正常字符：看 A[n - 1] 是否等于 B[m - 1]，如果相等则同时前移；</li><li><code>.</code>，可以匹配任意字符，直接看前一个是否匹配；</li><li><code>*</code>，表示 B[m - 2] 可以重复 0 次或多次：<ol><li>表示 0 次，B 最后两个字符无效，比较 B[0 : m - 3] 和 A[0 : n - 1] 是否匹配；</li><li>表示多次，即 B[m - 2] = c 可以出现多次，如果此时 A[n - 1] = c，或者 c = <code>.</code>，则可以匹配，那么 A 向前移动一个，B 不动，再次查看 A[0 : n - 2] 和 B[0 : m - 1] 是否匹配（将 A 从后往前等于 c 的元素都匹配上）。</li></ol></li></ol><h6 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h6><p>$dp[i][j]$ 表示 A 的前 $i$ 个 和 B 的前 $j$ 个能否匹配。</p><ul><li>对于前两种情况，可以合并为 $dp[i][j] = dp[i - 1][j - 1]$</li><li>对于第三种情况，简单记为 c*，分为两种情况<ol><li>表示 0 次，直接砍掉 B 后面两个字符，$dp[i][j] = dp[i][j - 2]$</li><li>表示多次，正则串不动，主串前移一个，$dp[i][j] = dp[i - 1][j]$</li></ol></li></ul><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>正则串为空，如果主串为空，则匹配，否则不匹配：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = i == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = p.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="comment">// i和j表示当前字符串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">                <span class="comment">// 如果正则串空，那么只能匹配空串</span></span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 正则串非空，分为*和非*</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果不为*，则直接比较当前字符是否相等，或正则串字符为.</span></span><br><span class="line">                    <span class="keyword">if</span>(p[j - <span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>))&#123;</span><br><span class="line">                            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 碰到*了，分为*表示0次还是多次</span></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 表示0次，直接砍掉正则串后两个</span></span><br><span class="line">                        <span class="keyword">if</span>(j &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                            dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 表示多次，主串当前和正则串上一位置相等，或正则串的前一位置为.</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>))&#123;</span><br><span class="line">                            dp[i][j] = dp[i][j] | dp[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line"><span class="comment">// 注意：使用 | 表示上述两种情况只要有一种满足即可！！！</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</a></p><h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a></h4><h5 id="题目描述※-2"><a href="#题目描述※-2" class="headerlink" title="题目描述※"></a>题目描述※</h5><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 <strong>小数</strong> 或者 整数</li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li></ul><img src="/blog/2021/07/12/剑指offer-1-20/offer-20.png"><h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h5><p>详见注释。</p><h5 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = s.find_first_not_of(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos1 == s.npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> pos2 = s.find_last_not_of(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">bool</span> numFlag = <span class="number">0</span>, dotFlag = <span class="number">0</span>, eFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos1; i &lt;= pos2; ++i)&#123;</span><br><span class="line">            <span class="comment">// 判定为数字，标记为numFlag</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                numFlag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判定为.，需要没出现过.且没出现过e</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'.'</span> &amp;&amp; !dotFlag &amp;&amp; !eFlag)&#123;</span><br><span class="line">                dotFlag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判定为e，需要没出现过e且出现过数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] == <span class="string">'E'</span> || s[i] == <span class="string">'e'</span>) &amp;&amp; numFlag &amp;&amp; !eFlag)&#123;</span><br><span class="line">                eFlag = <span class="number">1</span>;</span><br><span class="line">                numFlag = <span class="number">0</span>; <span class="comment">// 出现e之后重新判断整数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断为+-，只能出现在第一位或者紧接在e后面</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) &amp;&amp; (i == pos1 || s[i - <span class="number">1</span>] == <span class="string">'e'</span> || s[i - <span class="number">1</span>] == <span class="string">'E'</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他情况非法</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指 Offer 01~20&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>C++中static的用法总结</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/05/26/C-%E4%B8%ADstatic%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/05/26/C-%E4%B8%ADstatic%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-26T14:24:48.000Z</published>
    <updated>2021-05-26T15:22:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>C++ 中 <strong>static</strong> 关键字的作用。</p><a id="more"></a><h5 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h5><p>用于函数体内部修饰变量，这种变量的生存期长于该函数。</p><ol><li>该变量在<strong>全局数据区</strong>分配内存；</li><li>在首次执行到该对象声明处被首次初始化，以后的函数调用不再进行初始化，即：<strong>静态变量只初始化一次</strong>；</li><li><strong>静态局部变量一般在声明处初始化</strong>，如果没有显示初始化，会被程序自动初始化为 0；</li><li>它始终驻留在全局数据区，直到程序运行结束，但是其作用域为局部作用域，在函数体外无法使用。</li></ol><h5 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h5><p>定义在函数体外，用于修饰全局变量，表示该变量只在<strong>本文件</strong>可见。</p><ol><li>静态全局变量<strong>不能被其他文件使用</strong>（全局变量可以）；</li><li>其他文件可以定义同名变量且不会发生冲突。</li></ol><h5 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h5><p>类似于静态全局变量。</p><ol><li>静态函数<strong>不能被其他文件使用</strong>；</li><li>其他文件可以定义同名函数且不会发生冲突。</li></ol><h5 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h5><p>用于修饰类中的数据成员，称为<strong>静态成员</strong>。这种数据成员的生存期大于类的对象。静态数据成员是每个类有一份，普通数据成员每个对象有一份。</p><ol><li>静态成员存储在全局数据区，在定义时需要分配空间，所以不能在类中定义。且只分配一次内存，被类的所有对象共同访问；</li><li><strong>静态成员不占据类的空间，必须在类外进行初始化，且在初始化时与私有或公有无关</strong>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// sizeof(A) = 1，空类大小为1</span></span><br></pre></td></tr></table></figure><h5 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h5><p>用于修饰类的成员函数，可以用 <strong>类名::函数名</strong> 进行访问。</p><ol><li>静态成员函数<strong>可访问</strong>静态数据成员和静态成员函数；</li><li>非静态成员函数<strong>可访问</strong>静态数据成员和静态成员函数；</li><li>静态数据成员<strong>不可访问</strong>非静态数据成员和非静态成员函数；</li><li>调用静态成员函数，可以用成员访问操作符 (.) 和 (-&gt;) 为一个类的对象或指向类对象的指针调用静态成员函数，也可以用 类名::函数名 调用。</li></ol><p>静态成员函数不能声明为 <code>const</code>，因为其不能访问对象的非静态数据成员，无法使用 <code>thiscall</code>。</p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>（1）静态成员函数和非静态成员函数的区别？</p><p>静态成员函数不存在 <code>this</code> 指针，不能访问非静态成员变量。</p><p>（2）为什么要使用静态成员变量和静态成员函数？</p><p>为了实现共享。静态成员函数和静态成员变量属于类，不属于类的实体，这样可以被多个对象所共享。</p><p>（3）在头文件把一个变量声明为 static 变量，引用该文件的源文件能访问到该变量吗？</p><p>可以，因为 cpp 文件包含了头文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h4&gt;&lt;p&gt;C++ 中 &lt;strong&gt;static&lt;/strong&gt; 关键字的作用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="static" scheme="http://www.xingyuzhao.ltd/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>libevent服务端接收连接的代码示例</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/04/27/libevent%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/04/27/libevent%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</id>
    <published>2021-04-27T14:36:01.000Z</published>
    <updated>2021-04-27T15:27:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>libevent服务端接收连接的代码示例。</p><a id="more"></a><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPORT 5001</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listen_cb</span><span class="params">(struct evconnlistener *e, <span class="keyword">evutil_socket_t</span> s, struct sockaddr *a, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"listen_cb"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="comment">// 初始化socket库</span></span><br><span class="line">WSADATA wsa;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsa);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// 忽略管道信号，发送数据给已关闭的socket</span></span><br><span class="line"><span class="comment">// 防止程序down掉</span></span><br><span class="line"><span class="keyword">if</span> (signal(SIGPIPE, SIG_IGN) == SIG_ERR)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test server!\n"</span>;</span><br><span class="line"><span class="comment">// 创建libevent的上下文</span></span><br><span class="line">event_base *base = event_base_new();</span><br><span class="line"><span class="keyword">if</span> (base) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"event_base_new success"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line"><span class="comment">// socket，bind，listen在一起做了，绑定事件</span></span><br><span class="line">sockaddr_in <span class="built_in">sin</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(SPORT);</span><br><span class="line"></span><br><span class="line">evconnlistener *ev = evconnlistener_new_bind(base, <span class="comment">// libevent的上下文</span></span><br><span class="line">listen_cb,                <span class="comment">// 接受到连接的回调函数</span></span><br><span class="line">base,  <span class="comment">// 回调函数获取的参数arg</span></span><br><span class="line">LEV_OPT_REUSEABLE | LEV_OPT_CLOSE_ON_FREE, <span class="comment">// 地址重用，listen关闭同时关闭socket</span></span><br><span class="line"><span class="number">10</span>, <span class="comment">// 连接队列大小，对应listen函数</span></span><br><span class="line">(sockaddr*)&amp;<span class="built_in">sin</span>, <span class="comment">// 绑定的地址和端口</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">sin</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 事件分发处理</span></span><br><span class="line"><span class="keyword">if</span>(base)</span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"><span class="keyword">if</span>(ev)</span><br><span class="line">evconnlistener_free(ev);</span><br><span class="line"><span class="keyword">if</span>(base)</span><br><span class="line">event_base_free(base);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>在 cmd 中输入：<code>telnet 127.0.0.1 5001</code> 可以看到在控制台输出 <code>listen_cb</code>：</p><img src="/blog/2021/04/27/libevent服务端接收连接的代码示例/1.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;p&gt;libevent服务端接收连接的代码示例。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="libevent" scheme="http://www.xingyuzhao.ltd/tags/libevent/"/>
    
  </entry>
  
  <entry>
    <title>条款43：学习处理模板化基类内的名称</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/04/08/%E6%9D%A1%E6%AC%BE43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/04/08/%E6%9D%A1%E6%AC%BE43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0/</id>
    <published>2021-04-08T13:03:36.000Z</published>
    <updated>2021-04-08T15:29:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p>可在派生类模板内通过 <code>this-&gt;</code> 指出基类模板内的成员名称，或者由一个清晰的<strong>基类资格修饰符</strong>完成。</p><a id="more"></a><h4 id="一个传送信息的模板程序"><a href="#一个传送信息的模板程序" class="headerlink" title="一个传送信息的模板程序"></a>一个传送信息的模板程序</h4><p>我们需要一个程序将加密的信息或者未经加工的文字传到不同的公司去。如果在编译期间我们可知哪一个信息传到哪一家公司，可以使用基于模板的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// 未加工的文本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// 加密的信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyB</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// 未加工的文本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>; <span class="comment">// 加密的信息</span></span><br><span class="line">&#125;;</span><br><span class="line">... <span class="comment">// 针对其他公司设计的class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgInfo</span> &#123;</span> ... &#125;; <span class="comment">// 用来保存及产生信息</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> msg;</span><br><span class="line">根据info产生信息</span><br><span class="line">Company c;</span><br><span class="line">c.sendCleartext(msg);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 类似sendClear，调用sendEncrypted</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123; ... &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们希望在每次发送信息时记录某些信息，可以使用派生类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line">sendClear(info); <span class="comment">// 调用基类函数，代码无法通过编译</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码编译器会提示 <code>sendClear</code> 不存在，原因是编译器不知道类模板 <code>LoggingMsgSender</code> 继承的是什么样的类（ <code>MsgSender&lt;Company&gt;</code> 中的 <code>company</code> 未知），所以更不知道是否有 <code>sendClear</code> 函数。</p><h4 id="模板全特化"><a href="#模板全特化" class="headerlink" title="模板全特化"></a>模板全特化</h4><p>假设有个类 <code>CompanyZ</code> 坚持使用加密通信：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyZ</span>&#123;</span> <span class="comment">// 这个类不提供sendCleartext函数，你懂的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般性的 <code>MsgSender</code> 模板对 <code>CompanyZ</code> 并不合适，因为模板提供了 <code>sendClear</code> 函数，此函数又调用了 <code>sendCleartext</code> 函数，对 <code>CompanyZ</code> 对象来说合理吗？这不合理。针对这个问题，可以产生一个 <code>MsgSender</code> <strong>全特化版</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&lt;CompanyZ&gt;&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> <span class="comment">// 此函数针对加密文档的传送</span></span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="再看派生类LoggingMsgSender"><a href="#再看派生类LoggingMsgSender" class="headerlink" title="再看派生类LoggingMsgSender"></a>再看派生类LoggingMsgSender</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line">sendClear(info); <span class="comment">// 如果Company = CompanyZ，此函数将不存在</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如注释所言，如果基类被指定为 <code>MsgSender&lt;CompanyZ&gt;</code> 必然是不合法的，<strong>编译器知道基类模板有可能被特化</strong>，特化版本可能不提供和一般性模板相同的接口。因此编译器<strong>拒绝在模板化基类中寻找继承而来的名称</strong>（本例中 <code>MsgSender&lt;Company&gt;</code>）。</p><h5 id="令C-可以进入模板化基类"><a href="#令C-可以进入模板化基类" class="headerlink" title="令C++可以进入模板化基类"></a>令C++可以进入模板化基类</h5><ol><li>在基类函数调用动作之前加上 <code>this-&gt;</code>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line"><span class="keyword">this</span>-&gt;sendClear(info); <span class="comment">// 成立，sendClear将被继承</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>using</code> 声明式：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear; <span class="comment">// 告诉编译器，基类中存在sendClear</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line">sendClear(info); <span class="comment">// 成立，sendClear将被继承</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>明白指出被调用的函数位于基类：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span>&#123;</span><br><span class="line">将传送前信息写至<span class="built_in">log</span></span><br><span class="line">MsgSender&lt;Company&gt;::sendClear(info); <span class="comment">// 成立，sendClear将被继承</span></span><br><span class="line">将传送后信息写至<span class="built_in">log</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这种解法如果调用的是虚函数，上述做法会关闭虚函数的绑定行为。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;p&gt;可在派生类模板内通过 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 指出基类模板内的成员名称，或者由一个清晰的&lt;strong&gt;基类资格修饰符&lt;/strong&gt;完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="模板" scheme="http://www.xingyuzhao.ltd/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>条款42：了解typename的双重意义</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/04/06/%E6%9D%A1%E6%AC%BE42%EF%BC%9A%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/04/06/%E6%9D%A1%E6%AC%BE42%EF%BC%9A%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89/</id>
    <published>2021-04-06T07:53:08.000Z</published>
    <updated>2021-04-06T13:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ol><li>声明 template 参数时，前缀关键字 class 和 typename 可互换</li><li>请使用关键字 typename 标识嵌套从属类型名称；但不得在基类列表或成员初始化列表内作为基类的修饰符</li></ol><a id="more"></a><h4 id="从属名称和非从属名称"><a href="#从属名称和非从属名称" class="headerlink" title="从属名称和非从属名称"></a>从属名称和非从属名称</h4><p>以下程序想要实现打印 STL 容器里的第二个元素（STL 里对象为 int 类型）。先不管能否通过编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(container.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ++iter;</span><br><span class="line">        <span class="keyword">int</span> value = *iter;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>变量 iter 的类型是 C::const_iterator，实际是什么类型取决去 template 参数 C。如果 template 内出现的名称依赖于某个 template 参数，称之为从属名称，如果从属名称在 class 中呈嵌套状，称其为嵌套从属名称，C::const_iterator 就是如此；</li><li>变量 value 的类型是 int，int 不依赖任何 template 参数，所以这样的名称是非从属名称。</li></ul><p>如果解析器在 template 中遭遇一个嵌套从属名称，<strong>它便假设这个名称非一种类型，除非你使用 typename 告诉它确实是一种类型</strong>。以下才是合法的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(container.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个例外"><a href="#一个例外" class="headerlink" title="一个例外"></a>一个例外</h4><p>typename 必须作为嵌套从属类型名称的前缀词这一规则的例外是：</p><ul><li>typename 不可以出现在<strong>基类列表</strong>中的嵌套从属类型名称之前，也不可在<strong>成员初始化列表</strong>中作为基类的修饰符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested&#123; <span class="comment">// 基类列表中不允许typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span>: Base&lt;T&gt;::<span class="title">Nested</span><span class="params">(x)</span></span>&#123; <span class="comment">// 成员初始化列表中也不允许typename</span></span><br><span class="line"><span class="keyword">typename</span> Base&lt;T&gt;::Nested temp; <span class="comment">// 不在上述两种情况内且是嵌套从属类型名称，必须加上typename</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="typedef与typename结合"><a href="#typedef与typename结合" class="headerlink" title="typedef与typename结合"></a>typedef与typename结合</h4><p>假设我们正在撰写一个函数模板，它接受一个迭代器，我们要对迭代器所指向的对象做一份局部拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">void</span> workWithIterator&lt;IterT iter)&#123;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::iterator_traits&lt;IterT&gt;::value_type</code> 表示类型为 IterT 之对象所指之物的类型，并将 temp 初始化为 iter 所指物。即：IterT 是 <code>vector&lt;int&gt;::iterator</code>，temp 的类型就是 int，由于 value_type 是一个嵌套从属类型名称，所以我们必须在它之前放置 typename。</p><p>同时可以使用 typedef 减少一遍又一遍的使用 <code>std::iterator_traits&lt;IterT&gt;::value_type</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">void</span> workWithIterator&lt;IterT iter)&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span> value_type</span>;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;声明 template 参数时，前缀关键字 class 和 typename 可互换&lt;/li&gt;
&lt;li&gt;请使用关键字 typename 标识嵌套从属类型名称；但不得在基类列表或成员初始化列表内作为基类的修饰符&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="typename" scheme="http://www.xingyuzhao.ltd/tags/typename/"/>
    
  </entry>
  
  <entry>
    <title>条款38：通过复合塑模出has-a或“根据某物实现出”</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/04/01/%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/04/01/%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D/</id>
    <published>2021-04-01T14:53:27.000Z</published>
    <updated>2021-04-01T15:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>复合的意义和 public 继承完全不同。</li><li>在应用域，复合意味 has-a（有一个）。在实现域，复合意味 is-implemented-in-terms-of（根据某物实现出）。</li></ul><a id="more"></a><h4 id="复合指某种类型中含其他类型的对象"><a href="#复合指某种类型中含其他类型的对象" class="headerlink" title="复合指某种类型中含其他类型的对象"></a>复合指某种类型中含其他类型的对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">Address address; </span><br><span class="line">PhoneNumber voiceNumber;</span><br><span class="line">PhoneNumber faxNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person 对象由 string，Address，PhoneNumber，PhoneNumber 构成。</p><h4 id="has-a-or-is-implemented-in-terms-of"><a href="#has-a-or-is-implemented-in-terms-of" class="headerlink" title="has-a or is-implemented-in-terms-of"></a>has-a or is-implemented-in-terms-of</h4><h5 id="应用域与实现域"><a href="#应用域与实现域" class="headerlink" title="应用域与实现域"></a>应用域与实现域</h5><p>应用域：程序中的对象相当于你所塑造的世界中的某些事物，例如人、汽车等。</p><p>实现域：另外一些对象是实现细节上的人工制品，例如：缓冲区、互斥器、查找树等。</p><p>在应用域中的对象间，复合表现为 has-a 的关系；当它发生于实现域则表现 is-implemented-in-terms-of 的关系。</p><h4 id="区分-is-a-和-is-implemented-in-terms-of"><a href="#区分-is-a-和-is-implemented-in-terms-of" class="headerlink" title="区分 is-a 和 is-implemented-in-terms-of"></a>区分 is-a 和 is-implemented-in-terms-of</h4><p><strong>实现Set</strong>，基于标准库 list <strong>template</strong>。</p><h5 id="Set-template-继承-std-list"><a href="#Set-template-继承-std-list" class="headerlink" title="Set template 继承 std::list"></a>Set template 继承 std::list</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is-a</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 将list应用与set错误用法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span>:</span>:<span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>如果 Set 是一种 list，那么对 list 为真的每件事对 Set 也为真，但是 list 可以包含重复元素而 Set 不行。</p><h5 id="Set-对象根据-list-对象实现出来"><a href="#Set-对象根据-list-对象实现出来" class="headerlink" title="Set 对象根据 list 对象实现出来"></a>Set 对象根据 list 对象实现出来</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Set</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">member</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Set&lt;T&gt;::member(<span class="keyword">const</span> T&amp; item) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::find(rep.begin(), rep.end(), item) != rep.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; item)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!member(item)) rep.push_back(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::remove(<span class="keyword">const</span> T&amp; item)&#123;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::iterator it = </span><br><span class="line">        <span class="built_in">std</span>::find(rep.begin(), rep.end(), item);</span><br><span class="line">    <span class="keyword">if</span>(it != rep.end()) rep.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> Set&lt;T&gt;::size() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rep.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Set 与 list 的关系为：<strong>根据某物实现出（is-implemented-in-terms-of）</strong>而不是<strong>是一种（is-a）</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;复合的意义和 public 继承完全不同。&lt;/li&gt;
&lt;li&gt;在应用域，复合意味 has-a（有一个）。在实现域，复合意味 is-implemented-in-terms-of（根据某物实现出）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="has-a" scheme="http://www.xingyuzhao.ltd/tags/has-a/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode132-分割回文串Ⅱ</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/08/LeetCode132-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%E2%85%A1/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/08/LeetCode132-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%E2%85%A1/</id>
    <published>2021-03-08T07:57:54.000Z</published>
    <updated>2021-03-08T12:54:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 <strong>最少分割次数</strong> 。</p><a id="more"></a><img src="/blog/2021/03/08/LeetCode132-分割回文串Ⅱ/132.png"><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>与<a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a>类似，但是不能使用暴力回溯，会超时。</p><p>使用两次动态规划来解决：</p><ol><li>得到回文串的二维 <code>dp</code> 数组，<code>dp[i][j]</code> 表示 <code>s[i:j]</code> 是否构成回文子串；</li><li>设置新的一维数组 <code>f</code>，<code>f[i]</code> 表示以 <code>i</code> 结尾的字符串最少需要几次分割。</li></ol><p><strong>具体算法如下</strong>：</p><p>我们定义 f[i] 为以下标为 i 的字符作为结尾的最小分割次数，那么最终答案为 f[n - 1]。</p><p>不失一般性的考虑第 j 字符的分割方案：</p><ol><li>从起点字符到第 j 个字符能形成回文串，那么最小分割次数为 0。此时有 f[j] = 0；</li><li>从起点字符到第 j 个字符不能形成回文串：<ol><li>该字符独立消耗一次分割次数。此时有 f[j] = f[j - 1] + 1；</li><li>该字符不独立消耗一次分割次数，而是与前面的某个位置 i 形成回文串，[i, j] 作为整体消耗一次分割次数。此时有 f[j] = f[i - 1] + 1；</li></ol></li></ol><p>在 2.2 中满足回文要求的位置 i 可能有很多，我们在所有方案中取一个 min 即可。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        isPalindrome(s, n, dp);</span><br><span class="line">        <span class="comment">// f[i]表示以i结尾的字符串最少需要几次分割</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化，仅一个字符时不需要分割</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="comment">// 如果从起始位置到j可构成回文串，那么仍不需要分割</span></span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                f[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，以j结尾的字符串可选则分割一次或不分割</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 分割一次</span></span><br><span class="line">                f[j] = f[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 从之前某个字符开始时是回文子串</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; j; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                        <span class="comment">// 以i开始到j的字符串是回文串</span></span><br><span class="line">                        <span class="comment">// 由i-1处的分割次数加1得到，持续更新最小值</span></span><br><span class="line">                        f[j] = min(f[j], f[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j]) dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>作者：AC_OIer<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/xiang-jie-liang-bian-dong-tai-gui-hua-ji-s5xr/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/xiang-jie-liang-bian-dong-tai-gui-hua-ji-s5xr/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，请你将 &lt;code&gt;s&lt;/code&gt; 分割成一些子串，使每个子串都是回文。&lt;/p&gt;
&lt;p&gt;返回符合要求的 &lt;strong&gt;最少分割次数&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://www.xingyuzhao.ltd/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>回文子串/子序列相关问题</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/07/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/07/%E5%9B%9E%E6%96%87%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-07T09:02:58.000Z</published>
    <updated>2021-03-08T07:57:04.219Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h4><ol><li><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></li><li><a href="https://leetcode-cn.com/problems/shortest-palindrome/" target="_blank" rel="noopener">214. 最短回文串</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></li></ol><a id="more"></a><h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h4><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><img src="/blog/2021/03/07/回文相关问题/647.png" style="zoom:80%;"><h5 id="解决方案一：动态规划"><a href="#解决方案一：动态规划" class="headerlink" title="解决方案一：动态规划"></a>解决方案一：动态规划</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]表示s[i:j]是否是回文子串</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 三种情况</span></span><br><span class="line">        <span class="comment">// 1.自身</span></span><br><span class="line">        <span class="comment">// 2.如果长度为2，判断两个是否相同</span></span><br><span class="line">        <span class="comment">// 3.长度大于2，在两个字符相同的条件下，判断dp[i+1][j-1]也是就是左右各缩小一位的字串是否是回文</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i == <span class="number">1</span> &amp;&amp; s[j] == s[i])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i &gt; <span class="number">1</span> &amp;&amp; s[j] == s[i] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解决方案二：中心扩展法"><a href="#解决方案二：中心扩展法" class="headerlink" title="解决方案二：中心扩展法"></a>解决方案二：中心扩展法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 回文长度为奇数</span></span><br><span class="line">            <span class="keyword">int</span> count1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="comment">// 回文长度为偶数</span></span><br><span class="line">            <span class="keyword">int</span> count2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            ans += count1 + count2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中心扩展求当前字符起始的最长回文子串</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解决方案三：Manacher算法"><a href="#解决方案三：Manacher算法" class="headerlink" title="解决方案三：Manacher算法"></a>解决方案三：Manacher算法</h5><p>后续补充</p><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><img src="/blog/2021/03/07/回文相关问题/5.png"><h5 id="解决方案一：动态规划-1"><a href="#解决方案一：动态规划-1" class="headerlink" title="解决方案一：动态规划"></a>解决方案一：动态规划</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 以列填充dp数组，因为dp[i][j]由dp[i + 1][j - 1]转移而来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j]) dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时s[i]=s[j]，剩下的字符串长度为0或者1时，都是回文字符串</span></span><br><span class="line">                    <span class="comment">// 即(j - 1) - (i + 1)  + 1 &lt; 2 =&gt; j - i &lt; 3</span></span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                        begin = i;</span><br><span class="line">                        maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另一种动态规划的写法，跟<strong>回文子串</strong>类似，能稍微快些：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]表示s[i:j]是否是回文子串</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 三种情况</span></span><br><span class="line">        <span class="comment">// 1.自身</span></span><br><span class="line">        <span class="comment">// 2.如果长度为2，判断两个是否相同</span></span><br><span class="line">        <span class="comment">// 3.长度大于2，在两个字符相同的条件下，判断dp[i+1][j-1]也是就是左右各缩小一位的字串是否是回文</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i == <span class="number">1</span> &amp;&amp; s[j] == s[i])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j - i &gt; <span class="number">1</span> &amp;&amp; s[j] == s[i] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解决方案二：中心扩展法-1"><a href="#解决方案二：中心扩展法-1" class="headerlink" title="解决方案二：中心扩展法"></a>解决方案二：中心扩展法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="comment">// 回文串为奇数</span></span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="comment">// 回文串为偶数</span></span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> curLen = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(curLen &gt; maxLen)&#123;</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">                <span class="comment">// 自己画图模拟一下</span></span><br><span class="line">                begin = i - (maxLen - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正回文串长度需要减去两边</span></span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最短回文串"><a href="#最短回文串" class="headerlink" title="最短回文串"></a>最短回文串</h4><p>给定一个字符串 <strong><em>s</em></strong>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><img src="/blog/2021/03/07/回文相关问题/214.png"><p>本题其实是找包括  <code>s</code> 起始位置的最长回文子串，但是只有在 $O(n)$ 的复杂度情况下才能过，所以不能用 $O(n^2)$ 的动态规划或者中心扩展法，只能用Manacher算法和KMP匹配算法。</p><h5 id="解决方案：Manacher算法"><a href="#解决方案：Manacher算法" class="headerlink" title="解决方案：Manacher算法"></a>解决方案：Manacher算法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = longestPalindrome(s);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pos;</span><br><span class="line">        <span class="built_in">string</span> helper = s.substr(pos, s.size() - pos);</span><br><span class="line">        reverse(helper.begin(), helper.end());</span><br><span class="line">        s = helper + s;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> buf;</span><br><span class="line">        buf = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">int</span> mirror;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_pos;</span><br><span class="line">        <span class="keyword">int</span> l, r;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">            buf += ch;</span><br><span class="line">            buf += <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = buf.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i != n; ++i)&#123;</span><br><span class="line">            mirror = <span class="number">2</span> * center - i;</span><br><span class="line">            p[i] = min(p[mirror], max_right - i);</span><br><span class="line">            l = i - p[i] - <span class="number">1</span>;</span><br><span class="line">            r = i + p[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(buf[l] == buf[r])&#123;</span><br><span class="line">                    --l;</span><br><span class="line">                    ++r;</span><br><span class="line">                    ++p[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i - p[i] &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                max_pos = i + p[i];</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span>(i + p[i] &gt;= max_right)&#123;</span><br><span class="line">                max_right = i + p[i];</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; p[i] &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_pos / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p><img src="/blog/2021/03/07/回文相关问题/516.png"><h5 id="解决方案：动态规划"><a href="#解决方案：动态规划" class="headerlink" title="解决方案：动态规划"></a>解决方案：动态规划</h5><img src="/blog/2021/03/07/回文相关问题/516-helper.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// dp[i][j]表示从i到j的最长回文子序列</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从右下角进行左斜上遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">// 如果相等，缩小区间的最长回文子序列长度加上两个边界</span></span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 否则，缩小左区间或缩小右区间的最长回文子序列长度中的较大值得到</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目列表&quot;&gt;&lt;a href=&quot;#题目列表&quot; class=&quot;headerlink&quot; title=&quot;题目列表&quot;&gt;&lt;/a&gt;题目列表&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindromic-substrings/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;647. 回文子串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;5. 最长回文子串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shortest-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;214. 最短回文串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;516. 最长回文子序列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://www.xingyuzhao.ltd/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="中心扩展法" scheme="http://www.xingyuzhao.ltd/tags/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95/"/>
    
      <category term="Manacher算法" scheme="http://www.xingyuzhao.ltd/tags/Manacher%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>条款25：考虑写出一个不抛异常的swap函数</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/05/%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/05/%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-05T07:25:38.000Z</published>
    <updated>2021-03-05T09:08:47.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>缺省情况下 <code>swap</code> 动作由标准库提供的 <code>swap</code> 算法实现，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line"><span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要 T 支持拷贝运算（拷贝构造函数和拷贝赋值运算符）就可使用，但是经历了三次复制，对于某些类型而言，这样的复制操作并无必要，那么应该如何做？</p><a id="more"></a><h4 id="pimpl-pointer-to-implement"><a href="#pimpl-pointer-to-implement" class="headerlink" title="pimpl(pointer to implement)"></a>pimpl(pointer to implement)</h4><p>这种类型主要就是<strong>以指针指向一个对象，内含真正数据</strong>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span> <span class="comment">// 这个class使用pimpl手法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">privete:</span><br><span class="line">    WidgetImpl *pImpl; <span class="comment">// 所指对象内含Widget数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="为类特化std-swap"><a href="#为类特化std-swap" class="headerlink" title="为类特化std::swap"></a>为类特化std::swap</h5><p>我们希望告诉 <code>std::swap</code>：当 <code>Widget</code>被置换时真正该做的是置换其内部的 <code>pImpl</code> 指针。一个实现的思路是将 <code>std::swap</code> 针对 <code>Widget</code> 特例化，同时为了能够访问 <code>Widget</code> 的 <code>private</code>，令 <code>Widget</code> 声明一个 <code>swap</code> 的 <code>public</code> 成员函数做真正的置换操作，再将 <code>std::swap</code> 特例化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp;other)</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">swap(pImpl, other.pImpl);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123; <span class="comment">// 一般不能被改变std中任何东西，但是可以进行特例化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">void</span> swap&lt;Widget&gt;(Widget &amp;a, Widget &amp;b)&#123;</span><br><span class="line">a.swap(b); <span class="comment">// 调用Widget的成员函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="假设两个类都是类模板"><a href="#假设两个类都是类模板" class="headerlink" title="假设两个类都是类模板"></a>假设两个类都是类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure><p>此时再去特化 <code>std::swap</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt; &amp;a, Widget&lt;T&gt; &amp;b)&#123;</span><br><span class="line">a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上做法是<strong>错误的</strong>，因为我们企图<strong>偏特化</strong>一个函数模板，这是不允许的，<strong>因为有函数重载的概念，C++ 根据参数的类型来判断重载哪一个函数，如果还进行偏特化，这就与重载相冲突</strong>。但是我们可以对一个函数模板进行重载，同时需要注意不能在 std 中重载，因为 C++ 标准禁止添加新的 <code>template</code> 到 std 中（包括 <code>class</code> 或 <code>function</code> 等任何其他东西）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff&#123;</span><br><span class="line">... <span class="comment">// 模板化的WidgetImpl等</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 同前，含swap成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt; &amp;a, Widget&lt;T&gt; &amp;b)</span></span>&#123; <span class="comment">// 非成员函数且不属于std</span></span><br><span class="line">a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果准备置换两个对象，C++ 名称查找法则会找到 <code>WidgetStuff</code> 内的 <code>Widget</code> 的专属版本。</p><p>上述方法对<strong>类</strong>和<strong>类模板</strong>都适用，但是为了让你的<strong>类专属版</strong>的 <code>swap</code> 在更多的语境下调用，你需要同时在该 <code>class</code> 所在命名空间内写一个非成员函数版本和一个 <code>std::swap</code> 特化版本。</p><h5 id="更多语境下使用类专属的swap"><a href="#更多语境下使用类专属的swap" class="headerlink" title="更多语境下使用类专属的swap"></a>更多语境下使用类专属的swap</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T &amp;obj1, T &amp;obj2)</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 令std::swap在此函数内可用</span></span><br><span class="line">...</span><br><span class="line">swap(obj1, obj2); <span class="comment">// 为T型对象调用最佳的swap版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，C++ 的名称查找法则确保将找到 global 作用域及 T 所在命名空间内的任何 T 专属的 <code>swap</code>，具体顺序如下：</p><ol><li>编译器使用<strong>实参取决之查找规则</strong>找出 <code>WidgetStuff</code> 内的 <code>swap</code>，如果没有，转下；</li><li>使用 <code>std</code> 中对于 T 的特例化  <code>swap</code>，如果没有，转下；</li><li>使用 <code>std</code> 中一般化的 <code>template</code> 版本。</li></ol><p><strong>不能使用</strong> <code>std::swap(obj1, obj2)</code>，这会使**编译器只认 <code>std</code> 内的 <code>swap</code>**。</p><h5 id="成员版swap绝不可抛出异常"><a href="#成员版swap绝不可抛出异常" class="headerlink" title="成员版swap绝不可抛出异常"></a>成员版swap绝不可抛出异常</h5><p>当写下一个自定版本的 <code>swap</code>，往往提供的不只是高效率的置换对象值的办法，而且不抛出异常。因为高效率的 <code>swap</code> 几乎总是基于对内置类型的操作，而内置类型上的操作绝不会抛出异常。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ol><li>如果 <code>swap</code> 的缺省版本对类或者类模板提供可接受的效率，那么不需要额外做任何事。</li><li>如果效率不足，意味着你的类或者模板使用了 pimpl 手法，试着做以下事情：<ol><li>提供一个成员函数 <code>swap</code>，让它高效置换你的类型的两个对象值且不抛出异常；</li><li>在你的类或模板所在的命名空间提供一个非成员函数调用上述成员函数 <code>swap</code>；</li><li>如果你正在编写一个类而<strong>非</strong>类模板，特化 <code>std::swap</code>，并令其调用成员函数 <code>swap</code>，并且调用前使用 <code>using</code> 声明式。</li></ol></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>当 <code>std::swap</code> 对你的类型效率不高时，提供一个 <code>swap</code> 成员函数，并确定这个函数不抛出异常。</li><li>如果你提供一个成员函数 <code>swap</code>，也应提供一个非成员函数调用前者，对于类，也要特化 <code>std::swap</code>。</li><li>调用 <code>swap</code> 时应针对 <code>std::swap</code> 使用 <code>using </code> 声明式，然后调用 <code>swap</code> 并且不带任何<strong>命名空间资格修饰</strong>。</li><li>为“用户定义类型”进行 std <strong>template</strong> 全特化是好的，但不要尝试在 std 内加入对 std 而言全新的东西。</li></ol><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《Effective C++》条款 25：考虑写出一个不抛异常的 swap 函数</p><p><a href="https://blog.csdn.net/qq_35976351/article/details/82822285" target="_blank" rel="noopener">https://blog.csdn.net/qq_35976351/article/details/82822285</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;缺省情况下 &lt;code&gt;swap&lt;/code&gt; 动作由标准库提供的 &lt;code&gt;swap&lt;/code&gt; 算法实现，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T &amp;amp;a, T &amp;amp;b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		a = b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		b = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;只要 T 支持拷贝运算（拷贝构造函数和拷贝赋值运算符）就可使用，但是经历了三次复制，对于某些类型而言，这样的复制操作并无必要，那么应该如何做？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="swap" scheme="http://www.xingyuzhao.ltd/tags/swap/"/>
    
  </entry>
  
  <entry>
    <title>一些小tips</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/03/%E4%B8%80%E4%BA%9B%E5%B0%8Ftips/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/03/%E4%B8%80%E4%BA%9B%E5%B0%8Ftips/</id>
    <published>2021-03-03T07:06:14.000Z</published>
    <updated>2021-07-12T02:36:35.894Z</updated>
    
    <content type="html"><![CDATA[<p>有关做题时的一些小知识点，持续记录。</p><a id="more"></a><h5 id="位运算-i-amp-i-1"><a href="#位运算-i-amp-i-1" class="headerlink" title="位运算 $i&amp;(i-1)$"></a>位运算 $i&amp;(i-1)$</h5><p>作用：将 $i$ 的二进制表示中的最低位的 1 改为 0。</p><p>使用场景：计算二进制数中 1 的个数。</p><p>例题：<a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></p><h5 id="lowbit-x"><a href="#lowbit-x" class="headerlink" title="$lowbit(x)$"></a>$lowbit(x)$</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：$x$ 的二进制表示中最低位的 1 所对应的值。</p><p>例如，6 的二进制为 110，则 $lowbit(6)$ 为 $110&amp;010=010$，即 2。</p><p>使用场景：树状数组。</p><p>例题：<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></p><h5 id="位掩码"><a href="#位掩码" class="headerlink" title="位掩码"></a>位掩码</h5><h6 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h6><p>对于一个长度位 $n$ 的数组求其所有的子集，则一共有 $2^n$ 种可能，也就是 $1&lt;&lt;n$。使用一个长度为 $n$ 的二进制数表示数组中每一个数<strong>是否出现</strong>，出现为 1，否则为 0。</p><p>例如：数组 [1,2] 对应长度为 2 的二进制数，一共有四种可能：</p><ol><li>00 表示两个都不取，为 []；</li><li>01 表示只取第一个，为 [1]；</li><li>10 表示只取第二个，为 [2]；</li><li>11 表示全部都取，为 [1,2]。</li></ol><p>以上，就得到的数组的所有子集。</p><p>例题：<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></p><h6 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h6><p>详见：<a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/" target="_blank" rel="noopener">1178. 猜字谜</a></p><h5 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h5><p>作用：求取公因数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) swap(a, b);</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">365. 水壶问题</a></p><h5 id="快速幂运算"><a href="#快速幂运算" class="headerlink" title="快速幂运算"></a>快速幂运算</h5><p>作用：求 $x^n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line"><span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">ret *= x;</span><br><span class="line">x *= x;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? ret : <span class="number">1</span> / ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有关做题时的一些小知识点，持续记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="位运算" scheme="http://www.xingyuzhao.ltd/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="数学" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>条款03：尽可能使用const</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/03/01/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/03/01/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/</id>
    <published>2021-03-01T11:34:15.000Z</published>
    <updated>2021-04-01T15:31:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>const</code> 可以在  <code>class</code> 外部修饰 <code>global</code> 或 <code>namespace</code> 作用域中的常量，或修饰文件、函数、或<strong>区域作用块中被声明为 <code>static</code> 的对象</strong>；也可以修饰 <code>class</code> 内部的静态或非静态成员变量。对于指针，可以指出指针自身、指针所指物，或两者都（或都不）是 <code>const</code>。</p><a id="more"></a><h4 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = s; <span class="comment">// non_const pointer, non_const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = s; <span class="comment">// non_const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = s; <span class="comment">// const pointer, non_const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = s; <span class="comment">// const_pointer, const_data</span></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>const</code> 出现在 * 左侧，表示被指物为常量；如果出现在 * 右侧，表示指针自身为常量</strong>。</p></li><li><p>如果被指物为常量，则 <code>const char*</code> 或 <code>char const*</code> 都一样。</p></li></ul><h4 id="迭代器与const"><a href="#迭代器与const" class="headerlink" title="迭代器与const"></a>迭代器与const</h4><p>迭代器类似于 <code>T*</code> 指针：</p><ul><li>迭代器为 <code>const</code>：<code>T* const</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin(); <span class="comment">// T* const</span></span><br><span class="line">*iter = <span class="number">10</span>; <span class="comment">// 正确，所指变量可变</span></span><br><span class="line">iter++; <span class="comment">// 错误，迭代器不可变</span></span><br></pre></td></tr></table></figure><ul><li>迭代器所指对象为 <code>const</code>：<code>const T*</code> ，且需要使用 <code>const_iterator</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="comment">// auto cIter = vec.cbegin();</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.begin(); <span class="comment">// T* const</span></span><br><span class="line">*cIter = <span class="number">10</span>; <span class="comment">// 错误，所指变量为常量</span></span><br><span class="line">cIter++; <span class="comment">// 正确，迭代器可变</span></span><br></pre></td></tr></table></figure><h4 id="令函数返回一个常量值防止误操作而造成的意外"><a href="#令函数返回一个常量值防止误操作而造成的意外" class="headerlink" title="令函数返回一个常量值防止误操作而造成的意外"></a>令函数返回一个常量值防止误操作而造成的意外</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs);</span><br><span class="line"><span class="comment">/***************************/</span></span><br><span class="line">Rational a, b, c;</span><br><span class="line">(a * b) = c; <span class="comment">// 错误，防止无意义的赋值</span></span><br></pre></td></tr></table></figure><h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p><code>const</code> 用于成员函数，表示该成员函数可作用于 <code>const</code> 对象，其理由有二：</p><ol><li>使 <code>class</code> 接口容易理解，告诉哪个函数可以改变对象内容哪个不行；</li><li>使操作 <code>const</code> 对象成为可能。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TextBlock(<span class="built_in">string</span> &amp;s): text(s) &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)&#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/***************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function">TextBlock <span class="title">tb</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>]; <span class="comment">// OK，读一个non_const TextBlock</span></span><br><span class="line">    tb[<span class="number">0</span>] = <span class="string">'x'</span>; <span class="comment">// OK，写一个non_const TextBlock</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>]; <span class="comment">// OK，读一个const TextBlock</span></span><br><span class="line">    ctb[<span class="number">0</span>] = <span class="string">'x'</span>; <span class="comment">// Error，写一个const TextBlock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bitwise-constness"><a href="#bitwise-constness" class="headerlink" title="bitwise constness"></a>bitwise constness</h5><p>成员函数不能更改对象的任何成员变量（除了 <code>static</code>），编译器只需找到成员的赋值动作即可。</p><p>然而一个更改了”指针所指物“的成员函数虽然不能算是 <code>const</code>，但如果只有指针（而非其所指物）属于对象，那么称此函数为 <code>bitwise constness</code> 不会引发编译器异议。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CTextBlock(<span class="keyword">char</span> *s): pText(s) &#123;&#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span>&#123; <span class="comment">// bitwise const声明，但不恰当</span></span><br><span class="line">        <span class="keyword">return</span> pText[position];<span class="comment">// 并不更改pText，所以是bitwise const</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/***************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(s)</span></span>; <span class="comment">// 声明一个常量对象</span></span><br><span class="line">    <span class="keyword">char</span> *pc = &amp;cctb[<span class="number">0</span>]; <span class="comment">// 调用const operatorp[]取得一个指针，指向cctb数据</span></span><br><span class="line">    *pc = <span class="string">'J'</span>; <span class="comment">// cctb现在有了"Jello"的内容，这样是不允许的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="logical-constness"><a href="#logical-constness" class="headerlink" title="logical constness"></a>logical constness</h5><p>一个 <code>const</code> 成员函数可以修改它所处理的对象内的某些 <code>bits</code>，但只有在<strong>客户端侦测不出的情况下</strong>才得如此。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">size_t</span> textLength; <span class="comment">// 最近一次计算的文本区块长度</span></span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid; <span class="comment">// 目前的长度是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">        <span class="comment">// 错误！在const成员函数内不能赋值</span></span><br><span class="line">        textLength = <span class="built_in">strlen</span>(pText);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>logical constness</code>，编译器不允许这种做法，此时需要使用一个与 <code>const</code> 相关的摆动场：**<code>mutable</code>（可变的）**。<code>mutable</code> 释放掉 <code>non_static</code> 成员变量的 <code>bitwise constness</code> 约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="comment">// 这些成员变量可能总是会被更改，即使在const函数内</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> textLength; </span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">        <span class="comment">// 赋值正确</span></span><br><span class="line">        textLength = <span class="built_in">strlen</span>(pText);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h4><p>如果 <code>const</code> 和 <code>non_const</code> 成员函数有着等价的实现时，令 <code>non-const</code> 版本调用 <code>const</code> 版本可避免代码重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Zxy on 2021/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TextBlock(<span class="built_in">string</span> &amp;s): text(s) &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position)&#123;</span><br><span class="line">        <span class="comment">// 第一次为*this添加const，第二次从const operator[]的返回值移除const。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function">TextBlock <span class="title">tb</span><span class="params">(s)</span></span>;</span><br><span class="line">    tb[<span class="number">0</span>] = <span class="string">'H'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>]; <span class="comment">// 正确，对象为变量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">1</span>];</span><br><span class="line">    ctb[<span class="number">1</span>] = <span class="string">'E'</span>; <span class="comment">// 错误，对象为常量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>将某些东西声明为 <code>const</code> 可帮助编译器侦测出错误用法；</li><li>编译器强制实施 <code>bitwise constness</code>，但编程时应注重<strong>概念上的常量性</strong>；</li><li>如果 <code>const</code> 和 <code>non_const</code> 成员函数有着等价的实现时，令 <code>non-const</code> 版本调用 <code>const</code> 版本可避免代码重复。</li></ul><p>除此之外：</p><ul><li><code>const</code> 对象只能调用 <code>const</code> 成员函数；</li><li>非 <code>const</code> 对象既可以调用 <code>const</code> 成员函数，又可以调用非 <code>const</code> 成员函数。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《Effective C++》条款 03：尽可能使用 const</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 可以在  &lt;code&gt;class&lt;/code&gt; 外部修饰 &lt;code&gt;global&lt;/code&gt; 或 &lt;code&gt;namespace&lt;/code&gt; 作用域中的常量，或修饰文件、函数、或&lt;strong&gt;区域作用块中被声明为 &lt;code&gt;static&lt;/code&gt; 的对象&lt;/strong&gt;；也可以修饰 &lt;code&gt;class&lt;/code&gt; 内部的静态或非静态成员变量。对于指针，可以指出指针自身、指针所指物，或两者都（或都不）是 &lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Effective C++" scheme="http://www.xingyuzhao.ltd/categories/Effective-C/"/>
    
    
      <category term="const" scheme="http://www.xingyuzhao.ltd/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1178-猜字谜</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/26/LeetCode1178-%E7%8C%9C%E5%AD%97%E8%B0%9C/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/26/LeetCode1178-%E7%8C%9C%E5%AD%97%E8%B0%9C/</id>
    <published>2021-02-26T08:38:08.000Z</published>
    <updated>2021-02-26T09:21:51.577Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p><ul><li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li><li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。</li></ul><p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p><a id="more"></a><img src="/blog/2021/02/26/LeetCode1178-猜字谜/1178.png"><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>从题目我们可以得到两个信息（省略了在 <code>i</code> 处）：</p><ul><li><code>puzzle</code> 的第一个字母在 <code>word</code> 中；</li><li><code>puzzle</code> 中包括 <code>word</code> 中的任一字母。</li></ul><p>如果对于每个 <code>puzzle</code> 都去遍历每个 <code>word</code>，那么复杂度会很高，因为每个 <code>word</code> 都含有多个字母。<strong>除此之外，<code>puzzle</code> 的长度都为 7</strong>。</p><h6 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h6><p>如果我们用一个<strong>26位</strong>长的二进制数来表示对应字母是否存在（存在为 1，否则为 0），再用<strong>哈希表</strong>存储每种二进制数出现的次数，可以大大降低查询 <code>words</code> 的时间复杂度，这种方法称为<strong>状态压缩</strong>（换句话说，去重后的 <code>word</code> 如果具有相同特征，将对应相同的二进制数）。</p><h6 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h6><ol><li>统计 <code>words</code> 对应二进制数的出现次数（每个二进制数中 1 的个数必须小于等于 7，否则 <code>puzzle</code> 不可能将 <code>word</code> 完全覆盖）；</li><li>由于 <code>puzzle</code> 的长度为 7，且第一个字母必须出现在 <code>word</code> 中，所以只需要计算 $2^6$ 种二进制组合，再将 <code>puzzle[0]</code> 对应二进制数的位置为 1。如果哈希表中存在此二进制数，说明此二进制数是 <code>puzzle</code> 谜底。</li></ol><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据word建立哈希表，映射26个字母</span></span><br><span class="line">        <span class="comment">// 统计每种状态压缩的出现次数</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : words)&#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计二进制位中1的出现次数</span></span><br><span class="line">            <span class="keyword">if</span>(__builtin_popcount(mask) &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">                <span class="built_in">map</span>[mask]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// puzzle的第一个字母在word中</span></span><br><span class="line">        <span class="comment">// puzzle中包括word中的任一字母</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;puzzle : puzzles)&#123;</span><br><span class="line">            <span class="comment">// 一共有2^6种可能</span></span><br><span class="line">            <span class="comment">// puzzle的第一个字母对应的位必为1</span></span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> choose = <span class="number">0</span>; choose &lt; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>); ++choose)&#123;</span><br><span class="line">                <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// puzzle的每个字母</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">                    <span class="comment">// 每个位代表一个字母是否存在</span></span><br><span class="line">                    <span class="comment">// choose代表二进制的一种组合，使用与操作找到此种组合下存在的每一位</span></span><br><span class="line">                    <span class="keyword">if</span>(choose &amp; (<span class="number">1</span> &lt;&lt; i))&#123;</span><br><span class="line">                        mask |= (<span class="number">1</span> &lt;&lt; (puzzle[i + <span class="number">1</span>] - <span class="string">'a'</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// puzzle的第一个字母必须存在于word中</span></span><br><span class="line">                    mask |= (<span class="number">1</span> &lt;&lt; (puzzle[<span class="number">0</span>] - <span class="string">'a'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.count(mask))&#123;</span><br><span class="line">                    total += <span class="built_in">map</span>[mask];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/cai-zi-mi-by-leetcode-solution-345u/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/cai-zi-mi-by-leetcode-solution-345u/</a></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><code>__builtin_popcount(var)</code>：统计二进制数中 1 的个数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。&lt;/p&gt;
&lt;p&gt;字谜的迷面 &lt;code&gt;puzzle&lt;/code&gt; 按字符串形式给出，如果一个单词 &lt;code&gt;word&lt;/code&gt; 符合下面两个条件，那么它就可以算作谜底：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单词 &lt;code&gt;word&lt;/code&gt; 中包含谜面 &lt;code&gt;puzzle&lt;/code&gt; 的第一个字母。&lt;/li&gt;
&lt;li&gt;单词 &lt;code&gt;word&lt;/code&gt; 中的每一个字母都可以在谜面 &lt;code&gt;puzzle&lt;/code&gt; 中找到。&lt;br&gt;例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回一个答案数组 &lt;code&gt;answer&lt;/code&gt;，数组中的每个元素 &lt;code&gt;answer[i]&lt;/code&gt; 是在给出的单词列表 &lt;code&gt;words&lt;/code&gt; 中可以作为字谜迷面 &lt;code&gt;puzzles[i]&lt;/code&gt; 所对应的谜底的单词数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="位运算" scheme="http://www.xingyuzhao.ltd/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="状态压缩" scheme="http://www.xingyuzhao.ltd/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="哈希表" scheme="http://www.xingyuzhao.ltd/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++模板与泛型编程（三）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/24/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/24/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-02-24T04:11:34.000Z</published>
    <updated>2021-03-09T16:04:46.906Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>重载与模板</li><li>可变参数模板</li><li>模板特例化</li></ol><a id="more"></a><h4 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h4><h5 id="编写重载模板"><a href="#编写重载模板" class="headerlink" title="编写重载模板"></a>编写重载模板</h5><p>在调试中可能用到的一组函数，每个函数都返回一个给定对象的 <code>string</code> 表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line"><span class="built_in">ostringstream</span> ret;</span><br><span class="line">ret &lt;&lt; t;</span><br><span class="line"><span class="keyword">return</span> ret.str(); <span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个打印指针的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">// 此函数不能用于char*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T *p)</span></span>&#123;</span><br><span class="line"><span class="built_in">ostringstream</span> ret;</span><br><span class="line">ret &lt;&lt; <span class="string">"pointer: "</span> &lt;&lt; p; <span class="comment">// 打印指针本身的值</span></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">ret &lt;&lt; <span class="string">" "</span> &lt;&lt; debug_rep(*p); <span class="comment">// 打印p指向的值</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret &lt;&lt; <span class="string">" null pointer"</span>; <span class="comment">// 或指出p为空</span></span><br><span class="line"><span class="keyword">return</span> ret.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此函数不能打印字符指针</strong>。</p><ol><li>只能匹配第一个版本：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hi"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>两个版本都可匹配，而第二个精确匹配，选择第二个：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(&amp;s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="多个可行模板"><a href="#多个可行模板" class="headerlink" title="多个可行模板"></a>多个可行模板</h5><p>当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。</p><h5 id="非模板和模板重载"><a href="#非模板和模板重载" class="headerlink" title="非模板和模板重载"></a>非模板和模板重载</h5><p>对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</p><h5 id="重载模板与类型转换"><a href="#重载模板与类型转换" class="headerlink" title="重载模板与类型转换"></a>重载模板与类型转换</h5><p>C 风格字符串指针和字符串常量，考虑调用 <code>cout &lt;&lt; debug_rep(&quot;hi world!&quot;) &lt;&lt; endl</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debug_rep(<span class="keyword">const</span> T&amp;); <span class="comment">// T被绑定到char[10]</span></span><br><span class="line">debug_rep(T*); <span class="comment">// T被绑定到const char</span></span><br><span class="line">debug_rep(<span class="keyword">const</span> <span class="built_in">string</span>&amp;); <span class="comment">// 要求从const char*到string的类型转换</span></span><br></pre></td></tr></table></figure><h5 id="缺少声明可能导致程序行为异常"><a href="#缺少声明可能导致程序行为异常" class="headerlink" title="缺少声明可能导致程序行为异常"></a>缺少声明可能导致程序行为异常</h5><p>在定义任何函数之前，<strong>需要声明所有重载的函数版本</strong>，否则编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</p><h4 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h4><p>可变参数模板：接受<strong>可变数目</strong>参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>。</p><p>参数包有两种：</p><ol><li>模板参数包，表示零个或多个模板参数；</li><li>函数参数包，表示零个或多个函数参数。</li></ol><p>在一个模板参数列表中，<code>class...</code> 或 <code>typename...</code> 指出接下来的参数表示零个或多个类型的列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure><p>编译器从函数的实参推断模板参数类型，对于可变参数模板，编译器同时推断包中参数的数目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; <span class="built_in">string</span> s = <span class="string">"how now brown cow"</span>;</span><br><span class="line"><span class="comment">// void foo(const int&amp;, const string&amp;, const int&amp;, const double&amp;);</span></span><br><span class="line">foo(i, s, <span class="number">42</span>, d); <span class="comment">// 包中有三个参数</span></span><br><span class="line"><span class="comment">// void foo(const string&amp;, const int&amp;, const int&amp;, const char[3]&amp;);</span></span><br><span class="line">foo(s, <span class="number">42</span>, <span class="string">"hi"</span>); <span class="comment">// 包中有两个参数</span></span><br><span class="line"><span class="comment">// void foo(const double&amp;, const string&amp;);</span></span><br><span class="line">foo(d, s); <span class="comment">// 包中有一个参数</span></span><br><span class="line"><span class="comment">// void foo(const char[3]&amp;);</span></span><br><span class="line">foo(<span class="string">"hi"</span>); <span class="comment">// 空包</span></span><br></pre></td></tr></table></figure><p><strong>sizeof…运算符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 类型参数的数目</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h5><p>可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">// 此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> os &lt;&lt; t; <span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line">os &lt;&lt; t &lt;&lt; <span class="string">", "</span>; <span class="comment">// 打印第一个实参</span></span><br><span class="line"><span class="keyword">return</span> print(os, rest...); <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个版本的 <code>print</code> 负责终止递归并打印最后一个实参，第二个版本的 <code>print</code> 是可变参数版本，它打印绑定到 <code>t</code> 的实参，并调用自身来打印函数参数包中的剩余值。</p><p>对于 <code>print(cout, i, s, 42)</code>，递归会执行如下：</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/调用.png"><p>对于最后一个调用，两个函数提供同样好的匹配。但是<strong>非可变参数模板</strong>比<strong>可变参数模板</strong>更特例化，因此编译器选择非可变参数模板。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/调用warning.png"><h5 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h5><p>扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号 <code>...</code> 来触发扩展操作。（**此处不是很理解，包扩展不就是可变参数模板吗?**）</p><h6 id="理解包扩展"><a href="#理解包扩展" class="headerlink" title="理解包扩展"></a>理解包扩展</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在print调用中对每个实参调用debug_req</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span>&#123;</span><br><span class="line"><span class="comment">// print(os, debug_req(a1), debug_req(a2), ..., debug_req(an))</span></span><br><span class="line">print(os, debug_req(rest)...); <span class="comment">// print(os, debug_req(rest...))错误，此调用无匹配函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/24/C-模板与泛型编程（三）/包扩展.png"><h5 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h5><p>新标准下，我们可以组合使用可变参数模板与 <code>forward</code> 机制来编写函数，实现将其实参不变的传递给其他函数。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/建议_转发和可变参数模板.png"><h4 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h4><h5 id="定义函数模板特例化"><a href="#定义函数模板特例化" class="headerlink" title="定义函数模板特例化"></a>定义函数模板特例化</h5><p>定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。先前声明版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempalte &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span></span><br></pre></td></tr></table></figure><p>特例化版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// &lt;&gt;表示我们正在实例化一个模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="函数重载与模板实例化"><a href="#函数重载与模板实例化" class="headerlink" title="函数重载与模板实例化"></a>函数重载与模板实例化</h5><p><strong>一个特例化版本的本质上是一个实例，而非函数名的一个重载版本</strong>。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/函数重载与模板实例化.png"><img src="/blog/2021/02/24/C-模板与泛型编程（三）/普通作用域规则应用于特例化.png"><h5 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h5><p>P626.</p><h5 id="类模板部分特例化"><a href="#类模板部分特例化" class="headerlink" title="类模板部分特例化"></a>类模板部分特例化</h5><p>与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。</p><p>一个类模板的部分特例化（partial specialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p><img src="/blog/2021/02/24/C-模板与泛型编程（三）/类模板部分特例化.png"><p>标准库 <code>remove_reference</code> 模板是通过一系列的特例化版本来完成其功能的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 最原始、最通用版本</span><br><span class="line">template &lt;class T&gt; struct remove_reference&#123;</span><br><span class="line">typedef T type;</span><br><span class="line">&#125;;</span><br><span class="line">// 部分特例化版本， 将用于左值引用和右值引用</span><br><span class="line">template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt;&#123;</span><br><span class="line">typedef T type;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt;&#123;</span><br><span class="line">typedef T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// decltype(42)为int，使用原始模板</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;</span><br><span class="line"><span class="comment">// decltype(i)为int&amp;，使用特例化版本一</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(i)&gt;::type b;</span><br><span class="line"><span class="comment">// decltype(std::move(i))为int&amp;&amp;，使用特例化版本二</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="built_in">std</span>::move(i))&gt;::type c;</span><br></pre></td></tr></table></figure><p>以上三个变量都是 <code>int</code> 类型。</p><h5 id="特例化成员而不是类"><a href="#特例化成员而不是类" class="headerlink" title="特例化成员而不是类"></a>特例化成员而不是类</h5><p>我们可以只特例化成员函数而不是特例化整个模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">Foo(<span class="keyword">const</span> T &amp;t = T()): mem(t)&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span>&#123; <span class="comment">/* ... */</span>&#125;</span><br><span class="line">T mem;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// 特例化</span></span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()&#123;</span><br><span class="line"><span class="comment">// 进行应用于int的特例化处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 <code>Foo&lt;int&gt;</code> 类的一个成员，其他成员由 <code>Foo</code> 模板提供：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs; <span class="comment">// Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.Bar(); <span class="comment">// Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi; <span class="comment">// Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.Bar(); <span class="comment">// 使用我们特例化版本的Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;重载与模板&lt;/li&gt;
&lt;li&gt;可变参数模板&lt;/li&gt;
&lt;li&gt;模板特例化&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++模板与泛型编程（二）——模板实参推断</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/23/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/23/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-23T15:34:45.000Z</published>
    <updated>2021-02-24T09:18:43.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>类型转换与模板类型参数</li><li>函数模板显式实参</li><li>尾置返回类型与类型转换</li><li>函数指针和实参推断</li><li>模板实参推断和引用</li><li>理解 <code>std::move</code></li><li>转发</li></ol><a id="more"></a><p>从函数实参来确定模板实参的过程称为<strong>模板实参推断</strong>。</p><h4 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h4><p>编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。顶层 <code>const</code>无论在形参还是实参中都会被忽略。</p><ul><li><code>const</code> 转换：可以将一个非 <code>const</code> 对象的引用（或指针）传递给一个 <code>const</code> 的引用（或指针）形参。</li><li>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li></ul><img src="/blog/2021/02/23/C-模板与泛型编程（二）/实参传递给模板类型的函数形参note.png"><h5 id="使用相同模板参数类型的函数形参"><a href="#使用相同模板参数类型的函数形参" class="headerlink" title="使用相同模板参数类型的函数形参"></a>使用相同模板参数类型的函数形参</h5><p>一个模板类型参数可以作为多个函数形参的类型，但是传递给形参的实参类型必须相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>); <span class="comment">// 错误，不能实例化compare(long, int)，类型不匹配</span></span><br></pre></td></tr></table></figure><p>如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span><span class="params">(<span class="keyword">const</span> A&amp; v1, <span class="keyword">const</span> B&amp; v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="正常类型转换应用于普通函数实参"><a href="#正常类型转换应用于普通函数实参" class="headerlink" title="正常类型转换应用于普通函数实参"></a>正常类型转换应用于普通函数实参</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>os</code> 类型固定，因此调用 <code>print</code> 时，传递给它的实参会正常进行类型转换。</p><img src="/blog/2021/02/23/C-模板与泛型编程（二）/正常类型转换应用于普通函数实参.png"><h4 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h4><h5 id="指定显式模板实参"><a href="#指定显式模板实参" class="headerlink" title="指定显式模板实参"></a>指定显式模板实参</h5><p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure><p>每次调用前，调用者必须为 <code>T1</code> 提供一个<strong>显式模板实参</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng); <span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure><p><strong>显式模板实参按照由左至右的顺序与对应的模板参数匹配</strong>。</p><h5 id="正常类型转换应用于显式指定的实参"><a href="#正常类型转换应用于显式指定的实参" class="headerlink" title="正常类型转换应用于显式指定的实参"></a>正常类型转换应用于显式指定的实参</h5><p>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>); <span class="comment">// 错误：模板类型不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">// 正确：实例化compare(long, long)，接受两个const long&amp;;</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">// 正确：实例化compare(int, int)，lng被转换为int;</span></span><br></pre></td></tr></table></figure><h4 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回类型允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg) // 迭代器解引用返回元素引用</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> *beg; <span class="comment">// 返回序列中的一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进行类型转换的标准库模板类"><a href="#进行类型转换的标准库模板类" class="headerlink" title="进行类型转换的标准库模板类"></a>进行类型转换的标准库模板类</h5><p>如果希望编写一个类似 <code>fcn</code> 的函数，但返回一个元素的值而非引用。可以使用标准库的<strong>类型转换</strong>模板，定义在头文件 <code>type_traits</code> 中。模板如下表：</p><img src="/blog/2021/02/23/C-模板与泛型编程（二）/标准类型转换模板.png"><p>上述模板中每个都拥有一个名为 <code>type</code> 的 <code>public</code> 成员，表示一个类型。</p><ul><li>如果不可能（不必要）转换模板参数，则 <code>type</code> 成员就是模板参数本身。</li></ul><p>组合使用 <code>remove_reference</code> ，尾置返回类型及 <code>decltype</code>，我们可以在函数中返回元素值的拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用typename表示type是一个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;typnemae It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)::type</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h4><p>当我们使用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure><p>如果不能从函数指针类型确定函数模板，则产生错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func的重载版本，每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line">func(compare); <span class="comment">// 错误，使用compare的哪个实例？</span></span><br></pre></td></tr></table></figure><p>可以使用显式模板实参来消除 <code>func</code> 调用的歧义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;); <span class="comment">// 传递compare(const int&amp;, const int&amp;)</span></span><br></pre></td></tr></table></figure><h4 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h4><h5 id="从左值引用函数参数推断类型"><a href="#从左值引用函数参数推断类型" class="headerlink" title="从左值引用函数参数推断类型"></a>从左值引用函数参数推断类型</h5><p>当一个函数参数是模板类型参数的一个普通(左值)引用时（即，形如T&amp;）。绑定规则告诉我们：</p><ul><li>只能传递给它一个左值（如，一个变量或一个返回引用类型的表达式）。</li></ul><p>实参可以是 <code>const</code> 类型，也可以不是。如果实参是 <code>const</code> 的，则 <code>T</code> 将被推断为 <code>const</code> 类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>; <span class="comment">// 实参必须是一个左值</span></span><br><span class="line">f1(i); <span class="comment">// i是一个int，模板参数类型T是int</span></span><br><span class="line">f1(ci); <span class="comment">// ci是一个const int，模板参数T是const int</span></span><br><span class="line">f1(<span class="number">5</span>); <span class="comment">// 错误：5是右值</span></span><br></pre></td></tr></table></figure><p>如果一个函数参数的类型是 <code>const T&amp;</code>，正常的绑定规则告诉我们：</p><ul><li>可以传递给它任何类型的实参一个对象（ <code>const</code> 或非 <code>const</code> ）、一个临时对象或是一个字面常量值。</li></ul><p>当函数参数本身是 <code>const</code> 时，其已经是<strong>函数参数类型</strong>的一部分，因此，<strong>它不会也是模板参数类型的一部分</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">// f2中的参数是const &amp;，实参中的const是无关的</span></span><br><span class="line"><span class="comment">// 在每个调用中，f2的函数实参都被推断为const int&amp;</span></span><br><span class="line">f2(i); <span class="comment">// i是一个int，模板参数类型T是int</span></span><br><span class="line">f2(ci); <span class="comment">// ci是一个const int，但模板参数T是int</span></span><br><span class="line">f2(<span class="number">5</span>); <span class="comment">// 一个const &amp;参数可以绑定到一个右值，T是int</span></span><br></pre></td></tr></table></figure><h5 id="从右值引用函数参数推断类型"><a href="#从右值引用函数参数推断类型" class="headerlink" title="从右值引用函数参数推断类型"></a>从右值引用函数参数推断类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>); <span class="comment">// 实参是一个int类型的右值，模板参数T是int</span></span><br></pre></td></tr></table></figure><h5 id="引用折叠和右值引用参数"><a href="#引用折叠和右值引用参数" class="headerlink" title="引用折叠和右值引用参数"></a>引用折叠和右值引用参数</h5><ul><li>X&amp; &amp;、X&amp; &amp;&amp; 和 X&amp;&amp; &amp; 都折叠成类型 X&amp;</li><li>类型 X&amp;&amp; &amp;&amp; 折叠成 X&amp;&amp;</li></ul><img src="/blog/2021/02/23/C-模板与泛型编程（二）/引用折叠.png"><p>这两个规则导致了两个重要结果：</p><ol><li>函数参数指向模板类型参数的右值引用，则它可以被绑定到一个左值；</li><li>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个普通左值引用参数。</li></ol><img src="/blog/2021/02/23/C-模板与泛型编程（二）/右值引用参数.png" style="zoom:80%;"><h5 id="编写接受右值引用参数的函数模板"><a href="#编写接受右值引用参数的函数模板" class="headerlink" title="编写接受右值引用参数的函数模板"></a>编写接受右值引用参数的函数模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>; <span class="comment">// 绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// 左值和const右值</span></span><br></pre></td></tr></table></figure><h4 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h4><h5 id="std-move是如何定义的"><a href="#std-move是如何定义的" class="headerlink" title="std::move是如何定义的"></a>std::move是如何定义的</h5><p>标准库定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引用折叠，我们既可以传递给 <code>move</code> 一个左值，也可以传递给它一个右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("hi!"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"bye!"</span>)); <span class="comment">// 正确，从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1); <span class="comment">// 正确，但在赋值之后，s1的值是不确定的</span></span><br></pre></td></tr></table></figure><h5 id="std-move是如何工作的"><a href="#std-move是如何工作的" class="headerlink" title="std::move是如何工作的"></a>std::move是如何工作的</h5><p>在 <code>std::move(string(&quot;bye!&quot;))</code> 中：</p><ul><li>推断出的 <code>T</code> 的类型为 <code>string</code>。</li><li>因此，<code>remove reference</code> 用 <code>string</code> 进行实例化。</li><li><code>remove_reference&lt;string&gt; </code>的 <code>type</code> 成员是 <code>string</code>。</li><li><code>move</code> 的返回类型是 <code>string&amp;&amp;</code>。</li><li><code>move</code> 的函数参数 <code>t</code> 的类型为 <code>string&amp;&amp;</code>。</li></ul><p>这个调用实例化 <code>move&lt;string&gt;</code>，即函数：<code>string&amp;&amp; move(string &amp;&amp;t)</code>。无需类型转换。</p><p>第二个赋值，传递给 <code>move</code> 的实参是一个左值：</p><ul><li>推断出的 <code>T</code> 的类型为 <code>string&amp;</code>（ <code>string</code> 的引用，而非普通 <code>string</code>)。</li><li>因此，<code>remove_reference</code> 用 <code>string&amp;</code> 进行实例化。</li><li><code>remove_reference&lt;string&amp;&gt;</code> 的 <code>type</code> 成员是 <code>string</code>。</li><li><code>move</code>的返回类型仍是 <code>string&amp;</code>。</li><li><code>move</code> 的函数参数 <code>t</code> 实例化为 <code>string&amp; &amp;&amp;</code>，会折叠为 <code>string&amp;</code>。</li></ul><p>这个调用实例化 <code>move&lt;string&amp;&gt;</code>，即函数：<code>string&amp;&amp; move(string &amp;t)</code>。</p><p><strong>将一个右值引用绑定到一个左值</strong>。这个实例的函数体返回 <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>，在此情况下，<code>cast</code> 将 <code>t</code> 的类型 <code>string&amp;</code> 转换为 <code>string&amp;&amp;</code>。</p><h5 id="从一个左值static-cast到一个右值引用时允许的"><a href="#从一个左值static-cast到一个右值引用时允许的" class="headerlink" title="从一个左值static_cast到一个右值引用时允许的"></a>从一个左值static_cast到一个右值引用时允许的</h5><p> 可以用 <code>static_cast</code> 显式的将一个左值转换为一个右值引用。</p><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span>&#123;</span><br><span class="line">f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">" "</span> &lt;&lt; ++v2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>f</code> 改变了绑定到 <code>v2</code> 的实参的值，但是通过 <code>flip1</code> 调用 <code>f</code>，<code>f</code> 所作的改变就不会影响实参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">42</span>, i); <span class="comment">// f改变了实参i</span></span><br><span class="line">flip1(f, j, <span class="number">42</span>); <span class="comment">// 通过flip1调用f不会改变j</span></span><br></pre></td></tr></table></figure><h5 id="定义能保持类型信息的函数参数"><a href="#定义能保持类型信息的函数参数" class="headerlink" title="定义能保持类型信息的函数参数"></a>定义能保持类型信息的函数参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/23/C-模板与泛型编程（二）/转发.png"><p>当 <code>flip2</code> 调用 <code>f</code> 时，<code>f</code> 中的引用参数 <code>v2</code> 被绑定到 <code>t1</code>，也就是绑定到 <code>j</code>，当 <code>f</code> 递增 <code>v2</code> 时，它同时改变了 <code>j</code> 的值。</p><p>上述 <code>flip2</code> 不能用于接受右值引用参数的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 <code>flip2</code> 调用 <code>g</code>，则参数 <code>t2</code> 将被传递给 <code>g</code> 的右值引用参数。即使我们传递一个右值给 <code>flip2</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flip2(g, i, <span class="number">42</span>); <span class="comment">// 函数参数为左值表达式，不能从一个左值实例化int&amp;&amp;</span></span><br></pre></td></tr></table></figure><h5 id="在调用中使用std-forward保持类型信息"><a href="#在调用中使用std-forward保持类型信息" class="headerlink" title="在调用中使用std::forward保持类型信息"></a>在调用中使用std::forward保持类型信息</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在头文件utility中，forward必须通过显式模板来调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; intermediary(Type &amp;&amp;arg)&#123;</span><br><span class="line">finalFcn(<span class="built_in">std</span>::forward&lt;Type&gt;(arg));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/23/C-模板与泛型编程（二）/forward.png"><p>重写翻转函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span>&#123;</span><br><span class="line">f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用 <code>flip(g, i, 42)</code>，<code>i</code> 将以 <code>int&amp;</code> 类型传递给 <code>g</code>，<code>42</code> 将以 <code>int&amp;&amp;</code> 类型传递给 <code>g</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;类型转换与模板类型参数&lt;/li&gt;
&lt;li&gt;函数模板显式实参&lt;/li&gt;
&lt;li&gt;尾置返回类型与类型转换&lt;/li&gt;
&lt;li&gt;函数指针和实参推断&lt;/li&gt;
&lt;li&gt;模板实参推断和引用&lt;/li&gt;
&lt;li&gt;理解 &lt;code&gt;std::move&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转发&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="泛型" scheme="http://www.xingyuzhao.ltd/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1052-爱生气的书店老板</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/23/LeetCode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/23/LeetCode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</id>
    <published>2021-02-23T07:12:44.000Z</published>
    <updated>2021-02-25T14:24:24.640Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><a id="more"></a><img src="/blog/2021/02/23/LeetCode1052-爱生气的书店老板/1052.png"><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>先求得原始条件下可获得的满意数量之和 <code>sum</code>；</li><li>维护一个长度为 <code>X</code> 的窗口，从 <code>customers</code> 起始位置开始滑动。先得到当前窗口原始条件下的满意总和，使用 <code>sum</code> 减去此和，再加上当前窗口顾客全部满意数的和；</li><li>更新最大满意数量 <code>ans = max(ans, sum)</code>。</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum_copy = sum;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = left + X;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; customers.size() + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> subSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grumpy[j] == <span class="number">0</span>)</span><br><span class="line">                    subSum += customers[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; subSum &lt;&lt; " ";</span></span><br><span class="line">            sum -= subSum;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">            sum += accumulate(customers.begin() + left, customers.begin() + right, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">            ans = max(sum, ans);</span><br><span class="line">            sum = sum_copy;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度很高，为 $O((2X)^n)$。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>在求得原始条件下可获得的满意数量之和 <code>sum</code>，同时将不生气时顾客的满意值置为 0 后，此时题目转换为：在修改后的 <code>customers</code> 数组中，长度为 <code>X</code> 的子数组的最大的和为多少？找的这个最大值再加上 <code>sum</code> 即可。时间复杂度为 $O(n)$。</p><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(X == customers.size()) <span class="keyword">return</span> accumulate(customers.begin(), customers.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += customers[i];</span><br><span class="line">                customers[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> subSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; ++i)</span><br><span class="line">            subSum += customers[i];</span><br><span class="line">        <span class="keyword">int</span> maxVal = subSum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = X; i &lt; customers.size(); ++i)&#123;</span><br><span class="line">            subSum -= customers[i - X];</span><br><span class="line">            subSum += customers[i];</span><br><span class="line">            maxVal = max(maxVal, subSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum + maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>评论区：<a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/grumpy-bookstore-owner/comments/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;今天，书店老板有一家店打算试营业 &lt;code&gt;customers.length&lt;/code&gt; 分钟。每分钟都有一些顾客（&lt;code&gt;customers[i]&lt;/code&gt;）会进入书店，所有这些顾客都会在那一分钟结束后离开。&lt;/p&gt;
&lt;p&gt;在某些时候，书店老板会生气。 如果书店老板在第 &lt;code&gt;i&lt;/code&gt; 分钟生气，那么 &lt;code&gt;grumpy[i] = 1&lt;/code&gt;，否则 &lt;code&gt;grumpy[i] = 0&lt;/code&gt;。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。&lt;/p&gt;
&lt;p&gt;书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 &lt;code&gt;X&lt;/code&gt; 分钟不生气，但却只能使用一次。&lt;/p&gt;
&lt;p&gt;请你返回这一天营业下来，最多有多少客户能够感到满意的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://www.xingyuzhao.ltd/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>C++模板与泛型编程（一）——定义模板</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/22/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/22/C-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-22T09:01:08.000Z</published>
    <updated>2021-02-24T04:10:38.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>函数模板</li><li>类模板</li><li>模板参数</li><li>成员模板</li><li>控制实例化</li><li>效率与灵活性</li></ol><a id="more"></a><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模板定义中，模板参数列表不能为空。</p><h5 id="实例化函数模板"><a href="#实例化函数模板" class="headerlink" title="实例化函数模板"></a>实例化函数模板</h5><p>编译器用推断处的模板参数来进行<strong>实例化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化出int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// T为int</span></span><br></pre></td></tr></table></figure><h5 id="模板类型参数"><a href="#模板类型参数" class="headerlink" title="模板类型参数"></a>模板类型参数</h5><p>类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</p><p>类型参数前必须使用关键字 <code>class</code> 或 <code>typename</code>，两个关键字含义相同，可以互相使用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, class U&gt; calc(const T&amp;, const U&amp;);</span><br></pre></td></tr></table></figure><h5 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h5><p>一个非类型参数表示一个值而非一个类型。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个模板参数表示第一个数组的长度，第二个模板参数表示第二个数组的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用此函数 <code>compare(&quot;hi&quot;, &quot;mom&quot;)</code> 时，编译器使用字面常量的大小来代替 N 和 M，从而实例化模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[<span class="number">3</span>], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure><p><strong>非类型模板参数的模板实参必须是常量表达式</strong>。</p><h5 id="inline和constexpr的函数模板"><a href="#inline和constexpr的函数模板" class="headerlink" title="inline和constexpr的函数模板"></a>inline和constexpr的函数模板</h5><p>注意位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h5><p>模板的头文件通常既包括声明也包括定义。</p><ul><li>函数模板和类模板成员函数的定义通常放在头文件中。</li></ul><img src="/blog/2021/02/22/C-模板与泛型编程（一）/模板和头文件.png"><h5 id="大多数编译错误在实例化期间报告"><a href="#大多数编译错误在实例化期间报告" class="headerlink" title="大多数编译错误在实例化期间报告"></a>大多数编译错误在实例化期间报告</h5><img src="/blog/2021/02/22/C-模板与泛型编程（一）/调用者责任.png"><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><h5 id="定义类模板"><a href="#定义类模板" class="headerlink" title="定义类模板"></a>定义类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Blob之前只针对string</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="实例化类模板"><a href="#实例化类模板" class="headerlink" title="实例化类模板"></a>实例化类模板</h5><p>当使用一个类模板时，必须提供额外信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia; <span class="comment">// 空Blob&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>对我们指定的每一种元素类型，编译器都生成一个不同的类。</p><img src="/blog/2021/02/22/C-模板与泛型编程（一）/类模板的实例.png"><h5 id="在模板作用域中引用模板类型"><a href="#在模板作用域中引用模板类型" class="headerlink" title="在模板作用域中引用模板类型"></a>在模板作用域中引用模板类型</h5><p>通常将模板自己的参数当作被使用模板的参数。</p><h5 id="类模板的成员函数"><a href="#类模板的成员函数" class="headerlink" title="类模板的成员函数"></a>类模板的成员函数</h5><p>定义在类模板之外的成员函数必须以关键字 <code>template</code> 开始，后接类模板参数列表。</p><h5 id="类模板成员函数的实例化"><a href="#类模板成员函数的实例化" class="headerlink" title="类模板成员函数的实例化"></a>类模板成员函数的实例化</h5><p>成员函数只有在被用到时才进行实例化。</p><img src="/blog/2021/02/22/C-模板与泛型编程（一）/类模板成员函数实例.png"><h5 id="在类代码内简化模板类名的使用"><a href="#在类代码内简化模板类名的使用" class="headerlink" title="在类代码内简化模板类名的使用"></a>在类代码内简化模板类名的使用</h5><p>在类模板自己的作用域中，可以直接使用模板名而不提供实参。</p><h5 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h5><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。</p><h5 id="令模板自己的类型参数成为友元"><a href="#令模板自己的类型参数成为友元" class="headerlink" title="令模板自己的类型参数成为友元"></a>令模板自己的类型参数成为友元</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> Type; <span class="comment">// 将访问权限授予用来实例化Bar的类型</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如，对于某个类型名 <code>Foo</code>，<code>Foo</code> 将成为 <code>Bar&lt;Foo&gt;</code> 的友元。</p><h5 id="模板类型别名"><a href="#模板类型别名" class="headerlink" title="模板类型别名"></a>模板类型别名</h5><p>实例化的模板版本可以使用类型别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br></pre></td></tr></table></figure><p>新标准下，可以对类模板定义一个类型别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors; <span class="comment">// authors是一个pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure><h5 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个 <code>Foo</code> 实例都有自己的 <code>static</code> 成员实例，所有的 <code>Foo&lt;X&gt;</code> 类型的对象共享相同的 <code>ctr</code> 对象和 <code>count</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有三个对象共享相同的Foo&lt;int&gt;::ctr和Foo&lt;int&gt;::count成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2, fi3;</span><br></pre></td></tr></table></figure><p><strong>一个 static 成员函数只有在使用时才会实例化</strong>。</p><h4 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h4><h5 id="模板参数与作用域"><a href="#模板参数与作用域" class="headerlink" title="模板参数与作用域"></a>模板参数与作用域</h5><p>模板参数遵循普通的作用域规则。</p><h5 id="模板声明"><a href="#模板声明" class="headerlink" title="模板声明"></a>模板声明</h5><p>声明必须包括模板参数。且声明中的模板参数名字不必与定义中相同。</p><h5 id="使用类的类型成员"><a href="#使用类的类型成员" class="headerlink" title="使用类的类型成员"></a>使用类的类型成员</h5><p>假设 T 是一个模板参数类型，编译器遇到 <code>T::mem</code> 时不知道 <code>mem</code> 是一个类型成员还是一个 <code>static</code> 数据成员，直至实例化时才知道。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个p变量 or 一个名为size_type的static数据成员与变量p相乘</span></span><br><span class="line"><span class="comment">// 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型</span></span><br><span class="line">T::size_type * p;</span><br></pre></td></tr></table></figure><p>如果希望使用一个模板类型参数的类型成员，必须显示的告诉编译器该名字是一个类型，使用关键字 <code>typename</code> 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp;c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!c.empty())</span><br><span class="line"><span class="keyword">return</span> c.back();</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>top</code> 函数期待一个容器类型的实参，使用 <code>typename</code> 指明其返回类型并在 <code>c</code> 空时生成一个值初始化的元素返回给调用者。</p><img src="/blog/2021/02/22/C-模板与泛型编程（一）/名字表示类型.png"><h5 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="默认模板实参"></a>默认模板实参</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare有一个默认模板实参less&lt;T&gt;和一个默认函数实参F()</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = F())&#123;</span><br><span class="line"><span class="keyword">if</span>(f(v1, v2)) <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(f(v2,v1))) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>F</code> 为可调用对象的类型，新的函数参数 <code>f</code> 绑定到一个可调用对象上。</p><h5 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt; <span class="title">class</span> <span class="title">Numbers</span>&#123;</span> <span class="comment">// T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Numbers(T v = <span class="number">0</span>): val(v);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure><h4 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h4><h5 id="普通类的成员模板"><a href="#普通类的成员模板" class="headerlink" title="普通类的成员模板"></a>普通类的成员模板</h5><p>成员模板以模板参数列表开始。</p><h5 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h5><p>同时提供类模板和成员模板的参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。</p><h5 id="实例化与成员模板"><a href="#实例化与成员模板" class="headerlink" title="实例化与成员模板"></a>实例化与成员模板</h5><p>实例化一个类模板的成员模板，必须同时提供类和函数模板的实参。</p><h4 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h4><p>相同的实例可能出现在多个对象文件中，造成额外的开销。新标准中通过<strong>显示实例化</strong>来避免这种开销：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure><p><code>declaration</code> 是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span> <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure><p>当编译器遇到 <code>extern</code> 模板声明时，它不会再本文件中生成实例化代码。将一个实例化声明为 <code>extern</code> 就表示承诺在程序的其他位置有该实例化的一个非 <code>extern</code> 声明。对于一个给定的实例化版本，可能有多个 <code>extern</code> 声明，但必须只有一个定义。</p><h5 id="实例化定义会实例化所有成员"><a href="#实例化定义会实例化所有成员" class="headerlink" title="实例化定义会实例化所有成员"></a>实例化定义会实例化所有成员</h5><img src="/blog/2021/02/22/C-模板与泛型编程（一）/实例化定义会实例化所有成员.png"><h4 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h4><p>通过<strong>在编译时绑定删除器</strong>， <code>unique_ptr</code> 避免了间接调用删除器的运行时开销。通过<strong>在运行时绑定删除器</strong>，<code>shared_ptr</code> 使用户重载删除器更为方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;函数模板&lt;/li&gt;
&lt;li&gt;类模板&lt;/li&gt;
&lt;li&gt;模板参数&lt;/li&gt;
&lt;li&gt;成员模板&lt;/li&gt;
&lt;li&gt;控制实例化&lt;/li&gt;
&lt;li&gt;效率与灵活性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="泛型" scheme="http://www.xingyuzhao.ltd/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1004-最大连续1的个数Ⅲ</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/19/LeetCode1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%A2/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/19/LeetCode1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E2%85%A2/</id>
    <published>2021-02-19T06:26:39.000Z</published>
    <updated>2021-02-19T06:39:45.159Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>，我们最多可以将 <code>K</code> 个值从 0 变成 1 。</p><p>返回仅包含 1 的最长（连续）子数组的长度。</p><a id="more"></a><img src="/blog/2021/02/19/LeetCode1004-最大连续1的个数Ⅲ/1004.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用指针 <code>left</code> 表示当前的<strong>连续 1 的子数组</strong>的左端点，<code>right</code> 指针表示当前的<strong>连续1的子数组</strong>的右端点。</p><ul><li>如果 <code>A[right]</code> 为 0，并且此时 K 不为零，说明当前元素可以由 0 变为 1，并将次数减 1；</li><li>如果 <code>A[right]</code> 为 0，并且此时 K 为零，说明当前元素不可以由 0 变为 1，并且需要将窗口左端点右移：<ul><li>如果 <code>A[left]</code> 为 0，说明用使用过一次从 0 到 1。此时需要将这次值的改变“回收”，即 K++；</li><li>更新滑动窗口的最大长度，同时将左端点右移。</li></ul></li><li>如果 <code>A[right]</code> 为 0，右端点右移即可。</li></ul><p>最后一个连续 1 的子数组可能没被统计，所以需要再更新一次窗口最大长度。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; A.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[right] == <span class="number">1</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[right] == <span class="number">0</span> &amp;&amp; K != <span class="number">0</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                K--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[right] == <span class="number">0</span> &amp;&amp; K == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[left] == <span class="number">0</span>) K++;</span><br><span class="line">                ans = max(ans, right - left);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; ans &lt;&lt; " ";</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(right - left, ans); <span class="comment">// 最后一个值为1</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个由若干 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 组成的数组 &lt;code&gt;A&lt;/code&gt;，我们最多可以将 &lt;code&gt;K&lt;/code&gt; 个值从 0 变成 1 。&lt;/p&gt;
&lt;p&gt;返回仅包含 1 的最长（连续）子数组的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://www.xingyuzhao.ltd/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象程序设计（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/12/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/12/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-12T04:45:27.000Z</published>
    <updated>2021-02-25T14:21:02.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>抽象基类</li><li>访问控制与继承</li><li>继承中的类作用域</li><li>构造函数与拷贝控制</li></ol><a id="more"></a><h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p>含有（或者未经覆盖直接继承？）纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。</p><p>在函数体的位置（即声明语句的分号之前）书写 = 0 就可以将一个虚函数说明为纯虚函数。</p><h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><h5 id="受保护的成员protected"><a href="#受保护的成员protected" class="headerlink" title="受保护的成员protected"></a>受保护的成员protected</h5><ul><li>和私有成员类似，受保护的成员对类的用户是不可访问的。</li><li>和公有成员类似，受保护的成员对于派生类的成员和友元来说可访问。</li></ul><p>除此之外：</p><p><strong>派生类的成员和友元只能通过派生类对象来访问基类的受保护成员，而不能访问基类对象中的受保护成员。</strong></p><h5 id="公有、私有和受保护继承"><a href="#公有、私有和受保护继承" class="headerlink" title="公有、私有和受保护继承"></a>公有、私有和受保护继承</h5><img src="/blog/2021/02/12/C-面向对象程序设计（二）/继承1.png" style="zoom:67%;"><img src="/blog/2021/02/12/C-面向对象程序设计（二）/继承2.png" style="zoom:67%;"><img src="/blog/2021/02/12/C-面向对象程序设计（二）/继承3.png" style="zoom:67%;"><p>某个类对其继承而来的成员的访问权限受两个因素影响：</p><ol><li>基类中该成员的访问说明符；</li><li>派生类在派生列表中的访问说明符。</li></ol><p><strong>派生类访问说明符对派生类的成员及友元能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。</strong></p><p><strong>派生类访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限</strong>。</p><img src="/blog/2021/02/12/C-面向对象程序设计（二）/类的设计与受保护的成员.png"><h5 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h5><p>友元关系不能<strong>传递或继承</strong>，每个类负责控制各自成员的访问权限。</p><h5 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h5><p>使用 <code>using</code> 声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Derived的用户可以使用size成员</span></span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Derived的派生类可以使用n</span></span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的内部使用 <code>using </code>声明语句，将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。</p><ul><li><p>如果一条 <code>using</code> 声明语句出现在类的 <code>private</code> 部分,则该名字只能被类的成员和友元访问；</p></li><li><p>如果 <code>using</code> 声明语句位于 <code>public</code> 部分，则类的所有用户都能访问它；</p></li><li><p>如果 <code>using</code> 声明语句位于 <code>protected</code> 部分，则该名字对于成员、友元和派生类是可访问的。</p></li></ul><h5 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h5><p>默认情况下，使用 <code>class</code> 关键字定义的派生类是私有继承的；而使用 <code>struct</code> 关键字定义的派生类是公有继承的。</p><h4 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h4><h5 id="在编译时进行名字查找"><a href="#在编译时进行名字查找" class="headerlink" title="在编译时进行名字查找"></a>在编译时进行名字查找</h5><h5 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h5><p>派生类的成员将隐藏同名的基类成员。</p><h5 id="通过作用域运算符来使用隐藏的成员"><a href="#通过作用域运算符来使用隐藏的成员" class="headerlink" title="通过作用域运算符来使用隐藏的成员"></a>通过作用域运算符来使用隐藏的成员</h5><p>我们可以通过作用域运算符来使用一个被隐藏的基类成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base::mem; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/12/C-面向对象程序设计（二）/名字重用.png"><img src="/blog/2021/02/12/C-面向对象程序设计（二）/名字查找与继承.png" style="zoom:80%;"><h5 id="名字查找先于类型检查"><a href="#名字查找先于类型检查" class="headerlink" title="名字查找先于类型检查"></a>名字查找先于类型检查</h5><h5 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h5><p>基类与派生类中的虚函数必须有相同的形参列表。</p><h4 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h4><h5 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h5><p>基类通常应该定义一个虚析构函数。如果基类的析构函数不是虚函数，则 <code>delete</code> 一个指向派生类对象的基类指针将产生未定义的行为。</p><p><strong>虚析构函数将阻止合成移动操作</strong>。</p><h5 id="合成拷贝控制和继承"><a href="#合成拷贝控制和继承" class="headerlink" title="合成拷贝控制和继承"></a>合成拷贝控制和继承</h5><p>合成的成员负责使用<strong>直接基类</strong>中对应的操作对一个对象的<strong>直接基类部分</strong>进行初始化、赋值或销毁的操作。</p><h5 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h5><img src="/blog/2021/02/12/C-面向对象程序设计（二）/派生类的拷贝控制成员.png"><h6 id="定义派生类的拷贝或移动构造函数"><a href="#定义派生类的拷贝或移动构造函数" class="headerlink" title="定义派生类的拷贝或移动构造函数"></a>定义派生类的拷贝或移动构造函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">D(<span class="keyword">const</span> D&amp; d): Base(d) <span class="comment">// 拷贝基类成员</span></span><br><span class="line"><span class="comment">/* D的成员的初始值 */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">D(D&amp;&amp; d): Base(<span class="built_in">std</span>::move(d)) <span class="comment">// 移动基类成员</span></span><br><span class="line"><span class="comment">/* D的成员的初始值 */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/12/C-面向对象程序设计（二）/派生类的拷贝或移动构造函数.png"><h6 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base::operator=(const Base&amp;) 不会被自动调用</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)&#123;</span><br><span class="line">Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// 为基类部分赋值</span></span><br><span class="line"><span class="comment">// 为派生类的成员赋值</span></span><br><span class="line"><span class="comment">// 处理自赋值及释放已有资源等</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Base::Base 被自动调用执行</span></span><br><span class="line">~D() &#123; <span class="comment">/* 用户定义清楚派生类成员的操作 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派生类的析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直到最后。</p><h6 id="在构造函数和析构函数中调用虚函数"><a href="#在构造函数和析构函数中调用虚函数" class="headerlink" title="在构造函数和析构函数中调用虚函数"></a>在构造函数和析构函数中调用虚函数</h6><img src="/blog/2021/02/12/C-面向对象程序设计（二）/在构造函数和析构函数中调用虚函数.png"><h5 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h5><p>使用 <code>using</code> 声明语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Disc_quote::Disc_quote; <span class="comment">// 继承Disc_quote的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数</span></span><br><span class="line">derived(parms) : base(args) &#123; &#125;</span><br></pre></td></tr></table></figure><h6 id="继承的构造函数特点"><a href="#继承的构造函数特点" class="headerlink" title="继承的构造函数特点"></a>继承的构造函数特点</h6><p>与普通成员的 <code>using</code> 声明不同，一个构造函数的 <code>using</code> 声明不会改变该构造函数的访问级别。</p><p><code>using</code> 声明语句不能指定 <code>explicit</code> 或 <code>constexpr</code>。</p><p><strong>当一个基类构造函数含有默认实参时，这些实参并不会被继承</strong>。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p><p>例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：</p><ol><li><p>构造函数接受两个形参（没有默认实参），<strong>此时并未省略掉一个形参？</strong>；</p></li><li><p>构造函数只接受一个形参，它对应于基类中最左侧的<strong>没有默认值</strong>的那个形参。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;抽象基类&lt;/li&gt;
&lt;li&gt;访问控制与继承&lt;/li&gt;
&lt;li&gt;继承中的类作用域&lt;/li&gt;
&lt;li&gt;构造函数与拷贝控制&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="面向对象" scheme="http://www.xingyuzhao.ltd/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>2021，新年快乐！</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/12/2021%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/12/2021%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%81/</id>
    <published>2021-02-12T04:36:12.000Z</published>
    <updated>2021-02-12T04:47:46.305Z</updated>
    
    <content type="html"><![CDATA[<p>祝大家新年快乐，心想事成，牛年吉祥！</p><p>2021，新的一年，机遇与挑战并存。</p><p><strong>抓住机遇，迎接挑战！</strong>                                                    </p><p>​                        </p><p>​                                                                                          赵星宇</p><p>​                                                                                 2021.2.12  大年初一</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;祝大家新年快乐，心想事成，牛年吉祥！&lt;/p&gt;
&lt;p&gt;2021，新的一年，机遇与挑战并存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓住机遇，迎接挑战！&lt;/strong&gt;                                                    &lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++面向对象程序设计（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/02/08/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/02/08/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-08T14:19:04.000Z</published>
    <updated>2021-02-25T14:21:10.750Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>OOP：概述</li><li>定义基类和派生类</li><li>虚函数</li></ol><a id="more"></a><h4 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h4><p>面向对象程序设计的核心思想是<strong>数据抽象、继承和动态绑定</strong>。</p><p><strong>OOP</strong> 三大特征为：<strong>封装、继承、多态</strong>。</p><p>数据抽象：将类的接口与实现分离。</p><p>继承：可以定义相似的类型并对其相似关系建模。</p><p>动态绑定：在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象。</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>通过<strong>继承</strong>联系在一起的类构成一种层次关系。层次关系的根部有一个<strong>基类</strong>，负责定义层次关系中所有类共同拥有的成员。通过从基类继承得到的类称为<strong>派生类</strong>，每个派生类定义各自特有的成员。</p><p>如果某些函数基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派生类必须通过使用<strong>类派生列表</strong>明确指出它是从哪个（哪些）基类继承而来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++11 新标准允许派生类显式的注明它将使用哪个成员函数改写基类的虚函数，在该函数形参列表之后增加一个 <code>override</code> 关键字即可</strong>。而不用在函数前加上 <code>virtual</code> 关键字。</p><h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p>也称为<strong>运行时绑定</strong>，在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。</p><h4 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h4><h5 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h5><p>基类通常都需要定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p><h6 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h6><p>基类必须将它得两种成员函数区分开来：</p><ol><li>基类希望其派生类进行覆盖的函数，将其定义为虚函数。<ul><li>当使用指针或引用调用虚函数时，该调用将被动态绑定。</li><li>如果基类把一个函数声明为虚函数，则该函数的派生类中隐式的也是虚函数。</li></ul></li><li>基类希望直接继承而不需要改变的类。</li></ol><h6 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h6><p>派生类可以访问基类的公有成员。如果基类希望派生类可以访问成员，并且该成员禁止其他用户访问，这种成员应定义为<strong>受保护的（protected）</strong>。</p><h5 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h5><p>通过<strong>类派生列表</strong>，形式为：首先是一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前可以有：<code>public</code>、<code>protected</code> 或 <code>private</code> 中的一个。</p><h6 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h6><h6 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h6><p>可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；也可以把派生类对象的指针用在需要基类指针的地方。</p><h6 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h6><p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc): </span><br><span class="line">Quote(book, p), min_qty(qty), discount(disc) &#123; &#125;</span><br></pre></td></tr></table></figure><h6 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h6><img src="/blog/2021/02/08/C-面向对象程序设计（一）/遵循基类的接口.png"><h6 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h6><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p><h6 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h6><p>声明中包含类名但不包含它的派生列表。</p><h6 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h6><p>如果要将某个类用作基类，则该类必须已经定义而非仅仅声明。</p><h6 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h6><p>C++11 新标准提供关键字 <code>final</code> 防止继承发生：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> &#123;</span> <span class="comment">/* */</span> &#125;; <span class="comment">// NoDerived 不能作为基类</span></span><br></pre></td></tr></table></figure><h5 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h5><p>当使用基类的引用（或指针）时，实际上我们并不知道该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p><h6 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h6><p>静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。</p><h6 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h6><h6 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h6><p>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。</p><img src="/blog/2021/02/08/C-面向对象程序设计（一）/在对象之间不存在类型转换_note.png"><h6 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h6><img src="/blog/2021/02/08/C-面向对象程序设计（一）/转换规则.png"><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>无论是否被用到，每个虚函数都需要定义。</p><h5 id="对虚函数的调用可能运行时才被解析"><a href="#对虚函数的调用可能运行时才被解析" class="headerlink" title="对虚函数的调用可能运行时才被解析"></a>对虚函数的调用可能运行时才被解析</h5><p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。</p><h5 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h5><img src="/blog/2021/02/08/C-面向对象程序设计（一）/多态性.png"><h5 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h5><p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则<strong>它的形参类型必须与它覆盖的基类函数完全一致</strong>。一般来说，返回类型也应该一致，除非类的虚函数返回类型是类本身的指针或引用。</p><h5 id="final-和-override-说明符"><a href="#final-和-override-说明符" class="headerlink" title="final 和 override 说明符"></a>final 和 override 说明符</h5><p>如果使用 <code>override</code> 标记了某个函数，但是该函数并没有覆盖已存在的虚函数，此时编译器将报错。</p><p>如果将某个函数指定为 <code>final</code>，则之后任何尝试覆盖该函数的操作都将引发错误。</p><p>上述两个函数出现在形参列表（包括任何 <code>const</code> 或引用修饰符）以即尾置返回类型之后。</p><h5 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h5><p>如果某次函数调用使用了默认实参， 则该实参值由本次调用的静态类型决定。</p><p>如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参。</p><img src="/blog/2021/02/08/C-面向对象程序设计（一）/虚函数与默认实参.png"><h5 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h5><p>通常当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，需要回避虚函数机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强行调用基类中定义的函数版本而不管 baseP 的动态类型到底是什么</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><img src="/blog/2021/02/08/C-面向对象程序设计（一）/回避虚函数机制.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;OOP：概述&lt;/li&gt;
&lt;li&gt;定义基类和派生类&lt;/li&gt;
&lt;li&gt;虚函数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="面向对象" scheme="http://www.xingyuzhao.ltd/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
