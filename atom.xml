<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2021-01-27T15:12:51.758Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode1579-保证图可完全遍历</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/27/LeetCode1579-%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/27/LeetCode1579-%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/</id>
    <published>2021-01-27T14:21:51.000Z</published>
    <updated>2021-01-27T15:12:51.758Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边：</p><ul><li>类型 1：只能由 Alice 遍历。</li><li>类型 2：只能由 Bob 遍历。</li><li>类型 3：Alice 和 Bob 都可以遍历。</li></ul><p>给你一个数组 $edges$ ，其中 $edges[i] = [type_i, u_i, v_i]$ 表示节点 $u_i$ 和 $v_i$ 之间存在类型为 $type_i$ 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p><p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1。</p><a id="more"></a><img src="/blog/2021/01/27/LeetCode1579-保证图可完全遍历/1567.png" style="zoom:120%;"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题和<a href="http://www.xingyuzhao.ltd/blog/2021/01/23/LeetCode1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/#more">LeetCode1319-连通网络的操作次数</a>很相似，可以说是1319的加强版。这道题需要给两位主角分别建立一个并查集，并且要解决下面三个问题：</p><p><strong>1. 如何判断边重复？</strong></p><p>在进行 <code>union</code> 操作前后，如果 <code>count</code> 变化（减一），代表进行了合并；否则，说明此边重复，可以删掉。</p><p><strong>2. 什么是公共边？</strong></p><p>对于此题来说，$type$ 为 3 的边既可以被 Alice 遍历，也可以被 Bob 遍历。所以此种类型的边就是公共边。</p><p><strong>3. 如何处理公共边？</strong></p><p>这是本题的重点，对 Alice 和 Bob 分别根据公共边进行合并。</p><ul><li>如果先对 Alice 根据公共边合并，当发现边重复时，就需要删掉此边，不会对节点之间的连通性造成任何影响。</li><li>再对 Bob 根据公共边合并时，就不需要删边了，因为上一步已经删去了重复公共边，不需要再一次删除了。两者的联通集是一致的。</li></ul><p>总而言之，<strong>公共边只能删除一次。</strong></p><p>经历上述操作后，再分别对两个人按照自己可以遍历的类型进行合并，同样遇到了重复边可以删掉。将重复公共边总数和非公共边重复总数求和，就是最终结果了。</p><p>当然，如果合并结束后，两个并查集中有一个或多个不止一个联通集，说明无法全部遍历，返回 -1。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>顺序可能不太一致，但不影响最终结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumEdgesToRemove</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">unionFind <span class="title">Alice</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">unionFind <span class="title">Bob</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Alice</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> type = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(type != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> count = Alice.getCount();</span><br><span class="line">            Alice.unionElem(u - <span class="number">1</span>, v - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(Alice.getCount() == count)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> type = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(type != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> count = Alice.getCount();</span><br><span class="line">            Alice.unionElem(u - <span class="number">1</span>, v - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(Alice.getCount() == count)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Bob</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> type = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(type != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Bob.unionElem(u - <span class="number">1</span>, v - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;edge : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> type = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(type != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> count = Bob.getCount();</span><br><span class="line">            Bob.unionElem(u - <span class="number">1</span>, v - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(Bob.getCount() == count)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Alice.getCount() == <span class="number">1</span> &amp;&amp; Bob.getCount() == <span class="number">1</span> ? cnt : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型 1：只能由 Alice 遍历。&lt;/li&gt;
&lt;li&gt;类型 2：只能由 Bob 遍历。&lt;/li&gt;
&lt;li&gt;类型 3：Alice 和 Bob 都可以遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给你一个数组 $edges$ ，其中 $edges[i] = [type_i, u_i, v_i]$ 表示节点 $u_i$ 和 $v_i$ 之间存在类型为 $type_i$ 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。&lt;/p&gt;
&lt;p&gt;返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode959-由斜杠划分区域</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/25/LeetCode959-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/25/LeetCode959-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/</id>
    <published>2021-01-25T06:53:07.000Z</published>
    <updated>2021-01-26T12:47:31.099Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在由 1 x 1 方格组成的 N x N 网格 <code>grid</code> 中，每个 1 x 1 方块由 <code>/</code>、<code>\</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p><p>（请注意，反斜杠字符是转义的，因此 <code>\</code> 用 <code>&quot;\\&quot;</code> 表示。）。</p><p>返回区域的数目。</p><a id="more"></a><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>输入 <code>grid</code> 的长度 <code>n</code> 就是网格的<strong>边长</strong>。比如示例中 <code>grid</code> 的长度为2，那么就是对 $2\times2$ 的网格中的每一小格，通过字符确定如何划分这一小格。</p><p>将一个小格分为<strong>4</strong>个部分，分别为 <code>0,1,2,3</code>，如下：</p><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_1.png"><ul><li><p>如果输入字符为 <code>&quot;/&quot;</code> ，则将 <code>0-1</code> 与 <code>3-2</code> 分别连接。</p></li><li><p>如果输入字符为 <code>&quot;\\&quot;</code> ，则将 <code>0-3</code> 与 <code>1-2</code> 分别连接。</p></li><li><p>如果输入字符为 <code> &quot; &quot;</code>，则将 <code>0-1-2-3</code> 全部连接。</p></li></ul><p>左右相邻的两个小格需要将左边的 <code>1</code> 与右边的 <code>3</code> 相连：</p><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_2.png" style="zoom:80%;"><p>上下相邻的两个小格需要将上面的 <code>2</code>  与下边的 <code>0</code> 相连：</p><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_3.png"><p>除了第一行和第一列，其他的行和列都需要考虑上述两种相邻的情况。</p><p>合并结束后，连通集的个数就是区域的数目。</p><p>以示例4为例：</p><ul><li>仅对于每个字符合并：</li></ul><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_4.png"><ul><li>对行和列相邻的小格进行合并：</li></ul><img src="/blog/2021/01/25/LeetCode959-由斜杠划分区域/959_5.png"><p>如上图所示，区域一共有5个。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">genCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">regionsBySlashes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(<span class="number">4</span> * n * n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> start = <span class="number">4</span> * (i * n + j); <span class="comment">// 0号位置</span></span><br><span class="line">                <span class="keyword">switch</span>(grid[i][j])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                        uf.unionElem(start, start + <span class="number">1</span>);</span><br><span class="line">                        uf.unionElem(start + <span class="number">1</span>, start + <span class="number">2</span>);</span><br><span class="line">                        uf.unionElem(start + <span class="number">2</span>, start + <span class="number">3</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                        uf.unionElem(start, start + <span class="number">3</span>);</span><br><span class="line">                        uf.unionElem(start + <span class="number">1</span>, start + <span class="number">2</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">                        uf.unionElem(start, start + <span class="number">1</span>);</span><br><span class="line">                        uf.unionElem(start + <span class="number">2</span>, start + <span class="number">3</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 连接同一列2-0</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>) uf.unionElem(start, start - <span class="number">4</span> * n + <span class="number">2</span>);</span><br><span class="line">                <span class="comment">// 连接同一行1-3</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>) uf.unionElem(start + <span class="number">3</span>, start - <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.genCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>评论区：<a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regions-cut-by-slashes/comments/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在由 1 x 1 方格组成的 N x N 网格 &lt;code&gt;grid&lt;/code&gt; 中，每个 1 x 1 方块由 &lt;code&gt;/&lt;/code&gt;、&lt;code&gt;\&lt;/code&gt; 或空格构成。这些字符会将方块划分为一些共边的区域。&lt;/p&gt;
&lt;p&gt;（请注意，反斜杠字符是转义的，因此 &lt;code&gt;\&lt;/code&gt; 用 &lt;code&gt;&amp;quot;\\&amp;quot;&lt;/code&gt; 表示。）。&lt;/p&gt;
&lt;p&gt;返回区域的数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1319-连通网络的操作次数</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/23/LeetCode1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/23/LeetCode1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</id>
    <published>2021-01-23T02:51:28.000Z</published>
    <updated>2021-01-23T07:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>用以太网线缆将 <code>n</code> 台计算机连接成一个网络，计算机的编号从 <code>0</code> 到 <code>n-1</code>。线缆用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 连接了计算机 <code>a</code> 和 <code>b</code>。</p><p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p><p>给你这个计算机网络的初始布线 <code>connections</code>，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。</p><a id="more"></a><img src="/blog/2021/01/23/LeetCode1319-连通网络的操作次数/1319.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先我们需要得到<strong>多余</strong>的边的总数：先判断两个节点是否处于同一个连通集，如果处于同一个连通集并且当前还有一条边连接它们，那么就将<strong>可用边</strong>计数加1。</p><p>其次，我们需要得到连通集的个数，连通集的总数减去1就是要将它们连接起来<strong>所需要边</strong>的个数。</p><p>如果<strong>可用边</strong>小于<strong>所需要边</strong>的个数，就返回-1，代表无法使所有计算机连通。否则，取两者中的较小值，就是最小需要移动边的个数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeConnected</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> lines = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connections.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = uf.getCount();</span><br><span class="line">            uf.unionElem(connections[i][<span class="number">0</span>], connections[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(count == uf.getCount()) lines++;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">int</span> need = uf.getCount() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; lines &lt;&lt; " " &lt;&lt; need;</span></span><br><span class="line">        <span class="keyword">if</span>(lines &gt;= need)&#123;</span><br><span class="line">            <span class="keyword">return</span> min(lines, need);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;用以太网线缆将 &lt;code&gt;n&lt;/code&gt; 台计算机连接成一个网络，计算机的编号从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;。线缆用 &lt;code&gt;connections&lt;/code&gt; 表示，其中 &lt;code&gt;connections[i] = [a, b]&lt;/code&gt; 连接了计算机 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。&lt;/p&gt;
&lt;p&gt;给你这个计算机网络的初始布线 &lt;code&gt;connections&lt;/code&gt;，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++动态数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/20/C-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/20/C-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/</id>
    <published>2021-01-20T14:42:27.000Z</published>
    <updated>2021-01-24T12:20:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li><code>new</code> 和数组</li><li><code>allocator</code> 类</li><li>使用标准库：文本查询程序</li></ol><a id="more"></a><h4 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h4><p>使用 <code>new</code> 分配一个对象数组，在类型名后跟一对方括号，在其中指明要分配的对象的数目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()]; <span class="comment">// pia指向第一个int</span></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>]; <span class="comment">// arrT表示42个int的数组类型</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT; <span class="comment">// 分配一个42个int的数组；p指向第一个int</span></span><br></pre></td></tr></table></figure><h5 id="分配一个数组会得到一个元素类型的指针"><a href="#分配一个数组会得到一个元素类型的指针" class="headerlink" title="分配一个数组会得到一个元素类型的指针"></a>分配一个数组会得到一个元素类型的指针</h5><p>分配的内存不是一个数组类型，因此不能对动态数组调用 <code>begin</code> 和 <code>end</code> ，也不能用范围 <code>for</code>。</p><h5 id="初始化动态分配对象的数组"><a href="#初始化动态分配对象的数组" class="headerlink" title="初始化动态分配对象的数组"></a>初始化动态分配对象的数组</h5><p>动态数组中的元素可以进行值初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 未初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](); <span class="comment">// 值初始化（0）</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]; <span class="comment">// 10个空string</span></span><br><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>](); <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><p>新标准下还可以用花括号列表进行初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 前四个用给定的初始化器初始化，剩余的进行值初始化</span></span><br><span class="line"><span class="built_in">string</span> *pia = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]&#123;<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>,<span class="built_in">string</span>(<span class="number">3</span>, <span class="string">'x'</span>)&#125;;</span><br></pre></td></tr></table></figure><p>同时，动态分配一个空数组是合法的。</p><h5 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h5><p>在指针前加上一个空方括号对：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> []pa; <span class="comment">// pa必须指向一个动态分配的数组或为空</span></span><br></pre></td></tr></table></figure><h5 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// up指向一个包含10个未初始化int的数组</span></span><br><span class="line">unique_ptr&lt;int[]&gt; uo(new int[10]);</span><br><span class="line">up.release(); <span class="comment">// 自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure><p>当一个 <code>unique_ptr</code> 指向一个数组时，可以使用下标运算符来访问数组中的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">up[i] = i; <span class="comment">// 为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态数组/指向数组的unique_ptr.png"><p><em>如果希望使用 <code>shared_ptr</code> 管理一个动态数组，必须提供自己定义的删除器。</em></p><h4 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h4><p>标准库 <code>allocator</code> 类定义在 <code>memory</code> 中，它将内存分配和对象构造分离开来。当一个 <code>allocator</code> 对象分配内存时，它会根据给定的<strong>对象类型</strong>来确定恰当的内存大小和对齐位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc; <span class="comment">// 可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); <span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态数组/标准库allocator类及其算法.png"><h5 id="allocator-分配未构造的内存"><a href="#allocator-分配未构造的内存" class="headerlink" title="allocator 分配未构造的内存"></a>allocator 分配未构造的内存</h5><p><code>allocator</code> 分配的内存是未构造的，我们按需要在此内存中使用 <code>construct</code> 构造对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">// q指向最后构造的元素之后的位置</span></span><br><span class="line">alloc.construct(q++); <span class="comment">// *q为空字符串</span></span><br><span class="line">alloc.construct(q++, <span class="number">10</span>, <span class="string">'c'</span>); <span class="comment">// *q为cccccccccc</span></span><br><span class="line">alloc.construct(q++, <span class="string">"hi"</span>); <span class="comment">// *q为hi</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态数组/alloc_warning.png"><p>使用完对象后，必须对<strong>每个构造</strong>的元素调用 <code>destory</code> 来销毁它们。其接受一个指针，对指向的对象执行析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q != p)</span><br><span class="line">alloc.destory(--q); <span class="comment">// 第一次调用时，q指向最后一个构造的元素</span></span><br></pre></td></tr></table></figure><p>元素被销毁后，可以将这部分内存来保存其他 <code>string</code>，也可将其归还给系统，使用 <code>deallocate</code> 完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.deallocate(p, n);</span><br></pre></td></tr></table></figure><h5 id="拷贝和填充未初始化内存的算法"><a href="#拷贝和填充未初始化内存的算法" class="headerlink" title="拷贝和填充未初始化内存的算法"></a>拷贝和填充未初始化内存的算法</h5><p>标准库还定义了两个伴随算法，可以在未初始化内存中创建对象：</p><img src="/blog/2021/01/20/C-动态数组/allocator算法.png"><h4 id="使用标准库：文本查询程序"><a href="#使用标准库：文本查询程序" class="headerlink" title="使用标准库：文本查询程序"></a>使用标准库：文本查询程序</h4><p>在一个给定的文件中查询单词，结果是单词在文件中出现的次数及其所在行。如果一个单词一行中出现多次，只列出一次。行会按照升序输出。</p><p>读入一个英文文本，在其中查询单词 <code>element</code> ，输出结果的前几行如下图：</p><img src="/blog/2021/01/20/C-动态数组/example.png"><h5 id="查询类TextQuery"><a href="#查询类TextQuery" class="headerlink" title="查询类TextQuery"></a>查询类TextQuery</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> line_no = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">    TextQuery(ifstream&amp;);</span><br><span class="line">    <span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file; <span class="comment">// 输入文件，需要两个类共享</span></span><br><span class="line">    <span class="comment">// 每个单词到它所在的行号的集合的映射</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line">&#125;;</span><br><span class="line">TextQuery::TextQuery(ifstream &amp;is): file(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">string</span> text;</span><br><span class="line">    <span class="keyword">while</span>(getline(is, text))&#123; <span class="comment">// 对文件中每一行</span></span><br><span class="line">        file-&gt;push_back(text); <span class="comment">// 保存此行文本</span></span><br><span class="line">        <span class="keyword">int</span> n = file-&gt;size() - <span class="number">1</span>; <span class="comment">// 当前行号</span></span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">line</span><span class="params">(text)</span></span>; <span class="comment">// 将文本分解为单词</span></span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">while</span>(line &gt;&gt; word)&#123; <span class="comment">// 对行中的每个单词</span></span><br><span class="line">            <span class="comment">// 如果单词不在wm中，以之为下标在wm中添加一项</span></span><br><span class="line">            <span class="comment">// lines是一个引用，改变lines也会改变wm中的元素</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;lines = wm[word];</span><br><span class="line">            <span class="keyword">if</span>(!lines) <span class="comment">// 在我们第一次遇到这个单词时，此指针为空</span></span><br><span class="line">                lines.reset(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;); <span class="comment">// 分配一个新的set</span></span><br><span class="line">            lines-&gt;insert(n); <span class="comment">// 将此行号插入set中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QueryResult <span class="title">TextQuery::query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sought)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果未找到sought，返回一个指向此set的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; <span class="title">nodata</span><span class="params">(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;)</span></span>;</span><br><span class="line">    <span class="comment">// 使用find而不是下标运算符来查找单词，避免将单词添加到wm中</span></span><br><span class="line">    <span class="keyword">auto</span> loc = wm.find(sought);</span><br><span class="line">    <span class="keyword">if</span>(loc == wm.end())</span><br><span class="line">        <span class="keyword">return</span> QueryResult(sought, nodata, file); <span class="comment">// 未找到</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> QueryResult(sought, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询结果类QueryResult"><a href="#查询结果类QueryResult" class="headerlink" title="查询结果类QueryResult"></a>查询结果类QueryResult</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr,<span class="keyword">const</span> <span class="built_in">string</span> &amp;word, <span class="keyword">const</span> <span class="built_in">string</span> &amp;ending)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>; <span class="comment">// 友元函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> line_no = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line">    QueryResult(<span class="built_in">string</span> s, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; p, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; f):</span><br><span class="line">                sought(s), lines(p), file(f)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> sought; <span class="comment">// 查询单词</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; lines; <span class="comment">// 出现的行号</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file; <span class="comment">// 输入文件</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> QueryResult &amp;qr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果找到了单词，打印出现次数和所有出现的位置</span></span><br><span class="line">    os &lt;&lt; qr.sought &lt;&lt; <span class="string">" occurs "</span> &lt;&lt; qr.lines-&gt;size() &lt;&lt; <span class="string">" "</span></span><br><span class="line">       &lt;&lt; make_plural(qr.lines-&gt;size(), <span class="string">"time"</span>, <span class="string">"s"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 打印单词出现的每一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : *qr.lines)</span><br><span class="line">        <span class="comment">// 行号从1开始</span></span><br><span class="line">        os &lt;&lt; <span class="string">"\t(lines "</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; <span class="string">") "</span></span><br><span class="line">           &lt;&lt; *(qr.file-&gt;begin() + num) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;word, <span class="keyword">const</span> <span class="built_in">string</span> &amp;ending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctr == <span class="number">1</span>) ? word : word + ending;<span class="comment">//make_plural(wc, "word ", "s ")当输入中文本中</span></span><br><span class="line">    <span class="comment">//word数大于一是在word后加s，为words为word的复数！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"test.txt"</span>)</span></span>;</span><br><span class="line">    runQueries(infile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream &amp;infile)</span></span>&#123;</span><br><span class="line">    <span class="function">TextQuery <span class="title">tq</span><span class="params">(infile)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入要查询的单词，或按q退出："</span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">cin</span> &gt;&gt; s) || s == <span class="string">"q"</span>) <span class="keyword">break</span>;</span><br><span class="line">        print(<span class="built_in">cout</span>, tq.query(s)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h5><p><a href="https://gitee.com/settlezxy/learning-cpp.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/learning-cpp.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; 和数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allocator&lt;/code&gt; 类&lt;/li&gt;
&lt;li&gt;使用标准库：文本查询程序&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="动态数组" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++动态内存与智能指针</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/20/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/20/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2021-01-20T14:41:49.000Z</published>
    <updated>2021-01-25T15:04:57.562Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li><code>shared_ptr</code> 类</li><li>直接管理内存</li><li><code>shared_ptr</code> 和 <code>new</code> 结合使用</li><li>智能指针和异常</li><li><code>unique_ptr</code></li><li><code>weak_ptr</code></li></ol><a id="more"></a><p>静态内存：保存局部 <code>static</code> 对象、类 <code>static</code> 数据成员及定义在任何函数之外的变量。</p><p>栈内存：保存和定义在函数内的非 <code>static</code> 对象。</p><p>除了静态内存和栈内存，程序还拥有一个内存池，被称为<strong>自由空间</strong>或<strong>堆</strong>。程序用堆来存储<strong>动态分配</strong>的对象，当动态对象不再使用时，必须用代码显式的销毁它们。</p><p><strong>动态内存与智能指针</strong></p><ul><li><code>new</code> ：在动态内存中为对象分配空间并返回一个指向该对象的指针。</li><li><code>delete</code> ：接受一个动态对象的指针，销毁该对象，并释放相关内存。</li></ul><p>不合理时释放内存会出现内存泄漏（忘记释放）或产生引用非法内存的指针（有指针还在引用内存时就释放了它）。</p><p>标准库提供两种<strong>智能指针</strong>管理动态对象，它们可以自动释放所指向的对象。</p><ol><li><code>shared_ptr</code> 允许多个指针指向同一个对象。</li><li><code>unique_ptr</code> 则<strong>独占</strong>所指向的对象。</li></ol><p>标准库还定义了一个名为 <code>weak_ptr</code> 的伴随类，它是一种弱引用（**?**），指向 <code>shared_ptr</code> 所管理的对象。这三种类型都定义在 <code>memory</code> 头文件中。</p><h4 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h4><p>智能指针也是模板，必须提供指针可以指向的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1; <span class="comment">// 指向string</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;  p2; <span class="comment">// 指向int的list</span></span><br></pre></td></tr></table></figure><p>如果在一个条件判断中使用智能指针，效果就是检测它是否为空：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果p1不为空，并且指向一个空的string</span></span><br><span class="line"><span class="keyword">if</span>(p1 &amp;&amp; p1-&gt;empty())</span><br><span class="line">*p1 = <span class="string">"hi"</span>;</span><br></pre></td></tr></table></figure><p><code>shared_ptr </code>和 <code>unique_ptr</code> 都支持的操作：</p><img src="/blog/2021/01/20/C-动态内存与智能指针/shared_ptr与unique_ptr都支持的操作.png"><p><code>shared_ptr</code> 独有的操作：</p><img src="/blog/2021/01/20/C-动态内存与智能指针/shared_ptr独有的操作.png"><h5 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h5><p>此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 <code>shared_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向一个值为42的int的shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 指向一个值初始化的int，即，值为0</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p4 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="comment">// 也可以用auto</span></span><br></pre></td></tr></table></figure><p><strong>调用make_shared<t>时必须与T的某个构造函数相匹配</t></strong>。</p><h5 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h5><p>当进行拷贝或赋值操作时，每个 <code>shared_ptr</code> 都会记录又多少个其他 <code>shared_ptr</code> 指向相同的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">// p和q指向相同对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure><p>每个 <code>shared_ptr</code> 都有要给<strong>引用计数</strong>，只要我们拷贝一个 <code>shared_ptr</code> ，计数器就会增加，当我们给 <code>shared_ptr</code> 赋予一个新值或是 <code>shared_ptr</code> 被销毁，计数器递减。</p><p>一旦计数器变为0，它就会自动释放自己所管理的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q; <span class="comment">// 给r赋值，令它指向另一个地址</span></span><br><span class="line">   <span class="comment">// 递增q指向的对象的引用计数</span></span><br><span class="line">   <span class="comment">// 递减r原来指向的对象的引用计数</span></span><br><span class="line">   <span class="comment">// r原来指向的对象已经没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure><h5 id="shared-ptr自动销毁所管理的对象"><a href="#shared-ptr自动销毁所管理的对象" class="headerlink" title="shared_ptr自动销毁所管理的对象"></a>shared_ptr自动销毁所管理的对象</h5><p>当指向一个对象的最后一个 <code>shared_ptr</code> 被销毁时，<code>shared_ptr</code> 类会通过<strong>析构函数</strong>销毁此对象。<code>shared_ptr</code> 的析构函数会递减它所指向的对象的引用计数，如果引用计数变为0， <code>shared_ptr</code> 的析构函数就会销毁对象，并释放它占用的内存。</p><h5 id="shared-ptr还会自动释放相关联的内存"><a href="#shared-ptr还会自动释放相关联的内存" class="headerlink" title="shared_ptr还会自动释放相关联的内存"></a>shared_ptr还会自动释放相关联的内存</h5><img src="/blog/2021/01/20/C-动态内存与智能指针/note_shared_ptr释放内存.png"><h5 id="使用了动态生存期的资源的类"><a href="#使用了动态生存期的资源的类" class="headerlink" title="使用了动态生存期的资源的类"></a>使用了动态生存期的资源的类</h5><p>程序使用动态内存出于一下三种原因之一 ：</p><ol><li>程序不知道自己需要使用多少对象。</li><li>程序不知道所需对象的准确类型。</li><li>程序需要在多个对象间共享数据。</li></ol><p>一般而言，如果两个对象共享底层的数据，当某个对象被销毁时，我们不能单方面的销毁底层数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="built_in">string</span>&gt; b1; <span class="comment">// 空Blob</span></span><br><span class="line">&#123;新作用域</span><br><span class="line">    Blob&lt;<span class="built_in">string</span>&gt; b2 = &#123;<span class="string">"z"</span>,<span class="string">"zx"</span>,<span class="string">"zxy"</span>&#125;;</span><br><span class="line"> b1 = b2; <span class="comment">// b1和b2共享相同的元素</span></span><br><span class="line">&#125; <span class="comment">// b2被销毁了，但b2中的元素不能销毁</span></span><br><span class="line">  <span class="comment">// b1指向最初由b2创建的元素</span></span><br></pre></td></tr></table></figure><p>此例中，<code>b1</code> 和 <code>b2</code> 共享相同的元素。当 <code>b2</code> 离开作用域时，这些元素必须保留，<code>b1</code> 仍然在使用它们。</p><h4 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h4><h5 id="使用new动态分配和初始化对象"><a href="#使用new动态分配和初始化对象" class="headerlink" title="使用new动态分配和初始化对象"></a>使用new动态分配和初始化对象</h5><p>使用传统构造方式（使用圆括号），或列表初始化（使用花括号）初始化一个动态分配的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// pi指向的对象的值为1024</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'9'</span>); <span class="comment">// *ps为"9999999999"</span></span><br><span class="line"><span class="comment">// vector有10个元素，值以此从0到9</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>对动态分配的对象进行值初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(); <span class="comment">// 值初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// 值初始化为0；*pi为0</span></span><br></pre></td></tr></table></figure><h5 id="动态分配的const对象"><a href="#动态分配的const对象" class="headerlink" title="动态分配的const对象"></a>动态分配的const对象</h5><p>用 <code>new</code> 分配 <code>const</code> 是合法的，但必须进行初始化，返回一个指向 <code>cosnt</code> 的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *pcs = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// const对象是可以销毁的</span></span><br><span class="line"><span class="keyword">delete</span> pci;</span><br></pre></td></tr></table></figure><h5 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h5><p>如果 <code>new</code> 不能分配所要求的内存空间，它会抛出一个类型为 <code>bad_alloc</code> 的异常，但是可以使用 <code>new</code>  的方式阻止其抛出异常，称这种形式的 <code>new</code> 为<strong>定位new</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果分配失败，new返回一个空指针</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new抛出std:bad_alloc;</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new返回要给空指针</span></span><br></pre></td></tr></table></figure><h5 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// p必须指向一个动态分配的对象或是一个空指针</span></span><br></pre></td></tr></table></figure><p>释放一块非 <code>new</code> 分配的内存，或者将相同的指针值释放多次，其行为是未定义的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *pi1 = &amp;i;</span><br><span class="line"><span class="keyword">delete</span> pi1; <span class="comment">// 未定义：pi1指向一个局部变量</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> pi2; <span class="comment">// 正确：释放一个空指针总是没有错误的</span></span><br></pre></td></tr></table></figure><h5 id="动态对象的生存期直到被释放时为止"><a href="#动态对象的生存期直到被释放时为止" class="headerlink" title="动态对象的生存期直到被释放时为止"></a>动态对象的生存期直到被释放时为止</h5><img src="/blog/2021/01/20/C-动态内存与智能指针/warning_释放动态对象.png"><h5 id="使用new和delete管理动态内存存在的三个常见问题"><a href="#使用new和delete管理动态内存存在的三个常见问题" class="headerlink" title="使用new和delete管理动态内存存在的三个常见问题"></a>使用new和delete管理动态内存存在的三个常见问题</h5><ol><li>忘记 <code>delete</code> 内存，会导致<strong>内存泄漏</strong>，因为这种内存永远不可能被归还给自由空间了，只有真正耗尽内存时，才能检测到这种错误。</li><li>使用已释放掉的内存。</li><li>同一块内存释放两次。</li></ol><h5 id="delete之后重置指针值"><a href="#delete之后重置指针值" class="headerlink" title="delete之后重置指针值"></a>delete之后重置指针值</h5><p>在 <code>delete</code> 之后，指针就变成了<strong>空悬指针</strong>，即，指向一块曾经保存数据对象但现在已经无效的内存的指针。</p><h4 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h4><p>我们可以使用 <code>new</code> 返回的指针来初始化智能指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure><p>接受指针参数的智能指针的构造函数是 <code>explicit</code> 的，因此必须使用直接初始化形式来初始化一个智能指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态内存与智能指针/定义和改变shared_ptr的其他方法1.png"><img src="/blog/2021/01/20/C-动态内存与智能指针/定义和改变shared_ptr的其他方法2.png"><h5 id="get使用注意"><a href="#get使用注意" class="headerlink" title="get使用注意"></a>get使用注意</h5><img src="/blog/2021/01/20/C-动态内存与智能指针/warning_get_use.png"><h5 id="其他shared-ptr操作"><a href="#其他shared-ptr操作" class="headerlink" title="其他shared_ptr操作"></a>其他shared_ptr操作</h5><p>我们可以同 <code>reset</code> 来将一个新的指针赋予一个 <code>shared_ptr</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误，不能将一个指针赋予shared_ptr</span></span><br><span class="line">p.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>)); <span class="comment">// 正确，p指向一个新对象</span></span><br></pre></td></tr></table></figure><p><code>reset</code> 成员常与 <code>unique</code> 一起使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p.unique())&#123;</span><br><span class="line">p.reset(<span class="keyword">new</span> <span class="built_in">string</span>(*p)); <span class="comment">// 不是唯一用户，分配新的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line">*p += newVal; <span class="comment">// 现在唯一，可以改变对象的值</span></span><br></pre></td></tr></table></figure><h4 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h4><p>如果使用智能指针，即使程序块过早结束，智能指针也能确保在内存不再需要时将其释放；而 <code>new</code> 和 <code>delete</code> 之间发生异常，且异常未被捕获，则内存就永远不会被释放了。</p><h5 id="使用自己的释放操作"><a href="#使用自己的释放操作" class="headerlink" title="使用自己的释放操作"></a>使用自己的释放操作</h5><p>有些类未定义析构函数，需要用户显示地释放所使用的任何资源。假定我们正在使用一个C和C++都使用的网络库，使用这个库的代码可能如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">destination</span>;</span> <span class="comment">// 表示我们正在连接什么</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span>;</span> <span class="comment">// 使用连接所需的信息</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination *)</span></span>; <span class="comment">// 打开连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(connect)</span></span>; <span class="comment">// 关闭给定的连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获得一个连接，记住使用完之后要关闭！</span></span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 如果我们在f推出前忘记调用disconnect，就无法关闭c了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>shared_ptr</code> 来保证 <code>connection</code> 被正确关闭：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数来代替delete</span></span><br><span class="line"><span class="comment">// 这个「删除器」函数必须能够完成对shared_ptr中保存的指针进行释放的操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconnect (*p); &#125;;</span><br><span class="line"><span class="comment">// 创建shared_ptr时，可以传递一个（可选的）指向删除器函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 当f退出时（即使时因为异常而退出），connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>当我们定义一个 <code>unique_ptr</code> 时，需要将其绑定到一个 <code>new</code> 返回的指针上。如果进行初始化，必须是直接初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; p1; <span class="comment">// 可以指向一个double的unique_ptr</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure><p><code>unique</code> 不支持普通的拷贝或赋值操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"zxy"</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 错误，不能拷贝</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3;</span><br><span class="line">p3 = p2; <span class="comment">// 错误，不能赋值</span></span><br></pre></td></tr></table></figure><img src="/blog/2021/01/20/C-动态内存与智能指针/unique_str操作.png"><p>可以通过 <code>release</code> 或 <code>reset</code> 将指针的所有权（非const）从一个 <code>unique_ptr</code> 转移给另一个 <code>unique_ptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有权从p1转移给p2，并将p1置空</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;</span><br><span class="line"><span class="comment">// 将所有权从p3转移给p2，并将p3置空</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Zxy"</span>))</span></span>;</span><br><span class="line">p2.reset(p3.release()); <span class="comment">// reset释放了p2原来指向的内存</span></span><br></pre></td></tr></table></figure><p>需要注意：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2.release(); <span class="comment">// 错误，p2不会释放内存，而且我们丢失了指针</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.release(); <span class="comment">// 正确，但必须记得delete(p);</span></span><br></pre></td></tr></table></figure><h5 id="传递unique-ptr参数和返回unique-ptr"><a href="#传递unique-ptr参数和返回unique-ptr" class="headerlink" title="传递unique_ptr参数和返回unique_ptr"></a>传递unique_ptr参数和返回unique_ptr</h5><p>不能拷贝 <code>unique_ptr</code> 规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 <code>unique_ptr</code> 。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回局部对象的拷贝</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(p))</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="向unique-ptr传递删除器"><a href="#向unique-ptr传递删除器" class="headerlink" title="向unique_ptr传递删除器"></a>向unique_ptr传递删除器</h5><p>用 <code>unique_ptr</code> 来代替 <code>shared_ptr</code> ，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconnect (*p); &#125;;</span><br><span class="line"><span class="comment">// 创建shared_ptr时，可以传递一个（可选的）指向删除器函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;connection, <span class="keyword">decltype</span>(end_connection)*&gt; </span><br><span class="line">        p(&amp;c, end_connection);</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 当f退出时（即使时因为异常而退出），connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>decltype(end_connection)</code> 返回一个函数类型，所以我们必须添加一个 <code>*</code> 来指出我们正在使用该类型的一个指针。</p><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p><code>weak_ptr</code> 是一种不控制所指向对象生存期的智能指针，它指向一个由 <code>shared_ptr</code> 管理的对象。将一个 <code>weak_ptr</code> 绑定到一个 <code>shared_ptr</code> 不会改变 <code>shared_ptr</code> 的引用计数。一旦最后一个指向对象的 <code>shared_ptr</code> 被销毁，对象就会被释放。</p><img src="/blog/2021/01/20/C-动态内存与智能指针/weak_ptr.png"><p>创建一个 <code>weak_ptr</code> 时，要用一个 <code>shared_ptr</code> 来初始化它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>; <span class="comment">// wp弱共享p，p的引用计数未改变</span></span><br></pre></td></tr></table></figure><p>由于对象可能不存在，不能使用 <code>weak_ptr</code> 直接访问对象，必须调用 <code>lock</code>。如果对象存在， <code>lock</code> 返回一个指向共享对象的 <code>shared_ptr</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; np = wp.lock())&#123; <span class="comment">// 如果np不为空则条件成立</span></span><br><span class="line"><span class="comment">// 在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;shared_ptr&lt;/code&gt; 类&lt;/li&gt;
&lt;li&gt;直接管理内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shared_ptr&lt;/code&gt; 和 &lt;code&gt;new&lt;/code&gt; 结合使用&lt;/li&gt;
&lt;li&gt;智能指针和异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weak_ptr&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="智能指针" scheme="http://www.xingyuzhao.ltd/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>文件管理（二）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/20/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/20/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-01-20T02:53:35.000Z</published>
    <updated>2021-01-25T14:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>文件的物理结构</li><li>文件存储空间管理</li></ol><a id="more"></a><h4 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h4><p>对非空闲磁盘块的管理。磁盘中的存储单元被划分为一个个的“块、磁盘块、物理块”。<strong>磁盘块的大小与内存块、页面的大小相同</strong>。</p><h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。</p><img src="/blog/2021/01/20/文件管理（二）/连续分配目录.png"><p>优点：</p><ul><li>支持<strong>顺序访问和直接访问（即随机访问）</strong>。</li><li>连续分配的文件在顺序访问时速度最快。</li></ul><p>缺点：</p><ul><li>不方便文件拓展。</li><li>存储空间利用率低，会产生磁盘碎片。</li></ul><h5 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h5><p>链接分配采取<strong>离散</strong>分配的方式，可以为文件分配离散的磁盘块。分为<strong>隐式链接</strong>和显示链接。</p><h6 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h6><p>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p><img src="/blog/2021/01/20/文件管理（二）/隐式链接.png" style="zoom:80%;"><p>优点：</p><ul><li>方便文件拓展，不会有碎片问题，外存利用率高。</li></ul><p>缺点：</p><ul><li>只能顺序访问，查找效率低，指向下一个盘块的指针也需要消耗少量的存储空间。</li></ul><h6 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h6><p>把用于链接文件各物理块的指针显式地存放在一张表中，即<strong>文件分配表（FAT，File Allocation Table）</strong>。</p><img src="/blog/2021/01/20/文件管理（二）/显式链接.png" style="zoom:80%;"><p><em>一个磁盘仅设置一张FAT，开机时，将FAT读入内存，并常驻内存</em>。</p><p>优点：</p><ul><li>方便文件拓展，不会有碎片问题，外存利用率高，并且支持<strong>随机访问</strong>。</li><li>相比于隐式链接，地址转换不需要访问磁盘，因此文件的访问效率更高。</li></ul><p>缺点：</p><ul><li>文件分配表需要占用一定的存储空间。</li></ul><h5 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h5><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为<strong>每个文件</strong>建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</p><img src="/blog/2021/01/20/文件管理（二）/索引分配.png" style="zoom:80%;"><h6 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h6><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p><img src="/blog/2021/01/20/文件管理（二）/索引分配-链接方案.png" style="zoom:80%;"><p>缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，导致磁盘 I/O 过多，查找效率低下。</p><h6 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h6><p>建立多层索引（类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p><img src="/blog/2021/01/20/文件管理（二）/索引分配-多层索引.png" style="zoom:80%;"><p><em>采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操作</em>。</p><p>缺点：即使是小文件，访问一个数据块依然需要 K + 1 次读磁盘。</p><h6 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h6><p>多种索引分配方式的结合。例如，一个文件的顶级索引中，既包含<strong>直接地址索引（直接指向数据块）</strong>，又包含<strong>一级、二级间接索引</strong>。</p><img src="/blog/2021/01/20/文件管理（二）/索引分配-混合索引.png" style="zoom:80%;"><p>优点：对于小文件来说，访问要给数据块所需的读磁盘次数更少。</p><h5 id="文件的物理结构小结"><a href="#文件的物理结构小结" class="headerlink" title="文件的物理结构小结"></a>文件的物理结构小结</h5><img src="/blog/2021/01/20/文件管理（二）/文件的物理结构小结.png"><h4 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h4><p>对空闲磁盘块的管理。</p><p>存储空间的初始化：将各个文件卷划分为目录区、文件区。</p><ul><li>目录区存放文件目录信息（FCB）、用于词牌存储空间管理的信息。</li><li>文件区用于存放文件数据。</li></ul><h5 id="存储空间管理——空闲表法"><a href="#存储空间管理——空闲表法" class="headerlink" title="存储空间管理——空闲表法"></a>存储空间管理——空闲表法</h5><p>适用于连续分配方式。</p><p><strong>如何分配连续的存储空间</strong>：与内存管理中的动态分区分配类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p><p><strong>如何回收磁盘块</strong>：</p><ol><li>回收区前后都没有相邻空闲区。</li><li>回收区的前后都是空闲区。</li><li>回收区前面是空闲区。</li><li>回收区后面是空闲区。</li></ol><p><em>回收时注意表项的合并问题</em>。</p><h5 id="存储空间管理——空闲链表法"><a href="#存储空间管理——空闲链表法" class="headerlink" title="存储空间管理——空闲链表法"></a>存储空间管理——空闲链表法</h5><h6 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h6><img src="/blog/2021/01/20/文件管理（二）/空闲盘块链.png" style="zoom:80%;"><p>操作系统保存着<strong>链头、链尾指针</strong>。</p><p><strong>如何分配</strong>：若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针。</p><p><strong>如何回收</strong>：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p><h6 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h6><img src="/blog/2021/01/20/文件管理（二）/空闲盘区链.png" style="zoom:80%;"><p><strong>如何分配</strong>：若某文件申请 K 个盘块，可采用首次适应、最佳适应等算法从链头开始检索，找到符合的一个空闲盘区；若没有合适的连续空闲块，可将不同盘区的盘块分配给文件。</p><p><strong>如何回收</strong>：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为一个单独的空闲盘区挂到链尾。</p><h5 id="存储空间管理——位示图法"><a href="#存储空间管理——位示图法" class="headerlink" title="存储空间管理——位示图法"></a>存储空间管理——位示图法</h5><img src="/blog/2021/01/20/文件管理（二）/位示图法.png"><p><strong>位示图</strong>：每个二进制位对应一个盘号，空闲为 0，已分配为 1。位示图用<strong>字</strong>来表示，上图字长为16。可以用<strong>（字号，位号）</strong>对应一个盘块号。</p><ul><li><p>$（字号，位号）=(i,j)$ 的<strong>二进制位</strong>对应的<strong>盘块号</strong> $b=n\times i + j$。</p></li><li><p>$b$ 号<strong>盘块</strong>对应的<strong>字号</strong> $i=b/n$，位号 $j=b%n$。</p></li></ul><p><strong>如何分配</strong>：若文件需要 K 个块：</p><ol><li>顺序扫描位示图，找到 K 个相邻或不相邻的 0。</li><li>根据字号、位号算出对应的盘块号，将相应盘块分配给文件。</li><li>将相应位设置为 1。</li></ol><p><strong>如何回收</strong>：</p><ol><li>根据回收的盘块号计算出对应的字号、位号。</li><li>将相应的二进制位设为 0。</li></ol><h5 id="存储空间管理——成组链接法"><a href="#存储空间管理——成组链接法" class="headerlink" title="存储空间管理——成组链接法"></a>存储空间管理——成组链接法</h5><p>文件卷目录区用一个磁盘块作为<strong>超级块</strong>，系统启动时将其调入内存，并保证内外存超级块数据一致。</p><img src="/blog/2021/01/20/文件管理（二）/超级块.png"><p><strong>超级块（空闲盘块号栈）</strong></p><p>① 存放下一组空闲盘块的<strong>盘块号</strong>（不超过100）。</p><p>② 此组空闲盘的<strong>空闲块总数</strong> N。</p><p><strong>我的理解</strong>：超级块大小等于其他块中的第一个空闲块。都是用来存储下一组空闲块信息的，主要针对<strong>分配时只剩下一个空闲块</strong>（此空闲块存储了下一组空闲块信息）或<strong>回收时已经回收够100个空闲块</strong>的特殊情况。<strong>类似于链表中的哑节点</strong>。</p><img src="/blog/2021/01/20/文件管理（二）/超级块1.png" style="zoom:120%;"><p>最后一组的 <code>s.free[0] = -1</code>，表示空闲盘块链的结尾标志。</p><p><strong>N 兼做栈顶指针</strong></p><p>例如，当 <code>N = 100</code> 时，它指向<code>s.free(99)</code>，即 N 指向 <code>s.free(N - 1)</code>。</p><h6 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h6><p>将盘块 <code>4</code> 分配给文件，先将 <code>4</code> 出栈，再将 N 减1。同理再将 <code>3</code> 分配给文件，可得：</p><img src="/blog/2021/01/20/文件管理（二）/超级块2.png" style="zoom:120%;"><p>如果此时还要将 <code>2</code> 分配给文件（<code>2</code> 保存了下一个盘块的信息），需要进行以下操作：</p><ol><li>将 <code>2</code> 的信息保存到超级块中，将 <code>2</code> 分配给文件。</li><li>更新指针。</li></ol><img src="/blog/2021/01/20/文件管理（二）/超级块3.png" style="zoom:120%;"><h6 id="空间回收"><a href="#空间回收" class="headerlink" title="空间回收"></a>空间回收</h6><p>假如回收盘块 <code>4</code>，先将 <code>4</code> 压入栈中，再更新 N：</p><img src="/blog/2021/01/20/文件管理（二）/超级块4.png" style="zoom:120%;"><p>当栈满时，<strong>会将超级块的内容复制到新回收的块中</strong>，再更新指针，假如新回收的盘块为 <code>3</code>，可以得到下图:</p><img src="/blog/2021/01/20/文件管理（二）/超级块5.png" style="zoom:120%;"><p>再根据磁盘块 <code>3</code> 更新超级块中的栈和 N，显然 N 为1，超级块指向的下一个盘块只有 <code>3</code>，将 <code>3</code> 压入栈中，此时新回收盘块 <code>2</code>，将其压入栈中，N 再加1即可：</p><img src="/blog/2021/01/20/文件管理（二）/超级块6.png" style="zoom:120%;"><h5 id="文件的存储空间管理小结"><a href="#文件的存储空间管理小结" class="headerlink" title="文件的存储空间管理小结"></a>文件的存储空间管理小结</h5><img src="/blog/2021/01/20/文件管理（二）/文件的存储空间管理小结.png"><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>成组链接法bilibili：<a href="https://www.bilibili.com/video/av71840093/" target="_blank" rel="noopener">https://www.bilibili.com/video/av71840093/</a></p><p>实例讲解成组链接法：<a href="https://blog.csdn.net/smartab/article/details/81285353" target="_blank" rel="noopener">https://blog.csdn.net/smartab/article/details/81285353</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;文件的物理结构&lt;/li&gt;
&lt;li&gt;文件存储空间管理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="文件的物理结构" scheme="http://www.xingyuzhao.ltd/tags/%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1584-连接所有点的最小费用</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/19/LeetCode1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/19/LeetCode1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/</id>
    <published>2021-01-19T09:16:42.000Z</published>
    <updated>2021-01-19T09:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个 <code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi]</code> 。</p><p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>|xi - xj| + |yi - yj|</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p><a id="more"></a><img src="/blog/2021/01/19/LeetCode1584-连接所有点的最小费用/1584.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>points</code> 数组中两两节点相连构成一个完全图，根据 <code>Kruskal</code> 算法（并查集）找到完全图中的最小生成树，这棵树上的权值之和就是题目要求的最小费用。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Edge(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> weight) : v(v), w(w), weight(weight)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> f = [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2) -&gt; <span class="keyword">int</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(v1[<span class="number">0</span>] - v2[<span class="number">0</span>]) + <span class="built_in">abs</span>(v1[<span class="number">1</span>] - v2[<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(points.size())</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.size(); ++j)&#123;</span><br><span class="line">                edges.emplace_back(i, j, f(points[i], points[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 记录最小生成树边的个数</span></span><br><span class="line">        <span class="comment">// 每条边按照权值排序</span></span><br><span class="line">        sort(edges.begin(), edges.end(), [](Edge &amp;a, Edge &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v, w, weight] : edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uf.isConnected(v, w)) <span class="keyword">continue</span>;</span><br><span class="line">            res += weight;</span><br><span class="line">            num++;</span><br><span class="line">            uf.unionElem(v, w);</span><br><span class="line">            <span class="keyword">if</span>(num == points.size() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解：<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/lian-jie-suo-you-dian-de-zui-xiao-fei-yo-kcx7/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-cost-to-connect-all-points/solution/lian-jie-suo-you-dian-de-zui-xiao-fei-yo-kcx7/</a></p><h4 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h4><p>$\text{Kruskal}$ 算法是一种常见并且好写的最小生成树算法，由 $\text{Kruskal}$ 发明。该算法的基本思想是根据边的权值从小到大加入边，是一个贪心算法。</p><p>其算法流程为：</p><ol><li><p>将图 $G={V,E}$ 中的所有边按照长度由小到大进行排序，等长的边可以按任意顺序。</p></li><li><p>初始化图 $G’$ 初始化为 ${V,\varnothing}$，从前向后扫描排序后的边，如果扫描到的边 $e$ 在 $G’$ 中连接了两个不同的连通块,则将它插入 $G’$ 中。</p></li><li><p>最后得到的图 $G’$ 就是图 $G$ 的最小生成树。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个 &lt;code&gt;points&lt;/code&gt; 数组，表示 2D 平面上的一些点，其中 &lt;code&gt;points[i] = [xi, yi]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;连接点 &lt;code&gt;[xi, yi]&lt;/code&gt; 和点 &lt;code&gt;[xj, yj]&lt;/code&gt; 的费用为它们之间的 &lt;strong&gt;曼哈顿距离&lt;/strong&gt; ：&lt;code&gt;|xi - xj| + |yi - yj|&lt;/code&gt; ，其中 &lt;code&gt;|val|&lt;/code&gt; 表示 &lt;code&gt;val&lt;/code&gt; 的绝对值。&lt;/p&gt;
&lt;p&gt;请你返回将所有点连接的最小总费用。只有任意两点之间 &lt;strong&gt;有且仅有&lt;/strong&gt; 一条简单路径时，才认为所有点都已连接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小生成树" scheme="http://www.xingyuzhao.ltd/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode721-合并账户</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/18/LeetCode721-%E5%90%88%E5%B9%B6%E8%B4%A6%E6%88%B7/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/18/LeetCode721-%E5%90%88%E5%B9%B6%E8%B4%A6%E6%88%B7/</id>
    <published>2021-01-18T03:16:01.000Z</published>
    <updated>2021-01-25T15:09:30.317Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code> 是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code> 是 名称 <em>(name)*，其余元素是 *emails</em> 表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。</p><a id="more"></a><img src="/blog/2021/01/18/LeetCode721-合并账户/721.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据邮箱之间的连通性可以找到同一名字下的所有邮箱地址。可以将字符串映射到数字域方便建立并查集，同时需要建立反向哈希表，可以从数字得到字符串（数字必须唯一）。</p><p><strong>算法如下</strong>：</p><ul><li><p>使用并查集将同一名字下的邮箱地址进行合并。</p></li><li><p>再次遍历 <code>accounts</code>，找到每个邮箱地址对应的根节点，根据根节点建立节点间的连通关系。</p></li><li><p>从根节点邮箱找到对应的名字，然后再根据上一步的连通关系找到所有邮箱。</p></li></ul><p>细节详见代码。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(qRoot == pRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">accountsMerge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; <span class="built_in">map</span>; <span class="comment">// 建立邮箱对名字的映射</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; stoi; <span class="comment">// 将邮箱映射为数字，方便并查集处理</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; itos; <span class="comment">// 将上面的数字映射为邮箱，反向映射</span></span><br><span class="line">        <span class="comment">// 邮箱与数字之间的相互映射</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;account : accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stoi.count(account[i]))&#123;</span><br><span class="line">                    stoi[account[i]] = cnt;</span><br><span class="line">                    itos[cnt++] = account[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 邮箱对名字的映射</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;account : accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">map</span>.count(account[i]))&#123;</span><br><span class="line">                    <span class="built_in">map</span>[account[i]] = account[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建立并查集，对同一名字下的所有邮箱进行合并</span></span><br><span class="line">        <span class="comment">// 使不同的accounts之间，有相同的名字时必定在一个集合中</span></span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(stoi.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;account : accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; account.size(); ++i)&#123;</span><br><span class="line">                uf.unionElem(stoi[account[i]], stoi[account[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到邮箱对应的根节点，建立根节点与所有相连节点的映射</span></span><br><span class="line">        <span class="comment">// 此处根节点是数字，下一步需要转换为相应的邮箱（itos），再根据邮箱得到名字（map）</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; fin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;account : accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; account.size(); ++i)&#123;</span><br><span class="line">                <span class="comment">// 找到当前邮箱的根节点</span></span><br><span class="line">                <span class="keyword">int</span> root = uf.find(stoi[account[i]]);</span><br><span class="line">                <span class="comment">// 根据根节点建立连通关系</span></span><br><span class="line">                fin[root].insert(account[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m = fin.begin(); m != fin.end(); ++m)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; buf;</span><br><span class="line">            <span class="comment">// 根节点数字-&gt;根节点字符串-&gt;根节点对应的名字</span></span><br><span class="line">            buf.push_back(<span class="built_in">map</span>[itos[m-&gt;first]]);</span><br><span class="line">            <span class="comment">// 将根节点相连通的所有邮箱加入答案中，set已经进行排序</span></span><br><span class="line">            <span class="keyword">auto</span> vec = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(m-&gt;second.begin(), m-&gt;second.end());</span><br><span class="line">            buf.insert(buf.end(), vec.begin(), vec.end());</span><br><span class="line">            res.push_back(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个列表 &lt;code&gt;accounts&lt;/code&gt;，每个元素 &lt;code&gt;accounts[i]&lt;/code&gt; 是一个字符串列表，其中第一个元素 &lt;code&gt;accounts[i][0]&lt;/code&gt; 是 名称 &lt;em&gt;(name)*，其余元素是 *emails&lt;/em&gt; 表示该账户的邮箱地址。&lt;/p&gt;
&lt;p&gt;现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。&lt;/p&gt;
&lt;p&gt;合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>文件管理（一）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/16/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/16/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-01-16T03:17:11.000Z</published>
    <updated>2021-01-20T02:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>初识文件管理</li><li>文件的逻辑结构</li><li>文件目录</li></ol><a id="more"></a><h4 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h4><p>文件：一组有意义的信息/数据集合。</p><h5 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h5><p>文件名：由创建文件的用户决定，同一目录下不允许有重名文件。</p><p>标识符：操作系统用于区分各个文件（文件名相同更应如此）的一种内部名称。</p><p>类型：指明文件的类型。</p><p>位置：文件存放的路径、在外存中的地址。</p><p>大小：指明文件的大小。</p><p>创建时间、上次修改时间、文件所有者信息。</p><p>保护信息：对文件进行保护的访问控制信息。</p><h5 id="文件内部数据的组织"><a href="#文件内部数据的组织" class="headerlink" title="文件内部数据的组织"></a>文件内部数据的组织</h5><img src="/blog/2021/01/16/文件管理（一）/文件内部数据的组织.png"><h5 id="操作系统应该向上提供的功能"><a href="#操作系统应该向上提供的功能" class="headerlink" title="操作系统应该向上提供的功能"></a>操作系统应该向上提供的功能</h5><img src="/blog/2021/01/16/文件管理（一）/操作系统应该向上提供的功能.png"><ul><li><p>创建文件：新建后，图形化交互进程调用了<strong>create系统调用</strong>。</p></li><li><p>读文件：使用<strong>read系统调用</strong>，将文件数据从外存读入内存。</p></li><li><p>写文件：使用<strong>write系统调用</strong>，将文件数据从内存写回外存。</p></li><li><p>删除文件：删除后，图形化交互进程调用了<strong>delete系统调用</strong>。</p></li><li><p>打开文件：读/写文件之前，需要打开文件，使用<strong>open系统调用</strong>。</p></li><li><p>关闭文件：读/写文件结束之后，需要关闭文件，使用<strong>close系统调用</strong>。</p></li></ul><h5 id="从上往下看，文件应如何存放在外存？"><a href="#从上往下看，文件应如何存放在外存？" class="headerlink" title="从上往下看，文件应如何存放在外存？"></a>从上往下看，文件应如何存放在外存？</h5><p>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址。每个存储单元对应一个物理地址。</p><h5 id="其他需要由操作系统实现的功能"><a href="#其他需要由操作系统实现的功能" class="headerlink" title="其他需要由操作系统实现的功能"></a>其他需要由操作系统实现的功能</h5><ul><li>文件共享：使多个用户可以共享使用要给文件。</li><li>文件保护：不同的用户对文件有不同的操作权限。</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/16/文件管理（一）/初识文件管理小结.png"><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><img src="/blog/2021/01/16/文件管理（一）/文件的逻辑结构.png" style="zoom:80%;"><h5 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h5><p>文件内部的数据就是一系列的二进制流或字符流组成。又称<strong>流式文件</strong>。如 <code>txt</code> 文件。</p><h5 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h5><p>由一组相似的记录组成，又称<strong>记录式文件</strong>。每条记录由若干个数据项组成，如数据库表文件。一般每条记录有一个数据项可作为<strong>关键字</strong>。根据各条记录的长度是否相等，可分为<strong>定长记录</strong>和<strong>可变长记录</strong>。</p><h5 id="有结构文件的逻辑结构"><a href="#有结构文件的逻辑结构" class="headerlink" title="有结构文件的逻辑结构"></a>有结构文件的逻辑结构</h5><img src="/blog/2021/01/16/文件管理（一）/有结构文件的逻辑结构.png" style="zoom:80%;"><h6 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h6><p>文件中记录连续排列（逻辑上），记录可以是<strong>定长</strong>或<strong>可变长</strong>的。各个记录再物理上可以是<strong>顺序存储</strong>或<strong>链式存储</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/顺序文件存储方式.png"><ul><li>串结构：记录之间的顺序与关键字无关。</li><li>顺序结构：记录之间的顺序按关键字顺序排列。</li></ul><img src="/blog/2021/01/16/文件管理（一）/顺序文件存储方式+结构.png" style="zoom:80%;"><p>结论：定长记录的顺序文件，若物理上采用顺序存储，可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索。</p><h6 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h6><p><strong>可变长记录</strong>文件时查找第 <code>i</code> 个记录必须先查找前 <code>i-1</code> 个记录，如何解决这个问题？</p><hr><p>索引表：<strong>定长记录</strong>的<strong>顺序文件</strong>，可以快速找到第 <code>i</code> 个记录对应的索引项。应用于对信息处理的及时性要求比较好的场合。</p><img src="/blog/2021/01/16/文件管理（一）/索引表.png" style="zoom:80%;"><h6 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h6><p>与索引文件不同的是，不对每个记录都建立索引表项，而是<strong>一组记录对应一个索引表项</strong>。下图中，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不许眼按关键字排序。<strong>索引顺序文件指索引表中的项是按关键字排列的</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/索引顺序文件.png" style="zoom:80%;"><p><strong>多级索引顺序文件</strong></p><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。</p><img src="/blog/2021/01/16/文件管理（一）/多级索引顺序文件.png" style="zoom:80%;"><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/16/文件管理（一）/文件的逻辑结构小结.png"><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><img src="/blog/2021/01/16/文件管理（一）/文件目录.png" style="zoom:80%;"><h5 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h5><img src="/blog/2021/01/16/文件管理（一）/文件控制块FCB.png" style="zoom:80%;"><p><strong>FCB</strong>的有序集合称为“文件目录”，一个<strong>FCB</strong>就是一个文件<strong>目录项</strong>。</p><p><strong>FCB</strong>包含了文件的基本信息（文件名、物理地址、逻辑地址、物理结构等），存储控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（文件的建立时间、修改时间等）。</p><p><strong>最基本的是</strong>：文件名、文件存放的物理地址。</p><p>对目录进行的操作：</p><ul><li>搜索：系统根据文件名搜索目录，找到该文件对应的目录项。</li><li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项。</li><li>删除文件：当删除一个文件时，需要在目录中删除对应的目录项。</li><li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性。</li><li>修改目录：目录中保存了某些文件属性，这些属性变化时需要修改相应的目录项（如文件重命名）。</li></ul><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><h6 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h6><p>实现了<strong>按名存取</strong>，但是<strong>不允许文件重名</strong>。不适合多用户操作系统</p><img src="/blog/2021/01/16/文件管理（一）/单级目录结构.png" style="zoom:80%;"><h6 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h6><p>分为<strong>主文件目录</strong>和<strong>用户文件目录</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/两级目录结构.png" style="zoom:80%;"><h6 id="多级目录结构（树形目录结构）"><a href="#多级目录结构（树形目录结构）" class="headerlink" title="多级目录结构（树形目录结构）"></a>多级目录结构（树形目录结构）</h6><p>文件路径名是个字符串，各级目录之间用”/“隔开， 从根目录出发的路径称为<strong>绝对路径</strong>。系统根据绝对路径一层一层的找到下一级目录。树形结构<strong>不利于实现文件共享</strong>。</p><img src="/blog/2021/01/16/文件管理（一）/多级目录结构.png" style="zoom:80%;"><p><code>自拍.jpg</code>的绝对路径为<code>/照片/2015-0/自拍.jpg</code>。找到此文件需要3次读磁盘I/O操作。</p><p>每次从根目录查找很低效，可以设置<strong>当前目录</strong>，当用户访问某个文件时，可以使用<strong>从当前目录出发</strong>的<strong>相对路径</strong>。</p><h6 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h6><img src="/blog/2021/01/16/文件管理（一）/无环图目录结构.png" style="zoom:80%;"><p>用户提出删除节点时，只删除该用户的PCB，并使共享计数器减1，不会直接删去共享节点。只要共有计数器减为0时才删除节点。</p><h5 id="索引节点（FCB的改进）"><a href="#索引节点（FCB的改进）" class="headerlink" title="索引节点（FCB的改进）"></a>索引节点（FCB的改进）</h5><p>一般查找只需要用到<strong>文件名</strong>这个信息，文件名匹配时才需要读出文件的其他信息，所以可以使目录表包含最有用的信息来提高效率，如下图：</p><img src="/blog/2021/01/16/文件管理（一）/索引节点.png" style="zoom:80%;"><p>存放在<strong>外存</strong>的索引节点称为<strong>磁盘索引节点</strong>，当索引节点<strong>放入内存</strong>后称为<strong>内存索引节点</strong>。内存索引节点需要增加一些信息，如：文件是否被修改，此时有几个进程在访问该文件等。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/16/文件管理（一）/文件目录小结.png">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;初识文件管理&lt;/li&gt;
&lt;li&gt;文件的逻辑结构&lt;/li&gt;
&lt;li&gt;文件目录&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="文件的逻辑结构" scheme="http://www.xingyuzhao.ltd/tags/%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/"/>
    
      <category term="文件目录" scheme="http://www.xingyuzhao.ltd/tags/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode947-移除最多的同行或同列石头</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/15/LeetCode947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/15/LeetCode947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4/</id>
    <published>2021-01-15T14:06:08.000Z</published>
    <updated>2021-01-15T14:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p><p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p><p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [xi, yi]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p><a id="more"></a><img src="/blog/2021/01/15/LeetCode947-移除最多的同行或同列石头/947.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这个题的意思是：某行或者某列上最多只能存在一个石头，求移除的石头总数。</p><p>对于 <code>stones</code> 中任意两个位置，如果相对应的位置有一个相等，说明两个位置存在<strong>相同的</strong>行或者列，可以合并为一个集合。根据上述条件，使用双重循环将 <code>stones</code> 两两结合，最终合并的次数就是移除的石头个数，可以由 <code>stones</code> 的长度减去并查集中连通分量个数得到。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stones[i][<span class="number">0</span>] == stones[j][<span class="number">0</span>] || stones[i][<span class="number">1</span>] == stones[j][<span class="number">1</span>])</span><br><span class="line">                    uf.unionElem(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones.size() - uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为 <code>O(n^2)</code>。</p><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>如果将 <code>stones</code> 中的位置与其相应的行或者列绑定，那么可以将二维降为一维，将行和列当作一个数字，降低了时间复杂度。</p><ul><li>当遍历到点 <code>[x,y]</code> 时，直接将 <code>x</code> 和 <code>y</code> 进行合并，表示该行和该列的点属于同一个并查集（根节点相同）。</li><li><code>x</code> 和 <code>y</code> 的值可能相等，相等时不能进行合并（一维情况下，行与列需要区分开），根据题目范围，将 <code>y</code> 加上10001，两者不会重合。</li></ul><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; parent, rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind():count(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当不存在p时，创建p并且指向自身，根节点数加1</span></span><br><span class="line">        <span class="keyword">if</span>(!parent.count(p))&#123;</span><br><span class="line">            parent[p] = p;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        unionFind uf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;stone : stones)&#123;</span><br><span class="line">            uf.unionElem(stone[<span class="number">0</span>], stone[<span class="number">1</span>] + <span class="number">10001</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones.size() - uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>题解：<a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。&lt;/p&gt;
&lt;p&gt;如果一块石头的 &lt;strong&gt;同行或者同列&lt;/strong&gt; 上有其他石头存在，那么就可以移除这块石头。&lt;/p&gt;
&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;stones&lt;/code&gt; ，其中 &lt;code&gt;stones[i] = [xi, yi]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 块石头的位置，返回 &lt;strong&gt;可以移除的石子&lt;/strong&gt; 的最大数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode684-冗余连接</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/13/LeetCode684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/13/LeetCode684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-01-13T03:10:42.000Z</published>
    <updated>2021-01-15T14:45:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对 <code>[u, v]</code>，满足 <code>u &lt; v</code>，表示连接顶点 <code>u</code> 和 <code>v</code> 的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p><a id="more"></a><img src="/blog/2021/01/13/LeetCode684-冗余连接/684.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>并查集中使用 <code>count</code> 记录当前还有多少个根节点，如果<strong>上一次的根节点数等于本次的根节点数</strong>，说明本次的合并无效，记录当前坐标即可。一次遍历结束后，找到了不需要进行合并的最后一个边。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 合并一次，根节点数减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(edges.size())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> pre; <span class="comment">// 上一次根节点数</span></span><br><span class="line">        <span class="keyword">int</span> index; <span class="comment">// 不需要合并的最后一个边的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            pre = uf.getCount();</span><br><span class="line">            uf.unionElem(edges[i][<span class="number">0</span>] - <span class="number">1</span>, edges[i][<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 上次根节点数等于本次合并后根节点数，更新index</span></span><br><span class="line">            <span class="keyword">if</span>(pre == uf.getCount()) index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在本问题中, 树指的是一个连通且无环的无向图。&lt;/p&gt;
&lt;p&gt;输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。&lt;/p&gt;
&lt;p&gt;结果图是一个以边组成的二维数组。每一个边的元素是一对 &lt;code&gt;[u, v]&lt;/code&gt;，满足 &lt;code&gt;u &amp;lt; v&lt;/code&gt;，表示连接顶点 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 的无向图的边。&lt;/p&gt;
&lt;p&gt;返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 &lt;code&gt;[u, v]&lt;/code&gt; 应满足相同的格式 &lt;code&gt;u &amp;lt; v&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1203-项目管理</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/12/LeetCode1203-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/12/LeetCode1203-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2021-01-12T14:53:37.000Z</published>
    <updated>2021-01-12T15:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>公司共有 <code>n</code> 个项目和  <code>m</code> 个小组，每个项目要不无人接手，要不就由 <code>m</code> 个小组之一负责。</p><p><code>group[i]</code> 表示第 <code>i</code> 个项目所属的小组，如果这个项目目前无人接手，那么 <code>group[i]</code> 就等于 <code>-1</code>。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。</p><p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p><p>同一小组的项目，排序后在列表中彼此相邻。<br>项目之间存在一定的依赖关系，我们用一个列表 <code>beforeItems</code> 来表示，其中 <code>beforeItems[i]</code> 表示在进行第 <code>i</code> 个项目前（位于第 <code>i</code> 个项目左侧）应该完成的所有项目。<br>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 <strong>空列表</strong> 。</p><a id="more"></a><img src="/blog/2021/01/12/LeetCode1203-项目管理/1203.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题是真的难，看了别人的题解才勉强写出来。</p><h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><p>在有向无环图（DAG）问题中，如果节点之间含有<strong>依赖关系</strong>，比如要完成 <code>B</code> 工作，必须先完成 <code>A</code> 工作，考虑进行<strong>拓扑排序</strong>，有关知识点参考<a href="https://www.cnblogs.com/bigsai/p/11489260.html" target="_blank" rel="noopener">这里</a>。</p><p><strong>C++模板</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图，节点入度，节点编号</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inDegree, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;id)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : id)&#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>; <span class="comment">// 记录已经出队多少个点，小于节点数说明有环</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; afterSort;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">// 取出第一个入度为0的点</span></span><br><span class="line">        <span class="keyword">int</span> cur = q.front();</span><br><span class="line">        afterSort.push_back(cur);</span><br><span class="line">        q.pop();</span><br><span class="line">        times++;</span><br><span class="line">        <span class="comment">// 遍历图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); ++i)&#123;</span><br><span class="line">            inDegree[G[cur][i]]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[G[cur][i]] == <span class="number">0</span>)</span><br><span class="line">                q.push(G[cur][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(times &lt; id.size()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> afterSort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关于本题"><a href="#关于本题" class="headerlink" title="关于本题"></a>关于本题</h5><p>从宏观来看，本题要求同一小组所处理的项目是相邻的，<strong>小组与小组之间</strong>是有依赖关系的，根据 <code>Before</code> 得到。同时，<strong>项目与项目之间</strong>也是有依赖关系的，也是由 <code>Before</code> 得到。以示例1为例：</p><ul><li>项目与项目之间：对于小组0，3必须在6之后，4必须在3和6之后。</li><li>小组与小组之间：小组-1中的1必须在小组0中的6之后。</li></ul><p>根据以上两条信息，可以先对所有小组进行拓扑排序，再对排好序的小组集合中的每个小组进行一个拓扑排序，就可以得到结果了。<strong>所有小组号为-1的表示当前未进行处理，可以给其分配一个新的组号，从m开始递增</strong>，只要拓扑排序时无环，所有的项目都会被处理掉。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortItems</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; group, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; beforeItems)</span></span>&#123;      </span><br><span class="line">        <span class="comment">// 将同一组的放一起</span></span><br><span class="line">        <span class="comment">// 比如3, 4, 6分组为0，则sameGroup[0] = &#123;3,4,6&#125;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">sameGroup</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> samegroup = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(group[i] == <span class="number">-1</span>) group[i] = samegroup++;</span><br><span class="line">            sameGroup[group[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最多会有n + m个小组（比如m=2, 所有分组都为-1）</span></span><br><span class="line">        <span class="comment">// n + m个小组的序号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; groupid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m; ++i) groupid.push_back(i);</span><br><span class="line">        <span class="comment">// 建立group图和item图及其入度</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">itemGraph</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">groupGraph</span><span class="params">(n + m)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">itemIndegree</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">groupIndegree</span><span class="params">(n + m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; beforeItems.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curId = group[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : beforeItems[i])&#123;</span><br><span class="line">                <span class="comment">// 如果是同一个组，那么有item-&gt;i</span></span><br><span class="line">                <span class="comment">// i入度+1，同时节点item可达i</span></span><br><span class="line">                <span class="keyword">if</span>(group[item] == curId)&#123; </span><br><span class="line">                    itemIndegree[i]++;</span><br><span class="line">                    itemGraph[item].push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不同组，有小组group[item]-&gt;curId</span></span><br><span class="line">                <span class="comment">// 小组curId入度+1，同时小组group[item]可达curId</span></span><br><span class="line">                <span class="keyword">else</span>&#123; </span><br><span class="line">                    groupIndegree[curId]++;</span><br><span class="line">                    groupGraph[group[item]].push_back(curId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对group图进行topSort，得到小组之间的拓扑关系</span></span><br><span class="line">        <span class="keyword">auto</span> outGroup = topSort(groupGraph, groupIndegree, groupid);</span><br><span class="line">        <span class="comment">// 对每个小组进行topSort，得到组内的拓扑关系</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;g : outGroup)&#123;</span><br><span class="line">            <span class="keyword">auto</span> id = sameGroup[g];</span><br><span class="line">            <span class="keyword">if</span>(id.empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> res = topSort(itemGraph, itemIndegree, id);</span><br><span class="line">            <span class="keyword">if</span>(res.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r : res)</span><br><span class="line">                ret.push_back(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数：图，入度，当前的节点集合</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inDegree, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;id)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : id)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>; <span class="comment">// 记录已经出队多少个点，小于id数说明有环</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; afterSort;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="comment">// 取出第一个入度为0的点</span></span><br><span class="line">            <span class="keyword">int</span> cur = q.front();</span><br><span class="line">            afterSort.push_back(cur);</span><br><span class="line">            q.pop();</span><br><span class="line">            times++;</span><br><span class="line">            <span class="comment">// 遍历图</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); ++i)&#123;</span><br><span class="line">                inDegree[G[cur][i]]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[G[cur][i]] == <span class="number">0</span>)</span><br><span class="line">                    q.push(G[cur][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times &lt; id.size()) <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 有环，返回空</span></span><br><span class="line">        <span class="keyword">return</span> afterSort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>题解：<a href="https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/chao-xiang-xi-shuang-ceng-tuo-bu-pai-xu-5cyuc/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/solution/chao-xiang-xi-shuang-ceng-tuo-bu-pai-xu-5cyuc/</a></p><p>拓扑排序：<a href="https://www.cnblogs.com/bigsai/p/11489260.html" target="_blank" rel="noopener">https://www.cnblogs.com/bigsai/p/11489260.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;公司共有 &lt;code&gt;n&lt;/code&gt; 个项目和  &lt;code&gt;m&lt;/code&gt; 个小组，每个项目要不无人接手，要不就由 &lt;code&gt;m&lt;/code&gt; 个小组之一负责。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;group[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个项目所属的小组，如果这个项目目前无人接手，那么 &lt;code&gt;group[i]&lt;/code&gt; 就等于 &lt;code&gt;-1&lt;/code&gt;。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。&lt;/p&gt;
&lt;p&gt;请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：&lt;/p&gt;
&lt;p&gt;同一小组的项目，排序后在列表中彼此相邻。&lt;br&gt;项目之间存在一定的依赖关系，我们用一个列表 &lt;code&gt;beforeItems&lt;/code&gt; 来表示，其中 &lt;code&gt;beforeItems[i]&lt;/code&gt; 表示在进行第 &lt;code&gt;i&lt;/code&gt; 个项目前（位于第 &lt;code&gt;i&lt;/code&gt; 个项目左侧）应该完成的所有项目。&lt;br&gt;如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 &lt;strong&gt;空列表&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="拓扑排序" scheme="http://www.xingyuzhao.ltd/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode1202-交换字符串中的元素</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/11/LeetCode1202-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/11/LeetCode1202-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2021-01-11T02:27:01.000Z</published>
    <updated>2021-01-11T03:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 <code>s</code>，以及该字符串中的一些「索引对」数组 <code>pairs</code>，其中 <code>pairs[i] = [a, b]</code> 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 <strong>任意多次交换</strong> 在 <code>pairs</code> 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，<code>s</code> 可以变成的按字典序最小的字符串。</p><a id="more"></a><img src="/blog/2021/01/11/LeetCode1202-交换字符串中的元素/1202.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><del>不看提示我都没想到用并查集去解决这个问题</del>。</p><p>以示例三为例：<code>s = &quot;cba&quot;, pairs = [[0,1],[1,2]]</code>，输出为 <code>&quot;abc&quot;</code>。可以看出 <code>pairs</code> 中 <code>0,1,2</code> 三个点是相连的。相连的点在 <code>s</code> 中对应的元素 <code>&quot;cba&quot;</code> 可以任意排序，我们需要让这些元素的组合字典序最小，可以得到 <code>&quot;abc&quot;</code>。</p><p>将上述例子扩充，<code>s = &quot;cbafd&quot;, pairs = [[0,1],[1,2],[4,3]]</code>，输出为 <code>&quot;abcdf&quot;</code>。其中 <code>0,1,2</code> 相连，<code>4,3</code> 相连，分别将两个集合中对应的位置<strong>升序排序</strong>得到 <code>0,1,2</code> 和 <code>3,4</code>，再将 <code>s</code> 中对应位置元素取出来按照<strong>字典序排序</strong>，再根据对应位置修改 <code>s</code> 中的元素。所以<strong>一共需要进行两次排序</strong>。</p><hr><p>我们将 <code>pairs</code> 中的<strong>每一个</strong>元素想象成一个孤立的点，对于 <code>pairs</code> 中的<strong>每一对</strong>元素，表示两个点相连，所有相连的点构成不同的集合（只需要知道是否相连，不需要知道如何相连），所以使用并查集即可。</p><p><strong>算法如下</strong>：</p><ul><li>将 <code>pairs</code> 中的<strong>每一对</strong>元素进行 <code>union</code> 操作，再将它们根据共同祖先分为<strong>若干集合</strong>。</li><li>将每个集合中的序列<strong>升序排列</strong>，再找到 <code>s</code> 中对应的元素，将这些元素按<strong>字典序</strong>排序。</li><li>将按字典序排列的元素按照集合中序列的顺序依次修改 <code>s</code>。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 未用到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>; <span class="comment">// 未用到</span></span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            rank[pRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pairs.size() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); ++i)&#123;</span><br><span class="line">            uf.unionElem(pairs[i][<span class="number">0</span>], pairs[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> rootIdx = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(s.size());</span><br><span class="line">        <span class="comment">// 如果祖先相同，代表在同一个集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> root = uf.find(i);</span><br><span class="line">            rootIdx[root].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rootIdx.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rootIdx[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将同一个祖先的序列升序排列</span></span><br><span class="line">            sort(rootIdx[i].begin(), rootIdx[i].end());</span><br><span class="line">            <span class="built_in">string</span> buf;</span><br><span class="line">            <span class="comment">// 根据排好序的序列取出s中的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : rootIdx[i])&#123;</span><br><span class="line">                buf += s[v];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再将取出的元素按照字典序排列</span></span><br><span class="line">            sort(buf.begin(), buf.end());</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将排好序的字符串根据排好序的序列修改s中相应的位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : rootIdx[i])&#123;</span><br><span class="line">                s[v] = buf[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，以及该字符串中的一些「索引对」数组 &lt;code&gt;pairs&lt;/code&gt;，其中 &lt;code&gt;pairs[i] = [a, b]&lt;/code&gt; 表示字符串中的两个索引（编号从 0 开始）。&lt;/p&gt;
&lt;p&gt;你可以 &lt;strong&gt;任意多次交换&lt;/strong&gt; 在 &lt;code&gt;pairs&lt;/code&gt; 中任意一对索引处的字符。&lt;/p&gt;
&lt;p&gt;返回在经过若干次交换后，&lt;code&gt;s&lt;/code&gt; 可以变成的按字典序最小的字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode228-汇总区间</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/10/LeetCode228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/10/LeetCode228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</id>
    <published>2021-01-10T09:05:25.000Z</published>
    <updated>2021-01-10T09:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p><p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><a id="more"></a><img src="/blog/2021/01/10/LeetCode228-汇总区间/228.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果序列满足 <code>nums[i] == nums[i - 1]</code> 代表它们是同一个区间。</p><p>需要记录区间的起始位置的终止位置，使用双指针，<code>i</code> 代表当前区间的起始位置， <code>j</code> 代表当前区间的终止位置。</p><p>遍历结束时，还需要<strong>把最后一个区间加入答案中</strong>，如果最后一个区间的 <code>j - i == 1</code>，说明最后一个区间只有一个数，否则，需要再加入一个新的区间。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i + <span class="number">1</span>)&#123;</span><br><span class="line">                    ret.push_back(to_string(nums[i]));</span><br><span class="line">                    j++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ret.push_back(to_string(nums[i]) + <span class="string">"-&gt;"</span> + to_string(nums[j - <span class="number">1</span>]));</span><br><span class="line">                    i = j;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == j - <span class="number">1</span>) ret.push_back(to_string(nums[i]));</span><br><span class="line">        <span class="keyword">if</span>(i != j - <span class="number">1</span>) ret.push_back(to_string(nums[i]) + <span class="string">"-&gt;"</span> + to_string(nums[j - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个无重复元素的有序整数数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;返回 &lt;strong&gt;恰好覆盖数组中所有数字&lt;/strong&gt; 的 &lt;strong&gt;最小有序&lt;/strong&gt; 区间范围列表。也就是说，&lt;code&gt;nums&lt;/code&gt; 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 &lt;code&gt;nums&lt;/code&gt; 的数字 &lt;code&gt;x&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;列表中的每个区间范围 &lt;code&gt;[a,b]&lt;/code&gt; 应该按如下格式输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a-&amp;gt;b&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a != b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt; ，如果 &lt;code&gt;a == b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="双指针" scheme="http://www.xingyuzhao.ltd/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode189-旋转数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/08/LeetCode189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/08/LeetCode189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2021-01-08T15:12:16.000Z</published>
    <updated>2021-01-10T09:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>进阶</strong>：</p><ul><li>尽可能想出更多的解决方案，<del>至少有三种不同的方法可以解决这个问题</del>。</li><li>你可以使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法解决这个问题吗？</li></ul><a id="more"></a><img src="/blog/2021/01/08/LeetCode189-旋转数组/189.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据 <code>k</code> 值，将 <code>nums</code> 数组分为前后两个部分。将后 <code>k</code> 个值截取出来得到的数组，拼接到剩余数组之前即可。空间复杂度为 <code>O(n)</code>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 99% 9%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size(); <span class="comment">// 如果k大于nums的长度，取余之后再进行处理</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buf1</span><span class="params">(nums.begin() + nums.size() - k, nums.end())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">buf2</span><span class="params">(nums.begin(), nums.begin() + nums.size() - k)</span></span>;</span><br><span class="line">        buf1.insert(buf1.end(), buf2.begin(), buf2.end());</span><br><span class="line">        nums = buf1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>上述的空间复杂度为 <code>O(n)</code>，可以进一步压缩空间，使空间复杂度降为 <code>O(1)</code>。</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>具体思路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k = 3;</span><br><span class="line">----&gt;--&gt; 移动后得到 --&gt;----&gt;</span><br><span class="line">可以对原始序列进行如下操作：</span><br><span class="line">----&gt;--&gt; 反转后 &lt;--&lt;----</span><br><span class="line">其中&lt;-- 反转后 --&gt;&lt;----</span><br><span class="line">其中&lt;---- 反转后 --&gt;----&gt;</span><br></pre></td></tr></table></figure><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库函数 50.50% 84.77%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.begin() + k);</span><br><span class="line">        reverse(nums.begin() + k, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 非库函数 50.50% 74.88%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然速度慢了点（实际上为 <code>O(2n) = O(n)</code> ），不过空间使用较之前还是低了很多。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>官方题解及其评论区：<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 &lt;code&gt;k&lt;/code&gt; 个位置，其中 &lt;code&gt;k&lt;/code&gt; 是非负数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能想出更多的解决方案，&lt;del&gt;至少有三种不同的方法可以解决这个问题&lt;/del&gt;。&lt;/li&gt;
&lt;li&gt;你可以使用空间复杂度为 O(1) 的 &lt;strong&gt;原地&lt;/strong&gt; 算法解决这个问题吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>内存管理（五）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2021-01-08T09:41:08.000Z</published>
    <updated>2021-01-10T15:32:06.303Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h4><ol><li>虚拟内存基本概念</li><li>请求分页管理方式</li><li>页面置换算法</li><li>页面分配策略</li></ol><a id="more"></a><h4 id="虚拟内存基本概念"><a href="#虚拟内存基本概念" class="headerlink" title="虚拟内存基本概念"></a>虚拟内存基本概念</h4><h5 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h5><p>传统存储管理特点：</p><ol><li>一次性：作业必须<strong>一次性全部装入内存</strong>才能开始运行。</li><li>驻留性：一旦作业被装入内存，就<strong>会一直驻留在内存中</strong>。</li></ol><p>很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。</p><h5 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h5><ul><li>时间局部性</li><li>空间局部性</li></ul><h5 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h5><p>虚拟内存：若内存空间不够，由<strong>操作系统</strong>负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong>。虚拟性体现在：实际的物理内存大小没有变，只是在逻辑上进行了扩充。</p><ul><li>虚拟内存最大容量：计算机的地址结构（CPU寻址范围）确定。</li><li>虚拟内存实际容量：<em>min</em>(内存和外存容量之和，CPU寻址范围)。</li></ul><p>虚拟内存有以下三个特征：</p><ol><li>多次性（对应一次性）：允许作业被分成多次调入内存。</li><li>对换性（对应驻留性）：允许作业运行中，将作业换出、换入内存。</li><li>虚拟性：从逻辑上扩充了内存的容量。</li></ol><h5 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h5><img src="/blog/2021/01/08/内存管理（五）/虚拟内存的实现.png"><p>虚拟内存技术基于<strong>离散分配</strong>的内存管理方式。<strong>请求分页存储管理</strong>与<strong>基本分页存储管理</strong>的<strong>主要区别</strong>是：操作系统需要提供<strong>请求调页</strong>和<strong>页面置换</strong>功能。</p><ul><li>请求调页：程序执行过程中，当所访问信息<strong>不在内存中</strong>时，由操作系统负责<strong>将所需信息从外存调入内存</strong>。</li><li>页面置换：若内存空间不够，由操作系统将<strong>内存中暂时用不到的信息换出到外存</strong>。</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/虚拟内存基本概念小结.png" style="zoom:120%;"><h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><img src="/blog/2021/01/08/内存管理（五）/请求分页管理方式.png"><h5 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h5><ul><li>为了实现<strong>请求调页</strong>，操作系统需要知道每个页面是否已经调入内存；如果没调入，那么也需要知道该页面在外存中存放的位置。</li><li>为了实现<strong>内存置换</strong>，操作系统需要通过某些指标来决定到底换出哪个页面。需要记录各个页面是否被修改过，修改过才需要换出，将外存中的旧数据覆盖。</li></ul><img src="/blog/2021/01/08/内存管理（五）/页表机制.png"><h5 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h5><p>请求分页系统中，若访问页面<strong>不在内存中</strong>时，便产生一个<strong>缺页中断</strong>。然后由操作系统的<strong>缺页中断处理程序</strong>处理中断。此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><ul><li><p>如果内存中<strong>有空闲块</strong>，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中对应页表项。</p></li><li><p>如果内存中<strong>无空闲块</strong>，则由<strong>页面置换算法</strong>选择<strong>淘汰</strong>一个页面，若该页面在内存期间被<strong>修改过</strong>，则要将其<strong>写回外存</strong>。未修改过的页面不用写回外存。</p></li></ul><p>缺页中断是由于当前指令想要访问的目标页面未调入内存而产生的，因此属于<strong>内中断</strong>。一条指令在执行期间，可能产生<strong>多次</strong>缺页中断。</p><img src="/blog/2021/01/08/内存管理（五）/缺页中断机构.png"><h5 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h5><img src="/blog/2021/01/08/内存管理（五）/地址变化机构.png"><ul><li>新增步骤1：请求调页（查到页表项时进行判断）。</li><li>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行）。</li><li>新增步骤3：需要修改请求页表中新增的表项。</li></ul><img src="/blog/2021/01/08/内存管理（五）/地址变化机构步骤.png" style="zoom:120%;"><p>补充：</p><ol><li>换入/换出页面需要启动慢速I/O操作，如果过于频繁，会有很大开销。</li><li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li></ol><p>在具有快表的请求分页系统中，访问一个逻辑地址时，若发生缺页，地址变换步骤为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查快表（未命中）-&gt;查慢表（发现未调入内存）-&gt;调页（调入的页面对应的表项会直接加入快表）</span><br><span class="line">-&gt;查快表（命中）-&gt;访问目标内存单元</span><br></pre></td></tr></table></figure><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/地址变化机构小结.png" style="zoom:120%;"><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><img src="/blog/2021/01/08/内存管理（五）/页面置换算法.png" style="zoom:80%;"><h5 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h5><p>每次选择淘汰的页面<strong>以后永不使用</strong>或<strong>最长时间内不再被访问</strong>，保证最低缺页率。</p><p>缺点：只有进程执行的过程中才能知道接下来会访问到哪个页面，操作系统无法提前预判访问序列。因此，最佳置换算法<strong>无法实现</strong>。</p><h5 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h5><p>每次选择淘汰的页面是<strong>最早进入内存的页面</strong>。</p><p>Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>缺点：只有FIFO算法会产生<strong>Belady异常</strong>，虽然其实现简单，但是与进程实际运行时规律不适应，因为先进入的页面也有可能最经常被访问。因此算法<strong>性能差</strong>。</p><h5 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h5><p>每次选择淘汰的页面是<strong>最近最久未使用的页面</strong>。用每个页面页表项中的<strong>访问字段</strong>记录该页面自上次被访问以来所经历的时间 t 。淘汰时选择 t 最大的页面。</p><p>缺点：实现需要专门的硬件支持，虽然算法性能好，但<strong>实现困难，开销大</strong>。</p><h5 id="时钟置换算法（CLOCK）"><a href="#时钟置换算法（CLOCK）" class="headerlink" title="时钟置换算法（CLOCK）"></a>时钟置换算法（CLOCK）</h5><p>此算法是一种性能和开销较均衡的算法，也称<strong>最近未用算法（NRU，Not Recently Used）</strong>。</p><p>简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个<strong>循环队列</strong>。当某页被访问时，其<strong>访问位置为1</strong>。<strong>当需要淘汰一个页面时，只需检查页的访问位</strong>。</p><img src="/blog/2021/01/08/内存管理（五）/简单clock.png"><ul><li>如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面。</li><li>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）。</li></ul><h6 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h6><p>简单的CLOCK算法<strong>仅考虑一个页面最近是否被访问过</strong>，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<strong>只有被淘汰的页面被修改过，才需要写回外存</strong>。</p><p>因此，在其他条件都相同时，应<strong>优先淘汰没有修改过的页面</strong>，避免I/O操作。修改位为0时表示没有修改过，修改位为1，表示页面被修改过。</p><p>改进型CLOCK置换算法选择一个淘汰页面最多会进行<strong>四轮扫描</strong>。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/页面置换算法小结.png"><h4 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h4><h5 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h5><p>驻留集：请求分页存储管理中给进程分配的物理块的集合。驻留集大小一般小于进程的总大小。</p><ul><li>若驻留集太小，会导致缺页频繁。</li><li>若驻留集太大，会导致多道程序并发度下降。</li></ul><p>固定分配：操作系统为每个进程分配一组固定数目的物理块。进程运行期间驻留集<strong>大小不变</strong>。</p><p>可变分配：驻留集<strong>大小可变</strong>。</p><p>局部置换：缺页时只能选进程自己的物理块进行置换。</p><p>全局置换：操作系统保留的空闲物理块和别的进程持有的物理块（先置换到外存）都可以分配给缺页进程。</p><img src="/blog/2021/01/08/内存管理（五）/页面置换策略.png"><p>可变分配<strong>全局</strong>置换：只要缺页就给分配新物理块。</p><p>可变分配<strong>局部</strong>置换：根据<strong>缺页的频率</strong>来动态地增加或减少进程的物理块。</p><h5 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h5><ol><li>预调页策略：根据空间局部性，一次调入若干相邻的页面可能比一次调入一个页面更高效。主要用于<strong>进程的首次调入</strong>，由程序员指出（<strong>运行前调入</strong>）。</li><li>请求调页策略：进程在<strong>运行期间</strong>发现缺页时才将所缺页面调入内存。I/O开销较大（每次只能调入一页，每次调页都要进行磁盘I/O）。</li></ol><h5 id="何处调入页面"><a href="#何处调入页面" class="headerlink" title="何处调入页面"></a>何处调入页面</h5><h6 id="系统拥有足够的对换区空间"><a href="#系统拥有足够的对换区空间" class="headerlink" title="系统拥有足够的对换区空间"></a>系统拥有足够的对换区空间</h6><img src="/blog/2021/01/08/内存管理（五）/何处调入1.png"><h6 id="系统缺少足够的对换区空间"><a href="#系统缺少足够的对换区空间" class="headerlink" title="系统缺少足够的对换区空间"></a>系统缺少足够的对换区空间</h6><img src="/blog/2021/01/08/内存管理（五）/何处调入2.png"><h6 id="UNIX方式"><a href="#UNIX方式" class="headerlink" title="UNIX方式"></a>UNIX方式</h6><img src="/blog/2021/01/08/内存管理（五）/何处调入3.png"><h5 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h5><p>刚换出的页面马上要换入内存，或刚换入的需要换出，这种频繁的页面调度行为称为<strong>抖动（颠簸）</strong>。主要原因是进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）。</p><h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合。</p><p>工作集：指在某段时间间隔里，进程实际访问页面的集合。</p><img src="/blog/2021/01/08/内存管理（五）/工作集.png"><p><strong>窗口尺寸为4</strong>。</p><p><strong>工作集大小</strong>可能小于窗口尺寸，一般来说，驻留集大小不能<strong>小于</strong>工作集大小，否则进程运行过程中将频繁缺页。</p><h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><img src="/blog/2021/01/08/内存管理（五）/页面分配策略小结.png" style="zoom:120%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;虚拟内存基本概念&lt;/li&gt;
&lt;li&gt;请求分页管理方式&lt;/li&gt;
&lt;li&gt;页面置换算法&lt;/li&gt;
&lt;li&gt;页面分配策略&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.xingyuzhao.ltd/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="虚拟内存" scheme="http://www.xingyuzhao.ltd/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode547-省份数量</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/07/LeetCode547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/07/LeetCode547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</id>
    <published>2021-01-07T12:58:59.000Z</published>
    <updated>2021-01-07T13:30:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><a id="more"></a><img src="/blog/2021/01/07/LeetCode547-省份数量/547.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题的核心问题是<strong>节点之间是否相连</strong>。如果找到了这个核心点，就可以想到两种解决方案。一种是图论中，计算<strong>连通分量</strong>的个数；另一种是并查集，找到大家的<strong>公共祖先</strong>的个数。</p><p>考虑到我们并不需要知道节点与节点之间<strong>如何连接</strong>，只需要知道节点与节点之间<strong>是否连接</strong>，所以使用<strong>并查集</strong>来解决这个问题就足够了。</p><p>并查集的相关知识可参考<a href="%5Bhttp://www.xingyuzhao.ltd/blog/2020/09/06/%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find/">这里</a>，建议先看！</p><p>输入矩阵的长或者宽（其实就是一个邻接矩阵）的大小就是城市的个数，所以对于并查集的初始化，我们只需要设置长度与城市个数相等的<code>parent</code>数组即可，并且指向自身，同时可以初始化当前祖先的总数，即城市的个数。</p><p>在遍历<code>isconnected</code>矩阵时，遇到<code>isconnected[i][j]</code>为 1 时，代表<code>i, j</code>两节点相连，进行<code>union(i, j)</code>操作。同时祖先数减去 1 。否则不相连，不进行任何操作。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unionFind(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            count++;</span><br><span class="line">            rank.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == parent[p] ? p : parent[p] = find(parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElem</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根不同，将其相连，计数减1</span></span><br><span class="line">        <span class="keyword">if</span>(rank[pRoot] &lt; rank[qRoot])&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[pRoot] &gt; rank[qRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[pRoot] = qRoot; <span class="comment">// 随便指一个</span></span><br><span class="line">            rank[qRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isConnected.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">unionFind <span class="title">uf</span><span class="params">(isConnected)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> m = isConnected.size();</span><br><span class="line">        <span class="keyword">int</span> n = isConnected[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    uf.unionElem(i, j);</span><br><span class="line">                &#125;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个城市，其中一些彼此相连，另一些没有相连。如果城市 &lt;code&gt;a&lt;/code&gt; 与城市 &lt;code&gt;b&lt;/code&gt; 直接相连，且城市 &lt;code&gt;b&lt;/code&gt; 与城市 &lt;code&gt;c&lt;/code&gt; 直接相连，那么城市 &lt;code&gt;a&lt;/code&gt; 与城市 &lt;code&gt;c&lt;/code&gt; 间接相连。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;省份&lt;/strong&gt; 是一组直接或间接相连的城市，组内不含其他没有相连的城市。&lt;/p&gt;
&lt;p&gt;给你一个 &lt;code&gt;n x n&lt;/code&gt; 的矩阵 &lt;code&gt;isConnected&lt;/code&gt; ，其中 &lt;code&gt;isConnected[i][j] = 1&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个城市和第 &lt;code&gt;j&lt;/code&gt; 个城市直接相连，而 &lt;code&gt;isConnected[i][j] = 0&lt;/code&gt; 表示二者不直接相连。&lt;/p&gt;
&lt;p&gt;返回矩阵中 &lt;strong&gt;省份&lt;/strong&gt; 的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://www.xingyuzhao.ltd/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode399-除法求值</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/06/LeetCode399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/06/LeetCode399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</id>
    <published>2021-01-06T12:02:07.000Z</published>
    <updated>2021-01-25T15:10:21.148Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。</p><p><strong>注意</strong>：输入总是有效的。你可以假设除法运算中不会出现除数为 <code>0</code> 的情况，且不存在任何矛盾的结果。</p><a id="more"></a><img src="/blog/2021/01/06/LeetCode399-除法求值/399.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先得理解题目意思：</p><ul><li><code>equations</code>和<code>values</code>：<code>equations</code>中每个一维序列表示一对数进行相除（前 / 后），得到的结果就是<code>values</code>中相应位置的值，以上作为已知条件。</li><li><code>queries</code>：包含两个元素，目的是要我们求：第一个元素 / 第二个元素 = ？</li></ul><p>我们可以将其抽象为一个<strong>带权图</strong>问题，对于<code>queries</code>中的两个元素 <code>x</code>, <code>y</code> ，是否有一条路径可以从 <code>x</code> 到 <code>y</code> ，并求出经过这条路径的消耗是多少。由于两个元素的比值是一个常量，所以<strong>如果有多条路径，消耗是一样的</strong>，选其中一条就可以。</p><p>以示例1为例，对于<code>a/c</code>，可以由<code>a/b * b/c</code>得到，也就是<code>a-&gt;b</code>与<code>b-&gt;c</code>两条路径的权值相乘得到，所以路径上的消耗，就是<strong>所走过的每条路径的权值之积</strong>。</p><p>由于每个基本元素类型都是<code>string</code>，所以先对所有的元素映射到数字域，方便查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将equations中的string映射到0，1，2，3...</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : equations)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">map</span>.count(ch)) <span class="built_in">map</span>[ch] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步就是建图，使用邻接表，并且路径之间是<strong>双向</strong>的，权值<strong>互为倒数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; W;</span><br><span class="line">G = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">W = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); ++i)&#123;</span><br><span class="line">    G[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]);</span><br><span class="line">    W[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(values[i]);</span><br><span class="line">    G[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]);</span><br><span class="line">    W[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="number">1</span> / values[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建好图之后，就可以用<strong>深度优先搜索（DFS）</strong>和<strong>回溯算法</strong>来找路了，需要用一个数组记录走过的节点，防止重复走过，还需要一个变量<code>flag</code>表示起点与终点之间是否存在路径：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 初始为0，表示起点与终点之间没有路径。设置为全局变量，在函数中不用调用。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="built_in">map</span>.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; querie : queries) &#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = querie[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">string</span> s2 = querie[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 如果两个元素相同并且存在于map中，结果就是1</span></span><br><span class="line">    <span class="keyword">if</span> (s1 == s2 &amp;&amp; <span class="built_in">map</span>.count(s1)) &#123;</span><br><span class="line">        res.push_back(<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有一个元素不存在于map中，结果就是-1，因为没有这条路径</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">map</span>.count(s1) || !<span class="built_in">map</span>.count(s2)) &#123;</span><br><span class="line">        res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将起点标记为已使用</span></span><br><span class="line">    vis[<span class="built_in">map</span>[s1]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 参数：图，权值，标记数组，起点，终点，当前计算结果（初始为1）</span></span><br><span class="line">    dfs(G, W, vis, <span class="built_in">map</span>[s1], <span class="built_in">map</span>[s2], <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用过后，再次标记为未使用</span></span><br><span class="line">    vis[<span class="built_in">map</span>[s1]] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 没有路径，结果为-1</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">    <span class="comment">// 已经有路径，将flag置为0，结果已经在DFS中记录过，所以不用再次记录了</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS+回溯：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; &amp;W, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;vis, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">        res.push_back(val);</span><br><span class="line">        <span class="comment">// 有路径，flag为1</span></span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[start].size(); ++i)&#123;</span><br><span class="line">        <span class="comment">// 如果flag已经为1了，说明找到一条路径了，就不需要再找了</span></span><br><span class="line">        <span class="comment">// 剩下的就是一般的回溯算法</span></span><br><span class="line">        <span class="keyword">if</span>(vis[G[start][i]] || flag == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        vis[G[start][i]] = <span class="literal">true</span>;</span><br><span class="line">        val *= W[start][i];</span><br><span class="line">        dfs(G, W, vis, G[start][i], end, val);</span><br><span class="line">        val /= W[start][i];</span><br><span class="line">        vis[G[start][i]] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; W;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="comment">// set&lt;pair&lt;int, int&gt;&gt; set;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : equations)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">map</span>.count(ch)) <span class="built_in">map</span>[ch] = cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; map.size();</span></span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        G = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">        W = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">        vis = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="built_in">map</span>.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); ++i)&#123;</span><br><span class="line">            G[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; map[equations[i][0]] &lt;&lt; " " &lt;&lt; map[equations[i][1]];</span></span><br><span class="line">            W[<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]].push_back(values[i]);</span><br><span class="line">            G[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="built_in">map</span>[equations[i][<span class="number">0</span>]]);</span><br><span class="line">            W[<span class="built_in">map</span>[equations[i][<span class="number">1</span>]]].push_back(<span class="number">1</span> / values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto &amp;g : G)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;gg : g)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; gg &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; "    ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for(auto &amp;w : W)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;ww : w)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; ww &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; "    ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;querie : queries)&#123;</span><br><span class="line">            <span class="built_in">string</span> s1 = querie[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">string</span> s2 = querie[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s1 == s2 &amp;&amp; <span class="built_in">map</span>.count(s1))&#123;</span><br><span class="line">                res.push_back(<span class="number">1.0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.count(s1) || !<span class="built_in">map</span>.count(s2))&#123;</span><br><span class="line">                res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[<span class="built_in">map</span>[s1]] = <span class="literal">true</span>;</span><br><span class="line">            dfs(G, W, vis, <span class="built_in">map</span>[s1], <span class="built_in">map</span>[s2], <span class="number">1</span>);</span><br><span class="line">            vis[<span class="built_in">map</span>[s1]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>) res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int count = queries.size() - res.size();</span></span><br><span class="line">        <span class="comment">// while(count--)&#123;</span></span><br><span class="line">        <span class="comment">//     res.insert(res.begin(), -1.0);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;G, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; &amp;W, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;vis, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            res.push_back(val);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; val &lt;&lt; " ";</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[start].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[G[start][i]] || flag == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            vis[G[start][i]] = <span class="literal">true</span>;</span><br><span class="line">            val *= W[start][i];</span><br><span class="line">            dfs(G, W, vis, G[start][i], end, val);</span><br><span class="line">            val /= W[start][i];</span><br><span class="line">            vis[G[start][i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h4><p>可以使用并查集解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;给你一个变量对数组 &lt;code&gt;equations&lt;/code&gt; 和一个实数值数组 &lt;code&gt;values&lt;/code&gt; 作为已知条件，其中 &lt;code&gt;equations[i] = [Ai, Bi]&lt;/code&gt; 和 &lt;code&gt;values[i]&lt;/code&gt; 共同表示等式 &lt;code&gt;Ai / Bi = values[i]&lt;/code&gt; 。每个 &lt;code&gt;Ai&lt;/code&gt; 或 &lt;code&gt;Bi&lt;/code&gt; 是一个表示单个变量的字符串。&lt;/p&gt;
&lt;p&gt;另有一些以数组 &lt;code&gt;queries&lt;/code&gt; 表示的问题，其中 &lt;code&gt;queries[j] = [Cj, Dj]&lt;/code&gt; 表示第 &lt;code&gt;j&lt;/code&gt; 个问题，请你根据已知条件找出 &lt;code&gt;Cj / Dj = ?&lt;/code&gt; 的结果作为答案。&lt;/p&gt;
&lt;p&gt;返回 所有问题的答案 。如果存在某个无法确定的答案，则用 &lt;code&gt;-1.0&lt;/code&gt; 替代这个答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：输入总是有效的。你可以假设除法运算中不会出现除数为 &lt;code&gt;0&lt;/code&gt; 的情况，且不存在任何矛盾的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="图论" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="http://www.xingyuzhao.ltd/tags/DFS/"/>
    
      <category term="回溯算法" scheme="http://www.xingyuzhao.ltd/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode830-较大分组的位置</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/05/LeetCode830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/05/LeetCode830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</id>
    <published>2021-01-05T10:08:58.000Z</published>
    <updated>2021-01-05T12:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p><p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p><a id="more"></a><img src="/blog/2021/01/05/LeetCode830-较大分组的位置/830.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>寻找每个重复字符出现的起始位置和终止位置，如果长度大于等于3，记录一下结果就可以了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">largeGroupPositions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = s[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="comment">// 此位置的前一个位置就是上一个重复字符的终止位置</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] != ch)&#123;</span><br><span class="line">                ch = s[i];</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> - start + <span class="number">1</span> &gt;= <span class="number">3</span>) res.push_back(&#123;start, i - <span class="number">1</span>&#125;);</span><br><span class="line">                <span class="comment">// 更新起始位置</span></span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 字符重复</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> - start + <span class="number">1</span> &gt;= <span class="number">3</span>) res.push_back(&#123;start, i - <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一个由小写字母构成的字符串 &lt;code&gt;s&lt;/code&gt; 中，包含由一些连续的相同字符所构成的分组。&lt;/p&gt;
&lt;p&gt;例如，在字符串 &lt;code&gt;s = &amp;quot;abbxxxxzyy&amp;quot;&lt;/code&gt; 中，就含有 &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;bb&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;z&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;yy&amp;quot;&lt;/code&gt; 这样的一些分组。&lt;/p&gt;
&lt;p&gt;分组可以用区间 &lt;code&gt;[start, end]&lt;/code&gt; 表示，其中 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 分别表示该分组的起始和终止位置的下标。上例中的 &lt;code&gt;&amp;quot;xxxx&amp;quot;&lt;/code&gt; 分组用区间表示为 &lt;code&gt;[3,6]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;我们称所有包含大于或等于三个连续字符的分组为 &lt;strong&gt;较大分组&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;找到每一个 &lt;strong&gt;较大分组&lt;/strong&gt; 的区间，&lt;strong&gt;按起始位置下标递增顺序排序后&lt;/strong&gt;，返回结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode509-斐波那契数</title>
    <link href="http://www.xingyuzhao.ltd/blog/2021/01/04/LeetCode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://www.xingyuzhao.ltd/blog/2021/01/04/LeetCode509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2021-01-04T10:08:27.000Z</published>
    <updated>2021-01-05T12:21:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>斐波那契数，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><a id="more"></a><img src="/blog/2021/01/04/LeetCode509-斐波那契数/509.png"><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这个算是动态规划的入门题目。给定 $F(0)$ 和 $F(1)$ 之后，后面的数都是前面两个数之和。比如 $F(2)=F(0)+F(1)$，$F(3)=F(1)+F(2)$…</p><p>基于此，其实已经告诉了我们状态转移方程：<br>$$<br>dp[i]=dp[i-1]+dp[i-2]\quad i\geq2<br>$$<br>当 $i=0,1$ 时，函数值已经给定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上只用三个变量就可以表示每种状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        <span class="keyword">int</span> fin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i - 2]</span></span><br><span class="line">        <span class="keyword">int</span> fir = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="keyword">int</span> sec = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fin = fir + sec;</span><br><span class="line">            fir = sec;</span><br><span class="line">            sec = fin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;斐波那契数，通常用 &lt;code&gt;F(n)&lt;/code&gt; 表示，形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(0) = 0，F(1) = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(n) = F(n - 1) + F(n - 2)，其中 n &amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;给你 &lt;code&gt;n&lt;/code&gt; ，请计算 &lt;code&gt;F(n)&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
