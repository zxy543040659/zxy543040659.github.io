<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zxy&#39;s blog</title>
  
  <subtitle>长风破浪会有时，直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xingyuzhao.ltd/"/>
  <updated>2020-07-04T02:30:15.470Z</updated>
  <id>http://www.xingyuzhao.ltd/</id>
  
  <author>
    <name>Xingyu_Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode718-最长重复子数组</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/07/03/LeetCode718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/07/03/LeetCode718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-03T15:35:56.000Z</published>
    <updated>2020-07-04T02:30:15.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p><a id="more"></a><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/示例.png" style="zoom: 80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目的意思很好理解，如示例所示，公共的子数组除了单一的数值<code>[1],[2],[3]</code>，也有<code>[2,1],[3,2,1]</code>这些数组，其中最长的就是<code>[3,2,1]</code>这个数组，长度为3。像题目出现<strong>最长，最短</strong>之类的字都可以考虑用动态规划去解决。</p><h4 id="一、定义dp数组的含义"><a href="#一、定义dp数组的含义" class="headerlink" title="一、定义dp数组的含义"></a>一、定义dp数组的含义</h4><p>数组A长5，数组B长5，我们假设存在一个<code>6×6</code>的<code>dp</code>矩阵，使得矩阵坐标从1开始，同时保证边界位置上的计算，并初始化所有值为0。<strong>矩阵表示固定A的值时，到B数组的当前值与到A固定值的公共数组长度</strong>：</p><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index.png"><p>我们固定A数组，然后去遍历B数组。假如<code>A[i]=B[j]</code>时，公共数组的长度在上一次长度的基础上+1，否则不变，在后续分析中可以看到。</p><p>比如说<code>A[0]=1</code>，此时遍历B数组，<code>B[0]=3</code>，两个值不等。因为我们建立数组时候起始坐标是从1开始的，所以<code>dp[1][1] = 0</code>。继续遍历B数组，可以得到以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[1][2] = 0</span><br><span class="line">dp[1][3] = 1</span><br><span class="line">dp[1][4] = 0</span><br><span class="line">dp[1][5] = 0</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index1.png"><p>接下来改变A值，<code>A[1]=2</code>，可以得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[2][1] = 0</span><br><span class="line">dp[2][2] = 1</span><br><span class="line">dp[2][3] = 0</span><br><span class="line">dp[2][4] = 0</span><br><span class="line">dp[2][5] = 0</span><br></pre></td></tr></table></figure><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index2.png"><p>同理<code>A[2]=3</code>：</p><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index3.png"><p>当<code>A[3]=2,B[1]=2</code>时，此时满足<code>value(A)==value(B)</code>，所以<code>dp[4][2] = dp[3][1] + 1 = 2</code>，如图：</p><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index4.png"><p>当<code>A[4]=1,B[2]=1</code>时，此时满足<code>value(A)==value(B)</code>，所以<code>dp[5][3] = dp[4][2] + 1 = 3</code>，如图：</p><img src="/blog/2020/07/03/LeetCode718-最长重复子数组/index5.png"><p>遍历完一次B数组后更新最大长度，所以最后最大的公共数组长度就是3。</p><h4 id="二、状态转移方程"><a href="#二、状态转移方程" class="headerlink" title="二、状态转移方程"></a>二、状态转移方程</h4><p>根据上述分析，可以得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>])</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> **dp = <span class="keyword">new</span> <span class="keyword">int</span>*[A.size()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[B.size()+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size() + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从前往后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                res = max(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给两个整数数组 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，返回两个数组中公共的、长度最长的子数组的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>堆排序(heap sort)</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/27/%E5%A0%86%E6%8E%92%E5%BA%8F-heap-sort/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/27/%E5%A0%86%E6%8E%92%E5%BA%8F-heap-sort/</id>
    <published>2020-06-27T03:27:56.000Z</published>
    <updated>2020-07-12T12:09:15.899Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序是一种特殊的排序算法，涉及到了优先级的概念</p><p>更新于2020/7/12</p><h3 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h3><ol><li>了解优先队列的一些概念</li><li>堆排序概念及实现</li></ol><a id="more"></a><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul><li>普通队列：FIFO</li><li>优先队列：出队顺序与入队无关，与优先级有关</li></ul><p>为什么选择优先队列？</p><p>比如：在10000000个元素中选择前100名？(在N个元素中选择前M个)</p><ul><li>排序算法复杂度 O(NlogN)</li><li>优先队列 O(NlogM)</li></ul><p>优先队列的实现方法：</p><img src="/blog/2020/06/27/堆排序-heap-sort/实现方式.png" style="zoom:80%;"><p>使用普通数组在出队时需要遍历一次找到优先级最高的元素；顺序数组在每次插入的时候也要遍历一次找到相应的位置；使用堆这种结构可以让入队出队复杂度都为O(logN)。</p><h3 id="堆的基本实现"><a href="#堆的基本实现" class="headerlink" title="堆的基本实现"></a>堆的基本实现</h3><h4 id="二叉堆-Binary-Heap"><a href="#二叉堆-Binary-Heap" class="headerlink" title="二叉堆(Binary Heap)"></a>二叉堆(Binary Heap)</h4><p>二叉堆类似于二叉树，是一种树状结构，可以用数组来存储二叉堆，以最大堆为例。</p><p>最大堆：</p><ul><li><strong>堆中的某个节点值不大于其父亲节点(不意味着层数越高，数值越大)</strong></li><li><strong>堆总是一棵完全二叉树(这也是可以用数组表示的原因)</strong></li></ul><img src="/blog/2020/06/27/堆排序-heap-sort/二叉堆1.png" style="zoom:80%;"><p>给每个节点按照从上到小，从左到右进行编号，可以有以下的性质：</p><ul><li><strong>左节点的序号是父节点的二倍</strong></li><li><strong>右边序号为父节点的二倍加1</strong></li></ul><img src="/blog/2020/06/27/堆排序-heap-sort/二叉堆2.png" style="zoom:80%;"><p>用1来做起始标号是经典实现办法，数组对应的标号就是节点的索引：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组1.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 找到i的父节点序号</span><br><span class="line">parent[i] = i / <span class="number">2</span></span><br><span class="line"># i节点的孩子节点序号</span><br><span class="line">leftChild[i] = <span class="number">2</span> * i</span><br><span class="line">rightChild[i] = <span class="number">2</span> * i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>构建堆的基本结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="添加元素-Shift-Up"><a href="#添加元素-Shift-Up" class="headerlink" title="添加元素(Shift Up)"></a>添加元素(Shift Up)</h4><p>由于是用数组实现的堆，所以添加一个新的元素相当于在数组的末尾添加了一个元素：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组2.png"><p>相应的树形结构如下：</p><img src="/blog/2020/06/27/堆排序-heap-sort/shiftup1.png" style="zoom:80%;"><p>显然此时不符合最大堆的定义，新加入的52大于其父节点16，所以两个需要交换位置，以此类推，将52放在合适的位置，如下图所示：</p><img src="/blog/2020/06/27/堆排序-heap-sort/shiftup2.png" style="zoom: 67%;"><p>最终数组里的值为下图：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组3.png"><p><strong>Shift Up</strong>代码实现(在基本结构基础上)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 孩子节点大于父节点需要交换，并更新节点位置</span></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k] )&#123;</span><br><span class="line">            swap( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="comment">//添加新元素</span></span><br><span class="line">        data[count+<span class="number">1</span>] = item;</span><br><span class="line">        count ++;</span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="取出元素-Shift-Down"><a href="#取出元素-Shift-Down" class="headerlink" title="取出元素(Shift Down)"></a>取出元素(Shift Down)</h4><p>对于堆来说，每次只能取根节点的那个元素，在这里就是取最大的元素。</p><p>取出最大的元素后，根节点的位置就空出来了，这时候把最后一个元素补充到根节点处(保证仍然是一棵完全二叉树)，此时作为计数的变量<code>count--</code>，最后一个数组中的元素可以不动，使用<code>count</code>来卡住边界。</p><img src="/blog/2020/06/27/堆排序-heap-sort/shiftdown1.png" style="zoom:80%;"><p>此时数组中的元素为：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组4.png"><p>此时16也不满足最大堆的定义，接下来要调整这些元素的位置。将16一步一步的向下挪，直到合适的位置，所以叫<strong>Shift Down</strong>，不过每次下挪，有两个方向可以走，具体怎么选？<strong>需要找到子节点中更大的那个值进行交换</strong>，这样就可以保证子节点一定是不大于父节点的，过程如下：</p><img src="/blog/2020/06/27/堆排序-heap-sort/shiftdown2.png" style="zoom:80%;"><p>此时数组中的元素为：</p><img src="/blog/2020/06/27/堆排序-heap-sort/数组5"><p><strong>Shift Down</strong>代码实现(在基本结构基础上)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断k是否有孩子</span></span><br><span class="line">        <span class="comment">// 对于完全二叉树，有左孩子就代表一定有孩子</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="comment">// j+1为右孩子，需要判断是否存在</span></span><br><span class="line">            <span class="comment">// 再判断应该和哪个孩子交换</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] ) <span class="comment">// 右孩子大</span></span><br><span class="line">                j ++; <span class="comment">// j代表右孩子，否则为左孩子</span></span><br><span class="line">            <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            swap( data[k] , data[j] );</span><br><span class="line">            k = j; <span class="comment">// 交换后的新节点，继续Shift Down</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Heapify-将普通数组变为堆"><a href="#Heapify-将普通数组变为堆" class="headerlink" title="Heapify(将普通数组变为堆)"></a>Heapify(将普通数组变为堆)</h4><img src="/blog/2020/06/27/堆排序-heap-sort/数组6.png"><p>对于以上数组，可以直接构建成堆，不用先进行插入元素，二叉树形式为下图：</p><img src="/blog/2020/06/27/堆排序-heap-sort/heapify1.png" style="zoom:80%;"><p>对于上图的树来说，所有的叶子节点都是一个最大堆：</p><img src="/blog/2020/06/27/堆排序-heap-sort/heapify2" style="zoom:80%;"><p>第一个非叶子节点的位置为<code>count/2</code>，即<code>10/2=5</code>，对于每个非叶子节点进行<strong>Shift Down</strong>操作。</p><img src="/blog/2020/06/27/堆排序-heap-sort/heapify3" style="zoom: 67%;"><p><strong>Heapify</strong>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断k是否有孩子</span></span><br><span class="line">        <span class="comment">// 对于完全二叉树，有左孩子就代表一定有孩子</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k; </span><br><span class="line">            <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="comment">// j+1为右孩子，需要判断是否存在</span></span><br><span class="line">            <span class="comment">// 再找到值更大的孩子</span></span><br><span class="line">            <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] ) </span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">// 如果孩子中最大值小于等于父节点的值，就不用交换了</span></span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            swap( data[k] , data[j] );</span><br><span class="line">            <span class="comment">// 交换后的新节点，继续Shift Down</span></span><br><span class="line">            k = j; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据数组直接构造最大堆</span></span><br><span class="line">    MaxHeap(Item arr[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )</span><br><span class="line">            shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        swap( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="原地堆排序-从小到大"><a href="#原地堆排序-从小到大" class="headerlink" title="原地堆排序(从小到大)"></a>原地堆排序(从小到大)</h3><p>在之前构建一个堆需要额外的n个空间，实际上给定数组时候在原地也可以进行堆排序，过程如图所示：</p><img src="/blog/2020/06/27/堆排序-heap-sort/原地1.png" style="zoom:80%;"><ul><li>先对数组进行<code>Heapify</code>操作，则V就是最大值，V和W进行交换，此时最大值在末尾</li><li>此时V之前的数组不再是最大堆，对W进行<code>ShiftDown</code>操作使之前的数组再次成为最大堆</li><li>再次把此时的V和W(倒数第二个元素)进行交换，以此类推。</li></ul><p><strong>此时的索引是从0开始的</strong>，所以最后一个非叶子节点的索引为<code>(count-1)/2</code>，对于节点<strong>i</strong>，有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent[i] = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">left child[i] = <span class="number">2</span> × i + <span class="number">1</span>;</span><br><span class="line">right child[i] = <span class="number">2</span> × i + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><img src="/blog/2020/06/27/堆排序-heap-sort/原地2.png" style="zoom:80%;"><p>对应的数组为：</p><p><img src="/blog/2020/06/27/堆排序-heap-sort/D:%5CHexo%5Csource_posts%5C%E5%A0%86%E6%8E%92%E5%BA%8F-heap-sort%5C%E5%8E%9F%E5%9C%B03.png" alt="image-20200712164402912"></p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// heapify</span></span><br><span class="line">    <span class="comment">// from 第一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        __shiftDown(arr, n, i);</span><br><span class="line">    <span class="comment">// i最后为1，当只有也给元素时无需进行操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        __shiftDown(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">void</span> __shiftDown(T arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="comment">// 从0开始索引，k为父节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> * k + <span class="number">1</span> &lt; n)&#123; <span class="comment">// 如果左孩子存在</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 以下操作是为了与左右孩子中更大的那个交换</span></span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j])</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[k] &gt;= arr[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr[k], arr[j]);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125; </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="索引堆-Index-Heap"><a href="#索引堆-Index-Heap" class="headerlink" title="索引堆(Index Heap)"></a>索引堆(Index Heap)</h3><p>当进行堆排序之后，坐标和值的关系也就不复存在了，如果我们要继续使用坐标和值之间的关系，就需要对索引进行堆排序，以最大索引堆为例：</p><img src="/blog/2020/06/27/堆排序-heap-sort/index_heap1.png" style="zoom:80%;"><ul><li><code>data</code>数组并未改变，只有<code>index</code>数组发生了改变(<strong>根据data改变index</strong>)</li><li>堆顶的元素<code>index[1] = 10</code>，表示堆顶的元素是<strong>10索引</strong>所指向的<code>data[10]</code>，即62</li><li>同理可得，<code>index[2] = 9</code>表示62的左孩子是<strong>9索引</strong>所指向的<code>data[9] = 41</code>，<code>index[3] = 7</code>表示62的右孩子是<strong>7索引</strong>所指向的<code>data[7] = 28</code>，以此类推</li></ul><p><strong>优点</strong>：只有索引<code>index整型</code>数组发生了改变，<code>data</code>并未改变，<code>data</code>的类型并没有限制</p><p>对于<code>shiftDown</code>和<code>shiftUp</code>变化不大，同时可以支持返回最大值的索引值，也可以根据索引值就直接返回<code>data</code>，最重要的操作是修改数据内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    data[i] = newItem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到indexes[j] = i, j表示data[i]在堆中的位置</span></span><br><span class="line">    <span class="comment">// 之后shiftUp(j), 再shiftDown(j)，再次将index构建为最大堆</span></span><br><span class="line"><span class="comment">// 这里用的是遍历，复杂度较高O(n + logn)</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= count ; j ++ )</span><br><span class="line">        <span class="keyword">if</span>( indexes[j] == i )&#123;</span><br><span class="line">            shiftUp(j);</span><br><span class="line">            shiftDown(j);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化-change"><a href="#优化-change" class="headerlink" title="优化(change)"></a>优化(change)</h4><p><img src="/blog/2020/06/27/堆排序-heap-sort/D:%5CHexo%5Csource_posts%5C%E5%A0%86%E6%8E%92%E5%BA%8F-heap-sort%5Cindex_heap2.png" alt="image-20200712174809139"></p><ul><li><code>reverse[i]</code>表示索引<code>i</code>在<code>index</code>中的位置</li><li>比如我们要查找<code>i = 4</code>这个索引在<code>index</code>中的位置，先找到<code>rev[4] = 9</code>，那么索引<code>i = 4</code>就在<code>index[9]</code>处，时间复杂度为O(1)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indexes[i] = j;</span><br><span class="line">reverse[j] = i;</span><br><span class="line"></span><br><span class="line">indexes[reverse[i]] = i;</span><br><span class="line">reverse[indexes[i]] = i;</span><br></pre></td></tr></table></figure><p>在<code>swap</code>操作中需要修改<code>reverse</code></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IndexMaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line"></span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化为0，代表不存在</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= capacity ; i ++ )</span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    ~IndexMaxHeap()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        <span class="keyword">delete</span>[] indexes;</span><br><span class="line">        <span class="keyword">delete</span>[] reverse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入的i对用户而言,是从0索引的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span></span>&#123;</span><br><span class="line">        assert( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = item;</span><br><span class="line">        indexes[count+<span class="number">1</span>] = i;</span><br><span class="line">        reverse[i] = count+<span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 抽取最大的元素</span></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        Item ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        <span class="comment">// 此时最后一个元素没有意义了</span></span><br><span class="line">        <span class="comment">// 此时的堆顶的第一个元素的reverse需要更新</span></span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 抽取最大元素的坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        swap( indexes[<span class="number">1</span>] , indexes[count] );</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        count--;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回最大元素的值</span></span><br><span class="line">    <span class="function">Item <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> data[indexes[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回最大元素的坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &gt; <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> indexes[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 保证不越界</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">        <span class="keyword">return</span> reverse[i+<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回i处的元素值</span></span><br><span class="line">    <span class="function">Item <span class="title">getItem</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">        assert( contain(i) );</span><br><span class="line">        <span class="keyword">return</span> data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 改变i处的元素值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">( <span class="keyword">int</span> i , Item newItem )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        assert( contain(i) );</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        data[i] = newItem;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = reverse[i];</span><br><span class="line">        shiftUp( j );</span><br><span class="line">        shiftDown( j );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[indexes[k/<span class="number">2</span>]] &lt; data[indexes[k]] )&#123;</span><br><span class="line">            swap( indexes[k/<span class="number">2</span>] , indexes[k] );</span><br><span class="line">            reverse[indexes[k/<span class="number">2</span>]] = k/<span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[indexes[j+<span class="number">1</span>]] &gt; data[indexes[j]] )</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( data[indexes[k]] &gt;= data[indexes[j]] )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap( indexes[k] , indexes[j] );</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            reverse[indexes[j]] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="用堆解决第一节问题思路"><a href="#用堆解决第一节问题思路" class="headerlink" title="用堆解决第一节问题思路"></a>用堆解决第一节问题思路</h3><p>使用堆实现优先队列，动态选择优先级最高的任务执行。</p><p>第一节中的问题，在10000000个元素中选出前100名(在N个元素中选前M个元素)，维护一个优先队列(长度为100)，每次把最小的移除，遍历完成后，最后剩下的100个元素就是前100个元素。</p><h3 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h3><p><a href="https://gitee.com/settlezxy/algorithm_and_data_structure.git" target="_blank" rel="noopener">https://gitee.com/settlezxy/algorithm_and_data_structure.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆排序是一种特殊的排序算法，涉及到了优先级的概念&lt;/p&gt;
&lt;p&gt;更新于2020/7/12&lt;/p&gt;
&lt;h3 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;了解优先队列的一些概念&lt;/li&gt;
&lt;li&gt;堆排序概念及实现&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.xingyuzhao.ltd/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.xingyuzhao.ltd/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>string操作总结(不定期更新)</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/25/string%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/25/string%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-25T09:25:18.000Z</published>
    <updated>2020-06-25T12:50:31.442Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下C++中string的常见用法，包括但不局限于：</p><ol><li>初始化</li><li>string对象上的操作（包括取子串）</li><li>查找/删除/替换</li><li>与数值的相互转换</li></ol><a id="more"></a><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化，s1为空</span></span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="comment">//用s1初始化s2</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="comment">//s3为字面值"value"的副本，直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;</span><br><span class="line"><span class="comment">//与上述等价，不同之处在于这里是拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"value"</span>;</span><br><span class="line"><span class="comment">//类似vector，n个'c'组成字符串s4</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从is读取一行给s，返回is</span></span><br><span class="line">getline(is, s)</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line">s.empty()</span><br><span class="line"><span class="comment">//s的长度</span></span><br><span class="line">s.size() / s.length()</span><br><span class="line"><span class="comment">//完全一样则相等，大小写敏感</span></span><br><span class="line">s1 == s2</span><br><span class="line"><span class="comment">//字典序比较，大小写敏感</span></span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=</span><br></pre></td></tr></table></figure><h4 id="两个string对象相加"><a href="#两个string对象相加" class="headerlink" title="两个string对象相加"></a>两个string对象相加</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello, "</span>, s2 = <span class="string">"world"</span>;</span><br><span class="line"><span class="comment">//s3 = "hello, world"</span></span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2;</span><br><span class="line"><span class="comment">//s1 = "hello, world"</span></span><br><span class="line">s1 += s2;</span><br></pre></td></tr></table></figure><h4 id="字面值和string对象相加"><a href="#字面值和string对象相加" class="headerlink" title="字面值和string对象相加"></a>字面值和string对象相加</h4><p>当把string对象和字符字面值及字符串字面值混在一起相加时，必须确保<code>+</code>的两侧运算对象至少有一个string：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">","</span>; <span class="comment">//√</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hello"</span> + <span class="string">","</span><span class="comment">//×</span></span><br></pre></td></tr></table></figure><p>注意：字符串字面值与string是不同类型，以上操作是自动进行了类型转换。</p><h4 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在头文件cctype中</span></span><br><span class="line"><span class="built_in">isalnum</span>(c)<span class="comment">//当c是字母或数字为真</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)<span class="comment">//当c是字母为真</span></span><br><span class="line"><span class="built_in">iscntrl</span>(c)<span class="comment">//当c是控制字符为真，ASCII码前32</span></span><br><span class="line"><span class="built_in">isdigit</span>(c)<span class="comment">//当c是数字为真</span></span><br><span class="line"><span class="built_in">islower</span>(c)<span class="comment">//当c是小写字母为真</span></span><br><span class="line"><span class="built_in">isupper</span>(c)<span class="comment">//当c是大写字母为真</span></span><br><span class="line"><span class="built_in">ispunct</span>(c)<span class="comment">//当c是标点符号为真</span></span><br><span class="line"><span class="built_in">isspace</span>(c)<span class="comment">//当c是空白为真(空格，回车，制表符等)</span></span><br><span class="line"><span class="built_in">tolower</span>(c)<span class="comment">//如果c为大写字母，转为小写，否则不变</span></span><br><span class="line"><span class="built_in">toupper</span>(c)<span class="comment">//如果c为小写字母，转为大写，否则不变</span></span><br></pre></td></tr></table></figure><p><strong>范围for语句</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印s1的所有内容</span></span><br><span class="line"><span class="comment">//仅访问时可加上const</span></span><br><span class="line"><span class="comment">//简化类型名可用auto代替</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"zhaoxingyu"</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span> s : s1)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line"><span class="comment">//同时修改s1内容全为a</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span> &amp;s : s1)</span><br><span class="line">    s = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure><h4 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s.substr(pos, n)</span></span><br><span class="line"><span class="comment">//取s中从pos开始长度为n的子串</span></span><br><span class="line"><span class="comment">//如果pos超过s.size()则抛出out_of_range异常</span></span><br><span class="line"><span class="comment">//如果pos+n超过s.size()则substr自动调整n值，只拷贝到s末尾</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">string</span> str = s.substr(<span class="number">0</span>, <span class="number">5</span>);<span class="comment">//str = "hello"</span></span><br></pre></td></tr></table></figure><h3 id="查找-删除-替换"><a href="#查找-删除-替换" class="headerlink" title="查找/删除/替换"></a>查找/删除/替换</h3><h4 id="查找函数find"><a href="#查找函数find" class="headerlink" title="查找函数find"></a>查找函数find</h4><p>string中的find函数返回子串/字符第一次出现在母串中的位置，类型为size_t，可以把它视为一个范围很大的int类型。如果没有找到，返回一个npos标记，是一个很大的整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size_t pos = s.find(str, startPos)</span></span><br><span class="line"><span class="comment">//str为子串或字符，startPos为开始搜索位置，缺省时默认为0</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">size_t</span> pos = s.find(str);<span class="comment">//等价于pos = s.find("world")，返回6</span></span><br><span class="line"><span class="keyword">size_t</span> pos1 = s.find(<span class="string">"c"</span>);<span class="comment">//等价于pos1 = s.find('c')，返回npos</span></span><br></pre></td></tr></table></figure><p>还可以从后往前反向查找，函数为rfind</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">size_t</span> pos = s.rfind(<span class="string">"l"</span>); <span class="comment">//返回9</span></span><br></pre></td></tr></table></figure><p>其他一些find函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回子串首次出现位置</span></span><br><span class="line">pos = s.find_first_of(str);</span><br><span class="line"><span class="comment">//返回字串最后出现位置</span></span><br><span class="line">pos = s.find_last_of(str);</span><br></pre></td></tr></table></figure><h4 id="删除函数erase"><a href="#删除函数erase" class="headerlink" title="删除函数erase"></a>删除函数erase</h4><p>string中提供的成员函数可以用来删除字符串中的字符，这里主要介绍<code>erase</code>方法</p><ol><li>从给定位置pos开始删除长度为n的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//basic_string &amp; erase(size_type pos=0, size_type n=npos)</span></span><br><span class="line"><span class="comment">//n缺省时默认为删除到末尾</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line">s.erase(<span class="number">5</span>);<span class="comment">//从位置5开始全部删除，s = "hello";</span></span><br><span class="line">s.erase(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">//从0开始删除长度为2的字符串，s = "llo"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>删除迭代器位置处的单个字符，并返回<strong>下个元素</strong>的迭代器</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterator erase(const_iterator position)</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line">s.erase(s.begin());<span class="comment">//s = "ello world";</span></span><br></pre></td></tr></table></figure><ol start="3"><li>删除迭代器<code>[first, last)</code>区间的所有字符,返回一个指向被删除的最后一个元素的下一个字符的迭代器.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterator erase(const_iterator first, const_iterator last)</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">//iter = s.erase(s.begin() + 1, s.end() - 1);  //可以直接删除</span></span><br><span class="line"><span class="keyword">auto</span> iter = s.erase(s.begin() + <span class="number">1</span>, s.end() - <span class="number">1</span>); <span class="comment">//删除并返回迭代器</span></span><br><span class="line"><span class="comment">//s = "hd"，*iter = d</span></span><br></pre></td></tr></table></figure><p><strong>注：也可以用pop_back()删除最后一个元素</strong></p><h4 id="替换函数replace"><a href="#替换函数replace" class="headerlink" title="替换函数replace"></a>替换函数replace</h4><ol><li>用str替换指定字符串从pos开始长度为len的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp; replace(size_t pos, size_t len, const string&amp; str)</span></span><br><span class="line"><span class="comment">//注意这里的str必须是string对象，不能是char字符</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">s = s.replace(<span class="number">0</span>, <span class="number">5</span>, str);<span class="comment">//s = "# world"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>用str替换迭代器起始位置到终止位置的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp; replace(const_iterator it1, const_iterator it2, const string&amp; str)</span></span><br><span class="line"><span class="comment">//注意这里的str必须是string对象，不能是char字符</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">s = s.replace(s.begin(), s.begin() + <span class="number">5</span>, str);<span class="comment">//s = "# world"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>用重复n次的c字符替换从指定位置pos长度为len的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp; replace(size_t pos, size_t len, size_t n, char c)</span></span><br><span class="line"><span class="comment">//注意这里的c必须是char类型，不能是string对象</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'#'</span>;</span><br><span class="line">s = s.replace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, c);<span class="comment">//s = "## world"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>用重复n次的c字符替换从指定迭代器位置到终止位置的字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string&amp; replace (const_iterator i1, const_iterator i2, size_t n, char c)</span></span><br><span class="line"><span class="comment">//注意这里的c必须是char类型，不能是string对象</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'#'</span>;</span><br><span class="line">s = s.replace(s.begin(), s.end(), <span class="number">2</span>, c);<span class="comment">//s = "## world"</span></span><br></pre></td></tr></table></figure><h3 id="string与int相互转换"><a href="#string与int相互转换" class="headerlink" title="string与int相互转换"></a>string与int相互转换</h3><h4 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># string直接转int</span></span><br><span class="line"><span class="comment">//stoi(s, pos, b) 把字符串s从pos开始转换成b进制的int</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//a = 123，如果里面含有非数字，那么从pos开始连续的字符串型数字才会被转为数字</span></span><br><span class="line"><span class="keyword">int</span> a = stoi(s, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//stol(s,p,b)把字符串s从p开始转换成b进制的long</span></span><br><span class="line"><span class="comment">//stoul(s,p,b)把字符串s从p开始转换成b进制的unsigned long</span></span><br><span class="line"><span class="comment">//stoll(s,p,b)把字符串s从p开始转换成b进制的long long</span></span><br><span class="line"><span class="comment">//stoull(s,p,b)把字符串s从p开始转换成b进制的unsigned long long</span></span><br><span class="line"><span class="comment">//stof(s,p)把字符串s从p开始转换成float</span></span><br><span class="line"><span class="comment">//stod(s,p)把字符串s从p开始转换成double</span></span><br><span class="line"><span class="comment">//stold(s,p)把字符串s从p开始转换成long double</span></span><br><span class="line"><span class="meta"># char型数组字符串转int</span></span><br><span class="line"><span class="comment">//c_str()函数返回一个指向正规C字符串的指针, 内容与string串相同</span></span><br><span class="line"><span class="comment">//string类对象的成员函数c_str()把string转换为c类型字符串</span></span><br><span class="line"><span class="comment">//如果string不是数字形式的则转换结果为0</span></span><br><span class="line"><span class="comment">//实际步骤为string-&gt;char*-&gt;int</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> a = atoi(s.c_str());<span class="comment">//a = 123</span></span><br></pre></td></tr></table></figure><h4 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//to_string(val) 将val转为string</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">string</span> s = to_string(val);<span class="comment">//s = "100"</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>查找/删除/替换：</p><ol><li><p><a href="https://www.cnblogs.com/xzxl/p/7243490.html" target="_blank" rel="noopener">https://www.cnblogs.com/xzxl/p/7243490.html</a></p></li><li><p><a href="https://blog.csdn.net/cai_niaocainiao/article/details/81260902?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/cai_niaocainiao/article/details/81260902?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase</a></p></li><li><p><a href="https://blog.csdn.net/u010472607/article/details/80431604" target="_blank" rel="noopener">https://blog.csdn.net/u010472607/article/details/80431604</a></p></li></ol><p>字符串转数值</p><p><a href="https://blog.csdn.net/sinat_40872274/article/details/81367815" target="_blank" rel="noopener">https://blog.csdn.net/sinat_40872274/article/details/81367815</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下C++中string的常见用法，包括但不局限于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;li&gt;string对象上的操作（包括取子串）&lt;/li&gt;
&lt;li&gt;查找/删除/替换&lt;/li&gt;
&lt;li&gt;与数值的相互转换&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://www.xingyuzhao.ltd/categories/C/"/>
    
    
      <category term="string" scheme="http://www.xingyuzhao.ltd/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>git提交失败-ssh重置</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/25/git%E6%8F%90%E4%BA%A4%E5%A4%B1%E8%B4%A5-ssh%E9%87%8D%E7%BD%AE/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/25/git%E6%8F%90%E4%BA%A4%E5%A4%B1%E8%B4%A5-ssh%E9%87%8D%E7%BD%AE/</id>
    <published>2020-06-25T09:13:36.000Z</published>
    <updated>2020-06-25T09:24:56.794Z</updated>
    
    <content type="html"><![CDATA[<p>一段时间不提交，就容易出现“Please make sure you have the correct access rights and the repository exists.”，原因是ssh key出现了问题，记录一下解决方法，省的每次都去百度细节。</p><a id="more"></a><ol><li><p>重新配置身份信息</p><ul><li><code>git config --global user.name &quot;yourname&quot;</code></li><li><code>git config --global user.email &quot;your@email.com&quot;</code></li></ul></li><li><p>删除.ssh文件夹下的所有文件</p></li><li><p>输入命令<code>ssh-keygen -t rsa -C &quot;your@email.com&quot;</code>，出现提示直接回车</p></li><li><p>此时在.ssh文件夹下生成<strong>id_rsa</strong>和<strong>id_rsa.pub</strong>，用记事本打开<strong>id_rsa.pub</strong>并复制所有内容</p></li><li><p>打开github主页并进入到<code>SSH and GPG keys</code>中，新建shh，把刚才复制的内容粘贴进去</p></li><li><p>输入命令<code>ssh -T git@github.com&quot;</code>，出现提示输入<code>yes</code>，不是直接回车</p></li><li><p><strong>重新打开</strong>git进行提交</p></li></ol><p>以上所有git操作都在hexo根目录下</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一段时间不提交，就容易出现“Please make sure you have the correct access rights and the repository exists.”，原因是ssh key出现了问题，记录一下解决方法，省的每次都去百度细节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="常见问题" scheme="http://www.xingyuzhao.ltd/categories/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode139-单词拆分</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/25/LeetCode139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/25/LeetCode139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</id>
    <published>2020-06-25T08:03:33.000Z</published>
    <updated>2020-06-25T13:00:07.411Z</updated>
    
    <content type="html"><![CDATA[<p>这道题我一开始没想到可以用动态规划来做，先试着用暴力做了，结果通过34/36，看似只剩下3个没通过，但是问题很大，不好修改，具体原因后面分析。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><a id="more"></a><img src="/blog/2020/06/25/LeetCode139-单词拆分/示例.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题题意还是挺好理解的，给定字符串s，从字典wordDict中取出单个或多个字符串（可重复），最后如果可以拼接成s，返回true，反之返回false。</p><p>一开始暴力的思路就是遍历字典中的每一个字符串看是否出现在s中，如果出现了，那么用#号来代替s中的出现的子串，并且继续搜索，搜索完成后，将s中的#号清空，如果此时s为空，那么代表s可以被拆分，返回true。但是对于以下的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"abbbc"</span></span><br><span class="line">wordDict = [<span class="string">"ab"</span>, <span class="string">"b"</span>, <span class="string">"bbc"</span>]</span><br></pre></td></tr></table></figure><p>s可以由ab+bbc组合而成。但是用暴力法，只会搜到ab+b+b，再往下就搜索不到了，返回了false。如果需要修改，要用到dfs的思想，进行深搜，但是不剪枝也容易超时。在看了答案之后才知道可以用动态规划来做，而且很好理解。</p><p>按照第二个示例来说，<code>s = &quot;applepenapple&quot;, wordDcit = [&quot;apple&quot;, &quot;pen&quot;]</code>，从s的第一个字符<code>a</code>开始遍历：</p><ul><li>当等于<code>apple</code>时候，存在与字典中，就可以认为在第5个字符处是可以拆的；</li><li>继续向后遍历，当得到<code>applepen</code>时，增加了字符串<code>pen</code>，且它存在于字典中，所以可以知道第8个字符处也是可拆的；</li><li>直到<code>applepenapple</code>时，增加了<code>apple</code>，且它存在于字典中，最后一个字符即第13个字符处可拆。</li></ul><p>从上述分析可以知道，如果最后一个字符处可拆，就返回true，否则返回false。</p><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p>首先，<code>dp</code>数组应该是<code>bool</code>类型，长度为<code>s.length()+1</code>，并且<code>dp[0]=true</code>，否则dp数组全是false。<strong>dp数组含义为当前位置的字符是否可以被拆分</strong>。</p><p>如果<code>dp[j]</code>代表当前位置，<code>dp[i]</code>是某一起始位置，那么就需要检查从<code>i</code>到<code>j</code>的子串是否在字典中，如果在，并且<code>dp[i]</code>是可以拆分的，那么<code>dp[j]</code>也应该是可以拆分的，否则<code>dp[j]=false</code>。</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>根据上面的分析，可以容易写出以下的状态转移方程，同时将字典放入<code>unordered_map</code>中方便查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = dp[i] &amp;&amp; dict.count(s.substr(i, j - i))</span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存入字典，方便查找</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; dict; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;word : wordDict) dict[word] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 初始化dp数组，如果s为空，返回true</span></span><br><span class="line">        <span class="comment">// 实际上只初始化dp[0]即可</span></span><br><span class="line">        <span class="keyword">bool</span> *dp = <span class="keyword">new</span> <span class="keyword">bool</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                dp[j] = dp[i] &amp;&amp; dict.count(s.substr(i, j - i));</span><br><span class="line">                <span class="keyword">if</span>(dp[j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-ju-jue-zhuang-xcong-jian-dan-de-xi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-ju-jue-zhuang-xcong-jian-dan-de-xi/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题我一开始没想到可以用动态规划来做，先试着用暴力做了，结果通过34/36，看似只剩下3个没通过，但是问题很大，不好修改，具体原因后面分析。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拆分时可以重复使用字典中的单词。&lt;/li&gt;
&lt;li&gt;你可以假设字典中没有重复的单词。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode739-每日温度</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/13/LeetCode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/13/LeetCode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</id>
    <published>2020-06-13T03:39:44.000Z</published>
    <updated>2020-06-13T05:11:31.542Z</updated>
    
    <content type="html"><![CDATA[<p>这次主要学习一下单调栈这种数据结构，同时用此数据结构解决739题</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><a id="more"></a><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>先学习一下单调栈这种数据结构，单调栈就是栈的基础上使用一定的逻辑，使栈中的元素单调递增或者递减，一般只处理一种典型的问题，叫做<strong>下一个更大的元素</strong>，这个问题是说：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。举例如下：给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。</p><p>可以这样思考，把数组元素想象成人，如何求2的下一个更大的元素呢？如果2的下一个人比2还低或者一样高，那么就会被2遮挡住，直到第一个比他高的人，他挡不住了，就是答案。</p><img src="/blog/2020/06/13/LeetCode739-每日温度/人.jpg" style="zoom: 30%;"><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; <span class="comment">// 判定个子高矮，nums在s之前</span></span><br><span class="line">            s.pop(); <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">-1</span> : s.top(); <span class="comment">// 这个元素身后的第一个高个</span></span><br><span class="line">        s.push(nums[i]); <span class="comment">// 入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/blog/2020/06/13/LeetCode739-每日温度/栈.png" style="zoom: 80%;"><p>以上图是栈中元素的变化情况，只有当新的高个子来临，才会有出栈的操作。</p><h3 id="分析及代码实现"><a href="#分析及代码实现" class="headerlink" title="分析及代码实现"></a>分析及代码实现</h3><p>上面已经把单调栈阐述了一遍，本题唯一的区别是要返回还需要多少天，而不是那天的温度，所以要用栈来存储一下温度的坐标，根据当前温度的坐标与栈顶温度坐标的差作为返回值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 这里放元素索引，而不是元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = T.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">0</span> : (s.top() - i); <span class="comment">// 得到索引间距</span></span><br><span class="line">        s.push(i); <span class="comment">// 加入索引，而不是元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展：如何处理循环数组"><a href="#扩展：如何处理循环数组" class="headerlink" title="扩展：如何处理循环数组"></a>扩展：如何处理循环数组</h3><p>同样是<strong>下一个更大的元素</strong>，现在假设给你的数组是个环形的，如何处理？</p><p>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 。通过取模运算符%就可以模拟环形数组的效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = arr.length(), index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr[index % n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种方法是将数组翻倍，然后进行取模运算，节省空间的做法是直接将循环的坐标变成之前的2倍，代码看起来更容易理解，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>; <span class="comment">// 存放结果</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 假装这个数组长度翻倍了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])</span><br><span class="line">            s.pop();</span><br><span class="line">        res[i % n] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《labuladong的算法小抄》 单调栈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次主要学习一下单调栈这种数据结构，同时用此数据结构解决739题&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。&lt;/p&gt;
&lt;p&gt;例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。&lt;/p&gt;
&lt;p&gt;提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="单调栈" scheme="http://www.xingyuzhao.ltd/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode126-单词接龙2</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/07/LeetCode126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%992/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/07/LeetCode126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%992/</id>
    <published>2020-06-07T14:48:42.000Z</published>
    <updated>2020-06-08T02:35:20.149Z</updated>
    
    <content type="html"><![CDATA[<p>这是今天的每日一题，难度为hard，不过与之前软挑赛的题目有很多相似之处，但是我还是没做出来，还是要多总结。最后看了别人的答案，用BFS+DFS才解决这个问题。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明</strong>：</p><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><a id="more"></a><img src="/blog/2020/06/07/LeetCode126-单词接龙2/示例.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于beginWord，一次只能更改一个字母，同时更改后的字母必须出现在wordList中，所以考虑将wordList放入一个集合中，方便每次判断是否在集合内。一开始我考虑的是直接用DFS解决，虽然DFS可以找到所有路径，然后从中挑选最短，但是它无法直接找到最短路径。如果某条长度过长，很容易出现超时，事实上在刷题群里很多大佬已经出现了这个问题，所以只能找别的办法。直接用BFS是可以的，在找最短的同时记录路径，我没有尝试，之后可以再试试，我选择了使用BFS+DFS的方法，使用BFS建立逆邻接表，使用DFS在逆邻接表基础上搜索答案。</p><h4 id="BFS建立逆邻接表"><a href="#BFS建立逆邻接表" class="headerlink" title="BFS建立逆邻接表"></a>BFS建立逆邻接表</h4><p>使用BFS可以找到最短的路径，可以建立一个逆邻接表，用来表示可以到达当前节点的所有节点(当然这些节点必须是出现在wordList之中的)，<strong>我们用curr代表当前节点，temp代表更改一个字母后的节点</strong>。</p><p>使用<code>unordered_map&lt;string, vector&lt;string&gt;&gt; neighbor</code>来表示，就拿示例1来说，如下图所示：<img src="/blog/2020/06/07/LeetCode126-单词接龙2/邻接表.png"></p><p>上图表示可以到达cog的节点为dog和log，具体的实现还是需要一个记录当前节点深度的哈希表<code>unordered_map&lt;string, int&gt; depth</code>，用来判断curr是否可达temp，同时省去一些不必要的遍历。具体操作是：首先队列弹出curr节点，检查和它相差一个字母的temp是否在wordList中出现，如果出现了：</p><ul><li>没有记录过(<code>depth[temp] = 0</code>)，记录<code>curr-&gt;temp</code>，同时<code>depth[temp] = depth[curr] + 1</code>，将temp入队</li><li>记录过并且相邻(<code>depth[temp] = depth[curr] + 1</code>)，同时避免不是直接相邻的遍历，也避免了往回遍历。如下表，遍历改变pot一个字母的节点时，可能再次出现hot，但是此时<code>depth[hot] = 1 != depth[pot] + 1 = 2</code>所以避免了再次遍历hot。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   hot</span><br><span class="line"> /       \</span><br><span class="line"><span class="attribute">pot</span>     hit</span><br><span class="line"> \        /</span><br><span class="line">    pit</span><br></pre></td></tr></table></figure><p>通过以上步骤就可以建立逆临界表，代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; depth;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; neighbor;</span><br><span class="line"><span class="comment">//将wordList添加至集合中</span></span><br><span class="line"><span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordList.begin(),wordList.end())</span></span>;</span><br><span class="line"><span class="comment">//使用BFS建立逆邻接表</span></span><br><span class="line">depth[beginWord]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; Q;</span><br><span class="line">Q.push(beginWord);</span><br><span class="line"><span class="comment">//从begin到end建图</span></span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line"><span class="built_in">string</span> curr=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;curr.size();++i)&#123;</span><br><span class="line">        <span class="built_in">string</span> temp=curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">'a'</span>;c&lt;=<span class="string">'z'</span>;++c)&#123;</span><br><span class="line">            temp[i]=c;</span><br><span class="line">            <span class="comment">//如果修改后的这个temp是在集合里面</span></span><br><span class="line">            <span class="keyword">if</span>(wordSet.count(temp))&#123;</span><br><span class="line">           <span class="comment">//这个temp还没被添加进neighbor</span></span><br><span class="line">                <span class="keyword">if</span>(depth[temp] == <span class="number">0</span>)&#123; </span><br><span class="line">                    Q.push(temp);</span><br><span class="line">                    depth[temp]=depth[curr]+<span class="number">1</span>;<span class="comment">//更新深度</span></span><br><span class="line">                    neighbor[temp].push_back(curr);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//已经被添加并且相邻</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(depth[temp]==depth[curr]+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    neighbor[temp].push_back(curr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DFS从逆邻接表中搜索答案"><a href="#DFS从逆邻接表中搜索答案" class="headerlink" title="DFS从逆邻接表中搜索答案"></a>DFS从逆邻接表中搜索答案</h4><p>在上一步的BFS中已经存储了每个点的逆邻接点，我们从endWord沿着neighbor往回进行搜索，直到到达beginWord，将已经记录的路径(path)进行反转，存入最终的res中；如果无法到达，则DFS执行至末尾，将path重置(省去了使用&amp;path引用的pop_back()操作)。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;begin, <span class="built_in">string</span> &amp;curr, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;neighbor, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(curr == begin)&#123;</span><br><span class="line">        path.push_back(curr);</span><br><span class="line">        reverse(path.begin(), path.end());</span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(curr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;word : neighbor[curr])&#123;</span><br><span class="line">        dfs(begin, word, path, neighbor, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">findLadders</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">//如果wordList中没有endWord，则返回空</span></span><br><span class="line">        <span class="keyword">if</span>(find(wordList.begin(), wordList.end(), endWord) == wordList.end())</span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;<span class="comment">//记录路径</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; depth;<span class="comment">//记录深度</span></span><br><span class="line">        <span class="comment">//存储节点的逆邻接</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; neighbor;</span><br><span class="line">        <span class="comment">//将wordList添加至集合中</span></span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordset</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        depth[beginWord] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; Q;</span><br><span class="line">        Q.push(beginWord);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> curr = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.size(); i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> temp = curr;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++)&#123;</span><br><span class="line">                    temp[i] = c;</span><br><span class="line">                    <span class="comment">//如果修改后的这个temp是在集合里面</span></span><br><span class="line">                    <span class="keyword">if</span>(wordset.count(temp))&#123;</span><br><span class="line">                        <span class="comment">//这个temp还没被添加进neighbor</span></span><br><span class="line">                        <span class="keyword">if</span>(depth[temp] == <span class="number">0</span>)&#123;</span><br><span class="line">                            Q.push(temp);</span><br><span class="line">                            depth[temp] = depth[curr] + <span class="number">1</span>;<span class="comment">//更新深度</span></span><br><span class="line">                            neighbor[temp].push_back(curr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//已经被添加并且相邻</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(depth[temp] == depth[curr] + <span class="number">1</span>)&#123;</span><br><span class="line">                            neighbor[temp].push_back(curr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(beginWord, endWord, path, neighbor, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;begin, <span class="built_in">string</span> &amp;curr, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;neighbor, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前点已经等于beginWord</span></span><br><span class="line">        <span class="keyword">if</span>(curr == begin)&#123;</span><br><span class="line">            path.push_back(curr);</span><br><span class="line">            reverse(path.begin(), path.end());<span class="comment">//反转</span></span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;word : neighbor[curr])&#123;</span><br><span class="line">            dfs(begin, word, path, neighbor, res);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果没有逆邻接，则执行完毕此函数后，path还原为上一次的值，即省去了pop_back()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://leetcode-cn.com/problems/word-ladder-ii/solution/zhe-ti-you-xie-nan-bie-ren-de-dai-ma-zuo-xia-zhu-s/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder-ii/solution/zhe-ti-you-xie-nan-bie-ren-de-dai-ma-zuo-xia-zhu-s/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是今天的每日一题，难度为hard，不过与之前软挑赛的题目有很多相似之处，但是我还是没做出来，还是要多总结。最后看了别人的答案，用BFS+DFS才解决这个问题。&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次转换只能改变一个字母。&lt;/li&gt;
&lt;li&gt;转换过程中的中间单词必须是字典中的单词。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不存在这样的转换序列，返回一个空列表。&lt;/li&gt;
&lt;li&gt;所有单词具有相同的长度。&lt;/li&gt;
&lt;li&gt;所有单词只由小写字母组成。&lt;/li&gt;
&lt;li&gt;字典中不存在重复的单词。&lt;/li&gt;
&lt;li&gt;你可以假设 beginWord 和 endWord 是非空的，且二者不相同。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="BFS" scheme="http://www.xingyuzhao.ltd/tags/BFS/"/>
    
      <category term="DFS" scheme="http://www.xingyuzhao.ltd/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode837-新21点</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/06/06/LeetCode837-%E6%96%B021%E7%82%B9/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/06/06/LeetCode837-%E6%96%B021%E7%82%B9/</id>
    <published>2020-06-06T02:53:13.000Z</published>
    <updated>2020-06-06T03:39:57.280Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p><p>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p><p>当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？</p><a id="more"></a><img src="/blog/2020/06/06/LeetCode837-新21点/示例.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题一看不太明白什么意思，看过港片的都知道，在牌面加起来不大于21点时候，谁的牌面最大，谁就能获胜。这道题其实是求爱丽丝获胜的概率，不过点数为N，可以把规则复述一下：</p><ol><li>她可以从<code>[1,W]</code>的牌中任意取一张，可以无限重复取，也就是说取到范围中某张牌的概率一直是<code>1/W</code>；</li><li>如果她手上的牌总额小于K时，她就会继续抽牌，大于等于K时就停止抽牌；</li><li>停止抽牌后，和N进行比较，当小于等于N时，她就获胜了，求获胜的概率。</li></ol><h4 id="定义dp数组的含义"><a href="#定义dp数组的含义" class="headerlink" title="定义dp数组的含义"></a>定义dp数组的含义</h4><p>定义<code>dp[x]</code>为她手上牌面为x时，能获胜的概率。因为每次从<code>[1,W]</code>中抽取的机会都是均等的，所以<code>dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W])</code>。x最多可以到<code>K-1</code>，因为x等于K时会停止抽牌，所以当抽牌结束后，她可能达到的最大牌面是<code>K-1+W</code>，开始时她的牌面为0，所以用长度为K+W的dp数组就够了，最后<code>dp[0]</code>，也就是爱丽丝还没有抽牌时的胜率就是最终答案。</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>其实上一步已经提到了状态转移方程：<code>dp[x] =1/W * (dp[x+1] + dp[x+2] + ... + dp[x+W])</code>，但是dp数组具体应该怎么算呢，可以把它看成一个填格子的游戏，如下图：</p><img src="/blog/2020/06/06/LeetCode837-新21点/image1.png" style="zoom:80%;"><p>将格子分为两个部分，在橘黄色的格子中，爱丽丝是可以抽牌的，而在蓝色的格子中是不可以的。我们每次需要W个格子的结果进行状态转移。</p><p>在蓝色的格子中，对于<code>[K,K+W-1]</code>中小于等于N的值，相应的<code>dp[i]</code>概率就是1，反之为0，在初始化时候进行。</p><img src="/blog/2020/06/06/LeetCode837-新21点/image2.png" style="zoom:80%;"><p>接下来，从K-1处根据状态转移方程进行dp数组的计算。在计算K-2处概率值时，在上一步用一个中间变量<code>sumw</code>保存<code>[K,K+W-1]</code>的概率之和，这样新的概率和<code>sumw = sumw - dp[K-1+W] + dp[K-1]</code>，提高效率。这样从最右边橘黄色格子一直填到最左边，就是最后的结果dp[0]。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(K + W, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">double</span> sumw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K; i &lt;= K + W - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= N) dp[i] = <span class="number">1</span>;</span><br><span class="line">            sumw += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i] = (<span class="keyword">double</span>)<span class="number">1</span> / W * sumw; <span class="comment">//概率可能是小数，需要强制类型转换</span></span><br><span class="line">            sumw = sumw - dp[i+W] + dp[i]; </span><br><span class="line">            <span class="comment">//这里就是减去最右边概率dp[i+W]，加上最左边概率dp[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://leetcode-cn.com/problems/new-21-game/solution/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/new-21-game/solution/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：&lt;/p&gt;
&lt;p&gt;爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。&lt;/p&gt;
&lt;p&gt;当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode877-石子游戏</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/05/28/LeetCode877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/05/28/LeetCode877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</id>
    <published>2020-05-28T11:20:24.000Z</published>
    <updated>2020-05-28T11:56:57.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p><p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p><p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p><a id="more"></a><img src="/blog/2020/05/28/LeetCode877-石子游戏/877.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个题其实一定是先手获胜，为了更具有一般性，假设<strong>石头的堆数可以是任意正整数</strong>，那么就能打破先手必定获胜的局面了，比如<code>piles = [1, 100, 3]</code>，先手不管拿1还是3，能够决胜的100都会被后手拿走，后手获胜。</p><p><strong>博弈问题的难点在于，两个人要轮流进行选择，而且都很精明，应该如何编程表示这个过程呢？</strong>首先明确 dp 数组的含义，只要找到「状态」和「选择」，一切就水到渠成了。</p><h4 id="一、定义-dp-数组的含义"><a href="#一、定义-dp-数组的含义" class="headerlink" title="一、定义 dp 数组的含义"></a>一、定义 dp 数组的含义</h4><p>先看一下dp数组的最终样子，再介绍其含义</p><img src="/blog/2020/05/28/LeetCode877-石子游戏/dp.png" style="zoom:50%;"><p>定义dp数组是二维的，并且每个单元包含first和second两个属性，将这两个属性简写为fir和sec。如按上图的数据，我们说 <code>dp[1][3].fir = 10</code>，<code>dp[0][1].sec = 3</code>。</p><p><strong>以下是对 dp 数组含义的解释：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。</span><br><span class="line">dp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。</span><br><span class="line"></span><br><span class="line">举例理解一下，假设 piles = [<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>]，索引从 <span class="number">0</span> 开始</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>].fir = <span class="number">9</span> 意味着：面对石头堆 [<span class="number">3</span>, <span class="number">9</span>]，先手最终能够获得 <span class="number">9</span> 分。</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">3</span>].sec = <span class="number">2</span> 意味着：面对石头堆 [<span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>]，后手最终能够获得 <span class="number">2</span> 分。</span><br></pre></td></tr></table></figure><p>我们想求的答案是先手和后手最终分数哪个更大，按照这个定义也就是 <code>dp[0][n-1].fir</code>和<code>dp[0][n-1].sec</code>哪个更大。</p><h4 id="二、状态转移方程"><a href="#二、状态转移方程" class="headerlink" title="二、状态转移方程"></a>二、状态转移方程</h4><p>要写状态转移方程，需要找到所有<strong>状态</strong>和每个状态可以做出的<strong>选择</strong>，然后择优。</p><p>根据前面对 dp 数组的定义，<strong>状态</strong>显然有三个：<strong>开始的索引 i，结束的索引 j，当前轮到的人。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j][fir <span class="keyword">or</span> sec]</span><br><span class="line">其中：</span><br><span class="line"><span class="number">0</span> &lt;= i &lt; piles.length</span><br><span class="line">i &lt;= j &lt; piles.length</span><br></pre></td></tr></table></figure><p>对于这个问题的每个状态，可以做的<strong>选择</strong>有两个：<strong>选择最左边的那堆石头，或者选择最右边的那堆石头。</strong></p><p>这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？根据我们对 dp 数组的定义，很容易解决这个难点，<strong>写出状态转移方程：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j].fir = max(piles[i] + dp[i+<span class="number">1</span>][j].sec, piles[j] + dp[i][j<span class="number">-1</span>].sec)</span><br><span class="line">left = piles[i] + dp[i+<span class="number">1</span>][j].sec <span class="comment">//选择最左边的石头堆</span></span><br><span class="line">right = piles[j] + dp[i][j<span class="number">-1</span>].sec <span class="comment">//选择最右边的石头堆</span></span><br><span class="line"># 解释：我作为先手，面对 piles[i...j] 时，有两种选择：</span><br><span class="line"># 要么我选择最左边的那一堆石头，然后面对 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 在上一轮中，我是作为后手的；</span><br><span class="line"># 要么我选择最右边的那一堆石头，然后面对 piles[i...j<span class="number">-1</span>]</span><br><span class="line"># 在上一轮中，我是作为后手的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 先手选择左边:</span><br><span class="line">    dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir</span><br><span class="line"><span class="keyword">if</span> 先手选择右边:</span><br><span class="line">    dp[i][j].sec = dp[i][j<span class="number">-1</span>].fir</span><br><span class="line"># 解释：我作为后手，要等先手先选择，有两种情况：</span><br><span class="line"># 如果先手选择了最左边那堆，给我剩下了 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 此时轮到我，我变成了先手；</span><br><span class="line"># 如果先手选择了最右边那堆，给我剩下了 piles[i...j<span class="number">-1</span>]</span><br><span class="line"># 此时轮到我，我变成了先手。</span><br><span class="line">根据 dp 数组的定义，我们也可以找出base <span class="keyword">case</span>，也就是最简单的情况：</span><br><span class="line"></span><br><span class="line">dp[i][j].fir = piles[i]</span><br><span class="line">dp[i][j].sec = <span class="number">0</span></span><br><span class="line">其中 <span class="number">0</span> &lt;= i == j &lt; n</span><br><span class="line"># 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]，i != j时可以不需要初始化</span><br><span class="line"># 那么显然先手的得分为 piles[i]</span><br><span class="line"># 后手没有石头拿了，得分为 <span class="number">0</span></span><br></pre></td></tr></table></figure><img src="/blog/2020/05/28/LeetCode877-石子游戏/dp1.png" style="zoom:50%;"><p>这里需要注意一点，我们发现 base case 是斜着的，而且我们推算<code>dp[i][j]</code>时需要用到<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>:</p><img src="/blog/2020/05/28/LeetCode877-石子游戏/dp2.png" alt="dp2" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 举例：若i = <span class="number">0</span>, j = <span class="number">1</span></span><br><span class="line"># dp[i][j].fir = <span class="built_in">max</span>(piles[i] + dp[i+<span class="number">1</span>][j].sec, piles[j] + dp[i][j<span class="number">-1</span>].sec)</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>].fir = <span class="built_in">max</span>(piles[<span class="number">0</span>] + dp[<span class="number">1</span>][<span class="number">1</span>].sec, piles[<span class="number">1</span>] + dp[<span class="number">0</span>][<span class="number">0</span>].sec)</span><br><span class="line">     = <span class="built_in">max</span>(<span class="number">3</span> + <span class="number">0</span>, <span class="number">9</span> + <span class="number">0</span>) = <span class="number">9</span></span><br><span class="line"># 先手选择右边第一堆</span><br><span class="line"># <span class="keyword">if</span> 先手选择右边: dp[i][j].sec = dp[i][j<span class="number">-1</span>].fir</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>].sec = dp[<span class="number">0</span>][<span class="number">0</span>].fir = <span class="number">3</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = &#123;<span class="number">9</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>所以说算法不能简单的一行一行遍历 dp 数组，<strong>而要斜着遍历数组：</strong></p><img src="/blog/2020/05/28/LeetCode877-石子游戏/dp3.png" style="zoom:50%;"><p>如何斜着遍历二维数组是个问题，这里我不是很会，只是有个框架，具体的细节还需要再消化消化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 遍历的是橘黄色的部分</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = l + i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/*操作段*/</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><p>实现fir和sec这个单元可以用pair容器，也可以用<code>dp[n][n][2]</code>这种三维数组，我在这里使用了结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pair</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> fir;</span><br><span class="line">        <span class="keyword">int</span> sec;</span><br><span class="line">        Pair() &#123;&#125;;</span><br><span class="line">        Pair(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;fir = a;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sec = b;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        Pair** dp = <span class="keyword">new</span> Pair*[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> Pair[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][i].fir = piles[i];</span><br><span class="line">            dp[i][i].sec = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = l + i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> left = dp[i+<span class="number">1</span>][j].sec + piles[i];</span><br><span class="line">                <span class="keyword">int</span> right = dp[i][j<span class="number">-1</span>].sec + piles[j];</span><br><span class="line">                <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                    dp[i][j].fir = left;</span><br><span class="line">                    dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j].fir = right;</span><br><span class="line">                    dp[i][j].sec = dp[i][j<span class="number">-1</span>].fir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>][n<span class="number">-1</span>].fir &gt; dp[<span class="number">0</span>][n<span class="number">-1</span>].sec) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《labuladong的算法小抄》 动态规划之博弈问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。&lt;/p&gt;
&lt;p&gt;游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。&lt;/p&gt;
&lt;p&gt;亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。&lt;/p&gt;
&lt;p&gt;假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode300-最长上升子序列</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/05/26/LeetCode300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/05/26/LeetCode300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-05-26T01:43:18.000Z</published>
    <updated>2020-05-28T12:02:57.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><a id="more"></a><img src="/blog/2020/05/26/LeetCode300-最长上升子序列/sl.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道动态规划的经典入门题，这里的子序列不一定是连续的。比如示例中<code>[2, 3, 7, 101]</code>，只要是递增的，就是上升子序列，我需要找到这里面最长的上升子序列的长度。</p><p>动态规划一般是由历史信息推断当前信息的，并且历史信息是是独立的子问题，相互之间不会影响。现在考虑一个dp数组，如果说dp[0]到dp[i-1]都可以得到了，如果可以推出dp[i]，就可以得到dp数组的全部结果。</p><h4 id="一、定义dp数组的含义"><a href="#一、定义dp数组的含义" class="headerlink" title="一、定义dp数组的含义"></a>一、定义dp数组的含义</h4><p>我们可以定义dp[i]表示以nums[i]这个数结尾的最长上升子序列的长度。举两个例子：</p><img src="/blog/2020/05/26/LeetCode300-最长上升子序列/ex1.png" style="zoom:80%;"><p>根据这个定义，最终结果(子序列的最大长度)就是dp数组中的最大值。</p><h4 id="二、状态转移方程"><a href="#二、状态转移方程" class="headerlink" title="二、状态转移方程"></a>二、状态转移方程</h4><p>这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：</p><p>我们已经知道了 dp[0]到dp[4] 的所有结果，我们如何通过这些已知结果推出 dp[5] 呢？</p><img src="/blog/2020/05/26/LeetCode300-最长上升子序列/ex2.png" style="zoom:80%;"><p>根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。</p><p>nums[5] = 7，既然是递增子序列，我们只要找到前面那些结尾比 7 小的子序列，然后把 7 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p><p>当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[j]) </span><br><span class="line">        dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta"># dp数组需要初始化为1，因为自己本身也算一个序列</span></span><br><span class="line"># 当i = <span class="number">5</span>时</span><br><span class="line"># nums[<span class="number">5</span>] &gt; nums[<span class="number">2</span>] dp[<span class="number">5</span>] = max&#123;dp[<span class="number">5</span>], dp[<span class="number">2</span>] + <span class="number">1</span>&#125; = max&#123;<span class="number">1</span>, <span class="number">2</span>&#125; = <span class="number">2</span></span><br><span class="line"># nums[<span class="number">5</span>] &gt; nums[<span class="number">3</span>] dp[<span class="number">5</span>] = max&#123;dp[<span class="number">5</span>], dp[<span class="number">3</span>] + <span class="number">1</span>&#125; = max&#123;<span class="number">2</span>, <span class="number">2</span> + <span class="number">1</span>&#125; = <span class="number">3</span></span><br><span class="line"># nums[<span class="number">5</span>] &gt; nums[<span class="number">4</span>] dp[<span class="number">5</span>] = max&#123;dp[<span class="number">5</span>], dp[<span class="number">4</span>] + <span class="number">1</span>&#125; = max&#123;<span class="number">3</span>, <span class="number">2</span> + <span class="number">1</span>&#125; = <span class="number">3</span></span><br><span class="line"># 所以dp[<span class="number">5</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>根据上述的状态转移公式，就可以得到dp数组的所有值，我们再取其中的最大值，就是答案。</p><h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = max(dp[i],dp[j] + <span class="number">1</span>); </span><br><span class="line">                <span class="comment">//dp[i]是指历史中的最大长度，否则后面的长度+1小于历史最大长度时，会覆盖</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《labuladong的算法小抄》 动态规划设计：最长递增子序列</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://www.xingyuzhao.ltd/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2020学习/工作计划</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/04/30/2020%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/04/30/2020%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2020-04-30T11:38:26.000Z</published>
    <updated>2020-05-28T14:49:21.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ol><li>写在前面</li><li>疫情期间的工作</li><li>反思自己的不足</li><li>2020学习/工作计划</li></ol><a id="more"></a><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>2020年已经过去了四分之一，我才意识到需要做一个全年计划。这几个月来，小计划不断，但是都没有很好的完成，并且很容易受到外界因素的干扰，自己不知道自己到底<strong>需要做什么</strong>，于是看似做了不少东西，但是意义不大。我觉得全年的学习生活应该有一个基调，一年中总是要完成一些事情的。最近几周一直后悔来到西电读研，觉得为什么当初不选择一个985，我觉得我还是可以考上的，去年也没有下定决心再来一年，所以这可能是一辈子的遗憾了，反正读博是不存在的。也许等以后工作了才能慢慢释然吧。</p><h4 id="疫情期间都做了什么？"><a href="#疫情期间都做了什么？" class="headerlink" title="疫情期间都做了什么？"></a>疫情期间都做了什么？</h4><ol><li><p>首先是帮助师兄改了一个polar码的scl译码方法，其实到现在我对其原理也不是很明白，只是知道代码怎么用…</p></li><li><p>开始刷leetcode的题目，目前大概刷了100+，还是有一定的作用的。完成了</p><ul><li>数据结构部分：队列和栈，数组和字符串，二分查找(83%)，链表(46%)</li><li>算法：BFS，DFS，双指针</li><li>C++中vector，map，set等容器的使用，发现自己掌握的真是冰山一角</li></ul></li><li><p>阅读了机器学习的几篇论文，主要是了解了随机梯度下降(SGD)方法，后面还需要进一步学习</p></li><li><p>很有限的学习了机器学习，矩阵论相关的内容</p></li><li><p>参加了华为的软件精英挑战赛，西北赛区第十名，进入复赛</p></li></ol><h4 id="自己的不足"><a href="#自己的不足" class="headerlink" title="自己的不足"></a>自己的不足</h4><p>真正认识自己的不足也是在比赛期间，当你看到你辛辛苦苦半个月做出来的成果别人只需要几天，并且成绩还比你好的多的时候，你就越发的感觉到自己的渺小，我后悔的事情太多了，本科时候没有参加ACM是最大的错误，无论是数学建模或者是电赛，对于以后要进军互联网来说都没有ACM的奖牌作用大。不过我也意识到了这是教育之间的差异，有些人在中学的时候就开始接触比赛了，到了大学继续比赛那肯定更加熟练。我在高中的时候谈到计算机估计想的就是装个软件，换个内存条什么的，编程这个词都不知道啥意思，更不用说参加信息类的比赛了。。。为社么别人可以做到那些，我做不到，这并不全是自己的问题，种一棵树从现在开始也不迟，<strong>虽然已经知道和别人的差距很大，但是只要是能缩小差距，那就是自己的进步</strong>！还有一年的时间，一年是很快的，而且还有实验室的事情需要忙，所以时间很紧迫，千万不能再浪费了！</p><h4 id="2020学习-工作计划"><a href="#2020学习-工作计划" class="headerlink" title="2020学习/工作计划"></a>2020学习/工作计划</h4><ol><li>继续刷leetcode，学习了新算法，新思路或者新的函数之后在博客中进行总结，至少一周一篇，并且要做好题目的分类，算法和思路在tags中注明算法/思路，函数在tags中注明函数，在分类中注明C++。其中保证每周做7题以上，对于过于简单的题不计算在内，书籍<strong>《算法》</strong>。</li><li>继续学习C++，把<strong>《C++ Prime》</strong>过一遍，每周在博客总结一次，标签：C++ Prime，分类：C++；辅助阅读<strong>《STL源码剖析》</strong>和<strong>《Effective C++》</strong>标签：书名，分类：C++</li><li><strong>《计算机网络 自顶向下方法》</strong>前四章内容</li><li><strong>《UNIX 网络编程》《UNIX 环境高级编程》</strong> 辅助书籍<strong>《Unix/Linux 编程实践教程》</strong></li><li><strong>《深入理解计算机系统》</strong>三四章可以先不看</li><li>机器学习的相关课程：吴恩达机器学习基础课程，CS231n计算机视觉课程，适应阅读英文论文，加强英语的学习</li><li>积极参加有水平的比赛</li><li>阅读一本非专业的书籍，陶冶陶冶情操？</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;写在前面&lt;/li&gt;
&lt;li&gt;疫情期间的工作&lt;/li&gt;
&lt;li&gt;反思自己的不足&lt;/li&gt;
&lt;li&gt;2020学习/工作计划&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="生活随笔" scheme="http://www.xingyuzhao.ltd/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="计划" scheme="http://www.xingyuzhao.ltd/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode17-电话号码的字母组合</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/02/16/LeetCode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/02/16/LeetCode17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</id>
    <published>2020-02-16T06:40:09.000Z</published>
    <updated>2020-02-16T08:07:08.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>已知数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><a id="more"></a><img src="/blog/2020/02/16/LeetCode17-电话号码的字母组合/1.png" style="zoom:80%;"><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>字符串的长度不确定，所以用循环直接解决不实际；</p><p>可以由下至上进行递归来求解，以“23”为例，如图：</p><pre class="mermaid">graph TDA[2] -->|a| B[3]A[2] -->|b| C[3]A[2] -->|c| D[3]B[3] -->|d| E[ad]B[3] -->|f| F[af]B[3] -->|g| G[ag]C[3] -->|d| H[bd]C[3] -->|f| I[bf]C[3] -->|g| J[bg]D[3] -->|d| K[cd]D[3] -->|f| L[cf]D[3] -->|g| M[cg]</pre><p>记数字2为第0层，那么数字3为第1层，需要一个变量level，记录当前遍历数字的位置。递归表现在：如果选择了’a’，那么就需要再进行三次选择‘d’ ‘f’ ‘g’后才可以输出，再选择’b’，以此类推。即递归到最后一层，输出一次递归结果，全部递归完成，得到最终结果。</p><p>具体算法如下：</p><ul><li>建立一个<strong>map</strong>，用来存储数字与其对应的字符串，当然，这里的数字是char类型。</li><li>递归函数中，首先判断<strong>level</strong>，如果等于<strong>digits</strong>中数字的个数，那么将当前的结果并入<strong>res</strong>，然后返回。</li><li>否则通过<strong>digits</strong>中的数字找到对应的字符串，然后遍历取出整个字符串，将每个字符串都加到当前的组合后面，再调用递归函数。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; num_str&#123;&#123;<span class="string">'2'</span>,<span class="string">"abc"</span>&#125;,&#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;,&#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;,&#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;,&#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;,&#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,&#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        combin(digits,num_str,<span class="number">0</span>,<span class="string">""</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combin</span><span class="params">(<span class="built_in">string</span> digits,<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; num_str,<span class="keyword">int</span> level,<span class="built_in">string</span> out,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(level == digits.length())</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> buf = num_str[digits[level]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buf.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            combin(digits,num_str,level+<span class="number">1</span>,out+buf[i],res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。&lt;br&gt;已知数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://www.xingyuzhao.ltd/categories/LeetCode/"/>
    
    
      <category term="递归" scheme="http://www.xingyuzhao.ltd/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>转载：时间复杂度O(logn)意味着什么？（侵删）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2020/01/01/%E8%BD%AC%E8%BD%BD%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-logn-%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E4%BE%B5%E5%88%A0%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2020/01/01/%E8%BD%AC%E8%BD%BD%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-logn-%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E4%BE%B5%E5%88%A0%EF%BC%89/</id>
    <published>2020-01-01T15:15:50.000Z</published>
    <updated>2020-05-28T14:48:46.503Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;</p><ul><li>原文地址：https://github.com/xitu/gold-miner/blob/master/TODO/what-does-the-time-complexity-o-log-n-actually-mean.md</li>    <li>原文作者：<a href="https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F%40maazrk" rel="noopener" target="_blank">Maaz</a></li>    <li>译文出自：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner" rel="noopener" target="_blank">掘金翻译计划</a></li>    <li>译者：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcdpath" rel="noopener" target="_blank">cdpath</a></li>    <li>校对者：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fzaraguo" rel="noopener" target="_blank">zaraguo (zaraguo)</a>,&nbsp;<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwhatbeg" rel="noopener" target="_blank">whatbeg (Qiu Hu)</a></li></ul><p>&nbsp;</p><a id="more"></a><p><em>友情提示：如果图片挂了，请翻墙或者点击原文地址阅读。</em></p><p>&nbsp;</p><p>预先知道算法的复杂度是一回事，了解其后的原理是另一件事情。</p><p>&nbsp;</p><p>不管你是计算机科班出身还是想有效解决最优化问题，如果想要用自己的知识解决实际问题，你都必须理解时间复杂度。</p><p>先从简单直观的 O(1) 和 O(n) 复杂度说起。O(1) 表示一次操作即可直接取得目标元素（比如字典或哈希表），O(n) 意味着先要检查 n 个元素来搜索目标，但是 O(log n) 是什么意思呢？</p><p>你第一次听说 O(log n) 时间复杂度可能是在学二分搜索算法的时候。二分搜索一定有某种行为使其时间复杂度为 log n。我们来看看是二分搜索是如何实现的。</p><p>因为在最好情况下二分搜索的时间复杂度是 O(1)，最坏情况（平均情况）下 O(log n)，我们直接来看最坏情况下的例子。已知有 16 个元素的有序数组。</p><p>举个最坏情况的例子，比如我们要找的是数字 13。</p><p><img alt class="has" src="https://img-blog.csdnimg.cn/20191121164646526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70"></p><p>十六个元素的有序数组</p><p><img alt class="has" src="https://img-blog.csdnimg.cn/20191121164704291.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMzk2ODY0Mjg1,size_16,color_FFFFFF,t_70"></p><p>选中间的元素作为中心点（长度的一半）</p><p><img alt class="has" height="191" src="https://img-blog.csdnimg.cn/20191121164715238.jpeg" width="628"></p><p>13 小于中心点，所以不用考虑数组的后一半</p><p><img alt class="has" height="134" src="https://img-blog.csdnimg.cn/20191121164726473.jpeg" width="411"></p><p>重复这个过程，每次都寻找子数组的中间元素</p><p>&nbsp;</p><p><img alt class="has" height="101" src="https://img-blog.csdnimg.cn/20191121164751215.jpeg" width="285"></p><p><img alt class="has" height="91" src="https://img-blog.csdnimg.cn/20191121164811565.jpeg" width="223"></p><p>每次和中间元素比较都会使搜索范围减半。</p><p>所以为了从 16 个元素中找到目标元素，我们需要把数组平均分割 4 次，也就是说，</p><p><img alt class="has" height="141" src="https://img-blog.csdnimg.cn/20191121164824637.png" width="288"></p><p>简化后的公式</p><p>类似的，如果有 n 个元素，</p><p><img alt class="has" height="141" src="https://img-blog.csdnimg.cn/20191121164908192.png" width="301"></p><p>&nbsp;</p><p>归纳一下</p><p><img alt class="has" height="141" src="https://img-blog.csdnimg.cn/20191121164916433.png" width="275"></p><p>分子和分母代入指数</p><p><img alt class="has" height="141" src="https://img-blog.csdnimg.cn/20191121164930660.png" width="275"></p><p>等式两边同时乘以 2^k</p><p><img alt class="has" height="100" src="https://img-blog.csdnimg.cn/20191121164955503.png" width="285"></p><p>最终结果</p><p>现在来看看「对数」的定义：</p><blockquote><p>为使某数（底数）等于一给定数而必须取的乘幂的幂指数。</p></blockquote><p>也就是说可以写成这种形式</p><p><img alt class="has" height="87" src="https://img-blog.csdnimg.cn/2019112116500667.png" width="331"></p><p>对数形式</p><p>所以 log n 的确是有意义的，不是吗？没有其他什么可以表示这种行为。</p><p>就这样吧，我希望我讲得这些你都搞懂了。在从事计算机科学相关的工作时，了解这类知识总是有用的（而且很有趣）。说不定就因为你知道算法的原理，你成了小组里能找出问题的最优解的人呢，谁知道呢。祝好运！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原文地址：https://github.com/xitu/gold-miner/blob/master/TODO/what-does-the-time-complexity-o-log-n-actually-mean.md&lt;/li&gt;
    &lt;li&gt;原文作者：&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F%40maazrk&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Maaz&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;译文出自：&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;译者：&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcdpath&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;cdpath&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;校对者：&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fzaraguo&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;zaraguo (zaraguo)&lt;/a&gt;,&amp;nbsp;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwhatbeg&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;whatbeg (Qiu Hu)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://www.xingyuzhao.ltd/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="数据结构" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>链式栈</title>
    <link href="http://www.xingyuzhao.ltd/blog/2019/12/29/%E9%93%BE%E5%BC%8F%E6%A0%88/"/>
    <id>http://www.xingyuzhao.ltd/blog/2019/12/29/%E9%93%BE%E5%BC%8F%E6%A0%88/</id>
    <published>2019-12-29T14:00:21.000Z</published>
    <updated>2020-01-01T08:50:57.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h3><ol><li>编写链式栈</li><li>括号匹配问题</li></ol><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在程序中同时使用多个栈的情况下，使用链式栈不但可以提高存储效率，同时还可以达到共享存储空间的目的。</p><p>链式栈的结构如图所示，一般都不使用头结点，而进行直接实现。</p><img src="/blog/2019/12/29/链式栈/结构图.png" style="zoom: 50%;"><h4 id="1-结点类模板"><a href="#1-结点类模板" class="headerlink" title="1. 结点类模板"></a>1. 结点类模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line">Node&lt;ElemType&gt; *next;</span><br><span class="line"></span><br><span class="line">Node();</span><br><span class="line">Node(ElemType item, Node&lt;ElemType&gt; *link);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">Node&lt;ElemType&gt;::Node()</span><br><span class="line">&#123;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">Node&lt;ElemType&gt;::Node(ElemType item, Node&lt;ElemType&gt; *link)</span><br><span class="line">&#123;</span><br><span class="line">data = item;</span><br><span class="line">next = link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-链式栈类模板"><a href="#2-链式栈类模板" class="headerlink" title="2. 链式栈类模板"></a>2. 链式栈类模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Node&lt;ElemType&gt; *top;<span class="comment">//栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> count;<span class="comment">//元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">LinkStack();<span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">virtual</span>~LinkStack();<span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;<span class="comment">//清空栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(<span class="keyword">void</span>(*visit)(<span class="keyword">const</span> ElemType&amp;))</span> <span class="keyword">const</span></span>;<span class="comment">//对每个对象调用visit</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> ElemType &amp;e)</span></span>;<span class="comment">//压栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Top</span><span class="params">(ElemType &amp;e)</span> <span class="keyword">const</span></span>;<span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(ElemType &amp;e)</span></span>;<span class="comment">//出栈</span></span><br><span class="line">LinkStack(<span class="keyword">const</span> LinkStack&lt;ElemType&gt;&amp;copy);<span class="comment">//复制构造函数模板</span></span><br><span class="line">LinkStack&lt;ElemType&gt;&amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> LinkStack&lt;ElemType&gt;&amp;copy);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-成员函数"><a href="#3-成员函数" class="headerlink" title="3. 成员函数"></a>3. 成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">LinkStack&lt;ElemType&gt;::LinkStack()</span><br><span class="line">&#123;</span><br><span class="line">top = <span class="literal">NULL</span>;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">LinkStack&lt;ElemType&gt;::~LinkStack()</span><br><span class="line">&#123;</span><br><span class="line">Clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">int</span> LinkStack&lt;ElemType&gt;::Length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkStack&lt;ElemType&gt;::Empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkStack&lt;ElemType&gt;::Clear()</span><br><span class="line">&#123;</span><br><span class="line">ElemType tmpElem;</span><br><span class="line"><span class="keyword">while</span> (!Empty())</span><br><span class="line">&#123;</span><br><span class="line">Pop(tmpElem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">void</span> LinkStack&lt;ElemType&gt;::Traverse(<span class="keyword">void</span>(*visit)(<span class="keyword">const</span> ElemType &amp;)) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;ElemType&gt; *tmpPtr;</span><br><span class="line">LinkStack&lt;ElemType&gt; tmps;</span><br><span class="line"><span class="keyword">for</span> (tmpPtr = top; tmpPtr != <span class="literal">NULL</span>; tmpPtr = tmpPtr-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">tmps.Push(tmpPtr-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (tmpPtr = tmps.top; tmpPtr != <span class="literal">NULL</span>; tmpPtr = tmpPtr-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">(*visit)(tmpPtr-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkStack&lt;ElemType&gt;::Push(<span class="keyword">const</span> ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;ElemType&gt; *newTop = <span class="keyword">new</span> Node&lt;ElemType&gt;(e, top);</span><br><span class="line"><span class="keyword">if</span> (newTop == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">top = newTop;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkStack&lt;ElemType&gt;::Top(ElemType &amp;e) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">e = top-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> LinkStack&lt;ElemType&gt;::Pop(ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;ElemType&gt; *old_top = top;</span><br><span class="line">e = old_top-&gt;data;</span><br><span class="line">top = old_top-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> old_top;</span><br><span class="line">count--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">LinkStack&lt;ElemType&gt;::LinkStack(<span class="keyword">const</span> LinkStack&lt;ElemType&gt; &amp;copy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//由栈copy构造新栈——复制构造函数模板</span></span><br><span class="line"><span class="keyword">if</span> (copy.Empty())</span><br><span class="line">&#123;</span><br><span class="line">top = <span class="literal">NULL</span>;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">top = <span class="keyword">new</span> Node&lt;ElemType&gt;(copy.top-&gt;data,copy.top);<span class="comment">//栈顶</span></span><br><span class="line">count = copy.count;</span><br><span class="line"></span><br><span class="line">Node&lt;ElemType&gt; *buttomPtr = top;<span class="comment">//栈底</span></span><br><span class="line"><span class="keyword">for</span> (Node&lt;ElemType&gt;*tmpPtr = copy.top-&gt;next; tmpPtr != <span class="literal">NULL</span>; tmpPtr = tmpPtr-&gt;next)<span class="comment">//从copy中第二个值开始取，第一个已经被复制给top(buttomPtr)</span></span><br><span class="line">&#123;</span><br><span class="line">buttomPtr-&gt;next = <span class="keyword">new</span> Node&lt;ElemType&gt;(tmpPtr-&gt;data,tmpPtr-&gt;next);</span><br><span class="line">buttomPtr = buttomPtr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">LinkStack&lt;ElemType&gt;&amp;LinkStack&lt;ElemType&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> LinkStack&lt;ElemType&gt; &amp;copy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将栈copy赋值给当前栈——重载赋值运算符</span></span><br><span class="line"><span class="keyword">if</span> (&amp;copy != <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (copy.Empty())</span><br><span class="line">&#123;<span class="comment">//copy为空</span></span><br><span class="line">top = <span class="literal">NULL</span>;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">//copy非空，复制栈</span></span><br><span class="line">Clear();</span><br><span class="line">top = <span class="keyword">new</span> Node&lt;ElemType&gt;(copy.top-&gt;data,copy.top);</span><br><span class="line">count = copy.count;</span><br><span class="line"></span><br><span class="line">Node&lt;ElemType&gt;*buttomPtr = top;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;ElemType&gt;*tmpPtr = copy.top-&gt;next; tmpPtr != <span class="literal">NULL</span>; tmpPtr = tmpPtr-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">buttomPtr-&gt;next = <span class="keyword">new</span> Node&lt;ElemType&gt;(tmpPtr-&gt;data,tmpPtr-next);</span><br><span class="line">buttomPtr = buttomPtr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-main"><a href="#4-main" class="headerlink" title="4. main()"></a>4. main()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"alg.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStack&lt;<span class="keyword">int</span>&gt; l1;</span><br><span class="line"><span class="keyword">int</span> e1,e2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的三个数分别为5，1，2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">l1.Push(<span class="number">5</span>);</span><br><span class="line">l1.Push(<span class="number">1</span>);</span><br><span class="line">l1.Push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"当前栈长为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l1.Length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"弹出栈顶，返回值为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">l1.Pop(e1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"当前栈长为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l1.Length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">l1.Top(e2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"返回当前栈顶元素：\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出l1当前栈内元素(dir:bottom-&gt;top)：\n"</span>;</span><br><span class="line">l1.Traverse(<span class="built_in">display</span>); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack&lt;<span class="keyword">int</span>&gt; <span class="title">l2</span><span class="params">(l1)</span></span>;</span><br><span class="line"><span class="comment">//l2 = l1;//将l1复制给l2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出l2当前栈内元素(dir:bottom-&gt;top)：\n"</span>;</span><br><span class="line">l2.Traverse(<span class="built_in">display</span>); <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如图：</p><img src="/blog/2019/12/29/链式栈/结果图.png" style="zoom: 80%;"><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>设计一个算法判别用字符串表示的表达式中括号()[]{}是否配对出现，括号之间无优先级。</p><p>算法思路：</p><p>如果读入的字符为(、[、{，则进栈；</p><p>若读入的字符为)，如果栈空则说明不匹配；栈顶括号为(，则出栈匹配，否则不匹配，此时栈顶为[、{或空；</p><p>若读入的字符为]，如果栈空则说明不匹配；栈顶括号为[，则出栈匹配，否则不匹配，此时栈顶为(、{或空；</p><p>若读入的字符为}，如果栈空则说明不匹配；栈顶括号为{，则出栈匹配，否则不匹配，此时栈顶为[、(或空；</p><p>若读入其他字符，则继续读入；</p><p>扫描完各字符后，如栈为空则匹配，否则不匹配（括号数量为偶数，但括号不一定匹配）</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStack&lt;<span class="keyword">char</span>&gt; tmps;<span class="comment">//临时栈</span></span><br><span class="line"><span class="keyword">char</span> tmpch;<span class="comment">//临时字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'('</span> || s[i] == <span class="string">'['</span> || s[i] == <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmps.Push(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmps.Empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tmps.Top(tmpch), tmpch == <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmps.Pop(tmpch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmps.Empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tmps.Top(tmpch), tmpch == <span class="string">'['</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmps.Pop(tmpch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'&#125;'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmps.Empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tmps.Top(tmpch), tmpch == <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmps.Pop(tmpch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmps.Empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"无括号优先级"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> *s1 = <span class="string">"&#123;a*[c+d*(e+f)]&#125;"</span>;</span><br><span class="line"><span class="keyword">char</span> *s2 = <span class="string">"&#123;a*[c+d*[e+f)]&#125;"</span>;</span><br><span class="line"><span class="built_in">string</span> True = <span class="string">"匹配"</span>;</span><br><span class="line"><span class="built_in">string</span> False = <span class="string">"不匹配"</span>;</span><br><span class="line"><span class="built_in">string</span> s1_result = match(s1) ? True : False;</span><br><span class="line"><span class="built_in">string</span> s2_result = match(s2) ? True : False;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1_result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2_result &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/blog/2019/12/29/链式栈/匹配问题.png">]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;编写链式栈&lt;/li&gt;
&lt;li&gt;括号匹配问题&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.xingyuzhao.ltd/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>循环链表解决约瑟夫问题</title>
    <link href="http://www.xingyuzhao.ltd/blog/2019/11/18/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E8%A7%A3%E5%86%B3%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"/>
    <id>http://www.xingyuzhao.ltd/blog/2019/11/18/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E8%A7%A3%E5%86%B3%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</id>
    <published>2019-11-18T15:05:26.000Z</published>
    <updated>2019-12-03T05:05:27.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h3><ol><li>编写循环链表，由单链表修改得到</li><li>使用循环链表解决约瑟夫问题</li></ol><a id="more"></a><h3 id="循环链表与单链表的不同之处"><a href="#循环链表与单链表的不同之处" class="headerlink" title="循环链表与单链表的不同之处"></a>循环链表与单链表的不同之处</h3><p>循环链表是另外一种线性表链式存储结构，它的节点结构与单链表相同，与单链表不同的是在循环链表中的表尾节点的<code>next</code>不为空（NULL），而是指向头节点，所以循环链表为空的条件为<code>head-&gt;next==head</code>,如图所示：</p><img src="/blog/2019/11/18/循环链表解决约瑟夫问题/非空循环链表.png" style="zoom: 67%;"><p>​                                                                                    (a)非空循环链表</p><img src="/blog/2019/11/18/循环链表解决约瑟夫问题/空循环链表.png" style="zoom: 67%;"><p>​                                                                                        (b)空循环链表</p><p>循环链表的操作与线性表的操作基本相同，只是将算法中的循环条件改为<code>temPtr</code>是否等于头指针，以下给出与单链表不同之处：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">Node&lt;ElemType&gt; * SimpleCircLinkList&lt;ElemType&gt;::GetElemPtr(<span class="keyword">int</span> <span class="built_in">position</span>) <span class="keyword">const</span></span><br><span class="line"><span class="comment">//返回指向第position个结点的指针,时间复杂度O(n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">position</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;ElemType&gt; *tmpPtr = head-&gt;next; <span class="comment">//用tmpPtr遍历线性表以查找第position个结点</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">1</span>;<span class="comment">//tmpPtr所指结点的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tmpPtr != head&amp;&amp;pos &lt; <span class="built_in">position</span>)</span><br><span class="line">&#123;<span class="comment">//顺指针向后查找，直到tmpPtr指向第position个结点</span></span><br><span class="line">tmpPtr = tmpPtr-&gt;next;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmpPtr != head&amp;&amp;pos == <span class="built_in">position</span>)</span><br><span class="line">&#123;<span class="comment">//查找成功</span></span><br><span class="line"><span class="keyword">return</span> tmpPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">//查找失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">int</span> SimpleCircLinkList&lt;ElemType&gt;::Length() <span class="keyword">const</span></span><br><span class="line"><span class="comment">//返回线性表元素的个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;ElemType&gt; *tmpPtr = head-&gt;next; tmpPtr != <span class="literal">NULL</span>; tmpPtr = tmpPtr-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (tmpPtr == head) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> SimpleCircLinkList&lt;ElemType&gt;::Empty() <span class="keyword">const</span></span><br><span class="line"><span class="comment">//如果线性表为空，返回true，否则返回false</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> head-&gt;next == head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">void</span> SimpleCircLinkList&lt;ElemType&gt;::Traverse(<span class="keyword">void</span>(*visit)(<span class="keyword">const</span> ElemType &amp;)) <span class="keyword">const</span></span><br><span class="line"><span class="comment">//依次对线性表每个元素调用函数(*visit)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;ElemType&gt; * tmpPtr = head-&gt;next; tmpPtr != head; tmpPtr = tmpPtr-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">(*visit)(tmpPtr-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环列表解决与瑟夫问题"><a href="#循环列表解决与瑟夫问题" class="headerlink" title="循环列表解决与瑟夫问题"></a>循环列表解决与瑟夫问题</h3><p>问题描述：一个旅行社要从n个旅客中选出一名旅客，为他提供免费旅行服务，选择方法是让n个旅客围成一个圆圈，然后从信封中取出一张纸条，用上面写着的正整数m(m&lt;n)作为报数值，第一个人从1开始一个人一个人按顺时针报数，报到第m个旅客时，令其出列。然后从下一个人开始，从1顺时针报数，报到第m个游客时，再令其出列，如此下去，直到只剩下一个人为止。此人即为优胜者。如n=8，m=3，出列的顺序为3、6、1、5、2、8、4，最初编号为7的游客获得免费旅行服务。（待更新算法详细步骤）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//main.cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;alg.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename ElemType&gt;</span><br><span class="line">void display(ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//循环链表解决约瑟夫问题</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">SimpleCircLinkList&lt;int&gt; la;</span><br><span class="line">int n = 8, m = 3;</span><br><span class="line">int position = 1;</span><br><span class="line">int out, winer;</span><br><span class="line">for (int k = 1; k &lt;= n; k++)</span><br><span class="line">&#123;</span><br><span class="line">la.Insert(k, k);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 1; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (position &gt; la.Length())</span><br><span class="line">&#123;</span><br><span class="line">position = 1;</span><br><span class="line">&#125;</span><br><span class="line">position++;</span><br><span class="line">&#125;</span><br><span class="line">position--;</span><br><span class="line">la.Delete(position, out);</span><br><span class="line">cout &lt;&lt; out &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">la.GetElem(1, winer);</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; &quot;优胜者：&quot; &lt;&lt; winer &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="/blog/2019/11/18/循环链表解决约瑟夫问题/结果.png">]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;编写循环链表，由单链表修改得到&lt;/li&gt;
&lt;li&gt;使用循环链表解决约瑟夫问题&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.xingyuzhao.ltd/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>单链表的基本操作</title>
    <link href="http://www.xingyuzhao.ltd/blog/2019/10/30/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.xingyuzhao.ltd/blog/2019/10/30/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2019-10-29T16:35:50.000Z</published>
    <updated>2019-12-03T05:05:12.826Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点（更新于2019-12-3）"><a href="#本次学习要点（更新于2019-12-3）" class="headerlink" title="本次学习要点（更新于2019.12.3）"></a>本次学习要点（更新于2019.12.3）</h3><ol><li>掌握线性表的抽象数据类型</li><li>掌握链表的基本操作</li><li>学习链表的较复杂的操作</li></ol><a id="more"></a><h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h3><ol><li><code>int Length() const</code></li></ol><ul><li>初始条件：线性表已存在</li><li>操作结果：返回线性表中元素的个数</li></ul><ol start="2"><li><code>bool Empty() const</code></li></ol><ul><li>初始条件：线性表已存在</li><li>操作结果：判断线性表是否为空</li></ul><ol start="3"><li><code>void Clear()</code></li></ol><ul><li>初始条件：线性表已存在</li><li>操作结果：清空线性表</li></ul><ol start="4"><li><code>void Traverse(void(*visit)(const ElemType &amp;))</code></li></ol><ul><li>初始条件：线性表已存在</li><li>操作结果：对每个元素调用函数(*visit)</li></ul><ol start="5"><li><code>bool GetElem(int position,ElemType &amp;e) const</code></li></ol><ul><li>初始条件：线性表已存在，1&lt;=position&lt;=Length()</li><li>操作结果：用e返回第position处的元素值</li></ul><ol start="6"><li><code>bool SetElem(int position,const ElemType &amp;e)</code></li></ol><ul><li>初始条件：线性表已存在，1&lt;=position&lt;=Length()</li><li>操作结果：设置第position处的元素值为e</li></ul><ol start="7"><li><code>bool Delete(int position,ElemType &amp;e)</code></li></ol><ul><li>初始条件：线性表已存在，1&lt;=position&lt;=Length()</li><li>操作结果：删除第position个元素，并用e返回其值，长度减少1</li></ul><ol start="8"><li><code>bool Insert(int position,const ElemType &amp;e)</code></li></ol><ul><li>初始条件：线性表已存在，1&lt;=position&lt;=Length()+1</li><li>操作结果：在第position前插入元素e，长度加1</li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>函数声明中的<code>const</code>是什么作用？在不同位置的意思分别是什么？</p><p>答：在成员函数后的<code>const</code>指常成员函数，不能更改类成员变量的值；在变量前的<code>const</code>指常变量，在函数体重不能更改变量值。</p><h3 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名alg.h</span></span><br><span class="line"><span class="comment">//结点结构体模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//数据成员</span></span><br><span class="line">ElemType data;</span><br><span class="line">Node&lt;ElemType&gt; *next;</span><br><span class="line"><span class="comment">//构造函数模板</span></span><br><span class="line">Node();<span class="comment">//无参数的构造函数模板</span></span><br><span class="line">Node(ElemType item, Node&lt;ElemType&gt; *link);<span class="comment">//已知数据元素和后继指针建立结构</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结点模板的实现部分</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">Node&lt;ElemType&gt;::Node()</span><br><span class="line"><span class="comment">//构造后继指针为空的结点</span></span><br><span class="line">&#123;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">Node&lt;ElemType&gt;::Node(ElemType item, Node&lt;ElemType&gt; *link)</span><br><span class="line"><span class="comment">//构造一个数据元素为item和后继指针为link的结点</span></span><br><span class="line">&#123;</span><br><span class="line">data = item;</span><br><span class="line">next = link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性链表简单实现为数据成员只有头指针，成员函数模板与顺序表相似</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单线性链表类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Node&lt;ElemType&gt; *head;</span><br><span class="line"><span class="function">Node&lt;ElemType&gt; *<span class="title">GetElemPtr</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//返回指向第position个结点的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SimpleLinkList();</span><br><span class="line"><span class="keyword">virtual</span>~SimpleLinkList();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(<span class="keyword">void</span>(*visit)(<span class="keyword">const</span> ElemType &amp;))</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetElem</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, ElemType &amp;e)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SetElem</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="keyword">const</span> ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="keyword">const</span> ElemType &amp;e)</span></span>;</span><br><span class="line">SimpleLinkList(<span class="keyword">const</span> SimpleLinkList&lt;ElemType&gt; &amp;copy);</span><br><span class="line">SimpleLinkList&lt;ElemType&gt;&amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SimpleLinkList&lt;ElemType&gt;&amp;copy);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数模板的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">Node&lt;ElemType&gt; * SimpleLinkList&lt;ElemType&gt;::GetElemPtr(<span class="keyword">int</span> <span class="built_in">position</span>) <span class="keyword">const</span></span><br><span class="line"><span class="comment">//返回指向第position个结点的指针,时间复杂度O(n)</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;ElemType&gt; *tmpPtr = head; <span class="comment">//用tmpPtr遍历线性表以查找第position个结点</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;<span class="comment">//tmpPtr所指结点的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tmpPtr != <span class="literal">NULL</span>&amp;&amp;pos &lt; <span class="built_in">position</span>)</span><br><span class="line">&#123;<span class="comment">//顺指针向后查找，知道tmpPtr指向第position个结点</span></span><br><span class="line">tmpPtr = tmpPtr-&gt;next;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmpPtr != <span class="literal">NULL</span>&amp;&amp;pos == <span class="built_in">position</span>)</span><br><span class="line">&#123;<span class="comment">//查找成功</span></span><br><span class="line"><span class="keyword">return</span> tmpPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">//查找失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">SimpleLinkList&lt;ElemType&gt;::SimpleLinkList()</span><br><span class="line"><span class="comment">//构造一个空链表</span></span><br><span class="line">&#123;</span><br><span class="line">head = <span class="keyword">new</span> Node&lt;ElemType&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">SimpleLinkList&lt;ElemType&gt;::~SimpleLinkList()</span><br><span class="line"><span class="comment">//销毁线性表</span></span><br><span class="line">&#123;</span><br><span class="line">Clear();</span><br><span class="line"><span class="keyword">delete</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">int</span> SimpleLinkList&lt;ElemType&gt;::Length() <span class="keyword">const</span></span><br><span class="line"><span class="comment">//返回线性表元素的个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Node&lt;ElemType&gt; *tmpPtr;</span><br><span class="line"><span class="keyword">for</span> (tmpPtr = head-&gt;next; tmpPtr != <span class="literal">NULL</span>; tmpPtr = tmpPtr-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> SimpleLinkList&lt;ElemType&gt;::Empty() <span class="keyword">const</span></span><br><span class="line"><span class="comment">//如果线性表为空，返回true，否则返回false</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">void</span> SimpleLinkList&lt;ElemType&gt;::Clear()</span><br><span class="line"><span class="comment">//清空线性表</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType tmpElem;</span><br><span class="line"><span class="keyword">while</span> (!Empty())</span><br><span class="line">&#123;<span class="comment">//线性表非空，删除第一个元素</span></span><br><span class="line">Delete(<span class="number">1</span>, tmpElem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">void</span> SimpleLinkList&lt;ElemType&gt;::Traverse(<span class="keyword">void</span>(*visit)(<span class="keyword">const</span> ElemType &amp;)) <span class="keyword">const</span></span><br><span class="line"><span class="comment">//依次对线性表每个元素调用函数(*visit)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;ElemType&gt; * tmpPtr = head-&gt;next; tmpPtr != <span class="literal">NULL</span>; tmpPtr = tmpPtr-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">(*visit)(tmpPtr-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> SimpleLinkList&lt;ElemType&gt;::GetElem(<span class="keyword">int</span> <span class="built_in">position</span>, ElemType &amp;e) <span class="keyword">const</span></span><br><span class="line"><span class="comment">//当线性表存在第position给元素时，用e返回其指，返回true，否则</span></span><br><span class="line"><span class="comment">//返回false</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">position</span>&lt;<span class="number">1</span> || <span class="built_in">position</span>&gt;Length())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;ElemType&gt; * tmpPtr;</span><br><span class="line">tmpPtr = GetElemPtr(<span class="built_in">position</span>);</span><br><span class="line">e = tmpPtr-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> SimpleLinkList&lt;ElemType&gt;::SetElem(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="keyword">const</span> ElemType &amp;e)</span><br><span class="line"><span class="comment">//将线性表的第position个位置的元素设置成e，position合法时返回true，否则</span></span><br><span class="line"><span class="comment">//返回false</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">position</span>&lt;<span class="number">1</span> || <span class="built_in">position</span>&gt;Length())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;ElemType&gt; *tmpPtr;</span><br><span class="line">tmpPtr = GetElemPtr(<span class="built_in">position</span>);</span><br><span class="line">tmpPtr-&gt;data = e;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> SimpleLinkList&lt;ElemType&gt;::Delete(<span class="keyword">int</span> <span class="built_in">position</span>, ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">position</span>&lt;<span class="number">1</span> || <span class="built_in">position</span>&gt;Length())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;ElemType&gt; *tmpPtr;</span><br><span class="line">tmpPtr = GetElemPtr(<span class="built_in">position</span> - <span class="number">1</span>);<span class="comment">//取出指向第position-1个结点的指针</span></span><br><span class="line">Node&lt;ElemType&gt; *nextPtr;          <span class="comment">//新建指针nextPtr</span></span><br><span class="line">nextPtr = tmpPtr-&gt;next;           <span class="comment">//新指针为tmpPtr的后继</span></span><br><span class="line">tmpPtr-&gt;next = nextPtr-&gt;next;     <span class="comment">//删除position处的结点</span></span><br><span class="line">e = nextPtr-&gt;data;                <span class="comment">//用e返回其值</span></span><br><span class="line"><span class="keyword">delete</span> nextPtr;                   <span class="comment">//释放被删结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">bool</span> SimpleLinkList&lt;ElemType&gt;::Insert(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="keyword">const</span> ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">position</span>&lt;<span class="number">1</span> || <span class="built_in">position</span>&gt;Length() + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;ElemType&gt; *tmpPtr;</span><br><span class="line">tmpPtr = GetElemPtr(<span class="built_in">position</span> - <span class="number">1</span>);</span><br><span class="line">Node&lt;ElemType&gt; *nextPtr;</span><br><span class="line">nextPtr = <span class="keyword">new</span> Node&lt;ElemType&gt;(e, tmpPtr-&gt;next);</span><br><span class="line">tmpPtr-&gt;next = nextPtr;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">SimpleLinkList&lt;ElemType&gt;::SimpleLinkList(<span class="keyword">const</span> SimpleLinkList&lt;ElemType&gt; &amp;copy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//未写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line">SimpleLinkList&lt;ElemType&gt;&amp;SimpleLinkList&lt;ElemType&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> SimpleLinkList&lt;ElemType&gt;&amp;copy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//未写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名main.cpp</span></span><br><span class="line"><span class="comment">//单链表的基本操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"alg.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SimpleLinkList&lt;<span class="keyword">int</span>&gt; test;<span class="comment">//定义空链表</span></span><br><span class="line">SimpleLinkList&lt;<span class="keyword">int</span>&gt; test1;<span class="comment">//定义空链表</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">0</span>;<span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">int</span> e1 = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)<span class="comment">//建立链表</span></span><br><span class="line">&#123;</span><br><span class="line">test.Insert(k, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"建立的链表:"</span>;</span><br><span class="line">test.Traverse(<span class="built_in">display</span>);<span class="comment">//显示数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"链表的长度为:"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test.Length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"链表是否为空(0代表非空):"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test.Empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"返回第五个位置的值(5)(GetElem):"</span>;</span><br><span class="line">test.GetElem(<span class="number">5</span>, e);<span class="comment">//返回第五个值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"设置第五个位置的值(50)(SetElem):"</span>;</span><br><span class="line">test.SetElem(<span class="number">5</span>, e1);<span class="comment">//设置第五个值为e1;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出当前的链表:"</span>;</span><br><span class="line">test.Traverse(<span class="built_in">display</span>);<span class="comment">//显示数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"删除第5个元素:"</span>;</span><br><span class="line">test.Delete(<span class="number">5</span>, e);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"删除的元素值为:"</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"链表的长度为:"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test.Length() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出当前的链表:"</span>;</span><br><span class="line">test.Traverse(<span class="built_in">display</span>);<span class="comment">//显示数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"清空线性表(Clear)"</span>;</span><br><span class="line">test.Clear();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"链表是否为空(0代表非空):"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test.Empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="/blog/2019/10/30/单链表的基本操作/基本操作.png" style="zoom: 50%;"><h3 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h3><p>已知线性表la和lb中的数据元素按值递增，现在要将la和lb合并成新的线性表lc，使lc中的数据元素扔递增有序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点（更新于2019-12-3）&quot;&gt;&lt;a href=&quot;#本次学习要点（更新于2019-12-3）&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点（更新于2019.12.3）&quot;&gt;&lt;/a&gt;本次学习要点（更新于2019.12.3）&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;掌握线性表的抽象数据类型&lt;/li&gt;
&lt;li&gt;掌握链表的基本操作&lt;/li&gt;
&lt;li&gt;学习链表的较复杂的操作&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.xingyuzhao.ltd/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.xingyuzhao.ltd/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Git的基本使用(三)-Stash、Checkout和Reset（未完待续）</title>
    <link href="http://www.xingyuzhao.ltd/blog/2019/10/08/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-Stash%E3%80%81Checkout%E5%92%8Creset/"/>
    <id>http://www.xingyuzhao.ltd/blog/2019/10/08/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-Stash%E3%80%81Checkout%E5%92%8Creset/</id>
    <published>2019-10-08T15:39:20.000Z</published>
    <updated>2020-01-01T08:59:41.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点"><a href="#本次学习要点" class="headerlink" title="本次学习要点"></a>本次学习要点</h3><p><code>Stash、Checkout</code>和<code>Reset</code>指令</p><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点，所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 <code>git stash</code>。</p><a id="more"></a><h3 id="基本指令-stash"><a href="#基本指令-stash" class="headerlink" title="基本指令-stash"></a>基本指令-stash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git stash </span><br><span class="line">#保存当前工作区所有内容到当前分支的储藏栈的栈顶(工作区会变为最后一次commit时的内容)。</span><br><span class="line">git stash apply </span><br><span class="line">#应用当前分支的储藏栈栈顶的储藏到工作区。</span><br><span class="line">git stash apply &lt;stash id&gt; </span><br><span class="line">#应用当前分支的储藏栈指定位置的储藏到工作区，例如git stash apply stash@&#123;0&#125;。</span><br><span class="line">git stash list </span><br><span class="line">#列出当前分支的储藏栈详细信息。</span><br><span class="line">git stash drop &lt;stash id&gt; </span><br><span class="line">#移除当前分支的储藏栈指定位置的储藏。</span><br><span class="line">git stash pop</span><br><span class="line">#从git栈中获取到最近一次stash进去的内容，恢复工作区的内容，获取之后，会删除栈中对应的stash。</span><br></pre></td></tr></table></figure><ul><li>唯一需要注意的是，<code>git stash apply</code>并不会改变储藏栈的内容，所以如果你觉得之前的那个储藏没用了，请手动调用<code>git stash drop &lt;stash id&gt;</code>清理储藏栈。特别的，<code>git stash pop</code>会自动应用当前分支的储藏栈栈顶的储藏到工作区，并将其从栈顶移除。</li></ul><h4 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h4><ol><li>新建一个仓库，建立文件<code>test.txt</code>，随意键入一段内容（123），提交。</li><li>创建分支<code>feature</code>，修改<code>test.txt</code>文件内容（321）然后运行<code>git status</code>可以看到以下中间过程的内容：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><ol start="3"><li>现在你想切换分支，但是你还不想提交你正在进行中的工作；所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 <code>git stash</code>。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: 7ac5b3d master注释</span><br><span class="line">#test.txt中的内容变成了“123”，工作区内容变为最后一次提交的内容</span><br></pre></td></tr></table></figure><ol start="4"><li>这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 <code>git stash list</code>：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 7ac5b3d master注释</span><br></pre></td></tr></table></figure><ol start="5"><li>切换到分支<code>feature</code>并且使用指令<code>git stash pop</code>，观察<code>test.txt</code>中的内容变化。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (81b72af21b8037e4b185820e3a86b78d95b9f8d8)</span><br><span class="line">#文档内容变成了“321”，也就是master修改后的工作区，但现在pop命令把储藏的栈顶弹出，是在feature分支进行工作的，此时feature的工作区是修改后的文档。</span><br></pre></td></tr></table></figure><ol start="6"><li>再次使用指令<code>git stash</code>，然后<code>git checkout master</code>，再次使用<code>git stash pop</code>，那么修改后的文档就是在<code>master</code>工作区了，最后直接查看工作区状态。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><h4 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h4><p>在练习一基础上使用<code>apply</code>指令：</p><ol><li>当前工作区为<code>master</code>，<code>test.txt</code>中的内容是修改后的321，使用<code>stash</code>指令存储当前的工作区。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: 7ac5b3d master注释</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 7ac5b3d master注释</span><br></pre></td></tr></table></figure><ol start="2"><li>此时<code>test.txt</code>内容为（123），修改其内容（1234），然后进行<code>add</code>（不进行此操作也可以），再进行一次存储。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 7ac5b3d master注释</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 7ac5b3d master注释</span><br><span class="line">#现在堆栈里存储了两个工作区，工作区空</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">#test.txt中内容变为“123”</span><br></pre></td></tr></table></figure><ol start="3"><li>使用<code>apply</code>指令将堆栈中的栈顶应用到当前工作区，当前的栈顶应该是<code>stash@{0}</code>，所以内容应该恢复为“1234”。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">#打开test.txt发现内容已经变回“1234”</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 7ac5b3d master注释</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 7ac5b3d master注释</span><br><span class="line">#堆栈中的内容不会主动删除，继续保存下来</span><br></pre></td></tr></table></figure><ol start="4"><li>修改<code>test.txt</code>中的“1234”为“123”（初始工作区），然后使用<code>git stash apply</code>指令将栈中的<code>stash@{1}</code>（修改后的工作区，内容是“321”）返回到工作区，此时文档内容是“321”。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;1&#125;</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">#test.txt中的内容是“321”</span><br></pre></td></tr></table></figure><h4 id="一些标注"><a href="#一些标注" class="headerlink" title="一些标注"></a>一些标注</h4><h5 id="练习一-1"><a href="#练习一-1" class="headerlink" title="练习一"></a>练习一</h5><p>初始工作区的<code>test.txt</code>内容为：123</p><p>第一次修改后的<code>test.txt</code>内容为：321</p><p>最后<code>master</code>中的<code>stash@{0}</code>内容为：321</p><h5 id="练习二-1"><a href="#练习二-1" class="headerlink" title="练习二"></a>练习二</h5><p>初始<code>master</code>中的<code>stash@{0}</code>内容为：321</p><p>修改初始的工作区中的<code>test.txt</code>内容为：1234</p><p>进行存储，<code>stash@{0}-&gt;stash@{1}</code>，内容为：321</p><p>此时<code>stash@{0}</code>中的内容为：1234</p><p>本次练习最后结果改回了“1234”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点&quot;&gt;&lt;a href=&quot;#本次学习要点&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点&quot;&gt;&lt;/a&gt;本次学习要点&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Stash、Checkout&lt;/code&gt;和&lt;code&gt;Reset&lt;/code&gt;指令&lt;/p&gt;
&lt;p&gt;经常有这样的事情发生，当你正在进行项目中某一部分的工作，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点，所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 &lt;code&gt;git stash&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.xingyuzhao.ltd/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.xingyuzhao.ltd/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git的基本使用(二) --撤销提交</title>
    <link href="http://www.xingyuzhao.ltd/blog/2019/09/29/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E6%92%A4%E9%94%80%E6%8F%90%E4%BA%A4/"/>
    <id>http://www.xingyuzhao.ltd/blog/2019/09/29/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E6%92%A4%E9%94%80%E6%8F%90%E4%BA%A4/</id>
    <published>2019-09-29T14:13:33.000Z</published>
    <updated>2020-01-01T08:59:52.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点："><a href="#本次学习要点：" class="headerlink" title="本次学习要点："></a>本次学习要点：</h3><p>Git的撤销提交操作</p><p>与回滚不同，如果认为某次的提交是有问题的，需要撤回这次的提交，应该怎么做呢？</p><a id="more"></a><h3 id="主要指令"><a href="#主要指令" class="headerlink" title="主要指令"></a>主要指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;SHA ID&gt;</span><br></pre></td></tr></table></figure><p>该指令可以直接把某一次的提交取消，所有在本次提交中发生变更的文件都会还原回上一次提交的内容。因为针对同一分支master操作，所以会产生冲突（解决方法见一），解决冲突后，再将文件放入缓存区，进行提交.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &lt;之前某个版本ID&gt;</span><br><span class="line">$ git reset --hard &lt;之前某个版本ID&gt;</span><br></pre></td></tr></table></figure><p>上述指令是不安全的撤销方式。当年使用<code>git reset</code>来重置记录时，所有<strong>在此之后</strong>的记录都将永久消失，<strong>但是还会保留当前的提交</strong>。如果带上参数<code>--hard</code>，还会直接清空工作区里的所有变更（<strong>如果此时做了修改但是还没有提交，那么直接就会被撤销到未改动的时刻</strong>），直接使工作区内容撤销到指定提交的时刻，是一种比较暴力的撤销方式。</p><h3 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h3><ol><li>新建一个库，新建一个文件<code>text.txt</code> ，输入内容“1”，保存后提交。并以此类推，一共得到三次提交，内容分别是“1”，“2”，“3”，使用<code>git log</code>查看提交历史。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 51df17687ea6bb6a53ed24d614ddcfe9e455e9f9</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:47:24 2019 +0800</span><br><span class="line"></span><br><span class="line">    3.第三次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br><span class="line"></span><br><span class="line">commit 9e71ea1c78ff7aa910959e02acb44e8e3373a805</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:46:38 2019 +0800</span><br><span class="line"></span><br><span class="line">    2.第二次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br><span class="line"></span><br><span class="line">commit 3d4d2f3a3f44c0fcb5d4357d85abf5cb33304e97</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:45:09 2019 +0800</span><br><span class="line"></span><br><span class="line">    1.第一次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>git revert</code>进行撤销操作，撤销到第二次提交，那么结果应该是显示第一次提交的内容，即“1”。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert 9e71ea</span><br></pre></td></tr></table></figure><ol start="3"><li>此时产生了冲突，打开<code>test.txt</code>，将第三次的提交内容删除，留下内容“1”，不解决冲突无法提交。然后再加入缓存区，进行提交（当时没有记录，这里只有进行操作的指令，没有结果，失策失策）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line">$ git status#可以看到test.txt加入了缓存，可以不写</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure><ol start="4"><li>最后使用<code>git log</code>查看提交记录，会产生一个新的提交记录，并且之前记录都会存在，所以是一种安全的撤销操作。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 57124efed6dd52b7224c3e3b5ee0be7042cee27b (HEAD -&gt; master)</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:50:18 2019 +0800</span><br><span class="line"></span><br><span class="line">    Revert &quot;2.第二次提交&quot;</span><br><span class="line"></span><br><span class="line">    This reverts commit 9e71ea1c78ff7aa910959e02acb44e8e3373a805.</span><br><span class="line"></span><br><span class="line">commit 51df17687ea6bb6a53ed24d614ddcfe9e455e9f9</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:47:24 2019 +0800</span><br><span class="line"></span><br><span class="line">    3.第三次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br><span class="line"></span><br><span class="line">commit 9e71ea1c78ff7aa910959e02acb44e8e3373a805</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:46:38 2019 +0800</span><br><span class="line"></span><br><span class="line">    2.第二次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br><span class="line"></span><br><span class="line">commit 3d4d2f3a3f44c0fcb5d4357d85abf5cb33304e97</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:45:09 2019 +0800</span><br><span class="line"></span><br><span class="line">    1.第一次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br></pre></td></tr></table></figure><p>总结：revert指令可以使版本撤销到之前的某一次提交，并且在那次提交中改变的部分都会还原为上一次提交的内容（比如撤销到第二次，那么内容就会还原为第一次提交的内容），并且在这个过程中会产生冲突，按照我的理解，产生冲突之后修改的txt文档，决定了还原的最终结果。如果我在解决冲突的过程中，留下了“3”，而不是“1”，那么还原的内容应该是“3”。</p><h3 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h3><ol><li>新建一个库，新建一个文件<code>text.txt</code> ，输入内容“1”，保存后提交。并以此类推，一共得到三次提交，内容分别是“1”，“2”，“3”，使用<code>git log</code>查看提交历史。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 9e541291495cfe4c57b62f699ff17deed99bd853 (HEAD -&gt; master)</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:56:32 2019 +0800</span><br><span class="line"></span><br><span class="line">    3.第三次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br><span class="line"></span><br><span class="line">commit 1d0feb4e586995b4d1bd6e3d78af5350b2726b68</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:55:37 2019 +0800</span><br><span class="line"></span><br><span class="line">    2.第二次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br><span class="line"></span><br><span class="line">commit 47bbd152043e6f2de771413739b2fccadad6893d</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:54:36 2019 +0800</span><br><span class="line"></span><br><span class="line">    1.第一次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>git reset</code>进行撤销操作1。先改变<code>test.txt</code>中的内容，开始应为“3”，现在可以任意改变，假如改为“5”，然后执行指令（撤销到第三次），并得到以下结果：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset 9e5412</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       test.txt</span><br></pre></td></tr></table></figure><p>执行的结果就是<code>test.txt</code>文档中的”5”又变成了“3”，成功！</p><ol start="3"><li>使用<code>git reset</code>进行撤销操作2。直接执行指令撤销到第二次，得到以下结果：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git reset 1d0fe</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       test.txt</span><br><span class="line">#再执行git log指令</span><br><span class="line">$ git log</span><br><span class="line">commit 1d0feb4e586995b4d1bd6e3d78af5350b2726b68 (HEAD -&gt; master)</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:55:37 2019 +0800</span><br><span class="line"></span><br><span class="line">    2.第二次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br><span class="line"></span><br><span class="line">commit 47bbd152043e6f2de771413739b2fccadad6893d</span><br><span class="line">Author: zhaoxingyu &lt;543040659@qq.com&gt;</span><br><span class="line">Date:   Thu Sep 26 21:54:36 2019 +0800</span><br><span class="line"></span><br><span class="line">    1.第一次提交</span><br><span class="line">    sign off:&lt;543040659@qq.com&gt;</span><br></pre></td></tr></table></figure><p>可以发现第三次的提交已经没有了，所以是一种不安全的撤销，此时<code>test.txt</code>中应为“2”，如果你此时修改了文档中的内容，再执行以上步骤，文档中的内容修改会被继续保留下来，与下面的有所不同。</p><ol start="4"><li>使用<code>git reset --hard</code>进行撤销操作。如前所述，此指令会直接撤销到<strong>当前提交时刻的原始版本</strong>（以撤销到第二次为例）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1d0feb</span><br><span class="line">HEAD is now at 1d0feb4 2.第二次提交</span><br></pre></td></tr></table></figure><p>我们一开始在第二次提交时，里面的内容就是“2”，现在执行上述指令后，<code>test.txt</code>中就是“2”。如果把<code>test.txt</code>中的内容修改为“5”，甚至你已经进行add指令加入到了缓存，但是没有提交，那么再次执行上述hard指令后，文档中的内容又变成了“2”，你之前的所有修改都白费了，所以要特别小心，慎用！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这次的练习收获很多，不过只是很浅显的一些理解，不免有些理解不到位或者容易产生歧义的地方。如果有哪里有疑问，可以和我联系进行讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点：&quot;&gt;&lt;a href=&quot;#本次学习要点：&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点：&quot;&gt;&lt;/a&gt;本次学习要点：&lt;/h3&gt;&lt;p&gt;Git的撤销提交操作&lt;/p&gt;
&lt;p&gt;与回滚不同，如果认为某次的提交是有问题的，需要撤回这次的提交，应该怎么做呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.xingyuzhao.ltd/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.xingyuzhao.ltd/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git的基本使用(一)</title>
    <link href="http://www.xingyuzhao.ltd/blog/2019/09/26/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.xingyuzhao.ltd/blog/2019/09/26/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2019-09-26T14:24:21.000Z</published>
    <updated>2020-01-01T08:59:15.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次学习要点："><a href="#本次学习要点：" class="headerlink" title="本次学习要点："></a>本次学习要点：</h3><ol><li><p>如何建立一个本地仓库</p></li><li><p>设置你的个性化信息</p></li><li><p>工作区与缓存区</p></li><li><p>提交与历史</p></li></ol><a id="more"></a><h3 id="如何建立一个本地仓库"><a href="#如何建立一个本地仓库" class="headerlink" title="如何建立一个本地仓库"></a>如何建立一个本地仓库</h3><p>有两种方法，一种是Git GUI，一种是Git Bush，第一步都是先建立一个空文件夹。</p><ol><li>在文件夹空白处右键，选择Git GUI Here，点击Create New Repository，OK。</li><li>在文件夹空白处右键，选择Git Bush Here，输入<code>git init</code>，OK。</li></ol><h3 id="设置你的个性化信息"><a href="#设置你的个性化信息" class="headerlink" title="设置你的个性化信息"></a>设置你的个性化信息</h3><p>Git是一个团队开发工作，你对团队的每次贡献都会有相应的记录。所以此时你应该告诉这个仓库你的个人信息，主要包括两个：</p><ul><li><strong>邮箱</strong> 邮箱是别人联系你的途径，当然你应当留意你的个人隐私问题，这个内容我们会放到之后的几章中讲，此处你可以随便填写一个邮箱。</li><li><strong>姓名</strong> 你可以填真名或是化名，取决于你的实际开发和协作环境。</li></ul><ol><li>打开Git Bash界面，我们输入指令<code>git config --help</code>来查看<code>git config</code>的帮助文档。【–help】是一个很有用的指令参数，当你忘了某个指令的使用方法，你都可以如此进行搜寻。</li><li>我们可以看到如此一行：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user.email</span><br><span class="line">Your email address to be recorded in any newly created commits. </span><br><span class="line">Can be overridden by the GIT_AUTHOR_EMAIL, GIT_COMMITTER_EMAIL, </span><br><span class="line">and EMAIL environment variables. See git-commit-tree(1).</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>git config user.email &lt;你的Email&gt;</code>进行邮箱的设置。同样的，<code>git config user.name &lt;你的名字或化名&gt;</code>可以设置该本地仓库的所有者姓名。</p></li><li><p>当你设置完这些值之后，可以打开<code>.gti/config</code>，查看到你刚刚所设置邮箱和姓名。</p></li></ul><h3 id="工作区与缓存区"><a href="#工作区与缓存区" class="headerlink" title="工作区与缓存区"></a>工作区与缓存区</h3><img src="/blog/2019/09/26/Git的基本使用（一）/GitFlow.jpg" style="zoom:50%;"><p>​                                                            上图来源于西电腾讯TIC-Git的培训资料</p><p>Git的基本工作流程，目前阶段我们需要知道三个区域：<strong>工作区域</strong>、<strong>缓存区</strong>和<strong>仓库记录</strong>。其中，仓库记录是由<strong>历史记录</strong>构成的，因为历史纪录是一棵树状结构，也被叫做(History Tree)。</p><ul><li>用户在工作区域(或工作目录)中进行的修改会被Git检测到，通过<code>add</code>指令被提交到缓存区。</li><li>缓存区中的文件是工作区域中的文件的一次快照备份，你之后在工作区域中做任何修改都不会影响到缓存区中同一个文件的内容，除非再次使用<code>add</code>指令更新缓存区。</li><li>当你觉得工作做得差不多了，你可以使用<code>commit</code>指令，把缓存区中的文件提交到仓库记录，仓库记录会自动生成一次历史记录。你可以简单认为仓库记录就是个数据库，一次<code>commit</code>指令就是一次数据库写入请求。从此之后该记录将一直留在仓库中，你也可以把工作区中的数据文件随时回滚到当时提交的这个版本。</li><li>缓存区中的文件在并未被<code>commit</code>之前，并不会被写入记录，也就意味着有些操作会导致你丢失缓存区的文件快照备份(如<code>checkout</code>等)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">#添加文件至缓存区</span><br><span class="line">git status</span><br><span class="line">#查看当前缓存区的状态</span><br><span class="line">git commit</span><br><span class="line">#将缓存区的文件提交到仓库</span><br></pre></td></tr></table></figure><h3 id="提交与历史"><a href="#提交与历史" class="headerlink" title="提交与历史"></a>提交与历史</h3><ul><li><p>打开Git Bash，键入<code>git log</code>，即可查看提交的历史纪录。如果对当前提交不满意，找到上一次提交的版本ID值(SHA ID)，键入命令<code>git checkout &lt;SHA ID&gt;</code>，此时版本便已回滚到了之前那个版本，当前的提交会直接删除掉。</p></li><li><p>在Vim界面中，按字母a来进入编辑模式，编辑完毕后按ESC键退出编辑，再按大写锁定，按ZZ来退出Vim。</p></li></ul><p>编辑模板</p><p>提交了xxxx</p><p>来自：Zxy&lt;<a href="mailto:&#x35;&#x34;&#x33;&#x30;&#52;&#48;&#x36;&#x35;&#57;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x35;&#x34;&#x33;&#x30;&#52;&#48;&#x36;&#x35;&#57;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d;</a>&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本次学习要点：&quot;&gt;&lt;a href=&quot;#本次学习要点：&quot; class=&quot;headerlink&quot; title=&quot;本次学习要点：&quot;&gt;&lt;/a&gt;本次学习要点：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如何建立一个本地仓库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置你的个性化信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工作区与缓存区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提交与历史&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.xingyuzhao.ltd/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.xingyuzhao.ltd/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3安装Emmet插件遇到的问题及解决</title>
    <link href="http://www.xingyuzhao.ltd/blog/2019/09/16/Sublime-text3%E5%AE%89%E8%A3%85Emmet%E6%8F%92%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <id>http://www.xingyuzhao.ltd/blog/2019/09/16/Sublime-text3%E5%AE%89%E8%A3%85Emmet%E6%8F%92%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</id>
    <published>2019-09-16T05:52:06.000Z</published>
    <updated>2019-09-29T01:10:30.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近对前端的知识准备进行一个入门，首先学习一下html文档的写法，第一步就是选择一个合适的开发工具。<a id="more"></a>当然，html文件也可以用记事本的方式进行编写，不过在尝试了记事本编写之后还是放弃了，缩进或者格式都得自己来，无疑是给自己徒增烦恼。</p><p>在进行一番查看之后，选择了Sublime Text3这款工具来编写html文件，这款工具目前也比较流行，具体的好处就是可以带很多插件，提高你写代码的效率。这里附上ST3的下载网址：</p><p><a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">http://www.sublimetext.com/3</a></p><h1 id="为什么使用Emmet这个插件？"><a href="#为什么使用Emmet这个插件？" class="headerlink" title="为什么使用Emmet这个插件？"></a>为什么使用Emmet这个插件？</h1><p>在没有安装Emmet之前，Sublime Text的使用貌似和记事本没有什么不同，也是得自己写结构，区别就是颜色好看了些，而安装了Emmet之后就不同了，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度，可以直接使用 !+tab 快速得到一个标准的html5文档，如下图所示：</p><img src="/blog/2019/09/16/Sublime-text3安装Emmet插件遇到的问题及解决/ST界面.png" style="zoom:50%;"><h1 id="安装Emmet插件"><a href="#安装Emmet插件" class="headerlink" title="安装Emmet插件"></a>安装Emmet插件</h1><p>这里已经默认你安装了Package Control，这个组件是用来安装/删除插件和其他一些功能要用到的（目前我就用到了安装和删除两个功能）。</p><h2 id="自动安装法"><a href="#自动安装法" class="headerlink" title="自动安装法"></a>自动安装法</h2><p>这个方法就是看你运气，不过过程一定是正确的，但由于各种原因（墙、网络之类的）安装不成功的大有人在，所以先写一下自动安装法。</p><ol><li>在Sublime Text3的主页面按<strong>CTRL+SHIFT+P</strong>打开Package Control</li><li>输入<strong>install</strong>，选择第一个回车</li><li>这时候会让你选择需要安装的插件，你输入<strong>Emmet</strong>，选择第一个回车即可</li><li>左下角会显示下载PyV8，在提示<strong>PyV8 binary successfully loaded</strong>即安装完成</li><li>重启Sublime Text3，安装完成！</li></ol><p>当然，一般人像我运气一样的，这样是成功不了的（坏笑）。</p><h2 id="手动安装法"><a href="#手动安装法" class="headerlink" title="手动安装法"></a>手动安装法</h2><h3 id="1-安装PyV8"><a href="#1-安装PyV8" class="headerlink" title="1.安装PyV8"></a>1.安装PyV8</h3><p>在你安装Emmet时，你可能出现下面这种错误提示：</p><p><strong><em>Sublime Text Error while loading PyV8 binary: exit code 1 Try to manually install Pyv8 form <a href="https://github.com/emetio/pyv8-binaries" target="_blank" rel="noopener">https://github.com/emetio/pyv8-binaries</a></em></strong></p><p>出现这种情况的原因就是下载PyV8这个包不成功，那么你就得手动去下载，这个里也把网址给你了，如下：<a href="https://github.com/emmetio/pyv8-binaries" target="_blank" rel="noopener">https://github.com/emmetio/pyv8-binaries</a> 选择合适你电脑的版本去下载，这个必须记住，不然可能会用不了，我第一次就犯了这个错误。因为我电脑装了python3.7，所以我选择了 <strong>pyv8-win64-p3</strong>，我把下载地址也贴出来，不过因为gtihub是国外的网站，所以下载会很慢，链接如下：</p><p><a href="https://github.com/emmetio/pyv8-binaries/raw/master/pyv8-win64-p3.zip" target="_blank" rel="noopener">https://github.com/emmetio/pyv8-binaries/raw/master/pyv8-win64-p3.zip</a></p><p>下载好了之后，对它进行解压，得到下面这个文件：</p><img src="/blog/2019/09/16/Sublime-text3安装Emmet插件遇到的问题及解决/pyv8.png" style="zoom:80%;"><p>接下来按照以下的步骤做就ok了：</p><ol><li>打开Sublime Text</li><li>依次选择首选项 -&gt; 浏览插件目录（我的汉化了，不然是Preferences -&gt;Browse Packages）</li><li>新建PyV8文件夹</li><li>在PyV8文件夹把上图中的文件复制过来</li><li>重启Sublime Text</li></ol><p>现在你就可以在ST3中使用Emmet的功能了，不过还有运气不好的人，还是不能用，比如说我，那么继续往下看。</p><h3 id="2-手动安装Emmet"><a href="#2-手动安装Emmet" class="headerlink" title="2.手动安装Emmet"></a>2.手动安装Emmet</h3><p>如果你还是无法使用Emmet，但是你在首选项菜单中的Package Settings还能看到Emmet的身影，然而那只是个空壳，继续进入插件目录，你会发现没有与Emmet相关的文件夹的存在，那么你就需要自己手动安装Emmet。下载地址如下（下载也比较慢，但是只有200k左右）：</p><p><a href="https://codeload.github.com/sergeche/emmet-sublime/zip/master" target="_blank" rel="noopener">https://codeload.github.com/sergeche/emmet-sublime/zip/master</a></p><p>下载好了之后，继续进入插件目录（首选项 -&gt; 浏览插件目录），把解压后的文件放进去，如图：</p><img src="/blog/2019/09/16/Sublime-text3安装Emmet插件遇到的问题及解决/emmet.png" style="zoom:50%;"><p>接下来你再重启ST就行了，需要注意的是，如果你没有装PyV8，那么你打开ST之后它会自动再一次下载这个包，同样可能出现1中的问题，那么你可以先把PyV8装好，再手动安装Emmet，重启之后就大功告成，终于装好啦！我属于运气最差的那种，不好的都让我遇到了，刚接触花了几个小时才弄明白，虽然最后成功了，我还是流下了没有技术的眼泪。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近对前端的知识准备进行一个入门，首先学习一下html文档的写法，第一步就是选择一个合适的开发工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端学习入门" scheme="http://www.xingyuzhao.ltd/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="html" scheme="http://www.xingyuzhao.ltd/tags/html/"/>
    
      <category term="Sublime Text" scheme="http://www.xingyuzhao.ltd/tags/Sublime-Text/"/>
    
  </entry>
  
</feed>
